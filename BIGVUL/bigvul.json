[
    {
        "id": 0,
        "func": " IndexedDBCursor::~IndexedDBCursor() {\n   Close();\n }\n",
        "target": 1
    },
    {
        "id": 1,
        "func": "static void remove_trailing_rmap_items(struct mm_slot *mm_slot,\n\t\t\t\t       struct rmap_item **rmap_list)\n{\n\twhile (*rmap_list) {\n\t\tstruct rmap_item *rmap_item = *rmap_list;\n\t\t*rmap_list = rmap_item->rmap_list;\n\t\tremove_rmap_item_from_tree(rmap_item);\n\t\tfree_rmap_item(rmap_item);\n\t}\n}",
        "target": 0
    },
    {
        "id": 2,
        "func": "void LocalFrameClientImpl::DidEnforceInsecureRequestPolicy(\n    WebInsecureRequestPolicy policy) {\n  if (!web_frame_->Client())\n    return;\n  web_frame_->Client()->DidEnforceInsecureRequestPolicy(policy);\n}\n",
        "target": 0
    },
    {
        "id": 3,
        "func": "void rtmsg_ifinfo_send(struct sk_buff *skb, struct net_device *dev, gfp_t flags)\n{\n\tstruct net *net = dev_net(dev);\n\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, flags);\n}",
        "target": 0
    },
    {
        "id": 4,
        "func": "void WebPluginDelegateStub::OnMessageReceived(const IPC::Message& msg) {\n  child_process_logging::SetActiveURL(page_url_);\n\n  if (!in_destructor_)\n    AddRef();\n\n  IPC_BEGIN_MESSAGE_MAP(WebPluginDelegateStub, msg)\n    IPC_MESSAGE_HANDLER(PluginMsg_Init, OnInit)\n    IPC_MESSAGE_HANDLER(PluginMsg_WillSendRequest, OnWillSendRequest)\n    IPC_MESSAGE_HANDLER(PluginMsg_DidReceiveResponse, OnDidReceiveResponse)\n    IPC_MESSAGE_HANDLER(PluginMsg_DidReceiveData, OnDidReceiveData)\n    IPC_MESSAGE_HANDLER(PluginMsg_DidFinishLoading, OnDidFinishLoading)\n    IPC_MESSAGE_HANDLER(PluginMsg_DidFail, OnDidFail)\n    IPC_MESSAGE_HANDLER(PluginMsg_DidFinishLoadWithReason,\n                        OnDidFinishLoadWithReason)\n    IPC_MESSAGE_HANDLER(PluginMsg_SetFocus, OnSetFocus)\n    IPC_MESSAGE_HANDLER(PluginMsg_HandleInputEvent, OnHandleInputEvent)\n    IPC_MESSAGE_HANDLER(PluginMsg_Paint, OnPaint)\n    IPC_MESSAGE_HANDLER(PluginMsg_DidPaint, OnDidPaint)\n    IPC_MESSAGE_HANDLER(PluginMsg_Print, OnPrint)\n    IPC_MESSAGE_HANDLER(PluginMsg_GetPluginScriptableObject,\n                        OnGetPluginScriptableObject)\n    IPC_MESSAGE_HANDLER(PluginMsg_UpdateGeometry, OnUpdateGeometry)\n    IPC_MESSAGE_HANDLER(PluginMsg_UpdateGeometrySync, OnUpdateGeometry)\n    IPC_MESSAGE_HANDLER(PluginMsg_SendJavaScriptStream,\n                        OnSendJavaScriptStream)\n    IPC_MESSAGE_HANDLER(PluginMsg_DidReceiveManualResponse,\n                        OnDidReceiveManualResponse)\n    IPC_MESSAGE_HANDLER(PluginMsg_DidReceiveManualData, OnDidReceiveManualData)\n    IPC_MESSAGE_HANDLER(PluginMsg_DidFinishManualLoading,\n                        OnDidFinishManualLoading)\n    IPC_MESSAGE_HANDLER(PluginMsg_DidManualLoadFail, OnDidManualLoadFail)\n     IPC_MESSAGE_HANDLER(PluginMsg_InstallMissingPlugin, OnInstallMissingPlugin)\n     IPC_MESSAGE_HANDLER(PluginMsg_HandleURLRequestReply,\n                         OnHandleURLRequestReply)\n     IPC_MESSAGE_HANDLER(PluginMsg_CreateCommandBuffer,\n                         OnCreateCommandBuffer)\n     IPC_MESSAGE_UNHANDLED_ERROR()\n  IPC_END_MESSAGE_MAP()\n\n  if (!in_destructor_)\n    Release();\n}\n",
        "target": 1
    },
    {
        "id": 5,
        "func": "static void update_gt_cputime(struct task_cputime_atomic *cputime_atomic, struct task_cputime *sum)\n{\n\t__update_gt_cputime(&cputime_atomic->utime, sum->utime);\n\t__update_gt_cputime(&cputime_atomic->stime, sum->stime);\n\t__update_gt_cputime(&cputime_atomic->sum_exec_runtime, sum->sum_exec_runtime);\n}",
        "target": 0
    },
    {
        "id": 6,
        "func": "static int __must_push_back(struct multipath *m)\n{\n\treturn (m->queue_if_no_path != m->saved_queue_if_no_path &&\n\t\tdm_noflush_suspending(m->ti));\n}",
        "target": 0
    },
    {
        "id": 7,
        "func": "void RenderWidgetHostImpl::ShutdownAndDestroyWidget(bool also_delete) {\n  RejectMouseLockOrUnlockIfNecessary();\n\n  if (process_->HasConnection()) {\n    bool rv = Send(new ViewMsg_Close(routing_id_));\n    DCHECK(rv);\n  }\n\n  Destroy(also_delete);\n}\n",
        "target": 0
    },
    {
        "id": 8,
        "func": "xsltExtStyleShutdownTest(xsltStylesheetPtr style ATTRIBUTE_UNUSED,\n                         const xmlChar * URI, void *data)\n{\n    if (testStyleData == NULL) {\n        xsltGenericError(xsltGenericErrorContext,\n                         \"xsltExtShutdownTest: not initialized\\n\");\n        return;\n    }\n    if (data != testStyleData) {\n        xsltTransformError(NULL, NULL, NULL,\n                           \"xsltExtShutdownTest: wrong data\\n\");\n    }\n    testStyleData = NULL;\n    xsltGenericDebug(xsltGenericDebugContext,\n                     \"Unregistered test module : %s\\n\", URI);\n}\n",
        "target": 0
    },
    {
        "id": 9,
        "func": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\thdev = hci_pi(sk)->hdev;\n\tif (!hdev) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\t*addr_len = sizeof(*haddr);\n\thaddr->hci_family = AF_BLUETOOTH;\n\thaddr->hci_dev    = hdev->id;\n\thaddr->hci_channel= hci_pi(sk)->channel;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 10,
        "func": "    LineWidth(RenderBlock* block, bool isFirstLine, IndentTextOrNot shouldIndentText)\n        : m_block(block)\n        , m_uncommittedWidth(0)\n        , m_committedWidth(0)\n        , m_overhangWidth(0)\n        , m_left(0)\n        , m_right(0)\n        , m_availableWidth(0)\n        , m_segment(0)\n        , m_isFirstLine(isFirstLine)\n        , m_shouldIndentText(shouldIndentText)\n    {\n        ASSERT(block);\n        ShapeInsideInfo* shapeInsideInfo = m_block->layoutShapeInsideInfo();\n        if (shapeInsideInfo)\n            m_segment = shapeInsideInfo->currentSegment();\n        updateAvailableWidth();\n    }\n",
        "target": 0
    },
    {
        "id": 11,
        "func": "void DatabaseImpl::Commit(int64_t transaction_id) {\n  idb_runner_->PostTask(\n      FROM_HERE, base::Bind(&IDBThreadHelper::Commit, base::Unretained(helper_),\n                            transaction_id));\n}\n",
        "target": 0
    },
    {
        "id": 12,
        "func": " register_fstype(const char *name, const sa_share_ops_t *ops)\n {\n\tsa_fstype_t *fstype;\n\n\tfstype = calloc(sizeof (sa_fstype_t), 1);\n\n\tif (fstype == NULL)\n\t\treturn (NULL);\n\n\tfstype->name = name;\n\tfstype->ops = ops;\n\tfstype->fsinfo_index = fstypes_count;\n\n\tfstypes_count++;\n\n\tfstype->next = fstypes;\n\tfstypes = fstype;\n\n\treturn (fstype);\n}\n",
        "target": 0
    },
    {
        "id": 13,
        "func": "void TestController::setMockGeolocationPosition(double latitude, double longitude, double accuracy, bool providesAltitude, double altitude, bool providesAltitudeAccuracy, double altitudeAccuracy, bool providesHeading, double heading, bool providesSpeed, double speed)\n{\n    m_geolocationProvider->setPosition(latitude, longitude, accuracy, providesAltitude, altitude, providesAltitudeAccuracy, altitudeAccuracy, providesHeading, heading, providesSpeed, speed);\n}\n",
        "target": 0
    },
    {
        "id": 14,
        "func": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrlcpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrlcpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tstrlcpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "target": 1
    },
    {
        "id": 15,
        "func": "bool TestLifecycleUnit::Freeze() {\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 16,
        "func": "bool V8Window::namedSecurityCheckCustom(v8::Local<v8::Object> host, v8::Local<v8::Value> key, v8::AccessType type, v8::Local<v8::Value>)\n{\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n    v8::Handle<v8::Object> window = host->FindInstanceInPrototypeChain(V8Window::GetTemplate(isolate, worldTypeInMainThread(isolate)));\n    if (window.IsEmpty())\n        return false; // the frame is gone.\n\n    DOMWindow* targetWindow = V8Window::toNative(window);\n\n    ASSERT(targetWindow);\n\n    Frame* target = targetWindow->frame();\n    if (!target)\n        return false;\n\n    if (target->loader()->stateMachine()->isDisplayingInitialEmptyDocument())\n        target->loader()->didAccessInitialDocument();\n\n    if (key->IsString()) {\n        DEFINE_STATIC_LOCAL(AtomicString, nameOfProtoProperty, (\"__proto__\", AtomicString::ConstructFromLiteral));\n\n        String name = toWebCoreString(key.As<v8::String>());\n        Frame* childFrame = target->tree().scopedChild(name);\n        if (type == v8::ACCESS_HAS && childFrame)\n            return true;\n        v8::Handle<v8::String> keyString = key.As<v8::String>();\n        if (type == v8::ACCESS_GET\n            && childFrame\n            && !host->HasRealNamedProperty(keyString)\n            && !window->HasRealNamedProperty(keyString)\n            && name != nameOfProtoProperty)\n            return true;\n    }\n\n    return BindingSecurity::shouldAllowAccessToFrame(target, DoNotReportSecurityError);\n}\n",
        "target": 0
    },
    {
        "id": 17,
        "func": "xfs_vm_bmap(\n\tstruct address_space\t*mapping,\n\tsector_t\t\tblock)\n{\n\tstruct inode\t\t*inode = (struct inode *)mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\ttrace_xfs_vm_bmap(XFS_I(inode));\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\n\t/*\n\t * The swap code (ab-)uses ->bmap to get a block mapping and then\n\t * bypasseÑ• the file system for actual I/O.  We really can't allow\n\t * that on reflinks inodes, so we have to skip out here.  And yes,\n\t * 0 is the magic code for a bmap error..\n\t */\n\tif (xfs_is_reflink_inode(ip)) {\n\t\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\t\treturn 0;\n\t}\n\tfilemap_write_and_wait(mapping);\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\treturn generic_block_bmap(mapping, block, xfs_get_blocks);\n}",
        "target": 0
    },
    {
        "id": 18,
        "func": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n    }\n}",
        "target": 1
    },
    {
        "id": 19,
        "func": "long long AudioTrack::GetChannels() const\n  Track** i = m_trackEntries;\n  Track** const j = m_trackEntriesEnd;\n\n  while (i != j) {\n    Track* const pTrack = *i++;\n\n    if (pTrack == NULL)\n      continue;\n\n    if (tn == pTrack->GetNumber())\n      return pTrack;\n  }\n\n  return NULL;  // not found\n }\n",
        "target": 0
    },
    {
        "id": 20,
        "func": "static inline int get_sd_load_idx(struct sched_domain *sd,\n\t\t\t\t\tenum cpu_idle_type idle)\n{\n\tint load_idx;\n\n\tswitch (idle) {\n\tcase CPU_NOT_IDLE:\n\t\tload_idx = sd->busy_idx;\n\t\tbreak;\n\n\tcase CPU_NEWLY_IDLE:\n\t\tload_idx = sd->newidle_idx;\n\t\tbreak;\n\tdefault:\n\t\tload_idx = sd->idle_idx;\n\t\tbreak;\n\t}\n\n\treturn load_idx;\n}",
        "target": 0
    },
    {
        "id": 21,
        "func": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\tfsnotify_clear_marks_by_group(group);\n\n\t/* free this group, matching get was inotify_init->fsnotify_obtain_group */\n\tfsnotify_put_group(group);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 22,
        "func": "dissect_u3v_stream_payload(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, usb_conv_info_t *usb_conv_info _U_)\n{\n    proto_item *item = NULL;\n\n    /* Subtree initialization for Stream Leader */\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_payload, tvb, 0, -1, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_stream_payload);\n\n    /* Data */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_stream_data, tvb, 0, -1, ENC_NA);\n\n    /* Add payload type to information string */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"Stream Payload\");\n}",
        "target": 0
    },
    {
        "id": 23,
        "func": "static int hash_walk_next(struct crypto_hash_walk *walk)\n{\n\tunsigned int alignmask = walk->alignmask;\n\tunsigned int offset = walk->offset;\n\tunsigned int nbytes = min(walk->entrylen,\n\t\t\t\t  ((unsigned int)(PAGE_SIZE)) - offset);\n\n\twalk->data = kmap_atomic(walk->pg);\n\twalk->data += offset;\n\n\tif (offset & alignmask) {\n\t\tunsigned int unaligned = alignmask + 1 - (offset & alignmask);\n\t\tif (nbytes > unaligned)\n\t\t\tnbytes = unaligned;\n\t}\n\n\twalk->entrylen -= nbytes;\n\treturn nbytes;\n}",
        "target": 0
    },
    {
        "id": 24,
        "func": "static int fanout_rr_next(struct packet_fanout *f, unsigned int num)\n{\n\tint x = atomic_read(&f->rr_cur) + 1;\n\n\tif (x >= num)\n\t\tx = 0;\n\n\treturn x;\n}",
        "target": 0
    },
    {
        "id": 25,
        "func": "void RenderWidgetHostViewAura::SetTooltipText(\n    const base::string16& tooltip_text) {\n  tooltip_ = tooltip_text;\n  aura::Window* root_window = window_->GetRootWindow();\n  aura::client::TooltipClient* tooltip_client =\n      aura::client::GetTooltipClient(root_window);\n  if (tooltip_client) {\n    tooltip_client->UpdateTooltip(window_);\n    tooltip_client->SetTooltipShownTimeout(window_, 0);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 26,
        "func": "void RenderWidgetHostImpl::DispatchColorProfile() {\n#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)\n  static bool image_profiles = base::CommandLine::ForCurrentProcess()->\n     HasSwitch(switches::kEnableImageColorProfiles);\n  if (!image_profiles)\n    return;\n#if defined(OS_WIN)\n  BrowserThread::PostBlockingPoolTask(\n      FROM_HERE,\n      base::Bind(&RenderWidgetHostImpl::SendColorProfile,\n                 weak_factory_.GetWeakPtr()));\n#elif !defined(OS_CHROMEOS) && !defined(OS_IOS) && !defined(OS_ANDROID)\n  SendColorProfile();\n#endif\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 27,
        "func": "static void perf_event_comm_event(struct perf_comm_event *comm_event)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tchar comm[TASK_COMM_LEN];\n\tunsigned int size;\n\tstruct pmu *pmu;\n\tint ctxn;\n\n\tmemset(comm, 0, sizeof(comm));\n\tstrlcpy(comm, comm_event->task->comm, sizeof(comm));\n\tsize = ALIGN(strlen(comm)+1, sizeof(u64));\n\n\tcomm_event->comm = comm;\n\tcomm_event->comm_size = size;\n\n\tcomm_event->event_id.header.size = sizeof(comm_event->event_id) + size;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->active_pmu != pmu)\n\t\t\tgoto next;\n\t\tperf_event_comm_ctx(&cpuctx->ctx, comm_event);\n\n\t\tctxn = pmu->task_ctx_nr;\n\t\tif (ctxn < 0)\n\t\t\tgoto next;\n\n\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\tif (ctx)\n\t\t\tperf_event_comm_ctx(ctx, comm_event);\nnext:\n\t\tput_cpu_ptr(pmu->pmu_cpu_context);\n\t}\n\trcu_read_unlock();\n}",
        "target": 0
    },
    {
        "id": 28,
        "func": "  bool IsProcessBackgrounded(const base::Process& process) {\n#if defined(OS_MACOSX)\n    return process.IsProcessBackgrounded(port_provider_);\n#else\n    return process.IsProcessBackgrounded();\n#endif\n  }\n",
        "target": 0
    },
    {
        "id": 29,
        "func": "user_get_password_expiration_policy (AccountsUser          *auser,\n                                     GDBusMethodInvocation *context)\n{\n        User *user = (User*)auser;\n        int uid;\n        const gchar *action_id;\n\n        if (!get_caller_uid (context, &uid)) {\n                throw_error (context, ERROR_FAILED, \"identifying caller failed\");\n                return FALSE;\n        }\n\n        if (accounts_user_get_uid (ACCOUNTS_USER (user)) == (uid_t) uid)\n                action_id = \"org.freedesktop.accounts.change-own-user-data\";\n        else\n                action_id = \"org.freedesktop.accounts.user-administration\";\n\n        daemon_local_check_auth (user->daemon,\n                                 user,\n                                 action_id,\n                                 TRUE,\n                                 user_get_password_expiration_policy_authorized_cb,\n                                 context,\n                                 NULL,\n                                 NULL);\n\n        return TRUE;\n}\n",
        "target": 0
    },
    {
        "id": 30,
        "func": "  GetModifiedSinceTask(\n      QuotaManager* manager,\n      StorageType type,\n      base::Time modified_since,\n      GetOriginsCallback* callback)\n      : DatabaseTaskBase(manager),\n        type_(type),\n        modified_since_(modified_since),\n        callback_(callback) {}\n",
        "target": 0
    },
    {
        "id": 31,
        "func": "mm_audit_event(ssh_audit_event_t event)\n{\n\tBuffer m;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tbuffer_init(&m);\n\tbuffer_put_int(&m, event);\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUDIT_EVENT, &m);\n\tbuffer_free(&m);\n}",
        "target": 0
    },
    {
        "id": 32,
        "func": "static inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}",
        "target": 0
    },
    {
        "id": 33,
        "func": "   virtual void SetUp() {\n     old_browser_client_ = content::GetContentClient()->browser();\n     content::GetContentClient()->set_browser(&browser_client_);\n     url_util::AddStandardScheme(kPrivilegedScheme);\n    url_util::AddStandardScheme(chrome::kChromeUIScheme);\n  }\n",
        "target": 1
    },
    {
        "id": 34,
        "func": " void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", (unsigned long)outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \"29422022\");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n return NULL;\n }\n return memset(outHeader->pBuffer, c, len);\n}\n",
        "target": 1
    },
    {
        "id": 35,
        "func": "static void voidMethodNodeFilterArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::voidMethodNodeFilterArgMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 36,
        "func": "GF_Err gnrm_dump(GF_Box *a, FILE * trace)\n{\n\tGF_GenericSampleEntryBox *p = (GF_GenericSampleEntryBox *)a;\n\tif (p->EntryType)\n\t\ta->type = p->EntryType;\n\n\tgf_isom_box_dump_start(a, \"SampleDescriptionBox\", trace);\n\tfprintf(trace, \"DataReferenceIndex=\\\"%d\\\" ExtensionDataSize=\\\"%d\\\">\\n\", p->dataReferenceIndex, p->data_size);\n\ta->type = GF_ISOM_BOX_TYPE_GNRM;\n\tgf_isom_box_dump_done(\"SampleDescriptionBox\", a, trace);\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 37,
        "func": "static RAnalValue *anal_fill_reg_ref(RAnal *anal, int reg, st64 size){\n\tRAnalValue *ret = anal_fill_ai_rg (anal, reg);\n\tret->memref = size;\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 38,
        "func": "static void put_raw_sample(struct iw_context *ctx, double s,\n\t   int x, int y, int channel)\n{\n\tswitch(ctx->img2.bit_depth) {\n\tcase 8:  put_raw_sample_8(ctx,s,x,y,channel); break;\n\tcase 16: put_raw_sample_16(ctx,s,x,y,channel); break;\n\t}\n}",
        "target": 0
    },
    {
        "id": 39,
        "func": "EncodedJSValue JSC_HOST_CALL jsTestMediaQueryListListenerPrototypeFunctionMethod(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestMediaQueryListListener::s_info))\n        return throwVMTypeError(exec);\n    JSTestMediaQueryListListener* castedThis = jsCast<JSTestMediaQueryListListener*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestMediaQueryListListener::s_info);\n     TestMediaQueryListListener* impl = static_cast<TestMediaQueryListListener*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     RefPtr<MediaQueryListListener> listener(MediaQueryListListener::create(ScriptValue(exec->globalData(), MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined))));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->method(listener);\n    return JSValue::encode(jsUndefined());\n}\n",
        "target": 1
    },
    {
        "id": 40,
        "func": "  NavigationRecorder(WebContents* web_contents)\n      : WebContentsObserver(web_contents) {}\n",
        "target": 0
    },
    {
        "id": 41,
        "func": "BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT16 count;\n\t\tBITMAP_DATA* newdata;\n\t\tcount = bitmapUpdate->number * 2;\n\t\tnewdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                                 sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "id": 42,
        "func": "void LayerTreeHostQt::didSyncCompositingStateForLayer(const WebLayerInfo& info)\n{\n    m_shouldSyncFrame = true;\n    m_webPage->send(Messages::LayerTreeHostProxy::SyncCompositingLayerState(info));\n}\n",
        "target": 0
    },
    {
        "id": 43,
        "func": "  void FlushMonitoring() {\n    WaitableEvent flush_complete_event(false, false);\n    FlushMonitoring(&flush_complete_event);\n    flush_complete_event.Wait();\n  }\n",
        "target": 0
    },
    {
        "id": 44,
        "func": "struct dentry *d_alloc(struct dentry * parent, const struct qstr *name)\n{\n\tstruct dentry *dentry = __d_alloc(parent->d_sb, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tspin_lock(&parent->d_lock);\n\t/*\n\t * don't need child lock because it is not subject\n\t * to concurrency here\n\t */\n\t__dget_dlock(parent);\n\tdentry->d_parent = parent;\n\tlist_add(&dentry->d_child, &parent->d_subdirs);\n\tspin_unlock(&parent->d_lock);\n\n\treturn dentry;\n}",
        "target": 0
    },
    {
        "id": 45,
        "func": "void DestroySkImageOnOriginalThread(\n    sk_sp<SkImage> image,\n    base::WeakPtr<WebGraphicsContext3DProviderWrapper> context_provider_wrapper,\n    std::unique_ptr<gpu::SyncToken> sync_token) {\n  if (context_provider_wrapper &&\n      image->isValid(\n          context_provider_wrapper->ContextProvider()->GetGrContext())) {\n    if (sync_token->HasData()) {\n      context_provider_wrapper->ContextProvider()\n          ->ContextGL()\n          ->WaitSyncTokenCHROMIUM(sync_token->GetData());\n    }\n     image->getTexture()->textureParamsModified();\n   }\n }\n",
        "target": 1
    },
    {
        "id": 46,
        "func": " void MessageLoop::RunTask(PendingTask* pending_task) {\n  DCHECK(nestable_tasks_allowed_);\n   current_pending_task_ = pending_task;\n \n #if defined(OS_WIN)\n  DecrementHighResTaskCountIfNeeded(*pending_task);\n#endif\n\n  nestable_tasks_allowed_ = false;\n\n  TRACE_TASK_EXECUTION(\"MessageLoop::RunTask\", *pending_task);\n\n  for (auto& observer : task_observers_)\n    observer.WillProcessTask(*pending_task);\n  task_annotator_.RunTask(\"MessageLoop::PostTask\", pending_task);\n  for (auto& observer : task_observers_)\n    observer.DidProcessTask(*pending_task);\n\n  nestable_tasks_allowed_ = true;\n\n  current_pending_task_ = nullptr;\n}\n",
        "target": 1
    },
    {
        "id": 47,
        "func": "void ExtensionSystemImpl::Shared::InitPrefs() {\n  bool extensions_disabled =\n      profile_->GetPrefs()->GetBoolean(prefs::kDisableExtensions) ||\n      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableExtensions);\n  extension_prefs_ = ExtensionPrefs::Create(\n      profile_->GetPrefs(),\n      profile_->GetPath().AppendASCII(ExtensionService::kInstallDirectoryName),\n      ExtensionPrefValueMapFactory::GetForProfile(profile_),\n      extensions_disabled);\n  lazy_background_task_queue_.reset(new LazyBackgroundTaskQueue(profile_));\n  event_router_.reset(new EventRouter(profile_, extension_prefs_.get()));\n\n  state_store_.reset(new StateStore(\n      profile_,\n      profile_->GetPath().AppendASCII(ExtensionService::kStateStoreName),\n      true));\n  rules_store_.reset(new StateStore(\n      profile_,\n      profile_->GetPath().AppendASCII(ExtensionService::kRulesStoreName),\n      false));\n\n  shell_window_geometry_cache_.reset(new ShellWindowGeometryCache(\n      profile_, extension_prefs_.get()));\n\n  blacklist_.reset(new Blacklist(extension_prefs_.get()));\n\n  standard_management_policy_provider_.reset(\n      new StandardManagementPolicyProvider(extension_prefs_.get()));\n}\n",
        "target": 0
    },
    {
        "id": 48,
        "func": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\two = (rbuf == NULL || rlen == 0); /* write-only */\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 49,
        "func": "static int do_mlockall(int flags)\n{\n\tstruct vm_area_struct * vma, * prev = NULL;\n\n\tif (flags & MCL_FUTURE)\n\t\tcurrent->mm->def_flags |= VM_LOCKED;\n\telse\n\t\tcurrent->mm->def_flags &= ~VM_LOCKED;\n\tif (flags == MCL_FUTURE)\n\t\tgoto out;\n\n\tfor (vma = current->mm->mmap; vma ; vma = prev->vm_next) {\n\t\tvm_flags_t newflags;\n\n\t\tnewflags = vma->vm_flags & ~VM_LOCKED;\n\t\tif (flags & MCL_CURRENT)\n\t\t\tnewflags |= VM_LOCKED;\n\n\t\t/* Ignore errors */\n\t\tmlock_fixup(vma, &prev, vma->vm_start, vma->vm_end, newflags);\n\t\tcond_resched();\n\t}\nout:\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 50,
        "func": "String HTMLMediaElement::canPlayType(const String& mimeType) const {\n  MIMETypeRegistry::SupportsType support = supportsType(ContentType(mimeType));\n  String canPlay;\n\n  switch (support) {\n    case MIMETypeRegistry::IsNotSupported:\n      canPlay = emptyString;\n      break;\n    case MIMETypeRegistry::MayBeSupported:\n      canPlay = \"maybe\";\n      break;\n    case MIMETypeRegistry::IsSupported:\n      canPlay = \"probably\";\n      break;\n  }\n\n  BLINK_MEDIA_LOG << \"canPlayType(\" << (void*)this << \", \" << mimeType\n                  << \") -> \" << canPlay;\n\n  return canPlay;\n}\n",
        "target": 0
    },
    {
        "id": 51,
        "func": "  bool HasNavigationRequest() {\n    return contents()->GetFrameTree()->root()->navigation_request() != nullptr;\n  }\n",
        "target": 0
    },
    {
        "id": 52,
        "func": "  virtual void SetUp() {\n    content::GetContentClient()->set_renderer(&mock_content_renderer_client_);\n\n    static const char kThreadName[] = \"RenderThread\";\n    channel_.reset(new IPC::Channel(kThreadName,\n        IPC::Channel::MODE_SERVER, this));\n    ASSERT_TRUE(channel_->Connect());\n\n    mock_process_.reset(new MockRenderProcess);\n    render_thread_ = new RenderThreadImpl(kThreadName);\n\n    decoder_ = new media::MockAudioDecoder();\n\n    EXPECT_CALL(*decoder_, bits_per_channel())\n        .WillRepeatedly(Return(16));\n    EXPECT_CALL(*decoder_, channel_layout())\n        .WillRepeatedly(Return(CHANNEL_LAYOUT_MONO));\n    EXPECT_CALL(*decoder_, samples_per_second())\n        .WillRepeatedly(Return(44100));\n\n    scoped_refptr<media::AudioRendererSink> default_sink =\n        new AudioDevice();\n\n    renderer_ = new TestAudioRendererImpl(default_sink.get());\n    renderer_->Initialize(decoder_,\n                          media::NewExpectedStatusCB(media::PIPELINE_OK),\n                          NewUnderflowClosure(), NewAudioTimeClosure());\n\n    event_.reset(new base::WaitableEvent(false, false));\n  }\n",
        "target": 0
    },
    {
        "id": 53,
        "func": "static void acpi_os_map_cleanup(struct acpi_ioremap *map)\n{\n\tif (!map->refcount) {\n\t\tsynchronize_rcu_expedited();\n\t\tacpi_unmap(map->phys, map->virt);\n\t\tkfree(map);\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 54,
        "func": "void BackFramebuffer::Create() {\n  ScopedGLErrorSuppressor suppressor(\"BackFramebuffer::Create\",\n                                     decoder_->error_state_.get());\n  Destroy();\n  api()->glGenFramebuffersEXTFn(1, &id_);\n}\n",
        "target": 0
    },
    {
        "id": 55,
        "func": "RenderBlock* RenderBlock::continuationBefore(RenderObject* beforeChild)\n{\n    if (beforeChild && beforeChild->parent() == this)\n        return this;\n\n    RenderBlock* curr = toRenderBlock(continuation());\n    RenderBlock* nextToLast = this;\n    RenderBlock* last = this;\n    while (curr) {\n        if (beforeChild && beforeChild->parent() == curr) {\n            if (curr->firstChild() == beforeChild)\n                return last;\n            return curr;\n        }\n\n        nextToLast = last;\n        last = curr;\n        curr = toRenderBlock(curr->continuation());\n    }\n\n    if (!beforeChild && !last->firstChild())\n        return nextToLast;\n    return last;\n}\n",
        "target": 0
    },
    {
        "id": 56,
        "func": "void TestingAutomationProvider::WaitForTabCountToBecome(\n    int browser_handle,\n    int target_tab_count,\n    IPC::Message* reply_message) {\n  if (!browser_tracker_->ContainsHandle(browser_handle)) {\n    AutomationMsg_WaitForTabCountToBecome::WriteReplyParams(reply_message,\n                                                            false);\n    Send(reply_message);\n    return;\n  }\n\n  Browser* browser = browser_tracker_->GetResource(browser_handle);\n\n  new TabCountChangeObserver(this, browser, reply_message, target_tab_count);\n}\n",
        "target": 0
    },
    {
        "id": 57,
        "func": "int sm_broadcast_xml_config(p_fm_config_conx_hdlt hdl, fm_mgr_type_t mgr, int argc, char *argv[]) {\n\tfm_mgr_config_errno_t\tres;\n\tfm_msg_ret_code_t\t\tret_code;\n\n\tif((res = fm_mgr_simple_query(hdl, FM_ACT_GET, FM_DT_SM_BROADCAST_XML_CONFIG, mgr, 0, NULL, &ret_code)) != FM_CONF_OK)\n\t{\n\t\tfprintf(stderr, \"sm_broadcast_xml_config: Failed to retrieve data: \\n\"\n\t\t       \"\\tError:(%d) %s \\n\\tRet code:(%d) %s\\n\",\n\t\t       res, fm_mgr_get_error_str(res),ret_code,\n\t\t       fm_mgr_get_resp_error_str(ret_code));\n\t} else {\n\t\tprintf(\"sm_broadcast_xml_config: Successfully sent XML broadcast config command to local mgr instance\\n\");\n    }\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 58,
        "func": "static void print_stats(struct xen_blkif_ring *ring)\n{\n\tpr_info(\"(%s): oo %3llu  |  rd %4llu  |  wr %4llu  |  f %4llu\"\n\t\t \"  |  ds %4llu | pg: %4u/%4d\\n\",\n\t\t current->comm, ring->st_oo_req,\n\t\t ring->st_rd_req, ring->st_wr_req,\n\t\t ring->st_f_req, ring->st_ds_req,\n\t\t ring->persistent_gnt_c,\n\t\t xen_blkif_max_pgrants);\n\tring->st_print = jiffies + msecs_to_jiffies(10 * 1000);\n\tring->st_rd_req = 0;\n\tring->st_wr_req = 0;\n\tring->st_oo_req = 0;\n\tring->st_ds_req = 0;\n}",
        "target": 0
    },
    {
        "id": 59,
        "func": "void PepperMediaDeviceManager::StopEnumerateDevices(int request_id) {\n  enumerate_callbacks_.erase(request_id);\n\n#if defined(ENABLE_WEBRTC)\n  base::MessageLoop::current()->PostTask(\n      FROM_HERE,\n      base::Bind(&PepperMediaDeviceManager::StopEnumerateDevicesDelayed,\n                 AsWeakPtr(),\n                 request_id));\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 60,
        "func": "static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    ScriptState* currentState = ScriptState::current();\n    if (!currentState)\n        return;\n    ScriptState& state = *currentState;\n    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());\n    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);\n    if (state.hadException()) {\n        v8::Local<v8::Value> exception = state.exception();\n        state.clearException();\n        throwError(exception, info.GetIsolate());\n        return;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 61,
        "func": "  int capacity() const { return capacity_; };\n",
        "target": 0
    },
    {
        "id": 62,
        "func": "void SessionService::UpdateTabNavigation(\n    const SessionID& window_id,\n    const SessionID& tab_id,\n    int index,\n    const NavigationEntry& entry) {\n  if (!ShouldTrackEntry(entry.GetVirtualURL()) ||\n      !ShouldTrackChangesToWindow(window_id)) {\n    return;\n  }\n\n  if (tab_to_available_range_.find(tab_id.id()) !=\n      tab_to_available_range_.end()) {\n    std::pair<int, int>& range = tab_to_available_range_[tab_id.id()];\n    range.first = std::min(index, range.first);\n    range.second = std::max(index, range.second);\n  }\n  ScheduleCommand(CreateUpdateTabNavigationCommand(kCommandUpdateTabNavigation,\n                                                   tab_id.id(), index, entry));\n}\n",
        "target": 0
    },
    {
        "id": 63,
        "func": "bool ExtensionApiTest::StartFTPServer(const base::FilePath& root_directory) {\n  ftp_server_.reset(new net::SpawnedTestServer(net::SpawnedTestServer::TYPE_FTP,\n                                               root_directory));\n\n  if (!ftp_server_->Start())\n    return false;\n\n  test_config_->SetInteger(kFtpServerPort,\n                           ftp_server_->host_port_pair().port());\n\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 64,
        "func": " void DataReductionProxySettings::SetDataReductionProxyEnabled(bool enabled) {\n   DCHECK(thread_checker_.CalledOnValidThread());\n   DCHECK(data_reduction_proxy_service_->compression_stats());\n  if (spdy_proxy_auth_enabled_.GetValue() != enabled) {\n    spdy_proxy_auth_enabled_.SetValue(enabled);\n     OnProxyEnabledPrefChange();\n #if defined(OS_ANDROID)\n     data_reduction_proxy_service_->compression_stats()\n        ->SetDataUsageReportingEnabled(enabled);\n#endif  // defined(OS_ANDROID)\n  }\n}\n",
        "target": 1
    },
    {
        "id": 65,
        "func": "        static PassRefPtrWillBeRawPtr<CreateFileResult> create()\n        static CreateFileResult* create()\n         {\n            return new CreateFileResult();\n         }\n",
        "target": 0
    },
    {
        "id": 66,
        "func": "bool ldb_dn_is_valid(struct ldb_dn *dn)\n{\n\tif ( ! dn) return false;\n\treturn ! dn->invalid;\n}\n",
        "target": 0
    },
    {
        "id": 67,
        "func": "MagickExport MagickBooleanType GetTypeMetrics(Image *image,\n  const DrawInfo *draw_info,TypeMetric *metrics)\n{\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->text != (char *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->render=MagickFalse;\n  annotate_info->direction=UndefinedDirection;\n  (void) memset(metrics,0,sizeof(*metrics));\n  offset.x=0.0;\n  offset.y=0.0;\n  status=RenderType(image,annotate_info,&offset,metrics);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\"Metrics: text: %s; \"\n      \"width: %g; height: %g; ascent: %g; descent: %g; max advance: %g; \"\n      \"bounds: %g,%g  %g,%g; origin: %g,%g; pixels per em: %g,%g; \"\n      \"underline position: %g; underline thickness: %g\",annotate_info->text,\n      metrics->width,metrics->height,metrics->ascent,metrics->descent,\n      metrics->max_advance,metrics->bounds.x1,metrics->bounds.y1,\n      metrics->bounds.x2,metrics->bounds.y2,metrics->origin.x,metrics->origin.y,\n      metrics->pixels_per_em.x,metrics->pixels_per_em.y,\n      metrics->underline_position,metrics->underline_thickness);\n  annotate_info=DestroyDrawInfo(annotate_info);\n  return(status);\n}",
        "target": 0
    },
    {
        "id": 68,
        "func": "static int nlattr_to_dccp(struct nlattr *cda[], struct nf_conn *ct)\n{\n\tstruct nlattr *attr = cda[CTA_PROTOINFO_DCCP];\n\tstruct nlattr *tb[CTA_PROTOINFO_DCCP_MAX + 1];\n\tint err;\n\n\tif (!attr)\n\t\treturn 0;\n\n\terr = nla_parse_nested(tb, CTA_PROTOINFO_DCCP_MAX, attr,\n\t\t\t       dccp_nla_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[CTA_PROTOINFO_DCCP_STATE] ||\n\t    !tb[CTA_PROTOINFO_DCCP_ROLE] ||\n\t    nla_get_u8(tb[CTA_PROTOINFO_DCCP_ROLE]) > CT_DCCP_ROLE_MAX ||\n\t    nla_get_u8(tb[CTA_PROTOINFO_DCCP_STATE]) >= CT_DCCP_IGNORE) {\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&ct->lock);\n\tct->proto.dccp.state = nla_get_u8(tb[CTA_PROTOINFO_DCCP_STATE]);\n\tif (nla_get_u8(tb[CTA_PROTOINFO_DCCP_ROLE]) == CT_DCCP_ROLE_CLIENT) {\n\t\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\t\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\t} else {\n\t\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_SERVER;\n\t\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_CLIENT;\n\t}\n\tif (tb[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ]) {\n\t\tct->proto.dccp.handshake_seq =\n\t\tbe64_to_cpu(nla_get_be64(tb[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ]));\n\t}\n\tspin_unlock_bh(&ct->lock);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 69,
        "func": "void CrosLibrary::TestApi::SetSpeechSynthesisLibrary(\n",
        "target": 0
    },
    {
        "id": 70,
        "func": "void RenderMessageFilter::OnCompletedOpenChannelToNpapiPlugin(\n    OpenChannelToNpapiPluginCallback* client) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n  DCHECK(ContainsKey(plugin_host_clients_, client));\n  plugin_host_clients_.erase(client);\n}\n",
        "target": 0
    },
    {
        "id": 71,
        "func": "void virtqueue_flush(VirtQueue *vq, unsigned int count)\n{\n    uint16_t old, new;\n    /* Make sure buffer is written before we update index. */\n    smp_wmb();\n    trace_virtqueue_flush(vq, count);\n    old = vring_used_idx(vq);\n    new = old + count;\n    vring_used_idx_set(vq, new);\n    vq->inuse -= count;\n    if (unlikely((int16_t)(new - vq->signalled_used) < (uint16_t)(new - old)))\n        vq->signalled_used_valid = false;\n}\n",
        "target": 0
    },
    {
        "id": 72,
        "func": "static void handle_child_exit(int sig)\n{\n    pid_t pid;\n    int status;\n    time_t uptime;\n\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        FFServerStream *feed;\n\n        for (feed = config.first_feed; feed; feed = feed->next) {\n            if (feed->pid != pid)\n                continue;\n\n            uptime = time(0) - feed->pid_start;\n            feed->pid = 0;\n            fprintf(stderr,\n                    \"%s: Pid %\"PRId64\" exited with status %d after %\"PRId64\" \"\n                        \"seconds\\n\",\n                    feed->filename, (int64_t) pid, status, (int64_t)uptime);\n\n            if (uptime < 30)\n                /* Turn off any more restarts */\n                ffserver_free_child_args(&feed->child_argv);\n        }\n    }\n\n    need_to_start_children = 1;\n}",
        "target": 0
    },
    {
        "id": 73,
        "func": "  virtual void RunCallback() {\n    if (callback_) {\n      callback_->Run(error_code());\n      delete callback_;\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 74,
        "func": "int BlobURLRequestJob::ComputeBytesToRead() const {\n  int64 current_item_remaining_bytes =\n      item_length_list_[item_index_] - current_item_offset_;\n  int bytes_to_read = (read_buf_remaining_bytes_ > current_item_remaining_bytes)\n      ? static_cast<int>(current_item_remaining_bytes)\n      : read_buf_remaining_bytes_;\n  if (bytes_to_read > remaining_bytes_)\n    bytes_to_read = static_cast<int>(remaining_bytes_);\n  return bytes_to_read;\n}\n",
        "target": 0
    },
    {
        "id": 75,
        "func": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}",
        "target": 1
    },
    {
        "id": 76,
        "func": "status_t NuMediaExtractor::setDataSource(int fd, off64_t offset, off64_t size) {\n\n    ALOGV(\"setDataSource fd=%d (%s), offset=%lld, length=%lld\",\n            fd, nameForFd(fd).c_str(), (long long) offset, (long long) size);\n\n Mutex::Autolock autoLock(mLock);\n\n if (mImpl != NULL) {\n return -EINVAL;\n }\n\n    sp<FileSource> fileSource = new FileSource(dup(fd), offset, size);\n\n status_t err = fileSource->initCheck();\n if (err != OK) {\n return err;\n }\n\n    mImpl = MediaExtractor::Create(fileSource);\n\n if (mImpl == NULL) {\n return ERROR_UNSUPPORTED;\n }\n\n    err = updateDurationAndBitrate();\n if (err == OK) {\n        mDataSource = fileSource;\n }\n\n return OK;\n}\n",
        "target": 0
    },
    {
        "id": 77,
        "func": "void ShellWindowViews::ShowInactive() {\n  if (window_->IsVisible())\n    return;\n  window_->ShowInactive();\n}\n",
        "target": 0
    },
    {
        "id": 78,
        "func": "X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)\n{\n    return ctx->param;\n}\n",
        "target": 0
    },
    {
        "id": 79,
        "func": "error::Error GLES2DecoderPassthroughImpl::DoVertexAttribDivisorANGLE(\n    GLuint index,\n    GLuint divisor) {\n  api()->glVertexAttribDivisorANGLEFn(index, divisor);\n  return error::kNoError;\n}\n",
        "target": 0
    },
    {
        "id": 80,
        "func": "  Type type() const { return type_; }\n",
        "target": 0
    },
    {
        "id": 81,
        "func": "PHP_FUNCTION(mcrypt_enc_get_supported_key_sizes)\n {\n \tint i, count = 0;\n \tint *key_sizes;\n \tMCRYPT_GET_TD_ARG\n \tarray_init(return_value);\n \n\tkey_sizes = mcrypt_enc_get_supported_key_sizes(pm->td, &count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tadd_index_long(return_value, i, key_sizes[i]);\n\t}\n\n\tmcrypt_free(key_sizes);\n}\n",
        "target": 1
    },
    {
        "id": 82,
        "func": "static inline int aalg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\n\tif (id >= sizeof(t->aalgos) * 8)\n\t\treturn 0;\n\n\treturn (t->aalgos >> id) & 1;\n}",
        "target": 0
    },
    {
        "id": 83,
        "func": "JsVar *jsvArrayPopFirst(JsVar *arr) {\n  assert(jsvIsArray(arr));\n  if (jsvGetFirstChild(arr)) {\n    JsVar *child = jsvLock(jsvGetFirstChild(arr));\n    if (jsvGetFirstChild(arr) == jsvGetLastChild(arr))\n      jsvSetLastChild(arr, 0); // if 1 item in array\n    jsvSetFirstChild(arr, jsvGetNextSibling(child)); // unlink from end of array\n    jsvUnRef(child); // as no longer in array\n    if (jsvGetNextSibling(child)) {\n      JsVar *v = jsvLock(jsvGetNextSibling(child));\n      jsvSetPrevSibling(v, 0);\n      jsvUnLock(v);\n    }\n    jsvSetNextSibling(child, 0);\n    return child; // and return it\n  } else {\n    return 0;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 84,
        "func": "static void rds_ib_send_unmap_atomic(struct rds_ib_connection *ic,\n\t\t\t\t     struct rm_atomic_op *op,\n\t\t\t\t     int wc_status)\n{\n\t/* unmap atomic recvbuf */\n\tif (op->op_mapped) {\n\t\tib_dma_unmap_sg(ic->i_cm_id->device, op->op_sg, 1,\n\t\t\t\tDMA_FROM_DEVICE);\n\t\top->op_mapped = 0;\n\t}\n\n\trds_ib_send_complete(container_of(op, struct rds_message, atomic),\n\t\t\t     wc_status, rds_atomic_send_complete);\n\n\tif (op->op_type == RDS_ATOMIC_TYPE_CSWP)\n\t\trds_ib_stats_inc(s_ib_atomic_cswp);\n\telse\n\t\trds_ib_stats_inc(s_ib_atomic_fadd);\n}",
        "target": 0
    },
    {
        "id": 85,
        "func": "void PaintLayerScrollableArea::VisibleSizeChanged() {\n  ShowOverlayScrollbars();\n}\n",
        "target": 0
    },
    {
        "id": 86,
        "func": "static void regulator_disable_work(struct work_struct *work)\n{\n\tstruct regulator_dev *rdev = container_of(work, struct regulator_dev,\n\t\t\t\t\t\t  disable_work.work);\n\tint count, i, ret;\n\n\tmutex_lock(&rdev->mutex);\n\n\tBUG_ON(!rdev->deferred_disables);\n\n\tcount = rdev->deferred_disables;\n\trdev->deferred_disables = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = _regulator_disable(rdev);\n\t\tif (ret != 0)\n\t\t\trdev_err(rdev, \"Deferred disable failed: %d\\n\", ret);\n\t}\n\n\tmutex_unlock(&rdev->mutex);\n\n\tif (rdev->supply) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tret = regulator_disable(rdev->supply);\n\t\t\tif (ret != 0) {\n\t\t\t\trdev_err(rdev,\n\t\t\t\t\t \"Supply disable failed: %d\\n\", ret);\n\t\t\t}\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 87,
        "func": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n\n {\n     const char *perm = \"add\";\n \n    if (uid >= AID_APP) {\n         return 0; /* Don't allow apps to register services */\n     }\n \n return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n}\n",
        "target": 1
    },
    {
        "id": 88,
        "func": "int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\n\tm->msg_iov = iov;\n\terr = 0;\n\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 89,
        "func": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n \t\tstruct nfsd4_layoutget *lgp)\n {\n \tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n \t__be32 *p;\n \n \tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(1);\t/* we always set return-on-close */\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t/* we always return a single layout */\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n \t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n \t*p++ = cpu_to_be32(lgp->lg_layout_type);\n \n \tnfserr = ops->encode_layoutget(xdr, lgp);\n out:\n \tkfree(lgp->lg_content);\n\treturn nfserr;\n}\n",
        "target": 1
    },
    {
        "id": 90,
        "func": "static const SSL_METHOD *ssl23_get_client_method(int ver)\n\t{\n#ifndef OPENSSL_NO_SSL2\n        if (ver == SSL2_VERSION)\n                return(SSLv2_client_method());\n #endif\n        if (ver == SSL3_VERSION)\n                return(SSLv3_client_method());\n       else if (ver == TLS1_VERSION)\n                return(TLSv1_client_method());\n        else if (ver == TLS1_1_VERSION)\n                return(TLSv1_1_client_method());\n\telse\n\t\treturn(NULL);\n\t}\n",
        "target": 1
    },
    {
        "id": 91,
        "func": "PlatformSensor::~PlatformSensor() {\n  if (provider_)\n    provider_->RemoveSensor(GetType(), this);\n}\n",
        "target": 0
    },
    {
        "id": 92,
        "func": "static unsigned int decode_ftime(uint8_t *buf)\n{\n\tint raw;\n\tstruct tm datetime;\n\n\traw = (int) lha_decode_uint32(buf);\n\n\tif (raw == 0) {\n\t\treturn 0;\n\t}\n\n\t// Deconstruct the contents of the MS-DOS time value and populate the\n\t// 'datetime' structure. Note that 'mktime' generates a timestamp for\n\t// the local time zone: this is unfortunate, but probably the best\n\t// that can be done, due to the limited data stored in MS-DOS time\n\t// values.\n\n\tmemset(&datetime, 0, sizeof(struct tm));\n\n\tdatetime.tm_sec = (raw << 1) & 0x3e;\n\tdatetime.tm_min = (raw >> 5) & 0x3f;\n\tdatetime.tm_hour = (raw >> 11) & 0x1f;\n\tdatetime.tm_mday = (raw >> 16) & 0x1f;\n\tdatetime.tm_mon = ((raw >> 21) & 0xf) - 1;\n\tdatetime.tm_year = 80 + ((raw >> 25) & 0x7f);\n\tdatetime.tm_wday = 0;\n\tdatetime.tm_yday = 0;\n\tdatetime.tm_isdst = -1;\n\n\treturn (unsigned int) mktime(&datetime);\n}",
        "target": 0
    },
    {
        "id": 93,
        "func": "  void RunMultipleWheelScroll() {\n    DoSmoothWheelScroll(gfx::Vector2d(0, 100));\n    while (!VerifyRecordedSamplesForHistogram(\n        1, \"Event.Latency.ScrollBegin.Wheel.TimeToScrollUpdateSwapBegin4\")) {\n      GiveItSomeTime();\n      FetchHistogramsFromChildProcesses();\n    }\n\n    while (!VerifyRecordedSamplesForHistogram(\n        1, \"Event.Latency.ScrollUpdate.Wheel.TimeToScrollUpdateSwapBegin4\")) {\n      GiveItSomeTime();\n      FetchHistogramsFromChildProcesses();\n     }\n   }\n",
        "target": 0
    },
    {
        "id": 94,
        "func": "int kvm_deassign_device(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tpdev = assigned_dev->dev;\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\n\tiommu_detach_device(domain, &pdev->dev);\n\n\tpdev->dev_flags &= ~PCI_DEV_FLAGS_ASSIGNED;\n\n\tdev_info(&pdev->dev, \"kvm deassign device\\n\");\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 95,
        "func": "void kvm_set_page_dirty(struct page *page)\n{\n\tkvm_set_pfn_dirty(page_to_pfn(page));\n}\n",
        "target": 0
    },
    {
        "id": 96,
        "func": "ext4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}",
        "target": 1
    },
    {
        "id": 97,
        "func": "bool WebPage::selectionContainsDocumentPoint(const Platform::IntPoint& point)\n{\n    return d->m_selectionHandler->selectionContains(point);\n}\n",
        "target": 0
    },
    {
        "id": 98,
        "func": "static int CompareEdges(const void *x,const void *y)\n{\n  register const EdgeInfo\n    *p,\n    *q;\n\n  /*\n    Compare two edges.\n  */\n  p=(const EdgeInfo *) x;\n  q=(const EdgeInfo *) y;\n  if ((p->points[0].y-DrawEpsilon) > q->points[0].y)\n    return(1);\n  if ((p->points[0].y+DrawEpsilon) < q->points[0].y)\n    return(-1);\n  if ((p->points[0].x-DrawEpsilon) > q->points[0].x)\n    return(1);\n  if ((p->points[0].x+DrawEpsilon) < q->points[0].x)\n    return(-1);\n  if (((p->points[1].x-p->points[0].x)*(q->points[1].y-q->points[0].y)-\n       (p->points[1].y-p->points[0].y)*(q->points[1].x-q->points[0].x)) > 0.0)\n    return(1);\n  return(-1);\n}\n",
        "target": 0
    },
    {
        "id": 99,
        "func": "AppResult::AppResult(Profile* profile,\n                     const std::string& app_id,\n                     AppListControllerDelegate* controller,\n                     bool is_recommendation)\n    : profile_(profile),\n      app_id_(app_id),\n      controller_(controller),\n      extension_registry_(NULL) {\n  set_id(extensions::Extension::GetBaseURLFromExtensionId(app_id_).spec());\n  if (app_list::switches::IsExperimentalAppListEnabled())\n     set_display_type(is_recommendation ? DISPLAY_RECOMMENDATION : DISPLAY_TILE);\n \n   const extensions::Extension* extension =\n      extensions::ExtensionSystem::Get(profile_)->extension_service()\n          ->GetInstalledExtension(app_id_);\n   DCHECK(extension);\n \n   is_platform_app_ = extension->is_platform_app();\n\n  icon_.reset(\n      new extensions::IconImage(profile_,\n                                extension,\n                                extensions::IconsInfo::GetIcons(extension),\n                                GetPreferredIconDimension(),\n                                extensions::util::GetDefaultAppIcon(),\n                                this));\n  UpdateIcon();\n\n  StartObservingExtensionRegistry();\n}\n",
        "target": 1
    },
    {
        "id": 100,
        "func": "static int arcmsr_abort_one_cmd(struct AdapterControlBlock *acb,\n\t\tstruct CommandControlBlock *ccb)\n{\n\tint rtn;\n\trtn = arcmsr_polling_ccbdone(acb, ccb);\n\treturn rtn;\n}",
        "target": 0
    },
    {
        "id": 101,
        "func": "pgp_get_info_by_tag(sc_card_t *card, unsigned int tag)\n{\n\tstruct pgp_priv_data *priv = DRVDATA(card);\n\tstruct do_info *info;\n\n\tfor (info = priv->pgp_objects; (info != NULL) && (info->id > 0); info++)\n\t\tif (tag == info->id)\n\t\t\treturn info;\n\n\treturn NULL;\n}\n",
        "target": 0
    },
    {
        "id": 102,
        "func": "GC_API void * GC_CALL GC_generic_malloc(size_t lb, int k)\n{\n    void * result;\n    DCL_LOCK_STATE;\n\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    if (SMALL_OBJ(lb)) {\n        LOCK();\n        result = GC_generic_malloc_inner((word)lb, k);\n        UNLOCK();\n    } else {\n        size_t lg;\n        size_t lb_rounded;\n        word n_blocks;\n        GC_bool init;\n        lg = ROUNDED_UP_GRANULES(lb);\n        lb_rounded = GRANULES_TO_BYTES(lg);\n        n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n        init = GC_obj_kinds[k].ok_init;\n        LOCK();\n        result = (ptr_t)GC_alloc_large(lb_rounded, k, 0);\n        if (0 != result) {\n          if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n          } else {\n#           ifdef THREADS\n              /* Clear any memory that might be used for GC descriptors */\n              /* before we release the lock.                            */\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n          }\n        }\n        GC_bytes_allocd += lb_rounded;\n        UNLOCK();\n        if (init && !GC_debugging_started && 0 != result) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n    }\n    if (0 == result) {\n        return((*GC_get_oom_fn())(lb));\n    } else {\n        return(result);\n    }\n}",
        "target": 1
    },
    {
        "id": 103,
        "func": "static inline int decode_access_size(struct pt_regs *regs, unsigned int insn)\n{\n\tunsigned int tmp;\n\n\ttmp = ((insn >> 19) & 0xf);\n\tif (tmp == 11 || tmp == 14) /* ldx/stx */\n\t\treturn 8;\n\ttmp &= 3;\n\tif (!tmp)\n\t\treturn 4;\n\telse if (tmp == 3)\n\t\treturn 16;\t/* ldd/std - Although it is actually 8 */\n\telse if (tmp == 2)\n\t\treturn 2;\n\telse {\n\t\tprintk(\"Impossible unaligned trap. insn=%08x\\n\", insn);\n\t\tdie_if_kernel(\"Byte sized unaligned access?!?!\", regs);\n\n\t\t/* GCC should never warn that control reaches the end\n\t\t * of this function without returning a value because\n\t\t * die_if_kernel() is marked with attribute 'noreturn'.\n\t\t * Alas, some versions do...\n\t\t */\n\n\t\treturn 0;\n\t}\n}",
        "target": 0
    },
    {
        "id": 104,
        "func": "bool NavigationControllerRestoredObserver::FinishedRestoring() {\n  return (!controller_->NeedsReload() && !controller_->GetPendingEntry() &&\n          !controller_->GetWebContents()->IsLoading());\n}\n",
        "target": 0
    },
    {
        "id": 105,
        "func": "static inline int  perf_swevent_get_recursion_context(void)\t\t{ return -1; }",
        "target": 0
    },
    {
        "id": 106,
        "func": "bool SVGAnimateElement::animatedPropertyTypeSupportsAddition() const\n{\n    switch (m_animatedPropertyType) {\n    case AnimatedBoolean:\n    case AnimatedEnumeration:\n    case AnimatedPreserveAspectRatio:\n    case AnimatedString:\n    case AnimatedUnknown:\n        return false;\n    default:\n        return true;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 107,
        "func": "void nft_data_uninit(const struct nft_data *data, enum nft_data_types type)\n{\n\tswitch (type) {\n\tcase NFT_DATA_VALUE:\n\t\treturn;\n\tcase NFT_DATA_VERDICT:\n\t\treturn nft_verdict_uninit(data);\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}",
        "target": 0
    },
    {
        "id": 108,
        "func": "cmsBool CMSEXPORT cmsIT8SetPropertyStr(cmsHANDLE hIT8, const char* Key, const char *Val)\n{\n    cmsIT8* it8 = (cmsIT8*) hIT8;\n\n    if (!Val) return FALSE;\n    if (!*Val) return FALSE;\n\n    return AddToList(it8, &GetTable(it8)->HeaderList, Key, NULL, Val, WRITE_STRINGIFY) != NULL;\n}",
        "target": 0
    },
    {
        "id": 109,
        "func": "static void Com_InitRand(void)\n{\n\tunsigned int seed;\n\n\tif(Sys_RandomBytes((byte *) &seed, sizeof(seed)))\n\t\tsrand(seed);\n\telse\n\t\tsrand(time(NULL));\n}\n",
        "target": 0
    },
    {
        "id": 110,
        "func": "ikev1_cr_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi0 _U_,\n\t       uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CR)));\n\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CR)));\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "id": 111,
        "func": "void LayerTreeCoordinator::didPerformScheduledLayerFlush()\n{\n    if (m_notifyAfterScheduledLayerFlush) {\n        static_cast<DrawingAreaImpl*>(m_webPage->drawingArea())->layerHostDidFlushLayers();\n        m_notifyAfterScheduledLayerFlush = false;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 112,
        "func": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n{\n    FILE *fp = fopen(dest_filename, \"wx\");\n    if (!fp)\n        return false;\n\n    unsigned fd = 0;\n    while (fd <= 99999) /* paranoia check */\n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            /* in case the line is not terminated, terminate it */\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n\n    const int dest_fd = fileno(fp);\n    if (fchown(dest_fd, uid, gid) < 0)\n    {\n        perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dest_filename, (long)uid, (long)gid);\n        fclose(fp);\n        unlink(dest_filename);\n        return false;\n    }\n\n    fclose(fp);\n    return true;\n}\n",
        "target": 0
    },
    {
        "id": 113,
        "func": "static void pmcraid_clr_trans_op(\n\tstruct pmcraid_instance *pinstance\n)\n{\n\tunsigned long lock_flags;\n\n\tif (!pinstance->interrupt_mode) {\n\t\tiowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\n\t\t\tpinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\n\t\tiowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\n\t\t\tpinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t\tioread32(pinstance->int_regs.ioa_host_interrupt_clr_reg);\n\t}\n\n\tif (pinstance->reset_cmd != NULL) {\n\t\tdel_timer(&pinstance->reset_cmd->timer);\n\t\tspin_lock_irqsave(\n\t\t\tpinstance->host->host_lock, lock_flags);\n\t\tpinstance->reset_cmd->cmd_done(pinstance->reset_cmd);\n\t\tspin_unlock_irqrestore(\n\t\t\tpinstance->host->host_lock, lock_flags);\n\t}\n}",
        "target": 0
    },
    {
        "id": 114,
        "func": "qboolean FS_SV_FileExists( const char *file )\n{\n\tchar *testpath;\n\n\ttestpath = FS_BuildOSPath( fs_homepath->string, file, \"\");\n\ttestpath[strlen(testpath)-1] = '\\0';\n\n\treturn FS_FileInPathExists(testpath);\n}\n",
        "target": 0
    },
    {
        "id": 115,
        "func": "char *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}",
        "target": 1
    },
    {
        "id": 116,
        "func": "static EAS_RESULT ReadDLSID (SDLS_SYNTHESIZER_DATA *pDLSData, DLSID *pDLSID)\n{\n    EAS_RESULT result;\n    EAS_I32 n;\n\n if ((result = EAS_HWGetDWord(pDLSData->hwInstData, pDLSData->fileHandle, &pDLSID->Data1, EAS_FALSE)) != EAS_SUCCESS)\n return result;\n if ((result = EAS_HWGetWord(pDLSData->hwInstData, pDLSData->fileHandle, &pDLSID->Data2, EAS_FALSE)) != EAS_SUCCESS)\n return result;\n if ((result = EAS_HWGetWord(pDLSData->hwInstData, pDLSData->fileHandle, &pDLSID->Data3, EAS_FALSE)) != EAS_SUCCESS)\n return result;\n return EAS_HWReadFile(pDLSData->hwInstData, pDLSData->fileHandle, pDLSID->Data4, sizeof(pDLSID->Data4), &n);\n}\n",
        "target": 0
    },
    {
        "id": 117,
        "func": "    BluetoothSocketListenUsingRfcommFunction() {}\n",
        "target": 0
    },
    {
        "id": 118,
        "func": "  void CancelModalDialog() {\n    NativeAppModalDialog* native_dialog = GetDialog();\n    native_dialog->CancelAppModalDialog();\n  }\n",
        "target": 0
    },
    {
        "id": 119,
        "func": "int WebPluginDelegatePepper::PrintBegin(const gfx::Rect& printable_area,\n                                        int printer_dpi) {\n  int32 num_pages = 0;\n  NPPPrintExtensions* print_extensions = GetPrintExtensions();\n  if (print_extensions) {\n    NPRect np_printable_area = {0};\n    np_printable_area.left = printable_area.x();\n    np_printable_area.top = printable_area.y();\n    np_printable_area.right = np_printable_area.left + printable_area.width();\n    np_printable_area.bottom = np_printable_area.top + printable_area.height();\n    if (NPERR_NO_ERROR == print_extensions->printBegin(instance()->npp(),\n                                                       &np_printable_area,\n                                                       printer_dpi,\n                                                       &num_pages)) {\n      current_printable_area_ = printable_area;\n    }\n  }\n  return num_pages;\n}\n",
        "target": 0
    },
    {
        "id": 120,
        "func": "void DrawingBuffer::ResolveIfNeeded() {\n  if (anti_aliasing_mode_ != kNone && !contents_change_resolved_)\n    ResolveMultisampleFramebufferInternal();\n  contents_change_resolved_ = true;\n}\n",
        "target": 0
    },
    {
        "id": 121,
        "func": "static void update_group_times(struct perf_event *leader)\n{\n\tstruct perf_event *event;\n\n\tupdate_event_times(leader);\n\tlist_for_each_entry(event, &leader->sibling_list, group_entry)\n\t\tupdate_event_times(event);\n}",
        "target": 0
    },
    {
        "id": 122,
        "func": "BIGNUM *SRP_Calc_u(BIGNUM *A, BIGNUM *B, BIGNUM *N)\n\t{\n\t/* k = SHA1(PAD(A) || PAD(B) ) -- tls-srp draft 8 */\n\n\tBIGNUM *u;\t\n\tunsigned char cu[SHA_DIGEST_LENGTH];\n\tunsigned char *cAB;\n\tEVP_MD_CTX ctxt;\n\tint longN;  \n\tif ((A == NULL) ||(B == NULL) || (N == NULL))\n\t\treturn NULL;\n\n        if ((A == NULL) ||(B == NULL) || (N == NULL))\n                return NULL;\n \n        longN= BN_num_bytes(N);\n \n        if ((cAB = OPENSSL_malloc(2*longN)) == NULL) \n\tEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(A,cAB+longN), longN);\n\tEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(B,cAB+longN), longN);\n\tOPENSSL_free(cAB);\n\tEVP_DigestFinal_ex(&ctxt, cu, NULL);\n\tEVP_MD_CTX_cleanup(&ctxt);\n\n\tif (!(u = BN_bin2bn(cu, sizeof(cu), NULL)))\n\t\treturn NULL;\n\tif (!BN_is_zero(u))\n\t\treturn u;\n\tBN_free(u);\n\treturn NULL;\n}\n",
        "target": 1
    },
    {
        "id": 123,
        "func": "LogoServiceFactory::LogoServiceFactory()\n    : BrowserContextKeyedServiceFactory(\n          \"LogoService\",\n          BrowserContextDependencyManager::GetInstance()) {\n  DependsOn(TemplateURLServiceFactory::GetInstance());\n}\n",
        "target": 0
    },
    {
        "id": 124,
        "func": "static int xfrm6_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tskb_push(skb, -skb_network_offset(skb));\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 125,
        "func": "SparseHistogram::SparseHistogram(PersistentHistogramAllocator* allocator,\n                                 const std::string& name,\n                                 HistogramSamples::Metadata* meta,\n                                 HistogramSamples::Metadata* logged_meta)\n    : HistogramBase(name),\n      samples_(new PersistentSampleMap(HashMetricName(name), allocator, meta)),\n      logged_samples_(\n          new PersistentSampleMap(samples_->id() + 1, allocator, logged_meta)) {\n}\n",
        "target": 0
    },
    {
        "id": 126,
        "func": "gfx::Rect DesktopWindowTreeHostX11::ToPixelRect(\n    const gfx::Rect& rect_in_dip) const {\n  gfx::RectF rect_in_pixels = gfx::RectF(rect_in_dip);\n  GetRootTransform().TransformRect(&rect_in_pixels);\n  return gfx::ToEnclosingRect(rect_in_pixels);\n}\n",
        "target": 0
    },
    {
        "id": 127,
        "func": "findoprnd(ITEM *ptr, int32 *pos)\n{\n#ifdef BS_DEBUG\n\telog(DEBUG3, (ptr[*pos].type == OPR) ?\n\t\t \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);\n#endif\n\tif (ptr[*pos].type == VAL)\n\t{\n\t\tptr[*pos].left = 0;\n\t\t(*pos)--;\n\t}\n\telse if (ptr[*pos].val == (int32) '!')\n\t{\n\t\tptr[*pos].left = -1;\n\t\t(*pos)--;\n\t\tfindoprnd(ptr, pos);\n\t}\n\telse\n\t{\n\t\tITEM\t   *curitem = &ptr[*pos];\n\t\tint32\t\ttmp = *pos;\n\n\t\t(*pos)--;\n\t\tfindoprnd(ptr, pos);\n\t\tcuritem->left = *pos - tmp;\n\t\tfindoprnd(ptr, pos);\n\t}\n}",
        "target": 1
    },
    {
        "id": 128,
        "func": "int mem_cgroup_select_victim_node(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tmem_cgroup_may_update_nodemask(memcg);\n\tnode = memcg->last_scanned_node;\n\n\tnode = next_node(node, memcg->scan_nodes);\n\tif (node == MAX_NUMNODES)\n\t\tnode = first_node(memcg->scan_nodes);\n\t/*\n\t * We call this when we hit limit, not when pages are added to LRU.\n\t * No LRU may hold pages because all pages are UNEVICTABLE or\n\t * memcg is too small and all pages are not on LRU. In that case,\n\t * we use curret node.\n\t */\n\tif (unlikely(node == MAX_NUMNODES))\n\t\tnode = numa_node_id();\n\n\tmemcg->last_scanned_node = node;\n\treturn node;\n}\n",
        "target": 0
    },
    {
        "id": 129,
        "func": "MagickExport const char *GetLocaleValue(const LocaleInfo *locale_info)\n{\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(locale_info != (LocaleInfo *) NULL);\n  assert(locale_info->signature == MagickCoreSignature);\n  return(locale_info->message);\n}",
        "target": 0
    },
    {
        "id": 130,
        "func": "COMPS_HSList ** comps_mrtree_getp(COMPS_MRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_MRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found)\n            return NULL;\n        rtdata = (COMPS_MRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) return &rtdata->data;\n        else if (ended == 1) offset+=x;\n        else return NULL;\n        subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n    }\n    if (it)\n        return &((COMPS_MRTreeData*)it->data)->data;\n    else return NULL;\n}",
        "target": 0
    },
    {
        "id": 131,
        "func": "box_cn(Point *center, BOX *box)\n{\n\tcenter->x = (box->high.x + box->low.x) / 2.0;\n\tcenter->y = (box->high.y + box->low.y) / 2.0;\n}",
        "target": 0
    },
    {
        "id": 132,
        "func": "jsonb_delete_idx(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *in = PG_GETARG_JSONB(0);\n\tint\t\t\tidx = PG_GETARG_INT32(1);\n\tJsonbParseState *state = NULL;\n\tJsonbIterator *it;\n\tuint32\t\tr,\n\t\t\t\ti = 0,\n\t\t\t\tn;\n\tJsonbValue\tv,\n\t\t\t   *res = NULL;\n\n\tif (JB_ROOT_IS_SCALAR(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from scalar\")));\n\n\tif (JB_ROOT_IS_OBJECT(in))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot delete from object using integer subscript\")));\n\n\tif (JB_ROOT_COUNT(in) == 0)\n\t\tPG_RETURN_JSONB(in);\n\n\tit = JsonbIteratorInit(&in->root);\n\n\tr = JsonbIteratorNext(&it, &v, false);\n\tAssert (r == WJB_BEGIN_ARRAY);\n\tn = v.val.array.nElems;\n\n\tif (idx < 0)\n\t{\n\t\tif (-idx > n)\n\t\t\tidx = n;\n\t\telse\n\t\t\tidx = n + idx;\n\t}\n\n\tif (idx >= n)\n\t\tPG_RETURN_JSONB(in);\n\n\tpushJsonbValue(&state, r, NULL);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, true)) != 0)\n\t{\n\t\tif (r == WJB_ELEM)\n\t\t{\n\t\t\tif (i++ == idx)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tres = pushJsonbValue(&state, r, r < WJB_BEGIN_ARRAY ? &v : NULL);\n\t}\n\n\tAssert(res != NULL);\n\n\tPG_RETURN_JSONB(JsonbValueToJsonb(res));\n}\n",
        "target": 0
    },
    {
        "id": 133,
        "func": "static void mem_cgroup_update_tree(struct mem_cgroup *memcg, struct page *page)\n{\n\tunsigned long long excess;\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup_tree_per_zone *mctz;\n\tint nid = page_to_nid(page);\n\tint zid = page_zonenum(page);\n\tmctz = soft_limit_tree_from_page(page);\n\n\t/*\n\t * Necessary to update all ancestors when hierarchy is used.\n\t * because their event counter is not touched.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tmz = mem_cgroup_zoneinfo(memcg, nid, zid);\n\t\texcess = res_counter_soft_limit_excess(&memcg->res);\n\t\t/*\n\t\t * We have to update the tree if mz is on RB-tree or\n\t\t * mem is over its softlimit.\n\t\t */\n\t\tif (excess || mz->on_tree) {\n\t\t\tspin_lock(&mctz->lock);\n\t\t\t/* if on-tree, remove it */\n\t\t\tif (mz->on_tree)\n\t\t\t\t__mem_cgroup_remove_exceeded(memcg, mz, mctz);\n\t\t\t/*\n\t\t\t * Insert again. mz->usage_in_excess will be updated.\n\t\t\t * If excess is 0, no tree ops.\n\t\t\t */\n\t\t\t__mem_cgroup_insert_exceeded(memcg, mz, mctz, excess);\n\t\t\tspin_unlock(&mctz->lock);\n\t\t}\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 134,
        "func": "void RenderWidgetHostImpl::SendFrontSurfaceIsProtected(\n    bool is_protected,\n    uint32 protection_state_id,\n    int32 route_id,\n    int gpu_host_id) {\n  GpuProcessHostUIShim* ui_shim = GpuProcessHostUIShim::FromID(gpu_host_id);\n  if (ui_shim) {\n    ui_shim->Send(new AcceleratedSurfaceMsg_SetFrontSurfaceIsProtected(\n        route_id, is_protected, protection_state_id));\n  }\n}\n",
        "target": 1
    },
    {
        "id": 135,
        "func": " void ScreenRecorder::DoStopOnNetworkThread(const base::Closure& done_task) {\n   DCHECK(network_loop_->BelongsToCurrentThread());\n \n  network_stopped_ = true;\n\n  encode_loop_->PostTask(\n      FROM_HERE, base::Bind(&ScreenRecorder::DoStopOnEncodeThread,\n                            this, done_task));\n}\n",
        "target": 0
    },
    {
        "id": 136,
        "func": "  void ResetMaxCapacityBytes(size_t max_capacity_bytes) {\n    max_capacity_bytes_ = max_capacity_bytes;\n    Initialize();\n  }\n",
        "target": 0
    },
    {
        "id": 137,
        "func": "lspci_send(const char *output)\n{\n\tSTREAM s;\n\tsize_t len;\n\n\tlen = strlen(output);\n\ts = channel_init(lspci_channel, len);\n\tout_uint8p(s, output, len) s_mark_end(s);\n\tchannel_send(s, lspci_channel);\n}",
        "target": 0
    },
    {
        "id": 138,
        "func": "void RenderViewHostImpl::AddObserver(RenderViewHostObserver* observer) {\n  observers_.AddObserver(observer);\n}\n",
        "target": 0
    },
    {
        "id": 139,
        "func": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask /* flat mode */ &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}",
        "target": 1
    },
    {
        "id": 140,
        "func": "gifgetunsigned(Gif_Reader *grr)\n{\n  uint8_t one = gifgetbyte(grr);\n  uint8_t two = gifgetbyte(grr);\n  return one | (two << 8);\n}",
        "target": 0
    },
    {
        "id": 141,
        "func": "handle_tlbmiss(struct pt_regs *regs, unsigned long writeaccess,\n\t       unsigned long address)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tpte_t entry;\n\n\t/*\n\t * We don't take page faults for P1, P2, and parts of P4, these\n\t * are always mapped, whether it be due to legacy behaviour in\n\t * 29-bit mode, or due to PMB configuration in 32-bit mode.\n\t */\n\tif (address >= P3SEG && address < P3_ADDR_MAX) {\n\t\tpgd = pgd_offset_k(address);\n\t} else {\n\t\tif (unlikely(address >= TASK_SIZE || !current->mm))\n\t\t\treturn 1;\n\n\t\tpgd = pgd_offset(current->mm, address);\n\t}\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none_or_clear_bad(pud))\n\t\treturn 1;\n\tpmd = pmd_offset(pud, address);\n\tif (pmd_none_or_clear_bad(pmd))\n\t\treturn 1;\n\tpte = pte_offset_kernel(pmd, address);\n\tentry = *pte;\n\tif (unlikely(pte_none(entry) || pte_not_present(entry)))\n\t\treturn 1;\n\tif (unlikely(writeaccess && !pte_write(entry)))\n\t\treturn 1;\n\n\tif (writeaccess)\n\t\tentry = pte_mkdirty(entry);\n\tentry = pte_mkyoung(entry);\n\n\tset_pte(pte, entry);\n\n#if defined(CONFIG_CPU_SH4) && !defined(CONFIG_SMP)\n\t/*\n\t * SH-4 does not set MMUCR.RC to the corresponding TLB entry in\n\t * the case of an initial page write exception, so we need to\n\t * flush it in order to avoid potential TLB entry duplication.\n\t */\n\tif (writeaccess == 2)\n\t\tlocal_flush_tlb_one(get_asid(), address & PAGE_MASK);\n#endif\n\n\tupdate_mmu_cache(NULL, address, pte);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 142,
        "func": "void GraphicsContext::clip(const FloatRect& r)\n{\n    m_data->context->SetClippingRegion(r.x(), r.y(), r.width(), r.height());\n}\n",
        "target": 0
    },
    {
        "id": 143,
        "func": "\nnetdev_features_t netif_skb_features(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tnetdev_features_t features = dev->features;\n\n\tif (skb_is_gso(skb))\n\t\tfeatures = gso_features_check(skb, dev, features);\n\n\t/* If encapsulation offload request, verify we are testing\n\t * hardware encapsulation features instead of standard\n\t * features for the netdev\n\t */\n\tif (skb->encapsulation)\n\t\tfeatures &= dev->hw_enc_features;\n\n\tif (skb_vlan_tagged(skb))\n\t\tfeatures = netdev_intersect_features(features,\n\t\t\t\t\t\t     dev->vlan_features |\n\t\t\t\t\t\t     NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t\t\t     NETIF_F_HW_VLAN_STAG_TX);\n\n\tif (dev->netdev_ops->ndo_features_check)\n\t\tfeatures &= dev->netdev_ops->ndo_features_check(skb, dev,\n\t\t\t\t\t\t\t\tfeatures);\n\telse\n\t\tfeatures &= dflt_features_check(skb, dev, features);\n\n\treturn harmonize_features(skb, features);",
        "target": 0
    },
    {
        "id": 144,
        "func": "void RenderFrameImpl::PepperCaretPositionChanged(\n    PepperPluginInstanceImpl* instance) {\n  if (instance != render_view_->focused_pepper_plugin())\n    return;\n  GetRenderWidget()->UpdateSelectionBounds();\n}\n",
        "target": 0
    },
    {
        "id": 145,
        "func": "  cf2_freeSeacComponent( CFF_Decoder*  decoder,\n                         CF2_Buffer    buf )\n  {\n    FT_ASSERT( decoder );\n\n    cff_free_glyph_data( decoder->builder.face,\n                         (FT_Byte**)&buf->start,\n                         (FT_ULong)( buf->end - buf->start ) );\n  }\n",
        "target": 0
    },
    {
        "id": 146,
        "func": "void RenderViewHostImpl::AllowBindings(int bindings_flags) {\n  if (bindings_flags & BINDINGS_POLICY_WEB_UI &&\n      GetProcess()->HasConnection() &&\n      !ChildProcessSecurityPolicyImpl::GetInstance()->HasWebUIBindings(\n          GetProcess()->GetID())) {\n    RenderProcessHostImpl* process =\n        static_cast<RenderProcessHostImpl*>(GetProcess());\n    if (process->GetActiveViewCount() > 1)\n      return;\n  }\n\n  if (GetProcess()->IsGuest()) {\n    NOTREACHED() << \"Never grant bindings to a guest process.\";\n    return;\n  }\n\n  if (bindings_flags & BINDINGS_POLICY_WEB_UI) {\n    ChildProcessSecurityPolicyImpl::GetInstance()->GrantWebUIBindings(\n        GetProcess()->GetID());\n  }\n\n  enabled_bindings_ |= bindings_flags;\n  if (renderer_initialized_)\n    Send(new ViewMsg_AllowBindings(GetRoutingID(), enabled_bindings_));\n}\n",
        "target": 0
    },
    {
        "id": 147,
        "func": "SIZED_STRING* yr_object_get_string(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* string_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    string_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    string_obj = object;\n\n  va_end(args);\n\n  if (string_obj == NULL)\n    return NULL;\n\n  assertf(string_obj->type == OBJECT_TYPE_STRING,\n          \"type of \\\"%s\\\" is not string\\n\", field);\n\n  return ((YR_OBJECT_STRING*) string_obj)->value;\n}",
        "target": 0
    },
    {
        "id": 148,
        "func": " void PageRequestSummary::UpdateOrAddToOrigins(\n     const content::mojom::ResourceLoadInfo& resource_load_info) {\n  for (const auto& redirect_info : resource_load_info.redirect_info_chain)\n    UpdateOrAddToOrigins(redirect_info->url, redirect_info->network_info);\n  UpdateOrAddToOrigins(resource_load_info.url, resource_load_info.network_info);\n }\n",
        "target": 1
    },
    {
        "id": 149,
        "func": "  explicit SimpleAPIPermission(const APIPermissionInfo* permission)\n    : APIPermission(permission) { }\n",
        "target": 0
    },
    {
        "id": 150,
        "func": " OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n {\n \tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n \t(void)s;\n \tif (sp->libjpeg_jpeg_query_style==0)\n \t{\n \t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}\n",
        "target": 1
    },
    {
        "id": 151,
        "func": "void WebGLRenderingContextBase::LRUCanvasResourceProviderCache::BubbleToFront(\n    size_t idx) {\n  for (size_t i = idx; i > 0; --i)\n    resource_providers_[i].swap(resource_providers_[i - 1]);\n}\n",
        "target": 0
    },
    {
        "id": 152,
        "func": "void lock_buffer_pool(BufferPool *const pool) {\n#if CONFIG_MULTITHREAD\n  pthread_mutex_lock(&pool->pool_mutex);\n#else\n (void)pool;\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 153,
        "func": "static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)\n{\n\taddress &= PAGE_MASK;\n\tif ((vma->vm_flags & VM_GROWSDOWN) && address == vma->vm_start) {\n\t\tstruct vm_area_struct *prev = vma->vm_prev;\n\n\t\t/*\n\t\t * Is there a mapping abutting this one below?\n\t\t *\n\t\t * That's only ok if it's the same stack mapping\n\t\t * that has gotten split..\n\t\t */\n\t\tif (prev && prev->vm_end == address)\n\t\t\treturn prev->vm_flags & VM_GROWSDOWN ? 0 : -ENOMEM;\n\n\t\treturn expand_downwards(vma, address - PAGE_SIZE);\n\t}\n\tif ((vma->vm_flags & VM_GROWSUP) && address + PAGE_SIZE == vma->vm_end) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\n\t\t/* As VM_GROWSDOWN but s/below/above/ */\n\t\tif (next && next->vm_start == address + PAGE_SIZE)\n\t\t\treturn next->vm_flags & VM_GROWSUP ? 0 : -ENOMEM;\n\n\t\treturn expand_upwards(vma, address + PAGE_SIZE);\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 154,
        "func": "static struct fuse_dev *fuse_get_dev(struct file *file)\n{\n\t/*\n\t * Lockless access is OK, because file->private data is set\n\t * once during mount and is valid until the file is released.\n\t */\n\treturn READ_ONCE(file->private_data);\n}",
        "target": 0
    },
    {
        "id": 155,
        "func": "static BOOL update_send_surface_frame_bits(rdpContext* context,\n        const SURFACE_BITS_COMMAND* cmd,\n        BOOL first, BOOL last, UINT32 frameId)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (first)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_BEGIN,\n\t\t                                       frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!update_write_surfcmd_surface_bits(s, cmd))\n\t\tgoto out_fail;\n\n\tif (last)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_END, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                               cmd->skipCompression);\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 156,
        "func": "struct MACH0_(obj_t)* MACH0_(new_buf)(RBuffer *buf, bool verbose) {\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\n\tRBuffer * buf_copy = r_buf_new_with_buf (buf);\n\tif (!buf_copy) {\n\t\treturn NULL;\n\t}\n\n\treturn MACH0_(new_buf_steal) (buf_copy, verbose);\n}",
        "target": 0
    },
    {
        "id": 157,
        "func": "void ToggleFullscreenToolbar(Browser* browser) {\n  DCHECK(browser);\n\n  PrefService* prefs = browser->profile()->GetPrefs();\n  bool show_toolbar = prefs->GetBoolean(prefs::kShowFullscreenToolbar);\n  prefs->SetBoolean(prefs::kShowFullscreenToolbar, !show_toolbar);\n}\n",
        "target": 0
    },
    {
        "id": 158,
        "func": "bool DevToolsWindow::IsDocked() {\n  return dock_side_ != DEVTOOLS_DOCK_SIDE_UNDOCKED;\n}\n",
        "target": 0
    },
    {
        "id": 159,
        "func": "static __be32 *encode_fsid(__be32 *p, struct svc_fh *fhp)\n{\n\tu64 f;\n\tswitch(fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\tp = xdr_encode_hyper(p, (u64)huge_encode_dev\n\t\t\t\t     (fhp->fh_dentry->d_sb->s_dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u64*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u64*)fhp->fh_export->ex_uuid)[1];\n\t\tp = xdr_encode_hyper(p, f);\n\t\tbreak;\n\t}\n\treturn p;\n}\n",
        "target": 0
    },
    {
        "id": 160,
        "func": "struct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,\n\t\t\t     struct dx_entry *entries, int levels)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count = dx_get_count(entries), names = 0, space = 0, i;\n\tunsigned bcount = 0;\n\tstruct buffer_head *bh;\n\tint err;\n\tprintk(\"%i indexed blocks...\\n\", count);\n\tfor (i = 0; i < count; i++, entries++)\n\t{\n\t\text4_lblk_t block = dx_get_block(entries);\n\t\text4_lblk_t hash  = i ? dx_get_hash(entries): 0;\n\t\tu32 range = i < count - 1? (dx_get_hash(entries + 1) - hash): ~hash;\n\t\tstruct stats stats;\n\t\tprintk(\"%s%3u:%03u hash %8x/%8x \",levels?\"\":\"   \", i, block, hash, range);\n\t\tif (!(bh = ext4_bread (NULL,dir, block, 0,&err))) continue;\n\t\tstats = levels?\n\t\t   dx_show_entries(hinfo, dir, ((struct dx_node *) bh->b_data)->entries, levels - 1):\n\t\t   dx_show_leaf(hinfo, (struct ext4_dir_entry_2 *) bh->b_data, blocksize, 0);\n\t\tnames += stats.names;\n\t\tspace += stats.space;\n\t\tbcount += stats.bcount;\n\t\tbrelse(bh);\n\t}\n\tif (bcount)\n\t\tprintk(KERN_DEBUG \"%snames %u, fullness %u (%u%%)\\n\",\n\t\t       levels ? \"\" : \"   \", names, space/bcount,\n\t\t       (space/bcount)*100/blocksize);\n\treturn (struct stats) { names, space, bcount};\n}",
        "target": 0
    },
    {
        "id": 161,
        "func": "static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,\n                                      X509_ALGOR **pmaskHash)\n{\n    const unsigned char *p;\n    int plen;\n    RSA_PSS_PARAMS *pss;\n\n    *pmaskHash = NULL;\n\n    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);\n\n    if (!pss)\n        return NULL;\n\n     if (pss->maskGenAlgorithm) {\n         ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;\n         if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1\n            && param && param->type == V_ASN1_SEQUENCE) {\n             p = param->value.sequence->data;\n             plen = param->value.sequence->length;\n             *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);\n        }\n    }\n\n    return pss;\n}\n",
        "target": 0
    },
    {
        "id": 162,
        "func": "void UDPSocketWin::DidCompleteRead() {\n  DWORD num_bytes, flags;\n  BOOL ok = WSAGetOverlappedResult(socket_, &core_->read_overlapped_,\n                                   &num_bytes, FALSE, &flags);\n  WSAResetEvent(core_->read_overlapped_.hEvent);\n  int result = ok ? num_bytes : MapSystemError(WSAGetLastError());\n  if (recv_from_address_ && result >= 0) {\n    if (!ReceiveAddressToIPEndpoint(recv_from_address_))\n      result = ERR_ADDRESS_INVALID;\n  }\n  LogRead(result, core_->read_iobuffer_->data());\n  core_->read_iobuffer_ = NULL;\n  recv_from_address_ = NULL;\n  DoReadCallback(result);\n}\n",
        "target": 0
    },
    {
        "id": 163,
        "func": "void Browser::OnTranslateEnabledChanged(content::WebContents* source) {\n  DCHECK(source);\n  if (tab_strip_model_->GetActiveWebContents() == source)\n    UpdateToolbar(false);\n}\n",
        "target": 0
    },
    {
        "id": 164,
        "func": "static void call_console_drivers(unsigned start, unsigned end)\n{\n}\n",
        "target": 0
    },
    {
        "id": 165,
        "func": "  bool CanSendCookiesForOrigin(const GURL& gurl) {\n    const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n    if (!command_line.HasSwitch(switches::kEnableStrictSiteIsolation))\n      return true;\n\n    if (origin_lock_.is_empty())\n      return true;\n    GURL site_gurl = SiteInstanceImpl::GetSiteForURL(NULL, gurl);\n    return origin_lock_ == site_gurl;\n  }\n",
        "target": 0
    },
    {
        "id": 166,
        "func": "void NuMediaExtractor::releaseTrackSamples() {\n for (size_t i = 0; i < mSelectedTracks.size(); ++i) {\n TrackInfo *info = &mSelectedTracks.editItemAt(i);\n\n if (info->mSample != NULL) {\n            info->mSample->release();\n            info->mSample = NULL;\n\n            info->mSampleTimeUs = -1ll;\n }\n }\n}\n",
        "target": 0
    },
    {
        "id": 167,
        "func": "status_t MediaPlayer::getParameter(int key, Parcel *reply)\n{\n    ALOGV(\"MediaPlayer::getParameter(%d)\", key);\n Mutex::Autolock _l(mLock);\n if (mPlayer != NULL) {\n return  mPlayer->getParameter(key, reply);\n }\n    ALOGV(\"getParameter: no active player\");\n return INVALID_OPERATION;\n}\n",
        "target": 0
    },
    {
        "id": 168,
        "func": "static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}\n",
        "target": 0
    },
    {
        "id": 169,
        "func": "ThreadWatcherList::ThreadWatcherList() {\n  DCHECK(WatchDogThread::CurrentlyOnWatchDogThread());\n  CHECK(!g_thread_watcher_list_);\n  g_thread_watcher_list_ = this;\n}\n",
        "target": 0
    },
    {
        "id": 170,
        "func": "__tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t       struct tree_mod_elem **tm_list,\n\t\t       int nritems)\n{\n\tint i, j;\n\tint ret;\n\n\tfor (i = nritems - 1; i >= 0; i--) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret) {\n\t\t\tfor (j = nritems - 1; j > i; j--)\n\t\t\t\trb_erase(&tm_list[j]->node,\n\t\t\t\t\t &fs_info->tree_mod_log);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 171,
        "func": "poppler_page_free_annot_mapping (GList *list)\n{\n  if (!list)\n    return;\n\n  g_list_foreach (list, (GFunc)poppler_annot_mapping_free, NULL);\n  g_list_free (list);\n}\n",
        "target": 0
    },
    {
        "id": 172,
        "func": "static void DetectRun(ThreadVars *th_v,\n        DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\n        Packet *p)\n{\n    SCEnter();\n    SCLogDebug(\"pcap_cnt %\"PRIu64, p->pcap_cnt);\n\n    /* bail early if packet should not be inspected */\n    if (p->flags & PKT_NOPACKET_INSPECTION) {\n        /* nothing to do */\n        SCReturn;\n    }\n\n    /* Load the Packet's flow early, even though it might not be needed.\n     * Mark as a constant pointer, although the flow itself can change. */\n    Flow * const pflow = p->flow;\n\n    DetectRunScratchpad scratch = DetectRunSetup(de_ctx, det_ctx, p, pflow);\n\n    /* run the IPonly engine */\n    DetectRunInspectIPOnly(th_v, de_ctx, det_ctx, pflow, p);\n\n    /* get our rule group */\n    DetectRunGetRuleGroup(de_ctx, p, pflow, &scratch);\n    /* if we didn't get a sig group head, we\n     * have nothing to do.... */\n    if (scratch.sgh == NULL) {\n        SCLogDebug(\"no sgh for this packet, nothing to match against\");\n        goto end;\n    }\n\n    /* run the prefilters for packets */\n    DetectRunPrefilterPkt(th_v, de_ctx, det_ctx, p, &scratch);\n\n    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_RULES);\n    /* inspect the rules against the packet */\n    DetectRulePacketRules(th_v, de_ctx, det_ctx, p, pflow, &scratch);\n    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_RULES);\n\n    /* run tx/state inspection */\n    if (pflow && pflow->alstate) {\n        PACKET_PROFILING_DETECT_START(p, PROF_DETECT_TX);\n        DetectRunTx(th_v, de_ctx, det_ctx, p, pflow, &scratch);\n        PACKET_PROFILING_DETECT_END(p, PROF_DETECT_TX);\n    }\n\nend:\n    DetectRunPostRules(th_v, de_ctx, det_ctx, p, pflow, &scratch);\n\n    DetectRunCleanup(det_ctx, p, pflow);\n    SCReturn;\n}\n",
        "target": 0
    },
    {
        "id": 173,
        "func": "bool BackTexture::AllocateStorage(\n    const gfx::Size& size, GLenum format, bool zero) {\n  DCHECK_NE(id(), 0u);\n  ScopedGLErrorSuppressor suppressor(\"BackTexture::AllocateStorage\",\n                                     decoder_->state_.GetErrorState());\n  ScopedTextureBinder binder(&decoder_->state_, id(), Target());\n  uint32_t image_size = 0;\n  GLES2Util::ComputeImageDataSizes(size.width(), size.height(), 1, format,\n                                   GL_UNSIGNED_BYTE, 8, &image_size, nullptr,\n                                   nullptr);\n\n  bool success = false;\n  size_ = size;\n  if (decoder_->should_use_native_gmb_for_backbuffer_) {\n    DestroyNativeGpuMemoryBuffer(true);\n    success = AllocateNativeGpuMemoryBuffer(size, format, zero);\n  } else {\n    {\n      std::unique_ptr<char[]> zero_data;\n      if (zero) {\n        zero_data.reset(new char[image_size]);\n        memset(zero_data.get(), 0, image_size);\n      }\n\n      api()->glTexImage2DFn(Target(),\n                            0,  // mip level\n                            format, size.width(), size.height(),\n                            0,  // border\n                            format, GL_UNSIGNED_BYTE, zero_data.get());\n    }\n\n    decoder_->texture_manager()->SetLevelInfo(\n        texture_ref_.get(), Target(),\n        0,  // level\n        GL_RGBA, size.width(), size.height(),\n        1,  // depth\n        0,  // border\n        GL_RGBA, GL_UNSIGNED_BYTE, gfx::Rect(size));\n    success = api()->glGetErrorFn() == GL_NO_ERROR;\n  }\n\n  if (success) {\n    memory_tracker_.TrackMemFree(bytes_allocated_);\n    bytes_allocated_ = image_size;\n    memory_tracker_.TrackMemAlloc(bytes_allocated_);\n  }\n  return success;\n}\n",
        "target": 0
    },
    {
        "id": 174,
        "func": "static int usb_dev_freeze(struct device *dev)\n{\n\treturn usb_suspend(dev, PMSG_FREEZE);\n}",
        "target": 0
    },
    {
        "id": 175,
        "func": "static int raw_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t       int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len, addr_len);\n\t\tgoto out;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}",
        "target": 0
    },
    {
        "id": 176,
        "func": "static int amd_gpio_direction_output(struct gpio_chip *gc, unsigned offset,\n\t\tint value)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tpin_reg |= BIT(OUTPUT_ENABLE_OFF);\n\tif (value)\n\t\tpin_reg |= BIT(OUTPUT_VALUE_OFF);\n\telse\n\t\tpin_reg &= ~BIT(OUTPUT_VALUE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 177,
        "func": " int BrowserNonClientFrameViewAura::NonClientTopBorderHeight(\n     bool force_restored) const {\n   if (frame()->widget_delegate() &&\n       frame()->widget_delegate()->ShouldShowWindowTitle()) {\n     return close_button_->bounds().bottom();\n   }\n  if (!frame()->IsMaximized() || force_restored)\n    return kTabstripTopSpacingRestored;\n  return kTabstripTopSpacingMaximized;\n }\n",
        "target": 1
    },
    {
        "id": 178,
        "func": "ip_vs_edit_service(struct ip_vs_service *svc, struct ip_vs_service_user_kern *u)\n{\n\tstruct ip_vs_scheduler *sched, *old_sched;\n\tstruct ip_vs_pe *pe = NULL, *old_pe = NULL;\n\tint ret = 0;\n\n\t/*\n\t * Lookup the scheduler, by 'u->sched_name'\n\t */\n\tsched = ip_vs_scheduler_get(u->sched_name);\n\tif (sched == NULL) {\n\t\tpr_info(\"Scheduler module ip_vs_%s not found\\n\", u->sched_name);\n\t\treturn -ENOENT;\n\t}\n\told_sched = sched;\n\n\tif (u->pe_name && *u->pe_name) {\n\t\tpe = ip_vs_pe_getbyname(u->pe_name);\n\t\tif (pe == NULL) {\n\t\t\tpr_info(\"persistence engine module ip_vs_pe_%s \"\n\t\t\t\t\"not found\\n\", u->pe_name);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\told_pe = pe;\n\t}\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (u->af == AF_INET6 && (u->netmask < 1 || u->netmask > 128)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n#endif\n\n\twrite_lock_bh(&__ip_vs_svc_lock);\n\n\t/*\n\t * Wait until all other svc users go away.\n\t */\n\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 0);\n\n\t/*\n\t * Set the flags and timeout value\n\t */\n\tsvc->flags = u->flags | IP_VS_SVC_F_HASHED;\n\tsvc->timeout = u->timeout * HZ;\n\tsvc->netmask = u->netmask;\n\n\told_sched = svc->scheduler;\n\tif (sched != old_sched) {\n\t\t/*\n\t\t * Unbind the old scheduler\n\t\t */\n\t\tif ((ret = ip_vs_unbind_scheduler(svc))) {\n\t\t\told_sched = sched;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Bind the new scheduler\n\t\t */\n\t\tif ((ret = ip_vs_bind_scheduler(svc, sched))) {\n\t\t\t/*\n\t\t\t * If ip_vs_bind_scheduler fails, restore the old\n\t\t\t * scheduler.\n\t\t\t * The main reason of failure is out of memory.\n\t\t\t *\n\t\t\t * The question is if the old scheduler can be\n\t\t\t * restored all the time. TODO: if it cannot be\n\t\t\t * restored some time, we must delete the service,\n\t\t\t * otherwise the system may crash.\n\t\t\t */\n\t\t\tip_vs_bind_scheduler(svc, old_sched);\n\t\t\told_sched = sched;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\told_pe = svc->pe;\n\tif (pe != old_pe) {\n\t\tip_vs_unbind_pe(svc);\n\t\tip_vs_bind_pe(svc, pe);\n\t}\n\nout_unlock:\n\twrite_unlock_bh(&__ip_vs_svc_lock);\nout:\n\tip_vs_scheduler_put(old_sched);\n\tip_vs_pe_put(old_pe);\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 179,
        "func": "void Document::webkitWillEnterFullScreenForElement(Element* element)\n{\n    if (!attached() || inPageCache())\n        return;\n\n    ASSERT(element);\n\n    if (!page())\n        return;\n\n    ASSERT(page()->settings()->fullScreenEnabled());\n\n    if (m_fullScreenRenderer)\n        m_fullScreenRenderer->unwrapRenderer();\n\n    m_fullScreenElement = element;\n\n#if USE(NATIVE_FULLSCREEN_VIDEO)\n    if (element && element->isMediaElement())\n        return;\n#endif\n\n    RenderObject* renderer = m_fullScreenElement->renderer();\n    bool shouldCreatePlaceholder = renderer && renderer->isBox();\n    if (shouldCreatePlaceholder) {\n        m_savedPlaceholderFrameRect = toRenderBox(renderer)->frameRect();\n        m_savedPlaceholderRenderStyle = RenderStyle::clone(renderer->style());\n    }\n\n    if (m_fullScreenElement != documentElement())\n        RenderFullScreen::wrapRenderer(renderer, renderer ? renderer->parent() : 0, this);\n\n    m_fullScreenElement->setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);\n    \n    recalcStyle(Force);\n}\n",
        "target": 0
    },
    {
        "id": 180,
        "func": "XFixesSelectCursorInput(ClientPtr pClient, WindowPtr pWindow, CARD32 eventMask)\n{\n    CursorEventPtr *prev, e;\n    void *val;\n    int rc;\n\n    for (prev = &cursorEvents; (e = *prev); prev = &e->next) {\n        if (e->pClient == pClient && e->pWindow == pWindow) {\n            break;\n        }\n    }\n    if (!eventMask) {\n        if (e) {\n            FreeResource(e->clientResource, 0);\n        }\n        return Success;\n    }\n    if (!e) {\n        e = (CursorEventPtr) malloc(sizeof(CursorEventRec));\n        if (!e)\n            return BadAlloc;\n\n        e->next = 0;\n        e->pClient = pClient;\n        e->pWindow = pWindow;\n        e->clientResource = FakeClientID(pClient->index);\n\n        /*\n         * Add a resource hanging from the window to\n         * catch window destroy\n         */\n        rc = dixLookupResourceByType(&val, pWindow->drawable.id,\n                                     CursorWindowType, serverClient,\n                                     DixGetAttrAccess);\n        if (rc != Success)\n            if (!AddResource(pWindow->drawable.id, CursorWindowType,\n                             (void *) pWindow)) {\n                free(e);\n                return BadAlloc;\n            }\n\n        if (!AddResource(e->clientResource, CursorClientType, (void *) e))\n            return BadAlloc;\n\n        *prev = e;\n    }\n    e->eventMask = eventMask;\n    return Success;\n}\n",
        "target": 0
    },
    {
        "id": 181,
        "func": "void VideoRendererBase::AttemptRead_Locked() {\n  lock_.AssertAcquired();\n  DCHECK_NE(kEnded, state_);\n\n  if (pending_read_ ||\n      NumFrames_Locked() == limits::kMaxVideoFrames ||\n      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||\n      state_ == kFlushingDecoder ||\n      state_ == kFlushing) {\n    return;\n  }\n\n  pending_read_ = true;\n  decoder_->Read(base::Bind(&VideoRendererBase::FrameReady, this));\n}\n",
        "target": 0
    },
    {
        "id": 182,
        "func": "  void RunCryptohomeCheck(const AccountId& account_id, bool service_is_ready) {\n    if (!service_is_ready) {\n      LOG(ERROR) << \"Cryptohome is not available.\";\n      return;\n    }\n\n    const cryptohome::Identification cryptohome_id(account_id);\n    DBusThreadManager::Get()->GetCryptohomeClient()->NeedsDircryptoMigration(\n        cryptohome_id,\n        base::BindOnce(&DircryptoMigrationChecker::\n                           OnCryptohomeNeedsDircryptoMigrationCallback,\n                       weak_ptr_factory_.GetWeakPtr(), account_id));\n  }\n",
        "target": 0
    },
    {
        "id": 183,
        "func": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}",
        "target": 1
    },
    {
        "id": 184,
        "func": "  int GetCursorPositionX(int cursor_pos) {\n    return test_api_->GetRenderText()->GetCursorBounds(\n        gfx::SelectionModel(cursor_pos, gfx::CURSOR_FORWARD), false).x();\n  }\n",
        "target": 0
    },
    {
        "id": 185,
        "func": "PHP_FUNCTION(mb_ereg_search_init)\n{\n\tsize_t argc = ZEND_NUM_ARGS();\n\tzval *arg_str;\n\tchar *arg_pattern = NULL, *arg_options = NULL;\n\tint arg_pattern_len = 0, arg_options_len = 0;\n\tOnigSyntaxType *syntax = NULL;\n\tOnigOptionType option;\n\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"z|ss\", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {\n \t\treturn;\n \t}\n \tif (argc > 1 && arg_pattern_len == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty pattern\");\n \t\tRETURN_FALSE;\n\t}\n\n\toption = MBREX(regex_default_options);\n\tsyntax = MBREX(regex_default_syntax);\n\n\tif (argc == 3) {\n\t\toption = 0;\n\t\t_php_mb_regex_init_options(arg_options, arg_options_len, &option, &syntax, NULL);\n\t}\n\n\tif (argc > 1) {\n\t\t/* create regex pattern buffer */\n\t\tif ((MBREX(search_re) = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, option, MBREX(current_mbctype), syntax TSRMLS_CC)) == NULL) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tif (MBREX(search_str) != NULL) {\n\t\tzval_ptr_dtor(&MBREX(search_str));\n\t\tMBREX(search_str) = (zval *)NULL;\n\t}\n\n\tMBREX(search_str) = arg_str;\n\tZ_ADDREF_P(MBREX(search_str));\n\tSEPARATE_ZVAL_IF_NOT_REF(&MBREX(search_str));\n\n\tMBREX(search_pos) = 0;\n\n\tif (MBREX(search_regs) != NULL) {\n\t\tonig_region_free(MBREX(search_regs), 1);\n\t\tMBREX(search_regs) = (OnigRegion *) NULL;\n\t}\n\n\tRETURN_TRUE;\n}\n",
        "target": 1
    },
    {
        "id": 186,
        "func": "state_to_string (NMDeviceState state)\n{\n\treturn queued_state_to_string (state) + strlen (QUEUED_PREFIX);\n}\n",
        "target": 0
    },
    {
        "id": 187,
        "func": "queryin(char *buf)\n{\n\tQPRS_STATE\tstate;\n\tint32\t\ti;\n\tltxtquery  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n\n#ifdef BS_DEBUG\n\tchar\t\tpbuf[16384],\n\t\t\t   *cur;\n#endif\n\n\t/* init state */\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\n\t/* init list of operand */\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\n\t/* parse query & make polish notation (postfix, but in reverse order) */\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"syntax error\"),\n\t\t\t\t errdetail(\"Empty query.\")));\n\n\t/* make finish struct */\n\tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n\tquery = (ltxtquery *) palloc(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = state.num;\n\tptr = GETQUERY(query);\n\n\t/* set item in polish notation */\n\tfor (i = 0; i < state.num; i++)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\tptr[i].distance = state.str->distance;\n\t\tptr[i].length = state.str->length;\n\t\tptr[i].flag = state.str->flag;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\n\t/* set user friendly-operand view */\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\n\t/* set left operand's position for every operator */\n\tpos = 0;\n\tfindoprnd(ptr, &pos);\n\n\treturn query;\n}",
        "target": 1
    },
    {
        "id": 188,
        "func": "CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item != NULL) {\n        item->type = cJSON_Object | cJSON_IsReference;\n        item->child = (cJSON*)cast_away_const(child);\n    }\n\n    return item;\n}",
        "target": 0
    },
    {
        "id": 189,
        "func": "  bool EndDrag(EndDragReason reason) {\n    if (!drag_controller_.get())\n      return false;\n    bool started_drag = drag_controller_->started_drag();\n    drag_controller_->EndDrag(reason);\n    return started_drag;\n  }\n",
        "target": 0
    },
    {
        "id": 190,
        "func": "static const char *set_qualify_redirect_url(cmd_parms *cmd, void *d_, int flag)\n{\n    core_dir_config *d = d_;\n\n    d->qualify_redirect_url = flag ? AP_CORE_CONFIG_ON : AP_CORE_CONFIG_OFF;\n\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 191,
        "func": "gfx::Rect DesktopWindowTreeHostX11::GetWorkAreaBoundsInScreen() const {\n  return display::Screen::GetScreen()\n      ->GetDisplayNearestWindow(const_cast<aura::Window*>(window()))\n      .work_area();\n}\n",
        "target": 0
    },
    {
        "id": 192,
        "func": "std::string DownloadItemImpl::GetReferrerCharset() const {\n  return referrer_charset_;\n}\n",
        "target": 0
    },
    {
        "id": 193,
        "func": "inline void PulseAudioMixer::MainloopUnlock() const {\ninline void AudioMixerPulse::MainloopUnlock() const {\n   --mainloop_lock_count_;\n   pa_threaded_mainloop_unlock(pa_mainloop_);\n }\n",
        "target": 0
    },
    {
        "id": 194,
        "func": " void FakePlatformSensorProvider::CreateSensorInternal(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);\n   auto sensor =\n      base::MakeRefCounted<FakePlatformSensor>(type, std::move(mapping), this);\n   DoCreateSensorInternal(type, std::move(sensor), callback);\n }\n",
        "target": 1
    },
    {
        "id": 195,
        "func": "http_rxchunk(struct http *hp)\n{\n\tchar *q;\n\tint l, i;\n\n\tl = hp->prxbuf;\n\tdo\n\t\t(void)http_rxchar(hp, 1, 0);\n\twhile (hp->rxbuf[hp->prxbuf - 1] != '\\n');\n\tvtc_dump(hp->vl, 4, \"len\", hp->rxbuf + l, -1);\n\ti = strtoul(hp->rxbuf + l, &q, 16);\n\tbprintf(hp->chunklen, \"%d\", i);\n\tif ((q == hp->rxbuf + l) ||\n\t\t(*q != '\\0' && !vct_islws(*q))) {\n\t\tvtc_log(hp->vl, hp->fatal, \"chunked fail %02x @ %d\",\n\t\t    *q, q - (hp->rxbuf + l));\n\t}\n\tassert(q != hp->rxbuf + l);\n\tassert(*q == '\\0' || vct_islws(*q));\n\thp->prxbuf = l;\n\tif (i > 0) {\n\t\t(void)http_rxchar(hp, i, 0);\n\t\tvtc_dump(hp->vl, 4, \"chunk\",\n\t\t    hp->rxbuf + l, i);\n \t}\n \tl = hp->prxbuf;\n \t(void)http_rxchar(hp, 2, 0);\n\tif(!vct_iscrlf(hp->rxbuf[l]))\n \t\tvtc_log(hp->vl, hp->fatal,\n \t\t    \"Wrong chunk tail[0] = %02x\",\n \t\t    hp->rxbuf[l] & 0xff);\n\tif(!vct_iscrlf(hp->rxbuf[l + 1]))\n \t\tvtc_log(hp->vl, hp->fatal,\n \t\t    \"Wrong chunk tail[1] = %02x\",\n \t\t    hp->rxbuf[l + 1] & 0xff);\n\thp->prxbuf = l;\n\thp->rxbuf[l] = '\\0';\n\treturn (i);\n}\n",
        "target": 1
    },
    {
        "id": 196,
        "func": "void FileBrowserPrivateRequestDriveShareFunction::OnAddPermission(\n    drive::FileError error) {\n  SendResponse(error == drive::FILE_ERROR_OK);\n}\n",
        "target": 0
    },
    {
        "id": 197,
        "func": "static double outlog(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n    /* The command line parameters are either 8 bit (0..255) or 16 bit (0..65535)\n     * and so must be adjusted for low bit depth grayscale:\n    */\n if (out_depth <= 8)\n {\n if (pm->log8 == 0) /* switched off */\n return 256;\n\n if (out_depth < 8)\n return pm->log8 / 255 * ((1<<out_depth)-1);\n\n return pm->log8;\n }\n\n if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n {\n if (pm->log16 == 0)\n return 65536;\n\n return pm->log16;\n }\n\n /* This is the case where the value was calculated at 8-bit precision then\n    * scaled to 16 bits.\n    */\n if (pm->log8 == 0)\n return 65536;\n\n return pm->log8 * 257;\n}\n",
        "target": 1
    },
    {
        "id": 198,
        "func": "static void free_sched_groups(const struct cpumask *cpu_map,\n\t\t\t      struct cpumask *nodemask)\n{\n\tint cpu, i;\n\n\tfor_each_cpu(cpu, cpu_map) {\n\t\tstruct sched_group **sched_group_nodes\n\t\t\t= sched_group_nodes_bycpu[cpu];\n\n\t\tif (!sched_group_nodes)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < nr_node_ids; i++) {\n\t\t\tstruct sched_group *oldsg, *sg = sched_group_nodes[i];\n\n\t\t\tcpumask_and(nodemask, cpumask_of_node(i), cpu_map);\n\t\t\tif (cpumask_empty(nodemask))\n\t\t\t\tcontinue;\n\n\t\t\tif (sg == NULL)\n\t\t\t\tcontinue;\n\t\t\tsg = sg->next;\nnext_sg:\n\t\t\toldsg = sg;\n\t\t\tsg = sg->next;\n\t\t\tkfree(oldsg);\n\t\t\tif (oldsg != sched_group_nodes[i])\n\t\t\t\tgoto next_sg;\n\t\t}\n\t\tkfree(sched_group_nodes);\n\t\tsched_group_nodes_bycpu[cpu] = NULL;\n\t}\n}",
        "target": 0
    },
    {
        "id": 199,
        "func": "static void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_gdt(emul_to_vcpu(ctxt), dt);\n}",
        "target": 0
    },
    {
        "id": 200,
        "func": "beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\n\tif (l_strnstart(ndo, \"MSG\", 4, (const char *)bp, length)) /* A REQuest */\n\t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(ndo, \"RPY \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(ndo, \"ERR \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(ndo, \"ANS \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(ndo, \"NUL \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(ndo, \"SEQ \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(ndo, \"END\", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP END\"));\n\telse\n\t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}",
        "target": 0
    },
    {
        "id": 201,
        "func": "TransportDIB* TransportDIB::CreateWithHandle(Handle shmkey) {\n  TransportDIB* dib = new TransportDIB;\n  dib->key_.shmkey = shmkey;\n  return dib;\n}\n",
        "target": 0
    },
    {
        "id": 202,
        "func": "  virtual void TearDown() {\n    profile()->set_session_service(NULL);\n    session_helper_.set_service(NULL);\n\n    HistoryService* history =\n        profile()->GetHistoryService(Profile::IMPLICIT_ACCESS);\n    if (history) {\n      history->SetOnBackendDestroyTask(new MessageLoop::QuitTask);\n      MessageLoop::current()->Run();\n    }\n\n    NavigationControllerTest::TearDown();\n\n    ASSERT_TRUE(file_util::Delete(test_dir_, true));\n    ASSERT_FALSE(file_util::PathExists(test_dir_));\n  }\n",
        "target": 0
    },
    {
        "id": 203,
        "func": "void tcp_fin(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tinet_csk_schedule_ack(sk);\n\n\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\tsock_set_flag(sk, SOCK_DONE);\n\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_RECV:\n\tcase TCP_ESTABLISHED:\n\t\t/* Move to CLOSE_WAIT */\n\t\ttcp_set_state(sk, TCP_CLOSE_WAIT);\n\t\tinet_csk(sk)->icsk_ack.pingpong = 1;\n\t\tbreak;\n\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\t\t/* Received a retransmission of the FIN, do\n\t\t * nothing.\n\t\t */\n\t\tbreak;\n\tcase TCP_LAST_ACK:\n\t\t/* RFC793: Remain in the LAST-ACK state. */\n\t\tbreak;\n\n\tcase TCP_FIN_WAIT1:\n\t\t/* This case occurs when a simultaneous close\n\t\t * happens, we must ack the received FIN and\n\t\t * enter the CLOSING state.\n\t\t */\n\t\ttcp_send_ack(sk);\n\t\ttcp_set_state(sk, TCP_CLOSING);\n\t\tbreak;\n\tcase TCP_FIN_WAIT2:\n\t\t/* Received a FIN -- send ACK and enter TIME_WAIT. */\n\t\ttcp_send_ack(sk);\n\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\tbreak;\n\tdefault:\n\t\t/* Only TCP_LISTEN and TCP_CLOSE are left, in these\n\t\t * cases we should never reach this piece of code.\n\t\t */\n\t\tpr_err(\"%s: Impossible, sk->sk_state=%d\\n\",\n\t\t       __func__, sk->sk_state);\n\t\tbreak;\n\t}\n\n\t/* It _is_ possible, that we have something out-of-order _after_ FIN.\n\t * Probably, we should reset in this case. For now drop them.\n\t */\n\t__skb_queue_purge(&tp->out_of_order_queue);\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_reset(&tp->rx_opt);\n\tsk_mem_reclaim(sk);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\n\t\t/* Do not send POLL_HUP for half duplex close. */\n\t\tif (sk->sk_shutdown == SHUTDOWN_MASK ||\n\t\t    sk->sk_state == TCP_CLOSE)\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t\telse\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\t}\n}",
        "target": 0
    },
    {
        "id": 204,
        "func": "status_t Parcel::writeBoolVector(const std::vector<bool>& val)\n{\n return writeTypedVector(val, &Parcel::writeBool);\n}\n",
        "target": 0
    },
    {
        "id": 205,
        "func": "bool WebGLRenderingContextBase::ValidateImageBitmap(\n    const char* function_name,\n    ImageBitmap* bitmap,\n    ExceptionState& exception_state) {\n  if (bitmap->IsNeutered()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name,\n                      \"The source data has been detached.\");\n    return false;\n  }\n  if (!bitmap->OriginClean()) {\n    exception_state.ThrowSecurityError(\n        \"The ImageBitmap contains cross-origin data, and may not be loaded.\");\n    return false;\n  }\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 206,
        "func": "bool SyncBackendHost::EncryptEverythingEnabled() const {\n  if (initialization_state_ == NOT_INITIALIZED) {\n    NOTREACHED() << \"Cannot check encryption status without first \"\n                 << \"initializing backend.\";\n    return false;\n  }\n  return core_->sync_manager()->EncryptEverythingEnabled();\n}\n",
        "target": 0
    },
    {
        "id": 207,
        "func": "bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n",
        "target": 0
    },
    {
        "id": 208,
        "func": "static void queue_add(struct queue *head, struct queue *q)\n{\n\tstruct queue *pos = head->q_prev;\n\n\tq->q_prev = pos;\n\tq->q_next = pos->q_next;\n\tq->q_next->q_prev = q;\n\tpos->q_next = q;\n}",
        "target": 0
    },
    {
        "id": 209,
        "func": "void InspectorController::reconnectFrontend()\n{\n    if (!m_inspectorFrontend)\n        return;\n    InspectorFrontendChannel* frontendChannel = m_inspectorFrontend->channel();\n    disconnectFrontend();\n    connectFrontend(frontendChannel);\n}\n",
        "target": 0
    },
    {
        "id": 210,
        "func": "static noinline int mmc_ioctl_cdrom_pause_resume(struct cdrom_device_info *cdi,\n\t\t\t\t\t\t struct packet_command *cgc,\n\t\t\t\t\t\t int cmd)\n{\n\tconst struct cdrom_device_ops *cdo = cdi->ops;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMPAUSE/CDROMRESUME\\n\");\n\tcgc->cmd[0] = GPCMD_PAUSE_RESUME;\n\tcgc->cmd[8] = (cmd == CDROMRESUME) ? 1 : 0;\n\tcgc->data_direction = CGC_DATA_NONE;\n\treturn cdo->generic_packet(cdi, cgc);\n}",
        "target": 0
    },
    {
        "id": 211,
        "func": "void PPB_URLLoader_Impl::didFail(WebURLLoader* loader,\n                                 const WebURLError& error) {\n  int32_t pp_error = PP_ERROR_FAILED;\n  if (error.domain.equals(WebString::fromUTF8(net::kErrorDomain))) {\n    switch (error.reason) {\n      case net::ERR_ACCESS_DENIED:\n      case net::ERR_NETWORK_ACCESS_DENIED:\n        pp_error = PP_ERROR_NOACCESS;\n        break;\n    }\n  } else {\n    pp_error = PP_ERROR_NOACCESS;\n  }\n\n  FinishLoading(pp_error);\n}\n",
        "target": 0
    },
    {
        "id": 212,
        "func": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    /*\n     * PSK parameters:\n     *\n     * opaque psk_identity_hint<0..2^16-1>;\n     */\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Note: we currently ignore the PKS identity hint, as we only allow one\n     * PSK to be provisionned on the client. This could be changed later if\n     * someone needs that feature.\n     */\n    *p += len;\n    ret = 0;\n\n    return( ret );\n}",
        "target": 1
    },
    {
        "id": 213,
        "func": "MediaStreamImpl::~MediaStreamImpl() {\n  DCHECK(!peer_connection_handler_);\n  if (dependency_factory_.get())\n    dependency_factory_->ReleasePeerConnectionFactory();\n  if (network_manager_) {\n    if (chrome_worker_thread_.IsRunning()) {\n       chrome_worker_thread_.message_loop()->PostTask(FROM_HERE, base::Bind(\n           &MediaStreamImpl::DeleteIpcNetworkManager,\n           base::Unretained(this)));\n     } else {\n       NOTREACHED() << \"Worker thread not running.\";\n     }\n  }\n}\n",
        "target": 1
    },
    {
        "id": 214,
        "func": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* We only support context deletion tokens for now, and RFC 4121 does not\n     * define a context deletion token. */\n    if (ctx->proto) {\n        *minor_status = 0;\n        return(GSS_S_DEFECTIVE_TOKEN);\n    }\n\n    /* \"unseal\" the token */\n\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n\n    /* Mark the context as terminated, but do not delete it (as that would\n     * leave the caller with a dangling context handle). */\n    ctx->terminated = 1;\n    return(GSS_S_COMPLETE);\n}",
        "target": 0
    },
    {
        "id": 215,
        "func": "  RelayFlush(base::PlatformFile file,\n             base::FileUtilProxy::StatusCallback* callback)\n      : RelayWithStatusCallback(callback),\n        file_(file) {\n  }\n",
        "target": 0
    },
    {
        "id": 216,
        "func": "static int decode_commit(struct xdr_stream *xdr, struct nfs_writeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_COMMIT);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(8);\n\tCOPYMEM(res->verf->verifier, 8);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 217,
        "func": "static int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\t   pmd_t *dst_pmd, pmd_t *src_pmd, struct vm_area_struct *vma,\n\t\t   unsigned long addr, unsigned long end)\n{\n\tpte_t *orig_src_pte, *orig_dst_pte;\n\tpte_t *src_pte, *dst_pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tint progress = 0;\n\tint rss[NR_MM_COUNTERS];\n\tswp_entry_t entry = (swp_entry_t){0};\n\nagain:\n\tinit_rss_vec(rss);\n\n\tdst_pte = pte_alloc_map_lock(dst_mm, dst_pmd, addr, &dst_ptl);\n\tif (!dst_pte)\n\t\treturn -ENOMEM;\n\tsrc_pte = pte_offset_map(src_pmd, addr);\n\tsrc_ptl = pte_lockptr(src_mm, src_pmd);\n\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\torig_src_pte = src_pte;\n\torig_dst_pte = dst_pte;\n\tarch_enter_lazy_mmu_mode();\n\n\tdo {\n\t\t/*\n\t\t * We are holding two locks at this point - either of them\n\t\t * could generate latencies in another task on another CPU.\n\t\t */\n\t\tif (progress >= 32) {\n\t\t\tprogress = 0;\n\t\t\tif (need_resched() ||\n\t\t\t    spin_needbreak(src_ptl) || spin_needbreak(dst_ptl))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pte_none(*src_pte)) {\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\tentry.val = copy_one_pte(dst_mm, src_mm, dst_pte, src_pte,\n\t\t\t\t\t\t\tvma, addr, rss);\n\t\tif (entry.val)\n\t\t\tbreak;\n\t\tprogress += 8;\n\t} while (dst_pte++, src_pte++, addr += PAGE_SIZE, addr != end);\n\n\tarch_leave_lazy_mmu_mode();\n\tspin_unlock(src_ptl);\n\tpte_unmap(orig_src_pte);\n\tadd_mm_rss_vec(dst_mm, rss);\n\tpte_unmap_unlock(orig_dst_pte, dst_ptl);\n\tcond_resched();\n\n\tif (entry.val) {\n\t\tif (add_swap_count_continuation(entry, GFP_KERNEL) < 0)\n\t\t\treturn -ENOMEM;\n\t\tprogress = 0;\n\t}\n\tif (addr != end)\n\t\tgoto again;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 218,
        "func": "static struct clk_hw *hi3660_stub_clk_hw_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t     void *data)\n{\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= HI3660_CLK_STUB_NUM) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &hi3660_stub_clks[idx].hw;\n}",
        "target": 0
    },
    {
        "id": 219,
        "func": "static int ffs_ep_addr2idx(struct ffs_data *ffs, u8 endpoint_address)\n{\n\tint i;\n\n\tfor (i = 1; i < ARRAY_SIZE(ffs->eps_addrmap); ++i)\n\t\tif (ffs->eps_addrmap[i] == endpoint_address)\n\t\t\treturn i;\n\treturn -ENOENT;\n}",
        "target": 0
    },
    {
        "id": 220,
        "func": "static inline RefPtr<DocumentFragment> createFragmentFromSource(const String& sourceString, const String& sourceMIMEType, Document* outputDoc)\n{\n    RefPtr<DocumentFragment> fragment = outputDoc->createDocumentFragment();\n    if (sourceMIMEType == \"text/html\") {\n        RefPtr<HTMLBodyElement> fakeBody = HTMLBodyElement::create(outputDoc);\n        fragment->parseHTML(sourceString, fakeBody.get());\n    } else if (sourceMIMEType == \"text/plain\")\n        fragment->parserAddChild(Text::create(outputDoc, sourceString));\n    else {\n        bool successfulParse = fragment->parseXML(sourceString, 0);\n        if (!successfulParse)\n            return 0;\n    }\n    return fragment;\n}\n",
        "target": 1
    },
    {
        "id": 221,
        "func": "static u32 tcp_v6_init_seq(const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_seq(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\tipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\ttcp_hdr(skb)->dest,\n\t\t\t\ttcp_hdr(skb)->source);\n}",
        "target": 0
    },
    {
        "id": 222,
        "func": "void numa_default_policy(void)\n{\n\tdo_set_mempolicy(MPOL_DEFAULT, 0, NULL);\n}\n",
        "target": 0
    },
    {
        "id": 223,
        "func": "static void print_lat_help_header(struct seq_file *m)\n{\n\tseq_puts(m, \"#                  _------=> CPU#            \\n\"\n\t\t    \"#                 / _-----=> irqs-off        \\n\"\n\t\t    \"#                | / _----=> need-resched    \\n\"\n\t\t    \"#                || / _---=> hardirq/softirq \\n\"\n\t\t    \"#                ||| / _--=> preempt-depth   \\n\"\n\t\t    \"#                |||| /     delay            \\n\"\n\t\t    \"#  cmd     pid   ||||| time  |   caller      \\n\"\n\t\t    \"#     \\\\   /      |||||  \\\\    |   /         \\n\");\n}\n",
        "target": 0
    },
    {
        "id": 224,
        "func": "SkColor Textfield::GetSelectionBackgroundColor() const {\n  return use_default_selection_background_color_\n             ? GetNativeTheme()->GetSystemColor(\n                   ui::NativeTheme::\n                       kColorId_TextfieldSelectionBackgroundFocused)\n             : selection_background_color_;\n}\n",
        "target": 0
    },
    {
        "id": 225,
        "func": "static struct device *tty_get_device(struct tty_struct *tty)\n{\n\tdev_t devt = tty_devnum(tty);\n\treturn class_find_device(tty_class, NULL, &devt, dev_match_devt);\n}",
        "target": 0
    },
    {
        "id": 226,
        "func": "v8::Handle<v8::Object> V8TestObjectPython::createWrapper(PassRefPtr<TestObjectPython> impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)\n{\n    ASSERT(impl);\n    ASSERT(!DOMDataStore::containsWrapper<V8TestObjectPython>(impl.get(), isolate));\n    if (ScriptWrappable::wrapperCanBeStoredInObject(impl.get())) {\n        const WrapperTypeInfo* actualInfo = ScriptWrappable::getTypeInfoFromObject(impl.get());\n        RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(actualInfo->derefObjectFunction == wrapperTypeInfo.derefObjectFunction);\n    }\n\n    v8::Handle<v8::Object> wrapper = V8DOMWrapper::createWrapper(creationContext, &wrapperTypeInfo, toInternalPointer(impl.get()), isolate);\n    if (UNLIKELY(wrapper.IsEmpty()))\n        return wrapper;\n\n    installPerContextEnabledProperties(wrapper, impl.get(), isolate);\n    V8DOMWrapper::associateObjectWithWrapper<V8TestObjectPython>(impl, &wrapperTypeInfo, wrapper, isolate, WrapperConfiguration::Independent);\n    return wrapper;\n}\n",
        "target": 0
    },
    {
        "id": 227,
        "func": " void TranslateMessageInfoBar::Layout() {\n   TranslateInfoBarBase::Layout();\n \n  int x = icon_->bounds().right() + InfoBar::kIconLabelSpacing;\n   gfx::Size label_pref_size = label_->GetPreferredSize();\n   int available_width = GetAvailableWidth() - x;\n   gfx::Size button_pref_size;\n   if (button_) {\n     button_pref_size = button_->GetPreferredSize();\n     available_width -=\n        (button_pref_size.width() + InfoBar::kButtonInLabelSpacing);\n   }\n  label_->SetBounds(x, InfoBar::OffsetY(this, label_pref_size),\n                     std::min(label_pref_size.width(), available_width),\n                     label_pref_size.height());\n \n   if (button_) {\n     button_->SetBounds(label_->bounds().right() +\n                          InfoBar::kButtonInLabelSpacing,\n                       InfoBar::OffsetY(this, button_pref_size),\n                        button_pref_size.width(), button_pref_size.height());\n   }\n }\n",
        "target": 1
    },
    {
        "id": 228,
        "func": "static int ldm_get_vstr (const u8 *block, u8 *buffer, int buflen)\n{\n\tint length;\n\n\tBUG_ON (!block || !buffer);\n\n\tlength = block[0];\n\tif (length >= buflen) {\n\t\tldm_error (\"Truncating string %d -> %d.\", length, buflen);\n\t\tlength = buflen - 1;\n\t}\n\tmemcpy (buffer, block + 1, length);\n\tbuffer[length] = 0;\n\treturn length;\n}",
        "target": 0
    },
    {
        "id": 229,
        "func": "FloatRect EffectPaintPropertyNode::MapRect(const FloatRect& input_rect) const {\n  FloatRect rect = input_rect;\n  rect.MoveBy(-state_.paint_offset);\n  FloatRect result = state_.filter.MapRect(rect);\n  result.MoveBy(state_.paint_offset);\n  return result;\n}\n",
        "target": 0
    },
    {
        "id": 230,
        "func": "bool AutofillDialogViews::HandleKeyEvent(views::Textfield* sender,\n                                         const ui::KeyEvent& key_event) {\n  content::NativeWebKeyboardEvent event(key_event);\n  return delegate_->HandleKeyPressEventInInput(event);\n}\n",
        "target": 0
    },
    {
        "id": 231,
        "func": "static jboolean Region_op0(JNIEnv* env, jobject, jlong dstHandle, jint left, jint top, jint right, jint bottom, jint op) {\n SkRegion* dst = reinterpret_cast<SkRegion*>(dstHandle);\n SkIRect ir;\n\n    ir.set(left, top, right, bottom);\n bool result = dst->op(ir, (SkRegion::Op)op);\n return boolTojboolean(result);\n}\n",
        "target": 0
    },
    {
        "id": 232,
        "func": "void NavigationControllerImpl::SetTransientEntry(\n    std::unique_ptr<NavigationEntry> entry) {\n  int index = 0;\n  if (last_committed_entry_index_ != -1)\n    index = last_committed_entry_index_ + 1;\n  DiscardTransientEntry();\n  entries_.insert(entries_.begin() + index,\n                  NavigationEntryImpl::FromNavigationEntry(std::move(entry)));\n  transient_entry_index_ = index;\n  delegate_->NotifyNavigationStateChanged(INVALIDATE_TYPE_ALL);\n}\n",
        "target": 0
    },
    {
        "id": 233,
        "func": "void WebContentsImpl::DecrementCapturerCount() {\n  --capturer_count_;\n  DVLOG(1) << \"There are now \" << capturer_count_\n           << \" capturing(s) of WebContentsImpl@\" << this;\n  DCHECK_LE(0, capturer_count_);\n\n  if (is_being_destroyed_)\n    return;\n\n  if (!IsBeingCaptured()) {\n    const gfx::Size old_size = preferred_size_for_capture_;\n    preferred_size_for_capture_ = gfx::Size();\n    OnPreferredSizeChanged(old_size);\n\n    if (IsHidden()) {\n      DVLOG(1) << \"Executing delayed WasHidden().\";\n      WasHidden();\n    }\n\n    if (should_normally_be_occluded_)\n      WasOccluded();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 234,
        "func": "void OmniboxViewWin::OnRevertTemporaryText() {\n  SetSelectionRange(original_selection_);\n  TextChanged();\n}\n",
        "target": 0
    },
    {
        "id": 235,
        "func": "void Browser::ShowKeyboardOverlay() {\n  window_->ShowKeyboardOverlay(window_->GetNativeHandle());\n}\n",
        "target": 0
    },
    {
        "id": 236,
        "func": "xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tunsigned char *ea_name;\n\tint error;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tstruct xfs_acl *xfs_acl;\n\t\tint len;\n\n\t\txfs_acl = kzalloc(sizeof(struct xfs_acl), GFP_KERNEL);\n\t\tif (!xfs_acl)\n\t\t\treturn -ENOMEM;\n\n\t\txfs_acl_to_disk(xfs_acl, acl);\n\t\tlen = sizeof(struct xfs_acl) -\n\t\t\t(sizeof(struct xfs_acl_entry) *\n\t\t\t (XFS_ACL_MAX_ENTRIES - acl->a_count));\n\n\t\terror = -xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\tlen, ATTR_ROOT);\n\n\t\tkfree(xfs_acl);\n\t} else {\n\t\t/*\n\t\t * A NULL ACL argument means we want to remove the ACL.\n\t\t */\n\t\terror = -xfs_attr_remove(ip, ea_name, ATTR_ROOT);\n\n\t\t/*\n\t\t * If the attribute didn't exist to start with that's fine.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\terror = 0;\n\t}\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}",
        "target": 0
    },
    {
        "id": 237,
        "func": "  NavigationControllerTest() {}\n",
        "target": 0
    },
    {
        "id": 238,
        "func": "cJSON *cJSON_CreateFalse( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_False;\n\treturn item;\n}",
        "target": 1
    },
    {
        "id": 239,
        "func": "setcolorspace_nosubst(i_ctx_t * i_ctx_p)\n{\n    os_ptr  op = osp;\n    es_ptr ep;\n    int code, depth;\n\n    /* Make sure we have an operand... */\n    check_op(1);\n    /* Check its either a name (base space) or an array */\n    if (!r_has_type(op, t_name))\n        if (!r_is_array(op))\n            return_error(gs_error_typecheck);\n\n    code = validate_spaces(i_ctx_p, op, &depth);\n    if (code < 0)\n        return code;\n\n    /* Set up for the continuation procedure which will do the work */\n    /* Make sure the exec stack has enough space */\n    check_estack(5);\n    /* Store the initial value of CIE substitution (substituting) */\n    ep = esp += 1;\n    make_int(ep, 1);\n    /* Store the 'depth' of the space returned during checking above */\n    ep = esp += 1;\n    make_int(ep, depth);\n    /* Store the 'stage' of processing (initially 0) */\n    ep = esp += 1;\n    make_int(ep, 0);\n    /* Store a pointer to the color space stored on the operand stack\n     * as the stack may grow unpredictably making further access\n     * to the space difficult\n     */\n    ep = esp += 1;\n    *ep = *op;\n    /* Finally, the actual continuation routine */\n    push_op_estack(setcolorspace_cont);\n    return o_push_estack;\n}\n",
        "target": 0
    },
    {
        "id": 240,
        "func": "void SecurityHandler::SetRenderer(RenderProcessHost* process_host,\n                                   RenderFrameHostImpl* frame_host) {\n   host_ = frame_host;\n   if (enabled_ && host_)\n    AttachToRenderFrameHost();\n}\n",
        "target": 1
    },
    {
        "id": 241,
        "func": "static int cp2112_read(struct cp2112_device *dev, u8 *data, size_t size)\n{\n\tstruct hid_device *hdev = dev->hdev;\n\tstruct cp2112_force_read_report report;\n\tint ret;\n\n\tif (size > sizeof(dev->read_data))\n\t\tsize = sizeof(dev->read_data);\n\treport.report = CP2112_DATA_READ_FORCE_SEND;\n\treport.length = cpu_to_be16(size);\n\n\tatomic_set(&dev->read_avail, 0);\n\n\tret = cp2112_hid_output(hdev, &report.report, sizeof(report),\n\t\t\t\tHID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error requesting data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_wait(dev, &dev->read_avail);\n\tif (ret)\n\t\treturn ret;\n\n\thid_dbg(hdev, \"read %d of %zd bytes requested\\n\",\n\t\tdev->read_length, size);\n\n\tif (size > dev->read_length)\n\t\tsize = dev->read_length;\n\n\tmemcpy(data, dev->read_data, size);\n\treturn dev->read_length;\n}",
        "target": 0
    },
    {
        "id": 242,
        "func": "static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t     u64 param3, u64 param4)\n{\n \tint rc;\n \tu64 base_addr, size;\n \n \t/* If user manually set \"flags\", make sure it is legal */\n \tif (flags && (flags &\n \t\t~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We need extra sanity checks for memory errors.\n\t * Other types leap directly to injection.\n\t */\n\n\t/* ensure param1/param2 existed */\n\tif (!(param_extension || acpi5))\n\t\tgoto inject;\n\n\t/* ensure injection is memory related */\n\tif (type & ACPI5_VENDOR_BIT) {\n\t\tif (vendor_flags != SETWA_FLAGS_MEM)\n\t\t\tgoto inject;\n\t} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))\n\t\tgoto inject;\n\n\t/*\n\t * Disallow crazy address masks that give BIOS leeway to pick\n\t * injection address almost anywhere. Insist on page or\n\t * better granularity and that target address is normal RAM or\n\t * NVDIMM.\n\t */\n\tbase_addr = param1 & param2;\n\tsize = ~param2 + 1;\n\n\tif (((param2 & PAGE_MASK) != PAGE_MASK) ||\n\t    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)\n\t\t\t\t!= REGION_INTERSECTS) &&\n\t     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)\n\t\t\t\t!= REGION_INTERSECTS)))\n\t\treturn -EINVAL;\n\ninject:\n\tmutex_lock(&einj_mutex);\n\trc = __einj_error_inject(type, flags, param1, param2, param3, param4);\n\tmutex_unlock(&einj_mutex);\n\n\treturn rc;\n}\n",
        "target": 1
    },
    {
        "id": 243,
        "func": " virtual ~MessageList() {\n }\n",
        "target": 0
    },
    {
        "id": 244,
        "func": "void ACodec::initiateSetInputSurface(\n const sp<PersistentSurface> &surface) {\n    sp<AMessage> msg = new AMessage(kWhatSetInputSurface, this);\n    msg->setObject(\"input-surface\", surface);\n    msg->post();\n}\n",
        "target": 0
    },
    {
        "id": 245,
        "func": "   virtual void ChangeInputMethod(const std::string& input_method_id) {\n    tentative_current_input_method_id_ = input_method_id;\n     if (ibus_daemon_process_handle_ == base::kNullProcessHandle &&\n        input_method::IsKeyboardLayout(input_method_id)) {\n       ChangeCurrentInputMethodFromId(input_method_id);\n    } else {\n      StartInputMethodDaemon();\n      if (!ChangeInputMethodViaIBus(input_method_id)) {\n        VLOG(1) << \"Failed to change the input method to \" << input_method_id\n                << \" (deferring)\";\n      }\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 246,
        "func": "void WebContentsImpl::OnDidRunContentWithCertificateErrors(\n    RenderFrameHostImpl* source,\n    const GURL& url) {\n  NavigationEntry* entry = controller_.GetVisibleEntry();\n  if (!entry)\n    return;\n\n  controller_.ssl_manager()->DidRunContentWithCertErrors(\n      entry->GetURL().GetOrigin());\n}\n",
        "target": 0
    },
    {
        "id": 247,
        "func": "parse_register_dst(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n",
        "target": 0
    },
    {
        "id": 248,
        "func": "void LocalFrame::Trace(blink::Visitor* visitor) {\n  visitor->Trace(ad_tracker_);\n  visitor->Trace(probe_sink_);\n  visitor->Trace(performance_monitor_);\n  visitor->Trace(idleness_detector_);\n  visitor->Trace(inspector_trace_events_);\n  visitor->Trace(loader_);\n  visitor->Trace(navigation_scheduler_);\n  visitor->Trace(view_);\n  visitor->Trace(dom_window_);\n  visitor->Trace(page_popup_owner_);\n  visitor->Trace(script_controller_);\n  visitor->Trace(editor_);\n  visitor->Trace(spell_checker_);\n  visitor->Trace(selection_);\n  visitor->Trace(event_handler_);\n  visitor->Trace(console_);\n  visitor->Trace(input_method_controller_);\n  visitor->Trace(text_suggestion_controller_);\n  visitor->Trace(computed_node_mapping_);\n  Frame::Trace(visitor);\n  Supplementable<LocalFrame>::Trace(visitor);\n}\n",
        "target": 0
    },
    {
        "id": 249,
        "func": "const char *modbus_strerror(int errnum) {\n    switch (errnum) {\n    case EMBXILFUN:\n        return \"Illegal function\";\n    case EMBXILADD:\n        return \"Illegal data address\";\n    case EMBXILVAL:\n        return \"Illegal data value\";\n    case EMBXSFAIL:\n        return \"Slave device or server failure\";\n    case EMBXACK:\n        return \"Acknowledge\";\n    case EMBXSBUSY:\n        return \"Slave device or server is busy\";\n    case EMBXNACK:\n        return \"Negative acknowledge\";\n    case EMBXMEMPAR:\n        return \"Memory parity error\";\n    case EMBXGPATH:\n        return \"Gateway path unavailable\";\n    case EMBXGTAR:\n        return \"Target device failed to respond\";\n    case EMBBADCRC:\n        return \"Invalid CRC\";\n    case EMBBADDATA:\n        return \"Invalid data\";\n    case EMBBADEXC:\n        return \"Invalid exception code\";\n    case EMBMDATA:\n        return \"Too many data\";\n    case EMBBADSLAVE:\n        return \"Response not from requested slave\";\n    default:\n        return strerror(errnum);\n    }\n}",
        "target": 0
    },
    {
        "id": 250,
        "func": "static void append_prune_data(struct cmdline_pathspec *prune, const char **av)\n{\n\twhile (*av) {\n\t\tALLOC_GROW(prune->path, prune->nr + 1, prune->alloc);\n\t\tprune->path[prune->nr++] = *(av++);\n\t}\n}",
        "target": 0
    },
    {
        "id": 251,
        "func": "int InputDispatcher::handleReceiveCallback(int fd, int events, void* data) {\n InputDispatcher* d = static_cast<InputDispatcher*>(data);\n\n { // acquire lock\n AutoMutex _l(d->mLock);\n\n ssize_t connectionIndex = d->mConnectionsByFd.indexOfKey(fd);\n if (connectionIndex < 0) {\n            ALOGE(\"Received spurious receive callback for unknown input channel.  \"\n \"fd=%d, events=0x%x\", fd, events);\n return 0; // remove the callback\n }\n\n bool notify;\n        sp<Connection> connection = d->mConnectionsByFd.valueAt(connectionIndex);\n if (!(events & (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP))) {\n if (!(events & ALOOPER_EVENT_INPUT)) {\n                ALOGW(\"channel '%s' ~ Received spurious callback for unhandled poll event.  \"\n \"events=0x%x\", connection->getInputChannelName(), events);\n return 1;\n }\n\n nsecs_t currentTime = now();\n bool gotOne = false;\n status_t status;\n for (;;) {\n uint32_t seq;\n bool handled;\n                status = connection->inputPublisher.receiveFinishedSignal(&seq, &handled);\n if (status) {\n break;\n }\n                d->finishDispatchCycleLocked(currentTime, connection, seq, handled);\n                gotOne = true;\n }\n if (gotOne) {\n                d->runCommandsLockedInterruptible();\n if (status == WOULD_BLOCK) {\n return 1;\n }\n }\n\n            notify = status != DEAD_OBJECT || !connection->monitor;\n if (notify) {\n                ALOGE(\"channel '%s' ~ Failed to receive finished signal.  status=%d\",\n                        connection->getInputChannelName(), status);\n }\n } else {\n            notify = !connection->monitor;\n if (notify) {\n                ALOGW(\"channel '%s' ~ Consumer closed input channel or an error occurred.  \"\n \"events=0x%x\", connection->getInputChannelName(), events);\n }\n }\n\n        d->unregisterInputChannelLocked(connection->inputChannel, notify);\n return 0; // remove the callback\n } // release lock\n}\n",
        "target": 0
    },
    {
        "id": 252,
        "func": "epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n",
        "target": 1
    },
    {
        "id": 253,
        "func": " static Maybe<bool> IncludesValueImpl(Isolate* isolate,\n Handle<JSObject> receiver,\n Handle<Object> value,\n uint32_t start_from, uint32_t length) {\n    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n bool search_for_hole = value->IsUndefined(isolate);\n\n if (!search_for_hole) {\n Maybe<bool> result = Nothing<bool>();\n if (DictionaryElementsAccessor::IncludesValueFastPath(\n              isolate, receiver, value, start_from, length, &result)) {\n\n         return result;\n       }\n     }\n     Handle<SeededNumberDictionary> dictionary(\n         SeededNumberDictionary::cast(receiver->elements()), isolate);\n     for (uint32_t k = start_from; k < length; ++k) {\n       int entry = dictionary->FindEntry(isolate, k);\n       if (entry == SeededNumberDictionary::kNotFound) {\n         if (search_for_hole) return Just(true);\n continue;\n }\n\n PropertyDetails details = GetDetailsImpl(*dictionary, entry);\n switch (details.kind()) {\n case kData: {\n Object* element_k = dictionary->ValueAt(entry);\n if (value->SameValueZero(element_k)) return Just(true);\n break;\n }\n case kAccessor: {\n LookupIterator it(isolate, receiver, k,\n LookupIterator::OWN_SKIP_INTERCEPTOR);\n          DCHECK(it.IsFound());\n          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);\n Handle<Object> element_k;\n\n          ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n              isolate, element_k, JSObject::GetPropertyWithAccessor(&it),\n Nothing<bool>());\n\n if (value->SameValueZero(*element_k)) return Just(true);\n\n if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {\n return IncludesValueSlowPath(isolate, receiver, value, k + 1,\n                                         length);\n }\n\n if (*dictionary == receiver->elements()) continue;\n\n if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {\n if (receiver->map()->GetInitialElements() == receiver->elements()) {\n return Just(search_for_hole);\n }\n return IncludesValueSlowPath(isolate, receiver, value, k + 1,\n                                         length);\n }\n          dictionary = handle(\n SeededNumberDictionary::cast(receiver->elements()), isolate);\n break;\n }\n }\n }\n return Just(false);\n }\n",
        "target": 1
    },
    {
        "id": 254,
        "func": "static void methodWithUnsignedLongSequenceMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectV8Internal::methodWithUnsignedLongSequenceMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 255,
        "func": "static int mov_write_st3d_tag(AVIOContext *pb, AVStereo3D *stereo_3d)\n{\n    int8_t stereo_mode;\n\n    if (stereo_3d->flags != 0) {\n        av_log(pb, AV_LOG_WARNING, \"Unsupported stereo_3d flags %x. st3d not written.\\n\", stereo_3d->flags);\n        return 0;\n    }\n\n    switch (stereo_3d->type) {\n    case AV_STEREO3D_2D:\n        stereo_mode = 0;\n        break;\n    case AV_STEREO3D_TOPBOTTOM:\n        stereo_mode = 1;\n        break;\n    case AV_STEREO3D_SIDEBYSIDE:\n        stereo_mode = 2;\n        break;\n    default:\n        av_log(pb, AV_LOG_WARNING, \"Unsupported stereo_3d type %s. st3d not written.\\n\", av_stereo3d_type_name(stereo_3d->type));\n        return 0;\n    }\n    avio_wb32(pb, 13); /* size */\n    ffio_wfourcc(pb, \"st3d\");\n    avio_wb32(pb, 0); /* version = 0 & flags = 0 */\n    avio_w8(pb, stereo_mode);\n    return 13;\n}",
        "target": 0
    },
    {
        "id": 256,
        "func": "\nGF_Err fecr_Size(GF_Box *s)\n{\n\tFECReservoirBox *ptr = (FECReservoirBox *)s;\n\tptr->size += (ptr->version ? 4 : 2) +  ptr->nb_entries * (ptr->version ? 8 : 6);\n\treturn GF_OK;",
        "target": 0
    },
    {
        "id": 257,
        "func": "find_idlest_group_cpu(struct sched_group *group, struct task_struct *p, int this_cpu)\n{\n\tunsigned long load, min_load = ULONG_MAX;\n\tunsigned int min_exit_latency = UINT_MAX;\n\tu64 latest_idle_timestamp = 0;\n\tint least_loaded_cpu = this_cpu;\n\tint shallowest_idle_cpu = -1;\n\tint i;\n\n\t/* Check if we have any choice: */\n\tif (group->group_weight == 1)\n\t\treturn cpumask_first(sched_group_span(group));\n\n\t/* Traverse only the allowed CPUs */\n\tfor_each_cpu_and(i, sched_group_span(group), &p->cpus_allowed) {\n\t\tif (available_idle_cpu(i)) {\n\t\t\tstruct rq *rq = cpu_rq(i);\n\t\t\tstruct cpuidle_state *idle = idle_get_state(rq);\n\t\t\tif (idle && idle->exit_latency < min_exit_latency) {\n\t\t\t\t/*\n\t\t\t\t * We give priority to a CPU whose idle state\n\t\t\t\t * has the smallest exit latency irrespective\n\t\t\t\t * of any idle timestamp.\n\t\t\t\t */\n\t\t\t\tmin_exit_latency = idle->exit_latency;\n\t\t\t\tlatest_idle_timestamp = rq->idle_stamp;\n\t\t\t\tshallowest_idle_cpu = i;\n\t\t\t} else if ((!idle || idle->exit_latency == min_exit_latency) &&\n\t\t\t\t   rq->idle_stamp > latest_idle_timestamp) {\n\t\t\t\t/*\n\t\t\t\t * If equal or no active idle state, then\n\t\t\t\t * the most recently idled CPU might have\n\t\t\t\t * a warmer cache.\n\t\t\t\t */\n\t\t\t\tlatest_idle_timestamp = rq->idle_stamp;\n\t\t\t\tshallowest_idle_cpu = i;\n\t\t\t}\n\t\t} else if (shallowest_idle_cpu == -1) {\n\t\t\tload = weighted_cpuload(cpu_rq(i));\n\t\t\tif (load < min_load) {\n\t\t\t\tmin_load = load;\n\t\t\t\tleast_loaded_cpu = i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn shallowest_idle_cpu != -1 ? shallowest_idle_cpu : least_loaded_cpu;\n}",
        "target": 0
    },
    {
        "id": 258,
        "func": "void Type_LUTA2B_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}",
        "target": 0
    },
    {
        "id": 259,
        "func": "void PaintController::GenerateRasterInvalidation(\n    const DisplayItemClient& client,\n    PaintChunk& chunk,\n    const DisplayItem* old_item,\n    const DisplayItem* new_item) {\n  if (!new_item || new_item->VisualRect().IsEmpty()) {\n    if (old_item && !old_item->VisualRect().IsEmpty()) {\n      AddRasterInvalidation(client, chunk, old_item->VisualRect(),\n                            PaintInvalidationReason::kDisappeared);\n    }\n    return;\n  }\n\n  DCHECK(&client == &new_item->Client());\n  if (!old_item || old_item->VisualRect().IsEmpty()) {\n    AddRasterInvalidation(client, chunk, new_item->VisualRect(),\n                          PaintInvalidationReason::kAppeared);\n    return;\n  }\n\n  if (client.IsJustCreated()) {\n    AddRasterInvalidation(client, chunk, old_item->VisualRect(),\n                          PaintInvalidationReason::kDisappeared);\n    AddRasterInvalidation(client, chunk, new_item->VisualRect(),\n                          PaintInvalidationReason::kAppeared);\n    return;\n  }\n\n  auto reason = client.GetPaintInvalidationReason();\n  bool partial_raster_invalidation =\n      RuntimeEnabledFeatures::PartialRasterInvalidationEnabled() &&\n      (reason == PaintInvalidationReason::kRectangle ||\n       reason == PaintInvalidationReason::kSelection);\n  if ((!partial_raster_invalidation &&\n       reason != PaintInvalidationReason::kIncremental) ||\n      old_item->VisualRect().Location() != new_item->VisualRect().Location()) {\n    GenerateFullRasterInvalidation(chunk, *old_item, *new_item);\n    return;\n  }\n\n  GenerateIncrementalRasterInvalidation(chunk, *old_item, *new_item);\n\n  if (RuntimeEnabledFeatures::PartialRasterInvalidationEnabled()) {\n    auto partial_rect = client.PartialInvalidationRect();\n    if (!partial_rect.IsEmpty())\n      AddRasterInvalidation(client, chunk, FloatRect(partial_rect), reason);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 260,
        "func": "static ssize_t pages_to_scan_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint err;\n\tunsigned long nr_pages;\n\n\terr = strict_strtoul(buf, 10, &nr_pages);\n\tif (err || nr_pages > UINT_MAX)\n\t\treturn -EINVAL;\n\n\tksm_thread_pages_to_scan = nr_pages;\n\n\treturn count;\n}",
        "target": 0
    },
    {
        "id": 261,
        "func": " ZEND_METHOD(CURLFile, __wakeup)\n {\n       zend_update_property_string(curl_CURLFile_class, getThis(), \"name\", sizeof(\"name\")-1, \"\" TSRMLS_CC);\n        zend_throw_exception(NULL, \"Unserialization of CURLFile instances is not allowed\", 0 TSRMLS_CC);\n }\n",
        "target": 1
    },
    {
        "id": 262,
        "func": "void Document::removeFromTopLayer(Element* element)\n{\n    if (!element->isInTopLayer())\n        return;\n    size_t position = m_topLayerElements.find(element);\n    ASSERT(position != kNotFound);\n    m_topLayerElements.remove(position);\n    element->setIsInTopLayer(false);\n}\n",
        "target": 0
    },
    {
        "id": 263,
        "func": "int platform_pm_restore(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->restore)\n\t\t\tret = drv->pm->restore(dev);\n\t} else {\n\t\tret = platform_legacy_resume(dev);\n\t}\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 264,
        "func": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n\n        set_description (client);\n\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}",
        "target": 1
    },
    {
        "id": 265,
        "func": "size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tif (i->type & (ITER_BVEC|ITER_KVEC)) {\n\t\tvoid *kaddr = kmap_atomic(page);\n\t\tsize_t wanted = copy_to_iter(kaddr + offset, bytes, i);\n\t\tkunmap_atomic(kaddr);\n\t\treturn wanted;\n\t} else if (likely(!(i->type & ITER_PIPE)))\n\t\treturn copy_page_to_iter_iovec(page, offset, bytes, i);\n\telse\n\t\treturn copy_page_to_iter_pipe(page, offset, bytes, i);\n}",
        "target": 0
    },
    {
        "id": 266,
        "func": "scoped_ptr<GDataEntry> GDataDirectoryService::FromProtoString(\n    const std::string& serialized_proto) {\n  GDataEntryProto entry_proto;\n  if (!entry_proto.ParseFromString(serialized_proto))\n    return scoped_ptr<GDataEntry>();\n \n   scoped_ptr<GDataEntry> entry;\n   if (entry_proto.file_info().is_directory()) {\n    entry.reset(new GDataDirectory(NULL, this));\n     if (!entry->FromProto(entry_proto)) {\n       NOTREACHED() << \"FromProto (directory) failed\";\n       entry.reset();\n     }\n   } else {\n    scoped_ptr<GDataFile> file(new GDataFile(NULL, this));\n     if (file->FromProto(entry_proto)) {\n       entry.reset(file.release());\n    } else {\n      NOTREACHED() << \"FromProto (file) failed\";\n    }\n  }\n  return entry.Pass();\n}\n",
        "target": 1
    },
    {
        "id": 267,
        "func": "static long btrfs_ioctl_add_dev(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\tpr_info(\"btrfs: dev add/delete/balance/replace/resize operation in progress\\n\");\n\t\treturn -EINPROGRESS;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tret = btrfs_init_new_device(root, vol_args->name);\n\n\tkfree(vol_args);\nout:\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 268,
        "func": "static __le32 calc_sb_1_csum(struct mdp_superblock_1 *sb)\n{\n\t__le32 disk_csum;\n\tu32 csum;\n\tunsigned long long newcsum;\n\tint size = 256 + le32_to_cpu(sb->max_dev)*2;\n\t__le32 *isuper = (__le32*)sb;\n\n\tdisk_csum = sb->sb_csum;\n\tsb->sb_csum = 0;\n\tnewcsum = 0;\n\tfor (; size >= 4; size -= 4)\n\t\tnewcsum += le32_to_cpu(*isuper++);\n\n\tif (size == 2)\n\t\tnewcsum += le16_to_cpu(*(__le16*) isuper);\n\n\tcsum = (newcsum & 0xffffffff) + (newcsum >> 32);\n\tsb->sb_csum = disk_csum;\n\treturn cpu_to_le32(csum);\n}",
        "target": 0
    },
    {
        "id": 269,
        "func": "void ecryptfs_to_hex(char *dst, char *src, size_t src_size)\n{\n\tint x;\n\n\tfor (x = 0; x < src_size; x++)\n\t\tsprintf(&dst[x * 2], \"%.2x\", (unsigned char)src[x]);\n}",
        "target": 0
    },
    {
        "id": 270,
        "func": "bool TextCodecUTF8::HandlePartialSequence<LChar>(LChar*& destination,\n                                                 const uint8_t*& source,\n                                                 const uint8_t* end,\n                                                 bool flush,\n                                                 bool,\n                                                 bool&) {\n  DCHECK(partial_sequence_size_);\n  do {\n    if (IsASCII(partial_sequence_[0])) {\n      *destination++ = partial_sequence_[0];\n      ConsumePartialSequenceBytes(1);\n      continue;\n    }\n    int count = NonASCIISequenceLength(partial_sequence_[0]);\n    if (!count)\n      return true;\n\n    if (count > partial_sequence_size_) {\n      if (count - partial_sequence_size_ > end - source) {\n        if (!flush) {\n          memcpy(partial_sequence_ + partial_sequence_size_, source,\n                 end - source);\n          partial_sequence_size_ += end - source;\n          return false;\n        }\n        return true;\n      }\n      memcpy(partial_sequence_ + partial_sequence_size_, source,\n             count - partial_sequence_size_);\n      source += count - partial_sequence_size_;\n      partial_sequence_size_ = count;\n    }\n    int character = DecodeNonASCIISequence(partial_sequence_, count);\n    if (character & ~0xff)\n      return true;\n\n    partial_sequence_size_ -= count;\n    *destination++ = static_cast<LChar>(character);\n  } while (partial_sequence_size_);\n\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 271,
        "func": "ViewMsg_Navigate_Type::Value GetNavigationType(\n    BrowserContext* browser_context, const NavigationEntryImpl& entry,\n    NavigationController::ReloadType reload_type) {\n  switch (reload_type) {\n    case NavigationControllerImpl::RELOAD:\n      return ViewMsg_Navigate_Type::RELOAD;\n    case NavigationControllerImpl::RELOAD_IGNORING_CACHE:\n      return ViewMsg_Navigate_Type::RELOAD_IGNORING_CACHE;\n    case NavigationControllerImpl::RELOAD_ORIGINAL_REQUEST_URL:\n      return ViewMsg_Navigate_Type::RELOAD_ORIGINAL_REQUEST_URL;\n    case NavigationControllerImpl::NO_RELOAD:\n      break;  // Fall through to rest of function.\n  }\n\n  if (entry.restore_type() ==\n      NavigationEntryImpl::RESTORE_LAST_SESSION_EXITED_CLEANLY) {\n    if (entry.GetHasPostData())\n      return ViewMsg_Navigate_Type::RESTORE_WITH_POST;\n    return ViewMsg_Navigate_Type::RESTORE;\n  }\n\n  return ViewMsg_Navigate_Type::NORMAL;\n}\n",
        "target": 0
    },
    {
        "id": 272,
        "func": "void HTMLFormControlElement::attach(const AttachContext& context)\n{\n    HTMLElement::attach(context);\n\n    if (!layoutObject())\n        return;\n\n    layoutObject()->updateFromElement();\n\n    if (shouldAutofocusOnAttach(this))\n        document().setAutofocusElement(this);\n}\n",
        "target": 0
    },
    {
        "id": 273,
        "func": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
        "target": 0
    },
    {
        "id": 274,
        "func": "static int enum_dir(sc_path_t path, int depth)\n {\n \tsc_file_t *file;\n \tint r, file_type;\n\tu8 files[SC_MAX_APDU_BUFFER_SIZE];\n \n \tr = sc_lock(card);\n \tif (r == SC_SUCCESS)\n\t\tr = sc_select_file(card, &path, &file);\n\tsc_unlock(card);\n\tif (r) {\n\t\tfprintf(stderr, \"SELECT FILE failed: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\tprint_file(card, file, &path, depth);\n\tfile_type = file->type;\n\tsc_file_free(file);\n\tif (file_type == SC_FILE_TYPE_DF) {\n\t\tint i;\n\n\t\tr = sc_lock(card);\n\t\tif (r == SC_SUCCESS)\n\t\t\tr = sc_list_files(card, files, sizeof(files));\n\t\tsc_unlock(card);\n\t\tif (r < 0) {\n\t\t\tfprintf(stderr, \"sc_list_files() failed: %s\\n\", sc_strerror(r));\n\t\t\treturn 1;\n \t\t}\n \t\tif (r == 0) {\n \t\t\tprintf(\"Empty directory\\n\");\n\t\t} else\n\t\tfor (i = 0; i < r/2; i++) {\n\t\t\tsc_path_t tmppath;\n\t\t\tmemset(&tmppath, 0, sizeof(tmppath));\n\t\t\tmemcpy(&tmppath, &path, sizeof(path));\n\t\t\tmemcpy(tmppath.value + tmppath.len, files + 2*i, 2);\n\t\t\ttmppath.len += 2;\n\t\t\tenum_dir(tmppath, depth + 1);\n \t\t}\n \t}\n \treturn 0;\n}\n",
        "target": 1
    },
    {
        "id": 275,
        "func": "base::string16 GetDisplayName(int64_t display_id) {\n  return base::UTF8ToUTF16(\n      GetDisplayManager()->GetDisplayNameForId(display_id));\n}\n",
        "target": 0
    },
    {
        "id": 276,
        "func": "static void bond_setup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\t/* initialize rwlocks */\n\trwlock_init(&bond->lock);\n\trwlock_init(&bond->curr_slave_lock);\n\n\tbond->params = bonding_defaults;\n\n\t/* Initialize pointers */\n\tbond->dev = bond_dev;\n\tINIT_LIST_HEAD(&bond->vlan_list);\n\n\t/* Initialize the device entry points */\n\tether_setup(bond_dev);\n\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\n\tbond_dev->destructor = bond_destructor;\n\n\t/* Initialize the device options */\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\n\t/* At first, we block adding VLANs. That's the only way to\n\t * prevent problems that occur when adding VLANs over an\n\t * empty bond. The block will be removed once non-challenged\n\t * slaves are enslaved.\n\t */\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\n\t/* don't acquire bond device's netif_tx_lock when\n\t * transmitting */\n\tbond_dev->features |= NETIF_F_LLTX;\n\n\t/* By default, we declare the bond to be fully\n\t * VLAN hardware accelerated capable. Special\n\t * care is taken in the various xmit functions\n\t * when there are slaves that are not hw accel\n\t * capable\n\t */\n\n\tbond_dev->hw_features = BOND_VLAN_FEATURES |\n\t\t\t\tNETIF_F_HW_VLAN_TX |\n\t\t\t\tNETIF_F_HW_VLAN_RX |\n\t\t\t\tNETIF_F_HW_VLAN_FILTER;\n\n\tbond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM);\n\tbond_dev->features |= bond_dev->hw_features;\n}",
        "target": 1
    },
    {
        "id": 277,
        "func": "xfs_buf_associate_memory(\n\txfs_buf_t\t\t*bp,\n\tvoid\t\t\t*mem,\n\tsize_t\t\t\tlen)\n{\n\tint\t\t\trval;\n\tint\t\t\ti = 0;\n\tunsigned long\t\tpageaddr;\n\tunsigned long\t\toffset;\n\tsize_t\t\t\tbuflen;\n\tint\t\t\tpage_count;\n\n\tpageaddr = (unsigned long)mem & PAGE_MASK;\n\toffset = (unsigned long)mem - pageaddr;\n\tbuflen = PAGE_ALIGN(len + offset);\n\tpage_count = buflen >> PAGE_SHIFT;\n\n\t/* Free any previous set of page pointers */\n\tif (bp->b_pages)\n\t\t_xfs_buf_free_pages(bp);\n\n\tbp->b_pages = NULL;\n\tbp->b_addr = mem;\n\n\trval = _xfs_buf_get_pages(bp, page_count, 0);\n\tif (rval)\n\t\treturn rval;\n\n\tbp->b_offset = offset;\n\n\tfor (i = 0; i < bp->b_page_count; i++) {\n\t\tbp->b_pages[i] = mem_to_page((void *)pageaddr);\n\t\tpageaddr += PAGE_SIZE;\n\t}\n\n\tbp->b_io_length = BTOBB(len);\n\tbp->b_length = BTOBB(buflen);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 278,
        "func": "SPICE_GNUC_VISIBLE int spice_server_set_playback_compression(SpiceServer *s, int enable)\n{\n    spice_assert(reds == s);\n    snd_set_playback_compression(enable);\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 279,
        "func": "static int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,\n\t\t\t       void *priv)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tstruct timekeeper *tk = priv;\n\n\tupdate_pvclock_gtod(tk);\n\n\t/* disable master clock if host does not trust, or does not\n\t * use, TSC clocksource\n\t */\n\tif (gtod->clock.vclock_mode != VCLOCK_TSC &&\n\t    atomic_read(&kvm_guest_has_master_clock) != 0)\n\t\tqueue_work(system_long_wq, &pvclock_gtod_work);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 280,
        "func": "nt_errstr(uint32_t err)\n{\n    static char ret[128];\n    int i;\n\n    ret[0] = 0;\n\n    for (i = 0; nt_errors[i].name; i++) {\n\tif (err == nt_errors[i].code)\n\t    return nt_errors[i].name;\n    }\n\n    snprintf(ret, sizeof(ret), \"0x%08x\", err);\n    return ret;\n}",
        "target": 0
    },
    {
        "id": 281,
        "func": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\t/* Now we can treat all alike */\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t}\n\n\tmsg->msg_namelen = sizeof(*sax);\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;\n}",
        "target": 1
    },
    {
        "id": 282,
        "func": "static int unshare_vm(unsigned long unshare_flags, struct mm_struct **new_mmp)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif ((unshare_flags & CLONE_VM) &&\n\t    (mm && atomic_read(&mm->mm_users) > 1)) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 283,
        "func": "GF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n \t\t\tsscanf(szV, \"%x\", &v);\n \t\t\tvalue[i] = v;\n \t\t\ti++;\n \t\t}\n \t}\n \tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n",
        "target": 1
    },
    {
        "id": 284,
        "func": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 285,
        "func": "nm_setting_vpn_error_quark (void)\n{\n\tstatic GQuark quark;\n\n\tif (G_UNLIKELY (!quark))\n\t\tquark = g_quark_from_static_string (\"nm-setting-vpn-error-quark\");\n\treturn quark;\n}\n",
        "target": 0
    },
    {
        "id": 286,
        "func": "static void auto_release(struct usbi_transfer *itransfer)\n{\n\tstruct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);\n\tstruct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);\n\tlibusb_device_handle *dev_handle = transfer->dev_handle;\n\tstruct windows_device_handle_priv* handle_priv = _device_handle_priv(dev_handle);\n\tint r;\n\n\tusbi_mutex_lock(&autoclaim_lock);\n\tif (handle_priv->autoclaim_count[transfer_priv->interface_number] > 0) {\n\t\thandle_priv->autoclaim_count[transfer_priv->interface_number]--;\n\t\tif (handle_priv->autoclaim_count[transfer_priv->interface_number] == 0) {\n\t\t\tr = libusb_release_interface(dev_handle, transfer_priv->interface_number);\n\t\t\tif (r == LIBUSB_SUCCESS) {\n\t\t\t\tusbi_dbg(\"auto-released interface %d\", transfer_priv->interface_number);\n\t\t\t} else {\n\t\t\t\tusbi_dbg(\"failed to auto-release interface %d (%s)\",\n\t\t\t\t\ttransfer_priv->interface_number, libusb_error_name((enum libusb_error)r));\n\t\t\t}\n\t\t}\n\t}\n\tusbi_mutex_unlock(&autoclaim_lock);\n}\n",
        "target": 0
    },
    {
        "id": 287,
        "func": "SpoolssEnumPrinterDataEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep)\n{\n\tguint32 size, num_values;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_buffer_size, &size);\n\n\tdissect_ndr_uint32(\n\t\ttvb, offset + size + 4, pinfo, NULL, di, drep, hf_returned,\n\t\t&num_values);\n\n\tif (size) {\n\t\tproto_tree *subtree;\n\t\tint offset2 = offset;\n\t\tguint32 i;\n\n\t\tsubtree = proto_tree_add_subtree(\n\t\t\ttree, tvb, offset, 0, ett_PRINTER_DATA_CTR, NULL, \"Printer data\");\n\n\t\tfor (i=0; i < num_values; i++)\n\t\t\toffset2 = dissect_spoolss_printer_enum_values(\n\t\t\t\ttvb, offset2, pinfo, subtree, di, drep);\n\t}\n\n\toffset += size;\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_returned, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}",
        "target": 0
    },
    {
        "id": 288,
        "func": "void DevToolsWindow::OpenInNewTab(const std::string& url) {\n  content::OpenURLParams params(\n      GURL(url), content::Referrer(), NEW_FOREGROUND_TAB,\n      content::PAGE_TRANSITION_LINK, false);\n  content::WebContents* inspected_web_contents = GetInspectedWebContents();\n  if (inspected_web_contents) {\n    inspected_web_contents->OpenURL(params);\n  } else {\n    chrome::HostDesktopType host_desktop_type;\n    if (browser_) {\n      host_desktop_type = browser_->host_desktop_type();\n    } else {\n      NOTREACHED();\n      host_desktop_type = chrome::GetActiveDesktop();\n    }\n\n    const BrowserList* browser_list =\n        BrowserList::GetInstance(host_desktop_type);\n    for (BrowserList::const_iterator it = browser_list->begin();\n         it != browser_list->end(); ++it) {\n      if ((*it)->type() == Browser::TYPE_TABBED) {\n        (*it)->OpenURL(params);\n        break;\n      }\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 289,
        "func": "void V8WindowShell::updateDocument()\n{\n    ASSERT(m_world->isMainWorld());\n    if (m_global.isEmpty())\n        return;\n    if (m_context.isEmpty())\n        return;\n    updateDocumentProperty();\n    updateSecurityOrigin();\n}\n",
        "target": 0
    },
    {
        "id": 290,
        "func": "int test_div_recp(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,b,c,d,e;\n\tBN_RECP_CTX recp;\n\tint i;\n\n\tBN_RECP_CTX_init(&recp);\n\tBN_init(&a);\n\tBN_init(&b);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\n\tfor (i=0; i<num0+num1; i++)\n\t\t{\n\t\tif (i < num1)\n\t\t\t{\n\t\t\tBN_bntest_rand(&a,400,0,0);\n\t\t\tBN_copy(&b,&a);\n\t\t\tBN_lshift(&a,&a,i);\n\t\t\tBN_add_word(&a,i);\n\t\t\t}\n\t\telse\n\t\t\tBN_bntest_rand(&b,50+3*(i-num1),0,0);\n\t\ta.neg=rand_neg();\n\t\tb.neg=rand_neg();\n\t\tBN_RECP_CTX_set(&recp,&b,ctx);\n\t\tBN_div_recp(&d,&c,&a,&recp,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" / \");\n\t\t\t\tBN_print(bp,&b);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&d);\n\t\t\tBIO_puts(bp,\"\\n\");\n\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" % \");\n\t\t\t\tBN_print(bp,&b);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_mul(&e,&d,&b,ctx);\n\t\tBN_add(&d,&e,&c);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d))\n\t\t    {\n\t\t    fprintf(stderr,\"Reciprocal division test failed!\\n\");\n\t\t    fprintf(stderr,\"a=\");\n\t\t    BN_print_fp(stderr,&a);\n\t\t    fprintf(stderr,\"\\nb=\");\n\t\t    BN_print_fp(stderr,&b);\n\t\t    fprintf(stderr,\"\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&b);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\tBN_RECP_CTX_free(&recp);\n\treturn(1);\n\t}\n",
        "target": 0
    },
    {
        "id": 291,
        "func": "bool bdrv_dev_is_tray_open(BlockDriverState *bs)\n{\n    if (bs->dev_ops && bs->dev_ops->is_tray_open) {\n        return bs->dev_ops->is_tray_open(bs->dev_opaque);\n    }\n    return false;\n}\n",
        "target": 0
    },
    {
        "id": 292,
        "func": "static int protocol_version(VncState *vs, uint8_t *version, size_t len)\n{\n    char local[13];\n\n    memcpy(local, version, 12);\n    local[12] = 0;\n\n    if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) {\n        VNC_DEBUG(\"Malformed protocol version %s\\n\", local);\n        vnc_client_error(vs);\n        return 0;\n    }\n    VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n    if (vs->major != 3 ||\n        (vs->minor != 3 &&\n         vs->minor != 4 &&\n         vs->minor != 5 &&\n         vs->minor != 7 &&\n         vs->minor != 8)) {\n        VNC_DEBUG(\"Unsupported client version\\n\");\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n        vnc_flush(vs);\n        vnc_client_error(vs);\n        return 0;\n    }\n    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated\n     * as equivalent to v3.3 by servers\n     */\n    if (vs->minor == 4 || vs->minor == 5)\n        vs->minor = 3;\n\n    if (vs->minor == 3) {\n        if (vs->auth == VNC_AUTH_NONE) {\n            VNC_DEBUG(\"Tell client auth none\\n\");\n            vnc_write_u32(vs, vs->auth);\n            vnc_flush(vs);\n            start_client_init(vs);\n       } else if (vs->auth == VNC_AUTH_VNC) {\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n            vnc_write_u32(vs, vs->auth);\n            vnc_flush(vs);\n            start_auth_vnc(vs);\n       } else {\n            VNC_DEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth);\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n            vnc_flush(vs);\n            vnc_client_error(vs);\n       }\n    } else {\n        VNC_DEBUG(\"Telling client we support auth %d\\n\", vs->auth);\n        vnc_write_u8(vs, 1); /* num auth */\n        vnc_write_u8(vs, vs->auth);\n        vnc_read_when(vs, protocol_client_auth, 1);\n        vnc_flush(vs);\n    }\n\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 293,
        "func": "static int f2fs_write_end(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\n\ttrace_f2fs_write_end(inode, pos, len, copied);\n\n\t/*\n\t * This should be come from len == PAGE_SIZE, and we expect copied\n\t * should be PAGE_SIZE. Otherwise, we treat it with zero copied and\n\t * let generic_perform_write() try to copy data again through copied=0.\n\t */\n\tif (!PageUptodate(page)) {\n\t\tif (unlikely(copied != len))\n\t\t\tcopied = 0;\n\t\telse\n\t\t\tSetPageUptodate(page);\n\t}\n\tif (!copied)\n\t\tgoto unlock_out;\n\n\tset_page_dirty(page);\n\n\tif (pos + copied > i_size_read(inode))\n\t\tf2fs_i_size_write(inode, pos + copied);\nunlock_out:\n\tf2fs_put_page(page, 1);\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\treturn copied;\n}",
        "target": 0
    },
    {
        "id": 294,
        "func": "epass2003_write_key(struct sc_card *card, sc_epass2003_wkey_data * data)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (data->type & SC_EPASS2003_KEY) {\n\t\tif (data->type == SC_EPASS2003_KEY_RSA)\n\t\t\treturn internal_write_rsa_key(card, data->key_data.es_key.fid,\n\t\t\t\t\t\t      data->key_data.es_key.rsa);\n\t\telse\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t} else if (data->type & SC_EPASS2003_SECRET) {\n\t\tif (data->type == SC_EPASS2003_SECRET_PRE)\n\t\t\treturn internal_install_pre(card);\n\t\telse if (data->type == SC_EPASS2003_SECRET_PIN)\n\t\t\treturn internal_install_pin(card, data);\n\t\telse\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\telse {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n",
        "target": 0
    },
    {
        "id": 295,
        "func": "int php_stream_xmlIO_read(void *context, char *buffer, int len)\n{\n\tTSRMLS_FETCH();\n\treturn php_stream_read((php_stream*)context, buffer, len);\n}\n",
        "target": 0
    },
    {
        "id": 296,
        "func": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"compression\");\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "target": 1
    },
    {
        "id": 297,
        "func": "int board_early_init_f(void)\n{\n#if defined(CONFIG_SYS_I2C_SOFT)\n\tu32 tmp;\n\n\t/* set the 2 bitbang i2c pins as output gpios */\n\ttmp = readl(MVEBU_GPIO0_BASE + 4);\n\twritel(tmp & (~KM_KIRKWOOD_SOFT_I2C_GPIOS) , MVEBU_GPIO0_BASE + 4);\n#endif\n\t/* adjust SDRAM size for bank 0 */\n\tmvebu_sdram_size_adjust(0);\n\tkirkwood_mpp_conf(kwmpp_config, NULL);\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 298,
        "func": "ar6000_sysfs_bmi_write(struct file *fp, struct kobject *kobj,\n                       struct bin_attribute *bin_attr,\n                       char *buf, loff_t pos, size_t count)\n{\n    int index;\n    struct ar6_softc *ar;\n    struct hif_device_os_device_info   *osDevInfo;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Write %d bytes\\n\", (u32)count));\n    for (index=0; index < MAX_AR6000; index++) {\n        ar = (struct ar6_softc *)ar6k_priv(ar6000_devices[index]);\n        osDevInfo = &ar->osDevInfo;\n        if (kobj == (&(((struct device *)osDevInfo->pOSDevice)->kobj))) {\n            break;\n        }\n    }\n\n    if (index == MAX_AR6000) return 0;\n\n    if ((BMIRawWrite(ar->arHifDevice, (u8*)buf, count)) != 0) {\n        return 0;\n    }\n\n    return count;\n}",
        "target": 0
    },
    {
        "id": 299,
        "func": "int migrate_prep(void)\n{\n\t/*\n\t * Clear the LRU lists so pages can be isolated.\n\t * Note that pages may be moved off the LRU after we have\n\t * drained them. Those pages will fail to migrate like other\n\t * pages that may be busy.\n\t */\n\tlru_add_drain_all();\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 300,
        "func": "   std::unique_ptr<WebContents> CreateWebContents() {\n     std::unique_ptr<WebContents> web_contents = CreateTestWebContents();\n    ResourceCoordinatorTabHelper::CreateForWebContents(web_contents.get());\n     content::WebContentsTester::For(web_contents.get())\n         ->NavigateAndCommit(GURL(\"https://www.example.com\"));\n\n    base::RepeatingClosure run_loop_cb = base::BindRepeating(\n       &base::TestMockTimeTaskRunner::RunUntilIdle, task_runner_);\n\n    testing::WaitForLocalDBEntryToBeInitialized(web_contents.get(),\n                                                run_loop_cb);\n    testing::ExpireLocalDBObservationWindows(web_contents.get());\n     return web_contents;\n   }\n",
        "target": 0
    },
    {
        "id": 301,
        "func": " std::string TestFlashMessageLoop::TestBasics() {\n  message_loop_ = new pp::flash::MessageLoop(instance_);\n\n  pp::CompletionCallback callback = callback_factory_.NewCallback(\n      &TestFlashMessageLoop::QuitMessageLoopTask);\n  pp::Module::Get()->core()->CallOnMainThread(0, callback);\n  int32_t result = message_loop_->Run();\n \n   ASSERT_TRUE(message_loop_);\n   delete message_loop_;\n  message_loop_ = NULL;\n \n   ASSERT_EQ(PP_OK, result);\n   PASS();\n}\n",
        "target": 1
    },
    {
        "id": 302,
        "func": "bool BluetoothDeviceChromeOS::IsConnectable() const {\n  BluetoothInputClient::Properties* input_properties =\n      DBusThreadManager::Get()->GetBluetoothInputClient()->\n          GetProperties(object_path_);\n  if (!input_properties)\n    return true;\n\n  return input_properties->reconnect_mode.value() != \"device\";\n}\n",
        "target": 0
    },
    {
        "id": 303,
        "func": "cifs_find_tcon(struct cifs_ses *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifs_tcon, tcon_list);\n\t\tif (!match_tcon(tcon, unc))\n\t\t\tcontinue;\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 304,
        "func": "static struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}",
        "target": 0
    },
    {
        "id": 305,
        "func": "void RenderFrameHostImpl::OnShowCreatedWindow(int pending_widget_routing_id,\n                                              WindowOpenDisposition disposition,\n                                              const gfx::Rect& initial_rect,\n                                              bool user_gesture) {\n  delegate_->ShowCreatedWindow(GetProcess()->GetID(), pending_widget_routing_id,\n                               disposition, initial_rect, user_gesture);\n}\n",
        "target": 0
    },
    {
        "id": 306,
        "func": "static int ext3_write_dquot(struct dquot *dquot)\n{\n\tint ret, err;\n\thandle_t *handle;\n\tstruct inode *inode;\n\n\tinode = dquot_to_inode(dquot);\n\thandle = ext3_journal_start(inode,\n\t\t\t\t\tEXT3_QUOTA_TRANS_BLOCKS(dquot->dq_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\tret = dquot_commit(dquot);\n\terr = ext3_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 307,
        "func": "\tswitch (type) {\n#ifdef ELFCORE\n\tcase ET_CORE:\n\t\tflags |= FLAGS_IS_CORE;\n\t\tif (dophn_core(ms, clazz, swap, fd,\n\t\t    (off_t)elf_getu(swap, elfhdr.e_phoff),\n\t\t    elf_getu16(swap, elfhdr.e_phnum), \n\t\t    (size_t)elf_getu16(swap, elfhdr.e_phentsize),\n\t\t    fsize, &flags) == -1)\n\t\t\treturn -1;\n\t\tbreak;\n#endif\n\tcase ET_EXEC:\n\tcase ET_DYN:\n\t\tif (dophn_exec(ms, clazz, swap, fd,\n\t\t    (off_t)elf_getu(swap, elfhdr.e_phoff),\n\t\t    elf_getu16(swap, elfhdr.e_phnum), \n\t\t    (size_t)elf_getu16(swap, elfhdr.e_phentsize),\n\t\t    fsize, &flags, elf_getu16(swap, elfhdr.e_shnum))\n\t\t    == -1)\n\t\t\treturn -1;\n\t\t/*FALLTHROUGH*/\n\tcase ET_REL:\n\t\tif (doshn(ms, clazz, swap, fd,\n\t\t    (off_t)elf_getu(swap, elfhdr.e_shoff),\n\t\t    elf_getu16(swap, elfhdr.e_shnum),\n\t\t    (size_t)elf_getu16(swap, elfhdr.e_shentsize),\n\t\t    fsize, &flags, elf_getu16(swap, elfhdr.e_machine),\n\t\t    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)\n\t\t\treturn -1;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}",
        "target": 1
    },
    {
        "id": 308,
        "func": "PHP_FUNCTION(mcrypt_enc_is_block_algorithm)\n{\n \tMCRYPT_GET_TD_ARG\n \n \tif (mcrypt_enc_is_block_algorithm(pm->td) == 1) {\n\t\tRETURN_TRUE \n \t} else {\n \t\tRETURN_FALSE\n \t}\n}\n",
        "target": 1
    },
    {
        "id": 309,
        "func": "void TabStrip::StartMouseInitiatedRemoveTabAnimation(int model_index) {\n  Tab* tab_closing = tab_at(model_index);\n  int delta = tab_closing->width() + tab_h_offset();\n  DCHECK_NE(model_index + 1, tab_count());\n  if (tab_closing->data().mini && model_index + 1 < tab_count() &&\n      !tab_at(model_index + 1)->data().mini) {\n    delta += kMiniToNonMiniGap;\n  }\n\n  for (int i = model_index + 1; i < tab_count(); ++i) {\n    gfx::Rect bounds = ideal_bounds(i);\n    bounds.set_x(bounds.x() - delta);\n    set_ideal_bounds(i, bounds);\n  }\n\n  newtab_button_bounds_.set_x(newtab_button_bounds_.x() - delta);\n\n  PrepareForAnimation();\n\n  tab_closing->set_closing(true);\n\n  RemoveTabFromViewModel(model_index);\n\n  AnimateToIdealBounds();\n\n  gfx::Rect tab_bounds = tab_closing->bounds();\n  tab_bounds.set_width(0);\n  bounds_animator_.AnimateViewTo(tab_closing, tab_bounds);\n\n  bounds_animator_.SetAnimationDelegate(\n      tab_closing,\n      new RemoveTabDelegate(this, tab_closing),\n      true);\n}\n",
        "target": 0
    },
    {
        "id": 310,
        "func": "GfxSeparationColorSpace::~GfxSeparationColorSpace() {\n  delete name;\n  delete alt;\n  delete func;\n}\n",
        "target": 0
    },
    {
        "id": 311,
        "func": "void xen_netbk_schedule_xenvif(struct xenvif *vif)\n{\n\tunsigned long flags;\n\tstruct xen_netbk *netbk = vif->netbk;\n\n\tif (__on_net_schedule_list(vif))\n\t\tgoto kick;\n\n\tspin_lock_irqsave(&netbk->net_schedule_list_lock, flags);\n\tif (!__on_net_schedule_list(vif) &&\n\t    likely(xenvif_schedulable(vif))) {\n\t\tlist_add_tail(&vif->schedule_list, &netbk->net_schedule_list);\n\t\txenvif_get(vif);\n\t}\n\tspin_unlock_irqrestore(&netbk->net_schedule_list_lock, flags);\n\nkick:\n\tsmp_mb();\n\tif ((nr_pending_reqs(netbk) < (MAX_PENDING_REQS/2)) &&\n\t    !list_empty(&netbk->net_schedule_list))\n\t\txen_netbk_kick_thread(netbk);\n}",
        "target": 0
    },
    {
        "id": 312,
        "func": "int red_channel_client_test_remote_common_cap(RedChannelClient *rcc, uint32_t cap)\n{\n    return test_capabilty(rcc->remote_caps.common_caps,\n                          rcc->remote_caps.num_common_caps,\n                          cap);\n}\n",
        "target": 0
    },
    {
        "id": 313,
        "func": "void BluetoothAdapterChromeOS::AdapterRemoved(\n    const dbus::ObjectPath& object_path) {\n  if (object_path == object_path_)\n    RemoveAdapter();\n}\n",
        "target": 0
    },
    {
        "id": 314,
        "func": "void GrantFileAccess(int child_id,\n                     const std::vector<base::FilePath>& file_paths) {\n  ChildProcessSecurityPolicyImpl* policy =\n      ChildProcessSecurityPolicyImpl::GetInstance();\n\n  for (const auto& file : file_paths) {\n    if (!policy->CanReadFile(child_id, file))\n      policy->GrantReadFile(child_id, file);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 315,
        "func": "static inline bool ib_safe_file_access(struct file *filp)\n{\n\treturn filp->f_cred == current_cred() && segment_eq(get_fs(), USER_DS);\n}",
        "target": 0
    },
    {
        "id": 316,
        "func": "void ResourceDispatcherHostImpl::BeginSaveFile(\n    const GURL& url,\n    const content::Referrer& referrer,\n    int child_id,\n    int route_id,\n    ResourceContext* context) {\n  if (is_shutdown_)\n    return;\n\n  char url_buf[128];\n  base::strlcpy(url_buf, url.spec().c_str(), arraysize(url_buf));\n  base::debug::Alias(url_buf);\n  CHECK(ContainsKey(active_resource_contexts_, context));\n\n  scoped_refptr<ResourceHandler> handler(\n      new SaveFileResourceHandler(child_id,\n                                  route_id,\n                                  url,\n                                  save_file_manager_.get()));\n  request_id_--;\n\n  const net::URLRequestContext* request_context = context->GetRequestContext();\n  bool known_proto =\n      request_context->job_factory()->IsHandledURL(url);\n  if (!known_proto) {\n    NOTREACHED();\n    return;\n  }\n\n  net::URLRequest* request = new net::URLRequest(url, this);\n  request->set_method(\"GET\");\n  request->set_referrer(MaybeStripReferrer(referrer.url).spec());\n  webkit_glue::ConfigureURLRequestForReferrerPolicy(request, referrer.policy);\n  request->set_load_flags(net::LOAD_PREFERRING_CACHE);\n  request->set_context(context->GetRequestContext());\n\n  ResourceRequestInfoImpl* extra_info =\n      CreateRequestInfo(handler, child_id, route_id, false, context);\n  extra_info->AssociateWithRequest(request);  // Request takes ownership.\n\n  BeginRequestInternal(request);\n}\n",
        "target": 0
    },
    {
        "id": 317,
        "func": "int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tint ret = 0;\n\n\tif (type)\n\t\treturn -EINVAL;\n\n\tret = kvm_alloc_stage2_pgd(kvm);\n\tif (ret)\n\t\tgoto out_fail_alloc;\n\n\tret = create_hyp_mappings(kvm, kvm + 1);\n\tif (ret)\n\t\tgoto out_free_stage2_pgd;\n\n\t/* Mark the initial VMID generation invalid */\n\tkvm->arch.vmid_gen = 0;\n\n\treturn ret;\nout_free_stage2_pgd:\n\tkvm_free_stage2_pgd(kvm);\nout_fail_alloc:\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 318,
        "func": "armv6pmu_handle_irq(int irq_num,\n\t\t    void *dev)\n{\n\tunsigned long pmcr = armv6_pmcr_read();\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct pt_regs *regs;\n\tint idx;\n\n\tif (!armv6_pmcr_has_overflowed(pmcr))\n\t\treturn IRQ_NONE;\n\n\tregs = get_irq_regs();\n\n\t/*\n\t * The interrupts are cleared by writing the overflow flags back to\n\t * the control register. All of the other bits don't have any effect\n\t * if they are rewritten, so write the whole value back.\n\t */\n\tarmv6_pmcr_write(pmcr);\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\tfor (idx = 0; idx <= armpmu->num_events; ++idx) {\n\t\tstruct perf_event *event = cpuc->events[idx];\n\t\tstruct hw_perf_event *hwc;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have a single interrupt for all counters. Check that\n\t\t * each counter has overflowed before we process it.\n\t\t */\n\t\tif (!armv6_pmcr_counter_has_overflowed(pmcr, idx))\n\t\t\tcontinue;\n\n\t\thwc = &event->hw;\n\t\tarmpmu_event_update(event, hwc, idx, 1);\n\t\tdata.period = event->hw.last_period;\n\t\tif (!armpmu_event_set_period(event, hwc, idx))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 0, &data, regs))\n\t\t\tarmpmu->disable(hwc, idx);\n\t}\n\n\t/*\n\t * Handle the pending perf events.\n\t *\n\t * Note: this call *must* be run with interrupts disabled. For\n\t * platforms that can have the PMU interrupts raised as an NMI, this\n\t * will not work.\n\t */\n\tirq_work_run();\n\n\treturn IRQ_HANDLED;\n}",
        "target": 1
    },
    {
        "id": 319,
        "func": "void RenderThreadImpl::OnNetworkTypeChanged(\n    net::NetworkChangeNotifier::ConnectionType type) {\n  EnsureWebKitInitialized();\n  bool online = type != net::NetworkChangeNotifier::CONNECTION_NONE;\n  WebNetworkStateNotifier::setOnLine(online);\n  FOR_EACH_OBSERVER(\n      RenderProcessObserver, observers_, NetworkStateChanged(online));\n  WebNetworkStateNotifier::setWebConnectionType(\n      NetConnectionTypeToWebConnectionType(type));\n}\n",
        "target": 0
    },
    {
        "id": 320,
        "func": "static const char * read_line_input(char * line, int maxSize, Bool showContent) {\n\tchar read;\n\tint i = 0;\n\tif (fflush( stderr ))\n\t\tperror(\"Failed to flush buffer %s\");\n\tdo {\n\t\tline[i] = '\\0';\n\t\tif (i >= maxSize - 1)\n\t\t\treturn line;\n\t\tread = getch();\n\t\tif (read == 8 || read == 127) {\n\t\t\tif (i > 0) {\n\t\t\t\tfprintf(stderr, \"\\b \\b\");\n\t\t\t\ti--;\n\t\t\t}\n\t\t} else if (read > 32) {\n\t\t\tfputc(showContent ? read : '*', stderr);\n\t\t\tline[i++] = read;\n\t\t}\n\t\tfflush(stderr);\n\t} while (read != '\\n');\n\tif (!read)\n\t\treturn 0;\n\treturn line;\n}",
        "target": 0
    },
    {
        "id": 321,
        "func": "static void exposeJSAccessorsLongAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::exposeJSAccessorsLongAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 322,
        "func": "fep_client_forward_key_event (FepClient      *client,\n                              unsigned int    keyval,\n                              FepModifierType modifiers)\n{\n  FepControlMessage message;\n\n  message.command = FEP_CONTROL_FORWARD_KEY_EVENT;\n  _fep_control_message_alloc_args (&message, 2);\n  _fep_control_message_write_uint32_arg (&message, 0, keyval);\n  _fep_control_message_write_uint32_arg (&message, 1, modifiers);\n\n  if (client->filter_running)\n    client->messages = _fep_append_control_message (client->messages, &message);\n  else\n    _fep_write_control_message (client->control, &message);\n  _fep_control_message_free_args (&message);\n}\n",
        "target": 0
    },
    {
        "id": 323,
        "func": "static int mount_entry(const char *fsname, const char *target,\n\t\t       const char *fstype, unsigned long mountflags,\n\t\t       const char *data, int optional)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n#endif\n\n\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n\t\tif (optional) {\n\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,\n\t\t\t     target, strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\", fsname, target);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((mountflags & MS_REMOUNT) || (mountflags & MS_BIND)) {\n\t\tDEBUG(\"remounting %s on %s to respect bind or remount options\",\n\t\t      fsname ? fsname : \"(none)\", target ? target : \"(none)\");\n\t\tunsigned long rqd_flags = 0;\n\t\tif (mountflags & MS_RDONLY)\n\t\t\trqd_flags |= MS_RDONLY;\n#ifdef HAVE_STATVFS\n\t\tif (statvfs(fsname, &sb) == 0) {\n\t\t\tunsigned long required_flags = rqd_flags;\n\t\t\tif (sb.f_flag & MS_NOSUID)\n\t\t\t\trequired_flags |= MS_NOSUID;\n\t\t\tif (sb.f_flag & MS_NODEV)\n\t\t\t\trequired_flags |= MS_NODEV;\n\t\t\tif (sb.f_flag & MS_RDONLY)\n\t\t\t\trequired_flags |= MS_RDONLY;\n\t\t\tif (sb.f_flag & MS_NOEXEC)\n\t\t\t\trequired_flags |= MS_NOEXEC;\n\t\t\tDEBUG(\"(at remount) flags for %s was %lu, required extra flags are %lu\", fsname, sb.f_flag, required_flags);\n\t\t\t/*\n\t\t\t * If this was a bind mount request, and required_flags\n\t\t\t * does not have any flags which are not already in\n\t\t\t * mountflags, then skip the remount\n\t\t\t */\n\t\t\tif (!(mountflags & MS_REMOUNT)) {\n\t\t\t\tif (!(required_flags & ~mountflags) && rqd_flags == 0) {\n\t\t\t\t\tDEBUG(\"mountflags already was %lu, skipping remount\",\n\t\t\t\t\t\tmountflags);\n\t\t\t\t\tgoto skipremount;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmountflags |= required_flags;\n\t\t}\n#endif\n\n\t\tif (mount(fsname, target, fstype,\n\t\t\t  mountflags | MS_REMOUNT, data)) {\n\t\t\tif (optional) {\n\t\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\",\n\t\t\t\t\t fsname, target, strerror(errno));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\",\n\t\t\t\t\t fsname, target);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef HAVE_STATVFS\nskipremount:\n#endif\n\tDEBUG(\"mounted '%s' on '%s', type '%s'\", fsname, target, fstype);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 324,
        "func": "void TreeView::TreeNodeChanged(TreeModel* model, TreeModelNode* node) {\n  if (node_to_details_map_.find(node) == node_to_details_map_.end()) {\n    return;\n  }\n  const NodeDetails* details = GetNodeDetails(node);\n  TV_ITEM tv_item = {0};\n  tv_item.mask = TVIF_TEXT;\n  tv_item.hItem = details->tree_item;\n  tv_item.pszText = LPSTR_TEXTCALLBACK;\n  TreeView_SetItem(tree_view_, &tv_item);\n}\n",
        "target": 0
    },
    {
        "id": 325,
        "func": "void SyncManager::SyncInternal::RaiseAuthNeededEvent() {\n  ObserverList<SyncManager::Observer> temp_obs_list;\n  CopyObservers(&temp_obs_list);\n  FOR_EACH_OBSERVER(SyncManager::Observer, temp_obs_list,\n      OnAuthError(AuthError(AuthError::INVALID_GAIA_CREDENTIALS)));\n}\n",
        "target": 0
    },
    {
        "id": 326,
        "func": "  void SignalDone() {\n    DCHECK_CURRENTLY_ON(BrowserThread::IO);\n    if (!is_removing_)\n      return;\n    is_removing_ = false;\n    event_->Signal();\n  }\n",
        "target": 0
    },
    {
        "id": 327,
        "func": "static int nfc_llcp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tu32 opt;\n\tint err = 0;\n\n\tpr_debug(\"%p optname %d\\n\", sk, optname);\n\n\tif (level != SOL_NFC)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase NFC_LLCP_RW:\n\t\tif (sk->sk_state == LLCP_CONNECTED ||\n\t\t    sk->sk_state == LLCP_BOUND ||\n\t\t    sk->sk_state == LLCP_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > LLCP_MAX_RW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tllcp_sock->rw = (u8) opt;\n\n\t\tbreak;\n\n\tcase NFC_LLCP_MIUX:\n\t\tif (sk->sk_state == LLCP_CONNECTED ||\n\t\t    sk->sk_state == LLCP_BOUND ||\n\t\t    sk->sk_state == LLCP_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > LLCP_MAX_MIUX) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tllcp_sock->miux = cpu_to_be16((u16) opt);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tpr_debug(\"%p rw %d miux %d\\n\", llcp_sock,\n\t\t llcp_sock->rw, llcp_sock->miux);\n\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 328,
        "func": "void ChromeContentBrowserClient::NavigationRequestRedirected(\n    int frame_tree_node_id,\n    const GURL& url,\n    base::Optional<net::HttpRequestHeaders>* modified_request_headers) {\n  WebContents* web_contents =\n      WebContents::FromFrameTreeNodeId(frame_tree_node_id);\n  content::BrowserContext* browser_context = web_contents->GetBrowserContext();\n\n  if (!browser_context->IsOffTheRecord()) {\n    policy::PolicyHeaderService* policy_header_service =\n        policy::PolicyHeaderServiceFactory::GetForBrowserContext(\n            browser_context);\n    if (policy_header_service) {\n      std::unique_ptr<net::HttpRequestHeaders> extra_headers;\n      policy_header_service->AddPolicyHeaders(url, &extra_headers);\n      if (extra_headers)\n        *modified_request_headers = std::move(*extra_headers);\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 329,
        "func": "nfsd4_check_open_attributes(struct svc_rqst *rqstp,\n\tstruct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\t__be32 status = nfs_ok;\n\n\tif (open->op_create == NFS4_OPEN_CREATE) {\n\t\tif (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd_attrmask);\n\t\telse if (open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd41_ex_attrmask);\n\t}\n\n\treturn status;\n}\n",
        "target": 0
    },
    {
        "id": 330,
        "func": "RendererPreferences WebContentsImpl::GetRendererPrefs(\n    BrowserContext* browser_context) const {\n  return renderer_preferences_;\n}\n",
        "target": 0
    },
    {
        "id": 331,
        "func": "XSLStyleSheet::XSLStyleSheet(XSLImportRule* parentRule, const String& originalURL, const KURL& finalURL)\n    : m_ownerNode(0)\n    , m_originalURL(originalURL)\n    , m_finalURL(finalURL)\n    , m_isDisabled(false)\n    , m_embedded(false)\n     , m_processed(false) // Child sheets get marked as processed when the libxslt engine has finally seen them.\n     , m_stylesheetDoc(0)\n     , m_stylesheetDocTaken(false)\n     , m_parentStyleSheet(parentRule ? parentRule->parentStyleSheet() : 0)\n {\n }\n",
        "target": 1
    },
    {
        "id": 332,
        "func": "static inline void dirtyLineBoxesForRenderer(RenderObject* o, bool fullLayout)\n{\n    if (o->isText()) {\n        RenderText* renderText = toRenderText(o);\n        renderText->dirtyLineBoxes(fullLayout);\n    } else\n        toRenderInline(o)->dirtyLineBoxes(fullLayout);\n}\n",
        "target": 0
    },
    {
        "id": 333,
        "func": "HRESULT CGaiaCredentialBase::GetCheckboxValue(DWORD field_id,\n                                              BOOL* pbChecked,\n                                              wchar_t** ppszLabel) {\n  return E_NOTIMPL;\n}\n",
        "target": 0
    },
    {
        "id": 334,
        "func": "int nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\t\treturn err;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\t/* Don't recall a delegation if it was lost */\n\t\t\t\tnfs4_schedule_state_recovery(server->nfs_client);\n\t\t\t\treturn err;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 335,
        "func": "std::string SessionStore::GetTabStorageKey(const std::string& session_tag,\n                                           int tab_node_id) {\n  DCHECK_GE(tab_node_id, 0);\n  return EncodeStorageKey(session_tag, tab_node_id);\n}\n",
        "target": 0
    },
    {
        "id": 336,
        "func": "SandboxFlags SecurityContext::parseSandboxPolicy(const String& policy, String& invalidTokensErrorMessage)\n{\n    SandboxFlags flags = SandboxAll;\n    unsigned length = policy.length();\n    unsigned start = 0;\n    unsigned numberOfTokenErrors = 0;\n    StringBuilder tokenErrors;\n    while (true) {\n        while (start < length && isHTMLSpace<UChar>(policy[start]))\n            ++start;\n        if (start >= length)\n            break;\n        unsigned end = start + 1;\n        while (end < length && !isHTMLSpace<UChar>(policy[end]))\n            ++end;\n\n        String sandboxToken = policy.substring(start, end - start);\n        if (equalIgnoringCase(sandboxToken, \"allow-same-origin\"))\n            flags &= ~SandboxOrigin;\n        else if (equalIgnoringCase(sandboxToken, \"allow-forms\"))\n            flags &= ~SandboxForms;\n        else if (equalIgnoringCase(sandboxToken, \"allow-scripts\")) {\n            flags &= ~SandboxScripts;\n            flags &= ~SandboxAutomaticFeatures;\n        } else if (equalIgnoringCase(sandboxToken, \"allow-top-navigation\"))\n            flags &= ~SandboxTopNavigation;\n        else if (equalIgnoringCase(sandboxToken, \"allow-popups\"))\n            flags &= ~SandboxPopups;\n        else if (equalIgnoringCase(sandboxToken, \"allow-pointer-lock\"))\n            flags &= ~SandboxPointerLock;\n        else {\n            if (numberOfTokenErrors)\n                tokenErrors.appendLiteral(\", '\");\n            else\n                tokenErrors.append('\\'');\n            tokenErrors.append(sandboxToken);\n            tokenErrors.append('\\'');\n            numberOfTokenErrors++;\n        }\n\n        start = end + 1;\n    }\n\n    if (numberOfTokenErrors) {\n        if (numberOfTokenErrors > 1)\n            tokenErrors.appendLiteral(\" are invalid sandbox flags.\");\n        else\n            tokenErrors.appendLiteral(\" is an invalid sandbox flag.\");\n        invalidTokensErrorMessage = tokenErrors.toString();\n    }\n\n    return flags;\n}\n",
        "target": 0
    },
    {
        "id": 337,
        "func": "void DCTStream::init()\n{\n  jpeg_std_error(&jerr);\n  jerr.error_exit = &exitErrorHandler;\n  src.pub.init_source = str_init_source;\n  src.pub.fill_input_buffer = str_fill_input_buffer;\n  src.pub.skip_input_data = str_skip_input_data;\n  src.pub.resync_to_restart = jpeg_resync_to_restart;\n  src.pub.term_source = str_term_source;\n   src.pub.next_input_byte = NULL;\n   src.str = str;\n   src.index = 0;\n  src.abort = false;\n   current = NULL;\n   limit = NULL;\n   \n  limit = NULL;\n  \n  cinfo.err = &jerr;\n  jpeg_create_decompress(&cinfo);\n  cinfo.src = (jpeg_source_mgr *)&src;\n  row_buffer = NULL;\n}\n",
        "target": 1
    },
    {
        "id": 338,
        "func": "static int cirrus_vga_read_cr(CirrusVGAState * s, unsigned reg_index)\n{\n    switch (reg_index) {\n    case 0x00:\t\t\t// Standard VGA\n    case 0x01:\t\t\t// Standard VGA\n    case 0x02:\t\t\t// Standard VGA\n    case 0x03:\t\t\t// Standard VGA\n    case 0x04:\t\t\t// Standard VGA\n    case 0x05:\t\t\t// Standard VGA\n    case 0x06:\t\t\t// Standard VGA\n    case 0x07:\t\t\t// Standard VGA\n    case 0x08:\t\t\t// Standard VGA\n    case 0x09:\t\t\t// Standard VGA\n    case 0x0a:\t\t\t// Standard VGA\n    case 0x0b:\t\t\t// Standard VGA\n    case 0x0c:\t\t\t// Standard VGA\n    case 0x0d:\t\t\t// Standard VGA\n    case 0x0e:\t\t\t// Standard VGA\n    case 0x0f:\t\t\t// Standard VGA\n    case 0x10:\t\t\t// Standard VGA\n    case 0x11:\t\t\t// Standard VGA\n    case 0x12:\t\t\t// Standard VGA\n    case 0x13:\t\t\t// Standard VGA\n    case 0x14:\t\t\t// Standard VGA\n    case 0x15:\t\t\t// Standard VGA\n    case 0x16:\t\t\t// Standard VGA\n    case 0x17:\t\t\t// Standard VGA\n    case 0x18:\t\t\t// Standard VGA\n\treturn s->vga.cr[s->vga.cr_index];\n    case 0x24:\t\t\t// Attribute Controller Toggle Readback (R)\n        return (s->vga.ar_flip_flop << 7);\n    case 0x19:\t\t\t// Interlace End\n    case 0x1a:\t\t\t// Miscellaneous Control\n    case 0x1b:\t\t\t// Extended Display Control\n    case 0x1c:\t\t\t// Sync Adjust and Genlock\n    case 0x1d:\t\t\t// Overlay Extended Control\n    case 0x22:\t\t\t// Graphics Data Latches Readback (R)\n    case 0x25:\t\t\t// Part Status\n    case 0x27:\t\t\t// Part ID (R)\n\treturn s->vga.cr[s->vga.cr_index];\n    case 0x26:\t\t\t// Attribute Controller Index Readback (R)\n\treturn s->vga.ar_index & 0x3f;\n\tbreak;\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: inport cr_index %02x\\n\", reg_index);\n#endif\n\treturn 0xff;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 339,
        "func": "void GM2TabStyle::PaintTab(gfx::Canvas* canvas, const SkPath& clip) const {\n  int active_tab_fill_id = 0;\n  int active_tab_y_inset = 0;\n  if (tab_->GetThemeProvider()->HasCustomImage(IDR_THEME_TOOLBAR)) {\n    active_tab_fill_id = IDR_THEME_TOOLBAR;\n    active_tab_y_inset = GetStrokeThickness(true);\n   }\n \n   if (tab_->IsActive()) {\n    PaintTabBackground(canvas, true /* active */, active_tab_fill_id,\n                        active_tab_y_inset, nullptr /* clip */);\n   } else {\n     PaintInactiveTabBackground(canvas, clip);\n\n    const float throb_value = GetThrobValue();\n     if (throb_value > 0) {\n       canvas->SaveLayerAlpha(gfx::ToRoundedInt(throb_value * 0xff),\n                              tab_->GetLocalBounds());\n      PaintTabBackground(canvas, true /* active */, active_tab_fill_id,\n                          active_tab_y_inset, nullptr /* clip */);\n       canvas->Restore();\n     }\n  }\n}\n",
        "target": 1
    },
    {
        "id": 340,
        "func": " static uint32_t select_lease_time(struct dhcp_packet *packet)\n {\n \tuint32_t lease_time_sec = server_config.max_lease_sec;\n\tuint8_t *lease_time_opt = udhcp_get_option32(packet, DHCP_LEASE_TIME);\n \tif (lease_time_opt) {\n \t\tmove_from_unaligned32(lease_time_sec, lease_time_opt);\n \t\tlease_time_sec = ntohl(lease_time_sec);\n\t\tif (lease_time_sec > server_config.max_lease_sec)\n\t\t\tlease_time_sec = server_config.max_lease_sec;\n\t\tif (lease_time_sec < server_config.min_lease_sec)\n\t\t\tlease_time_sec = server_config.min_lease_sec;\n\t}\n\treturn lease_time_sec;\n}\n",
        "target": 0
    },
    {
        "id": 341,
        "func": "int __tlb_remove_page(struct mmu_gather *tlb, struct page *page)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tVM_BUG_ON(!tlb->end);\n\n\tbatch = tlb->active;\n\tbatch->pages[batch->nr++] = page;\n\tif (batch->nr == batch->max) {\n\t\tif (!tlb_next_batch(tlb))\n\t\t\treturn 0;\n\t\tbatch = tlb->active;\n\t}\n\tVM_BUG_ON_PAGE(batch->nr > batch->max, page);\n\n\treturn batch->max - batch->nr;\n}",
        "target": 0
    },
    {
        "id": 342,
        "func": "parse_rockridge_NM1(struct file_info *file,\n\t\t    const unsigned char *data, int data_length)\n{\n\tif (!file->name_continues)\n\t\tarchive_string_empty(&file->name);\n\tfile->name_continues = 0;\n\tif (data_length < 1)\n\t\treturn;\n\t/*\n\t * NM version 1 extension comprises:\n\t *   1 byte flag, value is one of:\n\t *     = 0: remainder is name\n\t *     = 1: remainder is name, next NM entry continues name\n\t *     = 2: \".\"\n\t *     = 4: \"..\"\n\t *     = 32: Implementation specific\n\t *     All other values are reserved.\n\t */\n\tswitch(data[0]) {\n\tcase 0:\n\t\tif (data_length < 2)\n\t\t\treturn;\n\t\tarchive_strncat(&file->name,\n\t\t    (const char *)data + 1, data_length - 1);\n\t\tbreak;\n\tcase 1:\n\t\tif (data_length < 2)\n\t\t\treturn;\n\t\tarchive_strncat(&file->name,\n\t\t    (const char *)data + 1, data_length - 1);\n\t\tfile->name_continues = 1;\n\t\tbreak;\n\tcase 2:\n\t\tarchive_strcat(&file->name, \".\");\n\t\tbreak;\n\tcase 4:\n\t\tarchive_strcat(&file->name, \"..\");\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n}",
        "target": 0
    },
    {
        "id": 343,
        "func": "int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n                                        int y, int w, int h)\n{\n     int i, j;\n     int has_fg, has_bg;\n     uint8_t *last_fg, *last_bg;\n    VncDisplay *vd = vs->vd;\n \n    last_fg = (uint8_t *) g_malloc(vd->server->pf.bytes_per_pixel);\n    last_bg = (uint8_t *) g_malloc(vd->server->pf.bytes_per_pixel);\n     has_fg = has_bg = 0;\n     for (j = y; j < (y + h); j += 16) {\n         for (i = x; i < (x + w); i += 16) {\n        for (i = x; i < (x + w); i += 16) {\n            vs->hextile.send_tile(vs, i, j,\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n                                  last_bg, last_fg, &has_bg, &has_fg);\n        }\n    }\n    g_free(last_fg);\n    g_free(last_bg);\n\n    return 1;\n}\n void vnc_hextile_set_pixel_conversion(VncState *vs, int generic)\n {\n     if (!generic) {\n        switch (vs->ds->surface->pf.bits_per_pixel) {\n            case 8:\n                vs->hextile.send_tile = send_hextile_tile_8;\n                break;\n            case 16:\n                vs->hextile.send_tile = send_hextile_tile_16;\n                break;\n            case 32:\n                vs->hextile.send_tile = send_hextile_tile_32;\n                break;\n         }\n     } else {\n        switch (vs->ds->surface->pf.bits_per_pixel) {\n            case 8:\n                vs->hextile.send_tile = send_hextile_tile_generic_8;\n                break;\n            case 16:\n                vs->hextile.send_tile = send_hextile_tile_generic_16;\n                break;\n            case 32:\n                vs->hextile.send_tile = send_hextile_tile_generic_32;\n                break;\n         }\n     }\n }\n}\n",
        "target": 1
    },
    {
        "id": 344,
        "func": "vmxnet3_io_bar0_write(void *opaque, hwaddr addr,\n                      uint64_t val, unsigned size)\n{\n    VMXNET3State *s = opaque;\n\n    if (!s->device_active) {\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,\n                        VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {\n        int tx_queue_idx =\n            VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_TXPROD,\n                                     VMXNET3_REG_ALIGN);\n        assert(tx_queue_idx <= s->txq_num);\n        vmxnet3_process_tx_queue(s, tx_queue_idx);\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n\n        VMW_CBPRN(\"Interrupt mask for line %d written: 0x%\" PRIx64, l, val);\n\n        vmxnet3_on_interrupt_mask_changed(s, l, val);\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||\n       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {\n        return;\n    }\n\n    VMW_WRPRN(\"BAR0 unknown write [%\" PRIx64 \"] = %\" PRIx64 \", size %d\",\n              (uint64_t) addr, val, size);\n}\n",
        "target": 0
    },
    {
        "id": 345,
        "func": "  WebGraphicsContext3DCommandBufferImpl* CreateContextCommon(\n      const base::WeakPtr<WebGraphicsContext3DSwapBuffersClient>& swap_client,\n      int surface_id) {\n    WebKit::WebGraphicsContext3D::Attributes attrs;\n    attrs.shareResources = true;\n    attrs.depth = false;\n    attrs.stencil = false;\n    attrs.antialias = false;\n    attrs.noAutomaticFlushes = true;\n    GpuChannelHostFactory* factory = BrowserGpuChannelHostFactory::instance();\n    GURL url(\"chrome://gpu/GpuProcessTransportFactory::CreateContextCommon\");\n    scoped_ptr<WebGraphicsContext3DCommandBufferImpl> context(\n        new WebGraphicsContext3DCommandBufferImpl(\n            surface_id,\n            url,\n            factory,\n            swap_client));\n    if (!context->Initialize(\n        attrs,\n        false,\n        CAUSE_FOR_GPU_LAUNCH_WEBGRAPHICSCONTEXT3DCOMMANDBUFFERIMPL_INITIALIZE))\n      return NULL;\n    return context.release();\n  }\n",
        "target": 0
    },
    {
        "id": 346,
        "func": "int RenderBlock::baselinePosition(FontBaseline baselineType, bool firstLine, LineDirectionMode direction, LinePositionMode linePositionMode) const\n{\n    if (isInline() && linePositionMode == PositionOnContainingLine) {\n        if (style()->hasAppearance() && !RenderTheme::theme().isControlContainer(style()->appearance()))\n            return RenderTheme::theme().baselinePosition(this);\n\n        bool ignoreBaseline = (layer() && layer()->scrollableArea() && (isMarquee() || (direction == HorizontalLine ? (layer()->scrollableArea()->verticalScrollbar() || layer()->scrollableArea()->scrollYOffset())\n            : (layer()->scrollableArea()->horizontalScrollbar() || layer()->scrollableArea()->scrollXOffset())))) || (isWritingModeRoot() && !isRubyRun());\n\n        int baselinePos = ignoreBaseline ? -1 : inlineBlockBaseline(direction);\n\n        if (isDeprecatedFlexibleBox()) {\n            LayoutUnit bottomOfContent = direction == HorizontalLine ? borderTop() + paddingTop() + contentHeight() : borderRight() + paddingRight() + contentWidth();\n            if (baselinePos > bottomOfContent)\n                baselinePos = -1;\n        }\n        if (baselinePos != -1)\n            return beforeMarginInLineDirection(direction) + baselinePos;\n\n        return RenderBox::baselinePosition(baselineType, firstLine, direction, linePositionMode);\n    }\n\n    ASSERT(linePositionMode == PositionOfInteriorLineBoxes);\n\n    const FontMetrics& fontMetrics = style(firstLine)->fontMetrics();\n    return fontMetrics.ascent(baselineType) + (lineHeight(firstLine, direction, linePositionMode) - fontMetrics.height()) / 2;\n}\n",
        "target": 0
    },
    {
        "id": 347,
        "func": "int lxc_clear_config_keepcaps(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->keepcaps, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 348,
        "func": "atmarp_addr_print(netdissect_options *ndo,\n\t\t  const u_char *ha, u_int ha_len, const u_char *srca,\n    u_int srca_len)\n{\n\tif (ha_len == 0)\n\t\tND_PRINT((ndo, \"<No address>\"));\n\telse {\n\t\tND_PRINT((ndo, \"%s\", linkaddr_string(ndo, ha, LINKADDR_ATM, ha_len)));\n\t\tif (srca_len != 0)\n\t\t\tND_PRINT((ndo, \",%s\",\n\t\t\t\t  linkaddr_string(ndo, srca, LINKADDR_ATM, srca_len)));\n\t}\n}",
        "target": 0
    },
    {
        "id": 349,
        "func": "void FetchContext::PrepareRequest(ResourceRequest&, RedirectType) {}\n",
        "target": 0
    },
    {
        "id": 350,
        "func": "const std::string& TemplateURLRef::GetPath(\n    const SearchTermsData& search_terms_data) const {\n  ParseIfNecessary(search_terms_data);\n  return path_;\n}\n",
        "target": 0
    },
    {
        "id": 351,
        "func": "bool ShouldShowAppsShortcutInBookmarkBar(Profile* profile) {\n  return IsAppsShortcutEnabled(profile) &&\n         profile->GetPrefs()->GetBoolean(\n             bookmarks::prefs::kShowAppsShortcutInBookmarkBar);\n}\n",
        "target": 0
    },
    {
        "id": 352,
        "func": "  void WaitForConfig() { config_run_loop_->Run(); }\n",
        "target": 0
    },
    {
        "id": 353,
        "func": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_char *b, *s, *t, c;\n\tint i, proto;\n\tconst void *se;\n\n        if (length <= 0)\n                return;\n\n\tb = (uint8_t *)malloc(length);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = (u_char *)p, t = b, i = length; i > 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i > 1) {\n\t\t\t\ti--;\n\t\t\t\tc = *s++ ^ 0x20;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}",
        "target": 1
    },
    {
        "id": 354,
        "func": "void RenderViewTest::OnLeakDetectionComplete(const Result& result) {\n  EXPECT_EQ(0u, result.number_of_live_audio_nodes);\n  EXPECT_EQ(0u, result.number_of_live_documents);\n  EXPECT_EQ(0u, result.number_of_live_nodes);\n  EXPECT_EQ(0u, result.number_of_live_layout_objects);\n  EXPECT_EQ(0u, result.number_of_live_resources);\n  EXPECT_EQ(0u, result.number_of_live_pausable_objects);\n  EXPECT_EQ(0u, result.number_of_live_script_promises);\n  EXPECT_EQ(0u, result.number_of_live_frames);\n  EXPECT_EQ(0u, result.number_of_live_v8_per_context_data);\n  EXPECT_EQ(0u, result.number_of_worker_global_scopes);\n}\n",
        "target": 0
    },
    {
        "id": 355,
        "func": "void CSSComputedStyleDeclaration::deref()\n{\n    ASSERT(m_refCount);\n    if (!--m_refCount)\n        delete this;\n}\n",
        "target": 0
    },
    {
        "id": 356,
        "func": "void Document::styleResolverMayHaveChanged()\n{\n    styleResolverChanged(hasNodesWithPlaceholderStyle() ? FullStyleUpdate : AnalyzedStyleUpdate);\n}\n",
        "target": 0
    },
    {
        "id": 357,
        "func": "static void btif_report_audio_state(btav_audio_state_t state,\n RawAddress* bd_addr) {\n if (bt_av_sink_callbacks != NULL) {\n    HAL_CBACK(bt_av_sink_callbacks, audio_state_cb, state, bd_addr);\n } else if (bt_av_src_callbacks != NULL) {\n    HAL_CBACK(bt_av_src_callbacks, audio_state_cb, state, bd_addr);\n }\n}\n",
        "target": 0
    },
    {
        "id": 358,
        "func": "cssp_gss_unwrap(gss_ctx_id_t ctx, STREAM in, STREAM out)\n{\n\tOM_uint32 major_status;\n\tOM_uint32 minor_status;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc inbuf, outbuf;\n\tint conf_state;\n\n\tinbuf.value = in->data;\n\tinbuf.length = s_length(in);\n\n\tmajor_status = gss_unwrap(&minor_status, ctx, &inbuf, &outbuf, &conf_state, &qop_state);\n\n\tif (major_status != GSS_S_COMPLETE)\n\t{\n\t\tcssp_gss_report_error(GSS_C_GSS_CODE, \"Failed to decrypt message\",\n\t\t\t\t      major_status, minor_status);\n\t\treturn False;\n\t}\n\n\tout->data = out->p = xmalloc(outbuf.length);\n\tout->size = outbuf.length;\n\tout_uint8p(out, outbuf.value, outbuf.length);\n\ts_mark_end(out);\n\n\tgss_release_buffer(&minor_status, &outbuf);\n\n\treturn True;\n}",
        "target": 0
    },
    {
        "id": 359,
        "func": "static int assigned_device_enable_host_msi(struct kvm *kvm,\n\t\t\t\t\t   struct kvm_assigned_dev_kernel *dev)\n{\n\tint r;\n\n\tif (!dev->dev->msi_enabled) {\n\t\tr = pci_enable_msi(dev->dev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tdev->host_irq = dev->dev->irq;\n\tif (request_threaded_irq(dev->host_irq, NULL, kvm_assigned_dev_thread,\n\t\t\t\t 0, dev->irq_name, (void *)dev)) {\n\t\tpci_disable_msi(dev->dev);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 360,
        "func": "FrameView::~FrameView()\n{\n    if (m_postLayoutTasksTimer.isActive())\n        m_postLayoutTasksTimer.stop();\n\n    if (m_didScrollTimer.isActive())\n        m_didScrollTimer.stop();\n\n    removeFromAXObjectCache();\n    resetScrollbars();\n\n    ASSERT(!horizontalScrollbar() || !horizontalScrollbar()->isCustomScrollbar());\n    ASSERT(!verticalScrollbar() || !verticalScrollbar()->isCustomScrollbar());\n\n    setHasHorizontalScrollbar(false); // Remove native scrollbars now before we lose the connection to the HostWindow.\n    setHasVerticalScrollbar(false);\n\n    ASSERT(!m_scrollCorner);\n\n    ASSERT(m_frame);\n    ASSERT(m_frame->view() != this || !m_frame->contentRenderer());\n    HTMLFrameOwnerElement* ownerElement = m_frame->deprecatedLocalOwner();\n    if (ownerElement && ownerElement->ownedWidget() == this)\n        ownerElement->setWidget(nullptr);\n}\n",
        "target": 0
    },
    {
        "id": 361,
        "func": "u32 gf_latm_get_value(GF_BitStream *bs)\n{\n\tu32 i, tmp, value = 0;\n\tu32 bytesForValue = gf_bs_read_int(bs, 2);\n\tfor (i=0; i <= bytesForValue; i++) {\n\t\tvalue <<= 8;\n\t\ttmp = gf_bs_read_int(bs, 8);\n\t\tvalue += tmp;\n\t}\n\treturn value;\n}",
        "target": 0
    },
    {
        "id": 362,
        "func": "MagickExport void LocaleUpper(char *string)\n{\n  register char\n    *q;\n\n  assert(string != (char *) NULL);\n  for (q=string; *q != '\\0'; q++)\n    *q=(char) LocaleUppercase((int) *q);\n}",
        "target": 0
    },
    {
        "id": 363,
        "func": "static int pix_abs16_xy2_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n    uint8_t *pix3 = pix2 + line_size;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - avg4(pix2[0], pix2[1], pix3[0], pix3[1]));\n        s += abs(pix1[1] - avg4(pix2[1], pix2[2], pix3[1], pix3[2]));\n        s += abs(pix1[2] - avg4(pix2[2], pix2[3], pix3[2], pix3[3]));\n        s += abs(pix1[3] - avg4(pix2[3], pix2[4], pix3[3], pix3[4]));\n        s += abs(pix1[4] - avg4(pix2[4], pix2[5], pix3[4], pix3[5]));\n        s += abs(pix1[5] - avg4(pix2[5], pix2[6], pix3[5], pix3[6]));\n        s += abs(pix1[6] - avg4(pix2[6], pix2[7], pix3[6], pix3[7]));\n        s += abs(pix1[7] - avg4(pix2[7], pix2[8], pix3[7], pix3[8]));\n        s += abs(pix1[8] - avg4(pix2[8], pix2[9], pix3[8], pix3[9]));\n        s += abs(pix1[9] - avg4(pix2[9], pix2[10], pix3[9], pix3[10]));\n        s += abs(pix1[10] - avg4(pix2[10], pix2[11], pix3[10], pix3[11]));\n        s += abs(pix1[11] - avg4(pix2[11], pix2[12], pix3[11], pix3[12]));\n        s += abs(pix1[12] - avg4(pix2[12], pix2[13], pix3[12], pix3[13]));\n        s += abs(pix1[13] - avg4(pix2[13], pix2[14], pix3[13], pix3[14]));\n        s += abs(pix1[14] - avg4(pix2[14], pix2[15], pix3[14], pix3[15]));\n        s += abs(pix1[15] - avg4(pix2[15], pix2[16], pix3[15], pix3[16]));\n        pix1 += line_size;\n        pix2 += line_size;\n        pix3 += line_size;\n    }\n    return s;\n}",
        "target": 0
    },
    {
        "id": 364,
        "func": "static int hwsim_fops_group_write(void *dat, u64 val)\n{\n\tstruct mac80211_hwsim_data *data = dat;\n\tdata->group = val;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 365,
        "func": "bool ATSParser::PSISection::isCRCOkay() const {\n if (!isComplete()) {\n return false;\n }\n uint8_t* data = mBuffer->data();\n\n if ((data[1] & 0x80) == 0) {\n return true;\n }\n\n\n     unsigned sectionLength = U16_AT(data + 1) & 0xfff;\n     ALOGV(\"sectionLength %u, skip %u\", sectionLength, mSkipBytes);\n \n     sectionLength -= mSkipBytes;\n \n uint32_t crc = 0xffffffff;\n for(unsigned i = 0; i < sectionLength + 4 /* crc */; i++) {\n uint8_t b = data[i];\n int index = ((crc >> 24) ^ (b & 0xff)) & 0xff;\n        crc = CRC_TABLE[index] ^ (crc << 8);\n }\n    ALOGV(\"crc: %08x\\n\", crc);\n return (crc == 0);\n}\n",
        "target": 1
    },
    {
        "id": 366,
        "func": "GF_Box *extr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ExtraDataBox, GF_ISOM_BOX_TYPE_EXTR);\n\treturn (GF_Box *)tmp;\n}",
        "target": 0
    },
    {
        "id": 367,
        "func": "void RenderFrameImpl::OnStopFinding(StopFindAction action) {\n  blink::WebPlugin* plugin = GetWebPluginForFind();\n  if (plugin) {\n    plugin->StopFind();\n    return;\n  }\n\n  frame_->StopFinding(static_cast<WebLocalFrame::StopFindAction>(action));\n}\n",
        "target": 0
    },
    {
        "id": 368,
        "func": "bool IsSensitiveURL(const GURL& url) {\n  bool sensitive_chrome_url = false;\n  const std::string host = url.host();\n  const char kGoogleCom[] = \".google.com\";\n  const char kClient[] = \"clients\";\n  if (base::EndsWith(host, kGoogleCom, base::CompareCase::SENSITIVE)) {\n    if (base::StartsWith(host, kClient, base::CompareCase::SENSITIVE)) {\n      bool match = true;\n      for (std::string::const_iterator i = host.begin() + strlen(kClient),\n               end = host.end() - strlen(kGoogleCom); i != end; ++i) {\n        if (!isdigit(*i)) {\n          match = false;\n          break;\n        }\n      }\n      sensitive_chrome_url = sensitive_chrome_url || match;\n    }\n    sensitive_chrome_url =\n        sensitive_chrome_url ||\n        base::EndsWith(url.host(), \".clients.google.com\",\n                       base::CompareCase::SENSITIVE) ||\n        url.host() == \"sb-ssl.google.com\" ||\n        (url.host() == \"chrome.google.com\" &&\n         base::StartsWith(url.path(), \"/webstore\",\n                          base::CompareCase::SENSITIVE));\n  }\n  GURL::Replacements replacements;\n  replacements.ClearQuery();\n  replacements.ClearRef();\n  GURL url_without_query = url.ReplaceComponents(replacements);\n  return sensitive_chrome_url ||\n      extension_urls::IsWebstoreUpdateUrl(url_without_query) ||\n      extension_urls::IsBlacklistUpdateUrl(url);\n}\n",
        "target": 0
    },
    {
        "id": 369,
        "func": "std::string Extension::GenerateIdForPath(const FilePath& path) {\n  FilePath new_path = Extension::MaybeNormalizePath(path);\n  std::string path_bytes =\n      std::string(reinterpret_cast<const char*>(new_path.value().data()),\n                  new_path.value().size() * sizeof(FilePath::CharType));\n  std::string id;\n  return GenerateId(path_bytes, &id) ? id : \"\";\n}\n",
        "target": 0
    },
    {
        "id": 370,
        "func": "void TabStripModel::AddTabAtToSelection(int index) {\n  DCHECK(ContainsIndex(index));\n  TabStripSelectionModel new_model;\n  new_model.Copy(selection_model_);\n  new_model.AddIndexToSelection(index);\n  SetSelection(new_model, NOTIFY_DEFAULT);\n}\n",
        "target": 0
    },
    {
        "id": 371,
        "func": "HeapObjectHeader* NormalPage::FindHeaderFromAddress(Address address) {\n  if (!ContainedInObjectPayload(address))\n    return nullptr;\n  if (ArenaForNormalPage()->IsInCurrentAllocationPointRegion(address))\n    return nullptr;\n  HeapObjectHeader* header = reinterpret_cast<HeapObjectHeader*>(\n      object_start_bit_map()->FindHeader(address));\n  if (header->IsFree())\n    return nullptr;\n  DCHECK_LT(0u, header->GcInfoIndex());\n  DCHECK_GT(header->PayloadEnd(), address);\n  return header;\n}\n",
        "target": 0
    },
    {
        "id": 372,
        "func": "int get_unalign_ctl(struct task_struct *tsk, unsigned long adr)\n{\n\treturn put_user(tsk->thread.align_ctl, (unsigned int __user *)adr);\n}",
        "target": 0
    },
    {
        "id": 373,
        "func": "static int msg_fetch_header(struct Context *ctx, struct ImapHeader *h, char *buf, FILE *fp)\n{\n  unsigned int bytes;\n  int rc = -1; /* default now is that string isn't FETCH response */\n  int parse_rc;\n\n  struct ImapData *idata = ctx->data;\n\n  if (buf[0] != '*')\n    return rc;\n\n  /* skip to message number */\n  buf = imap_next_word(buf);\n  if (mutt_str_atoui(buf, &h->data->msn) < 0)\n    return rc;\n\n  /* find FETCH tag */\n  buf = imap_next_word(buf);\n  if (mutt_str_strncasecmp(\"FETCH\", buf, 5) != 0)\n    return rc;\n\n  rc = -2; /* we've got a FETCH response, for better or worse */\n  buf = strchr(buf, '(');\n  if (!buf)\n    return rc;\n  buf++;\n\n  /* FIXME: current implementation - call msg_parse_fetch - if it returns -2,\n   *   read header lines and call it again. Silly. */\n  parse_rc = msg_parse_fetch(h, buf);\n  if (!parse_rc)\n    return 0;\n  if (parse_rc != -2 || !fp)\n    return rc;\n\n  if (imap_get_literal_count(buf, &bytes) == 0)\n  {\n    imap_read_literal(fp, idata, bytes, NULL);\n\n    /* we may have other fields of the FETCH _after_ the literal\n     * (eg Domino puts FLAGS here). Nothing wrong with that, either.\n     * This all has to go - we should accept literals and nonliterals\n     * interchangeably at any time. */\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n      return rc;\n\n    if (msg_parse_fetch(h, idata->buf) == -1)\n      return rc;\n  }\n\n  rc = 0; /* success */\n\n  /* subtract headers from message size - unfortunately only the subset of\n   * headers we've requested. */\n  h->content_length -= bytes;\n\n  return rc;\n}",
        "target": 0
    },
    {
        "id": 374,
        "func": "mrb_mod_alias(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_sym new_name, old_name;\n\n  mrb_get_args(mrb, \"nn\", &new_name, &old_name);\n  mrb_alias_method(mrb, c, new_name, old_name);\n  return mrb_nil_value();\n}",
        "target": 0
    },
    {
        "id": 375,
        "func": "static UINT dvcman_receive_channel_data(drdynvcPlugin* drdynvc,\n                                        IWTSVirtualChannelManager* pChannelMgr,\n                                        UINT32 ChannelId, wStream* data)\n{\n\tUINT status = CHANNEL_RC_OK;\n\tDVCMAN_CHANNEL* channel;\n\tsize_t dataSize = Stream_GetRemainingLength(data);\n\tchannel = (DVCMAN_CHANNEL*) dvcman_find_channel_by_id(pChannelMgr, ChannelId);\n\n\tif (!channel)\n\t{\n\t\t/* Windows 8.1 tries to open channels not created.\n\t\t\t\t * Ignore cases like this. */\n\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"ChannelId %\"PRIu32\" not found!\", ChannelId);\n\t\treturn CHANNEL_RC_OK;\n\t}\n\n \tif (channel->dvc_data)\n \t{\n \t\t/* Fragmented data */\n\t\tif (Stream_GetPosition(channel->dvc_data) + dataSize > (UINT32) Stream_Capacity(\n\t\t        channel->dvc_data))\n \t\t{\n \t\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"data exceeding declared length!\");\n \t\t\tStream_Release(channel->dvc_data);\n \t\t\tchannel->dvc_data = NULL;\n \t\t\treturn ERROR_INVALID_DATA;\n \t\t}\n \n\t\tStream_Write(channel->dvc_data, Stream_Pointer(data), dataSize);\n \n \t\tif (Stream_GetPosition(channel->dvc_data) >= channel->dvc_data_length)\n \t\t{\n\t\t\tStream_SealLength(channel->dvc_data);\n\t\t\tStream_SetPosition(channel->dvc_data, 0);\n\t\t\tstatus = channel->channel_callback->OnDataReceived(channel->channel_callback,\n\t\t\t         channel->dvc_data);\n\t\t\tStream_Release(channel->dvc_data);\n\t\t\tchannel->dvc_data = NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tstatus = channel->channel_callback->OnDataReceived(channel->channel_callback,\n\t\t         data);\n\t}\n\n\treturn status;\n}\n",
        "target": 1
    },
    {
        "id": 376,
        "func": "static enum d_walk_ret detach_and_collect(void *_data, struct dentry *dentry)\n{\n\tstruct detach_data *data = _data;\n\n\tif (d_mountpoint(dentry)) {\n\t\t__dget_dlock(dentry);\n\t\tdata->mountpoint = dentry;\n\t\treturn D_WALK_QUIT;\n\t}\n\n\treturn select_collect(&data->select, dentry);\n}",
        "target": 0
    },
    {
        "id": 377,
        "func": "void Pack<WebGLImageConversion::kDataFormatRGBA8,\n          WebGLImageConversion::kAlphaDoPremultiply,\n          uint8_t,\n          uint8_t>(const uint8_t* source,\n                   uint8_t* destination,\n                   unsigned pixels_per_row) {\n  for (unsigned i = 0; i < pixels_per_row; ++i) {\n    float scale_factor = source[3] / 255.0f;\n    uint8_t source_r =\n        static_cast<uint8_t>(static_cast<float>(source[0]) * scale_factor);\n    uint8_t source_g =\n        static_cast<uint8_t>(static_cast<float>(source[1]) * scale_factor);\n    uint8_t source_b =\n        static_cast<uint8_t>(static_cast<float>(source[2]) * scale_factor);\n    destination[0] = source_r;\n    destination[1] = source_g;\n    destination[2] = source_b;\n    destination[3] = source[3];\n    source += 4;\n    destination += 4;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 378,
        "func": "static void vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint r;\n\n\tif (pi_test_and_set_pir(vector, &vmx->pi_desc))\n\t\treturn;\n\n\tr = pi_test_and_set_on(&vmx->pi_desc);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n#ifdef CONFIG_SMP\n\tif (!r && (vcpu->mode == IN_GUEST_MODE))\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu),\n\t\t\t\tPOSTED_INTR_VECTOR);\n\telse\n#endif\n\t\tkvm_vcpu_kick(vcpu);\n}",
        "target": 0
    },
    {
        "id": 379,
        "func": "WebPlugin* RenderViewImpl::createPluginReplacement(\n    WebFrame* frame,\n    const WebPluginParams& params) {\n  webkit::WebPluginInfo info;\n  std::string mime_type;\n  GetPluginInfo(params.url, frame->top()->document().url(),\n                params.mimeType.utf8(), &info, &mime_type);\n  return content::GetContentClient()->renderer()->CreatePluginReplacement(\n      this, info.path);\n}\n",
        "target": 0
    },
    {
        "id": 380,
        "func": "void LockScreenMediaControlsView::SetArtwork(\n    base::Optional<gfx::ImageSkia> img) {\n  if (!img.has_value()) {\n    session_artwork_->SetImage(nullptr);\n     return;\n   }\n \n  session_artwork_->SetImageSize(ScaleSizeToFitView(\n      img->size(), gfx::Size(kArtworkViewWidth, kArtworkViewHeight)));\n   session_artwork_->SetImage(*img);\n }\n",
        "target": 1
    },
    {
        "id": 381,
        "func": "bool ZeroSuggestProvider::StoreSuggestionResponse(\n    const std::string& json_data,\n    const base::Value& parsed_data) {\n  if (!OmniboxFieldTrial::InZeroSuggestPersonalizedFieldTrial() ||\n      json_data.empty())\n    return false;\n  client()->GetPrefs()->SetString(omnibox::kZeroSuggestCachedResults,\n                                  json_data);\n\n  const base::ListValue* root_list = NULL;\n  const base::ListValue* results_list = NULL;\n  if (parsed_data.GetAsList(&root_list) &&\n      root_list->GetList(1, &results_list) &&\n      results_list->empty())\n    return false;\n\n  if (results_from_cache_)\n    done_ = true;\n\n  return results_from_cache_;\n}\n",
        "target": 0
    },
    {
        "id": 382,
        "func": "void RendererSchedulerImpl::SetHasVisibleRenderWidgetWithTouchHandler(\n    bool has_visible_render_widget_with_touch_handler) {\n  helper_.CheckOnValidThread();\n  if (has_visible_render_widget_with_touch_handler ==\n      main_thread_only().has_visible_render_widget_with_touch_handler)\n    return;\n\n  main_thread_only().has_visible_render_widget_with_touch_handler =\n      has_visible_render_widget_with_touch_handler;\n\n  base::AutoLock lock(any_thread_lock_);\n  UpdatePolicyLocked(UpdateType::kForceUpdate);\n}\n",
        "target": 0
    },
    {
        "id": 383,
        "func": "JSValue jsTestObjMutablePoint(ExecState* exec, JSValue slotBase, const Identifier&)\n{\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(slotBase));\n    UNUSED_PARAM(exec);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(SVGStaticPropertyTearOff<TestObj, FloatPoint>::create(impl, impl->mutablePoint(), &TestObj::updateMutablePoint)));\n    return result;\n}\n",
        "target": 0
    },
    {
        "id": 384,
        "func": "void WebPageProxy::showCorrectionPanel(int32_t panelType, const WebCore::FloatRect& boundingBoxOfReplacedString, const String& replacedString, const String& replacementString, const Vector<String>& alternativeReplacementStrings)\n{\n    m_pageClient->showCorrectionPanel((WebCore::CorrectionPanelInfo::PanelType)panelType, boundingBoxOfReplacedString, replacedString, replacementString, alternativeReplacementStrings);\n}\n",
        "target": 0
    },
    {
        "id": 385,
        "func": "int FS_GetFileList(  const char *path, const char *extension, char *listbuf, int bufsize ) {\n\tint nFiles, i, nTotal, nLen;\n\tchar **pFiles = NULL;\n\n\t*listbuf = 0;\n\tnFiles = 0;\n\tnTotal = 0;\n\n\tif ( Q_stricmp( path, \"$modlist\" ) == 0 ) {\n\t\treturn FS_GetModList( listbuf, bufsize );\n\t}\n\n\tpFiles = FS_ListFiles( path, extension, &nFiles );\n\n\tfor ( i = 0; i < nFiles; i++ ) {\n\t\tnLen = strlen( pFiles[i] ) + 1;\n\t\tif ( nTotal + nLen + 1 < bufsize ) {\n\t\t\tstrcpy( listbuf, pFiles[i] );\n\t\t\tlistbuf += nLen;\n\t\t\tnTotal += nLen;\n\t\t} else {\n\t\t\tnFiles = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tFS_FreeFileList( pFiles );\n\n\treturn nFiles;\n}\n",
        "target": 0
    },
    {
        "id": 386,
        "func": "alloc_limit_assert (char *fn_name, size_t size)\n{\n    if (alloc_limit && size > alloc_limit)\n    {\n\talloc_limit_failure (fn_name, size);\n\texit (-1);\n    }\n}",
        "target": 1
    },
    {
        "id": 387,
        "func": "error::Error GLES2DecoderImpl::HandleGetProgramInfoLog(\n    uint32 immediate_data_size, const cmds::GetProgramInfoLog& c) {\n  GLuint program_id = c.program;\n  uint32 bucket_id = static_cast<uint32>(c.bucket_id);\n  Bucket* bucket = CreateBucket(bucket_id);\n  Program* program = GetProgramInfoNotShader(\n      program_id, \"glGetProgramInfoLog\");\n  if (!program || !program->log_info()) {\n    bucket->SetFromString(\"\");\n    return error::kNoError;\n  }\n  bucket->SetFromString(program->log_info()->c_str());\n  return error::kNoError;\n}\n",
        "target": 0
    },
    {
        "id": 388,
        "func": "static __sum16 __tcp_checksum_complete_user(struct sock *sk,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\t__sum16 result;\n\n\tif (sock_owned_by_user(sk)) {\n\t\tlocal_bh_enable();\n\t\tresult = __tcp_checksum_complete(skb);\n\t\tlocal_bh_disable();\n\t} else {\n\t\tresult = __tcp_checksum_complete(skb);\n\t}\n\treturn result;\n}",
        "target": 0
    },
    {
        "id": 389,
        "func": "static int ocfs2_lock_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tdown_read(&oi->ip_alloc_sem);\n\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\tup_read(&oi->ip_alloc_sem);\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 390,
        "func": "void ip6_flush_pending_frames(struct sock *sk)\n{\n\t__ip6_flush_pending_frames(sk, &sk->sk_write_queue,\n\t\t\t\t   &inet_sk(sk)->cork, &inet6_sk(sk)->cork);\n}",
        "target": 0
    },
    {
        "id": 391,
        "func": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}",
        "target": 1
    },
    {
        "id": 392,
        "func": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\n/*\n\txmlInitParser();\n */\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n               ctxt->options &= ~XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\t/*ctxt->sax->fatalError = NULL;*/\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\n/*\n\txmlCleanupParser();\n*/\n\n/*\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n*/\n\treturn ret;\n}\n",
        "target": 0
    },
    {
        "id": 393,
        "func": "void WebContentsImpl::RenderViewTerminated(RenderViewHost* rvh,\n                                           base::TerminationStatus status,\n                                           int error_code) {\n  if (rvh != GetRenderViewHost()) {\n    return;\n  }\n\n  if (IsFullscreenForCurrentTab())\n    ExitFullscreenMode(false);\n\n  CancelActiveAndPendingDialogs();\n\n  if (delegate_)\n    delegate_->HideValidationMessage(this);\n\n  audio_stream_monitor_.RenderProcessGone(rvh->GetProcess()->GetID());\n\n  ResetLoadProgressState();\n  NotifyDisconnected();\n  SetIsCrashed(status, error_code);\n\n  for (auto& observer : observers_)\n    observer.RenderProcessGone(GetCrashedStatus());\n}\n",
        "target": 0
    },
    {
        "id": 394,
        "func": "error::Error GLES2DecoderImpl::HandleWaitSync(\n    uint32_t immediate_data_size, const void* cmd_data) {\n  if (!unsafe_es3_apis_enabled())\n    return error::kUnknownCommand;\n  const gles2::cmds::WaitSync& c =\n      *static_cast<const gles2::cmds::WaitSync*>(cmd_data);\n  GLuint sync = static_cast<GLuint>(c.sync);\n  GLbitfield flags = static_cast<GLbitfield>(c.flags);\n  GLuint64 timeout = GLES2Util::MapTwoUint32ToUint64(c.timeout_0, c.timeout_1);\n  GLsync service_sync = 0;\n  if (!group_->GetSyncServiceId(sync, &service_sync)) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, \"WaitSync\", \"invalid sync\");\n    return error::kNoError;\n  }\n  glWaitSync(service_sync, flags, timeout);\n  return error::kNoError;\n}\n",
        "target": 0
    },
    {
        "id": 395,
        "func": "MojoAudioOutputIPC::~MojoAudioOutputIPC() {\n  DCHECK(!AuthorizationRequested() && !StreamCreationRequested())\n      << \"CloseStream must be called before destructing the AudioOutputIPC\";\n}\n",
        "target": 0
    },
    {
        "id": 396,
        "func": "bool ChromeContentBrowserClient::ShouldAllowOpenURL(\n    content::SiteInstance* site_instance, const GURL& url) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  bool result;\n  if (ChromeContentBrowserClientExtensionsPart::ShouldAllowOpenURL(\n          site_instance, url, &result))\n    return result;\n#endif\n\n  GURL from_url = site_instance->GetSiteURL();\n  if (from_url.GetOrigin().spec() == chrome::kChromeUIChromeSigninURL &&\n      url.SchemeIs(content::kChromeUIScheme) &&\n      url.host_piece() != chrome::kChromeUIChromeSigninHost) {\n    VLOG(1) << \"Blocked navigation to \" << url.spec() << \" from \"\n            << chrome::kChromeUIChromeSigninURL;\n    return false;\n  }\n\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 397,
        "func": "static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}",
        "target": 1
    },
    {
        "id": 398,
        "func": "void AutocompletePopupViewGtk::OnDragCanceled() {\n  ignore_mouse_drag_ = true;\n}\n",
        "target": 0
    },
    {
        "id": 399,
        "func": "bool isAllowedByAll(const CSPDirectiveListVector& policies,\n                    Element* element,\n                    const String& contextURL,\n                    const String& nonce,\n                    const WTF::OrdinalNumber& contextLine,\n                    SecurityViolationReportingPolicy reportingPolicy,\n                    const String& content) {\n  bool isAllowed = true;\n  for (const auto& policy : policies) {\n    isAllowed &= (policy.get()->*allowed)(\n        element, contextURL, nonce, contextLine, reportingPolicy, content);\n  }\n  return isAllowed;\n}\n",
        "target": 0
    },
    {
        "id": 400,
        "func": "void Player::setStartTime(double newStartTime)\nvoid Player::setStartTime(double newStartTime, bool serviceAnimations)\n {\n     if (!std::isfinite(newStartTime))\n         return;\n     updateCurrentTimingState(); // Update the value of held\n     m_startTime = newStartTime;\n     if (!m_held)\n         updateCurrentTimingState();\n    if (serviceAnimations)\n        m_timeline.serviceAnimations();\n    else\n        update();\n }\n",
        "target": 0
    },
    {
        "id": 401,
        "func": "void CairoOutputDev::type3D1(GfxState *state, double wx, double wy,\n\t\t\t     double llx, double lly, double urx, double ury) {\n  t3_glyph_wx = wx;\n  t3_glyph_wy = wy;\n  t3_glyph_bbox[0] = llx;\n  t3_glyph_bbox[1] = lly;\n  t3_glyph_bbox[2] = urx;\n  t3_glyph_bbox[3] = ury;\n  t3_glyph_has_bbox = gTrue;\n}\n",
        "target": 0
    },
    {
        "id": 402,
        "func": " ref_param_read_signal_error(gs_param_list * plist, gs_param_name pkey, int code)\n {\n     iparam_list *const iplist = (iparam_list *) plist;\n    iparam_loc loc = {0};\n \n    ref_param_read(iplist, pkey, &loc, -1);\n    if (loc.presult)\n        *loc.presult = code;\n     switch (ref_param_read_get_policy(plist, pkey)) {\n         case gs_param_policy_ignore:\n             return 0;\n            return_error(gs_error_configurationerror);\n        default:\n            return code;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 403,
        "func": "static void rx_fixup(unsigned long data)\n{\n\tstruct rtl8150 *dev = (struct rtl8150 *)data;\n\tstruct sk_buff *skb;\n\tint status;\n\n\tspin_lock_irq(&dev->rx_pool_lock);\n\tfill_skb_pool(dev);\n\tspin_unlock_irq(&dev->rx_pool_lock);\n\tif (test_bit(RX_URB_FAIL, &dev->flags))\n\t\tif (dev->rx_skb)\n\t\t\tgoto try_again;\n\tspin_lock_irq(&dev->rx_pool_lock);\n\tskb = pull_skb(dev);\n\tspin_unlock_irq(&dev->rx_pool_lock);\n\tif (skb == NULL)\n\t\tgoto tlsched;\n\tdev->rx_skb = skb;\n\tusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t      dev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\ntry_again:\n\tstatus = usb_submit_urb(dev->rx_urb, GFP_ATOMIC);\n\tif (status == -ENODEV) {\n\t\tnetif_device_detach(dev->netdev);\n\t} else if (status) {\n\t\tset_bit(RX_URB_FAIL, &dev->flags);\n\t\tgoto tlsched;\n\t} else {\n\t\tclear_bit(RX_URB_FAIL, &dev->flags);\n\t}\n\n\treturn;\ntlsched:\n\ttasklet_schedule(&dev->tl);\n}",
        "target": 0
    },
    {
        "id": 404,
        "func": "void GpuCommandBufferStub::OnDestroyVideoDecoder(int decoder_route_id) {\n  TRACE_EVENT0(\"gpu\", \"GpuCommandBufferStub::OnDestroyVideoDecoder\");\n  channel_->RemoveRoute(decoder_route_id);\n  video_decoders_.Remove(decoder_route_id);\n}\n",
        "target": 0
    },
    {
        "id": 405,
        "func": "png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n   {\n      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n      size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit=PNG_UINT_31_MAX;\n      else\n         idat_limit = png_ptr->height * row_factor;\n      row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); /* zlib+deflate overhead */\n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}",
        "target": 1
    },
    {
        "id": 406,
        "func": "OpenGLFunctionTable* openGLFunctionTable()\n{\n    static OpenGLFunctionTable table;\n    return &table;\n}\n",
        "target": 0
    },
    {
        "id": 407,
        "func": "  Ins_NPUSHB( TT_ExecContext  exc,\n              FT_Long*        args )\n  {\n    FT_UShort  L, K;\n\n\n    L = (FT_UShort)exc->code[exc->IP + 1];\n\n    if ( BOUNDS( L, exc->stackSize + 1 - exc->top ) )\n    {\n      exc->error = FT_THROW( Stack_Overflow );\n      return;\n    }\n\n    for ( K = 1; K <= L; K++ )\n      args[K - 1] = exc->code[exc->IP + K + 1];\n\n    exc->new_top += L;\n  }\n",
        "target": 0
    },
    {
        "id": 408,
        "func": "  int ExecuteScriptAndExtractInt(const std::string& script) {\n    int value = 0;\n    EXPECT_TRUE(content::ExecuteScriptAndExtractInt(\n        shell(), \"domAutomationController.send(\" + script + \")\", &value));\n    return value;\n  }\n",
        "target": 0
    },
    {
        "id": 409,
        "func": "megasas_adp_reset_gen2(struct megasas_instance *instance,\n\t\t\tstruct megasas_register_set __iomem *reg_set)\n{\n\tu32 retry = 0 ;\n\tu32 HostDiag;\n\tu32 __iomem *seq_offset = &reg_set->seq_offset;\n\tu32 __iomem *hostdiag_offset = &reg_set->host_diag;\n\n\tif (instance->instancet == &megasas_instance_template_skinny) {\n\t\tseq_offset = &reg_set->fusion_seq_offset;\n\t\thostdiag_offset = &reg_set->fusion_host_diag;\n\t}\n\n\twritel(0, seq_offset);\n\twritel(4, seq_offset);\n\twritel(0xb, seq_offset);\n\twritel(2, seq_offset);\n\twritel(7, seq_offset);\n\twritel(0xd, seq_offset);\n\n\tmsleep(1000);\n\n\tHostDiag = (u32)readl(hostdiag_offset);\n\n\twhile (!(HostDiag & DIAG_WRITE_ENABLE)) {\n\t\tmsleep(100);\n\t\tHostDiag = (u32)readl(hostdiag_offset);\n\t\tdev_notice(&instance->pdev->dev, \"RESETGEN2: retry=%x, hostdiag=%x\\n\",\n\t\t\t\t\tretry, HostDiag);\n\n\t\tif (retry++ >= 100)\n\t\t\treturn 1;\n\n\t}\n\n\tdev_notice(&instance->pdev->dev, \"ADP_RESET_GEN2: HostDiag=%x\\n\", HostDiag);\n\n\twritel((HostDiag | DIAG_RESET_ADAPTER), hostdiag_offset);\n\n\tssleep(10);\n\n\tHostDiag = (u32)readl(hostdiag_offset);\n\twhile (HostDiag & DIAG_RESET_ADAPTER) {\n\t\tmsleep(100);\n\t\tHostDiag = (u32)readl(hostdiag_offset);\n\t\tdev_notice(&instance->pdev->dev, \"RESET_GEN2: retry=%x, hostdiag=%x\\n\",\n\t\t\t\tretry, HostDiag);\n\n\t\tif (retry++ >= 1000)\n\t\t\treturn 1;\n\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 410,
        "func": "void FilePathWatcherImpl::OnFilePathChanged(\n    InotifyReader::Watch fired_watch,\n    const FilePath::StringType& child,\n    bool created,\n    bool is_directory) {\n\n  if (!message_loop()->BelongsToCurrentThread()) {\n    message_loop()->PostTask(FROM_HERE,\n        base::Bind(&FilePathWatcherImpl::OnFilePathChanged,\n                   this,\n                   fired_watch,\n                   child,\n                   created,\n                   is_directory));\n    return;\n  }\n\n  DCHECK(MessageLoopForIO::current());\n\n  WatchVector::const_iterator watch_entry(watches_.begin());\n  for ( ; watch_entry != watches_.end(); ++watch_entry) {\n    if (fired_watch == watch_entry->watch_) {\n      bool change_on_target_path = child.empty() ||\n          ((child == watch_entry->subdir_) && watch_entry->linkname_.empty()) ||\n          (child == watch_entry->linkname_);\n\n      DCHECK(watch_entry->subdir_.empty() ||\n          (watch_entry + 1) != watches_.end());\n      bool target_changed =\n          (watch_entry->subdir_.empty() && (child == watch_entry->linkname_)) ||\n          (watch_entry->subdir_.empty() && watch_entry->linkname_.empty()) ||\n          (watch_entry->subdir_ == child && (watch_entry + 1)->subdir_.empty());\n\n      if (change_on_target_path && !UpdateWatches()) {\n        delegate_->OnFilePathError(target_);\n        return;\n      }\n\n      if (target_changed ||\n          (change_on_target_path && !created) ||\n          (change_on_target_path && file_util::PathExists(target_))) {\n        delegate_->OnFilePathChanged(target_);\n        return;\n      }\n    }\n  }\n\n}\n",
        "target": 0
    },
    {
        "id": 411,
        "func": " int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size, uint32_t user_id)\n{\n if(h < 0 || h >= MAX_THREAD)\n {\n        APPL_TRACE_ERROR(\"invalid bt thread handle:%d\", h);\n return FALSE;\n }\n if(ts[h].cmd_fdw == -1)\n {\n        APPL_TRACE_ERROR(\"cmd socket is not created. socket thread may not initialized\");\n return FALSE;\n }\n sock_cmd_t cmd = {CMD_USER_PRIVATE, 0, type, size, user_id};\n    APPL_TRACE_DEBUG(\"post cmd type:%d, size:%d, h:%d, \", type, size, h);\n sock_cmd_t* cmd_send = &cmd;\n int size_send = sizeof(cmd);\n if(data && size)\n {\n        size_send = sizeof(cmd) + size;\n        cmd_send = (sock_cmd_t*)alloca(size_send);\n if(cmd_send)\n {\n *cmd_send = cmd;\n            memcpy(cmd_send + 1, data, size);\n }\n else\n {\n            APPL_TRACE_ERROR(\"alloca failed at h:%d, cmd type:%d, size:%d\", h, type, size_send);\n\n             return FALSE;\n         }\n     }\n    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;\n }\n",
        "target": 1
    },
    {
        "id": 412,
        "func": "  Ins_DEBUG( INS_ARG )\n  {\n    DO_DEBUG\n  }\n",
        "target": 0
    },
    {
        "id": 413,
        "func": "int ext4_convert_unwritten_extents(struct inode *inode, loff_t offset,\n\t\t\t\t    ssize_t len)\n{\n\thandle_t *handle;\n\tunsigned int max_blocks;\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct ext4_map_blocks map;\n\tunsigned int credits, blkbits = inode->i_blkbits;\n\n\tmap.m_lblk = offset >> blkbits;\n\t/*\n\t * We can't just convert len to max_blocks because\n\t * If blocksize = 4096 offset = 3072 and len = 2048\n\t */\n\tmax_blocks = ((EXT4_BLOCK_ALIGN(len + offset, blkbits) >> blkbits) -\n\t\t      map.m_lblk);\n\t/*\n\t * credits to insert 1 extent into extent tree\n\t */\n\tcredits = ext4_chunk_trans_blocks(inode, max_blocks);\n\twhile (ret >= 0 && ret < max_blocks) {\n\t\tmap.m_lblk += ret;\n\t\tmap.m_len = (max_blocks -= ret);\n\t\thandle = ext4_journal_start(inode, credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tbreak;\n\t\t}\n\t\tret = ext4_map_blocks(handle, inode, &map,\n\t\t\t\t      EXT4_GET_BLOCKS_IO_CONVERT_EXT);\n\t\tif (ret <= 0) {\n\t\t\tWARN_ON(ret <= 0);\n\t\t\text4_msg(inode->i_sb, KERN_ERR,\n\t\t\t\t \"%s:%d: inode #%lu: block %u: len %u: \"\n\t\t\t\t \"ext4_ext_map_blocks returned %d\",\n\t\t\t\t __func__, __LINE__, inode->i_ino, map.m_lblk,\n\t\t\t\t map.m_len, ret);\n\t\t}\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tret2 = ext4_journal_stop(handle);\n\t\tif (ret <= 0 || ret2 )\n\t\t\tbreak;\n\t}\n\treturn ret > 0 ? ret2 : ret;\n}",
        "target": 0
    },
    {
        "id": 414,
        "func": "uint32_t ReverbGetDecayTime(ReverbContext *pContext){\n\n    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */\n    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */\n\n /* Get the current settings */\n LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\n    LVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"ReverbGetDecayTime\")\n\n if(ActiveParams.T60 != pContext->SavedDecayTime){\n        ALOGV(\"\\tLVM_ERROR : ReverbGetDecayTime() has wrong level -> %d %d\\n\",\n ActiveParams.T60, pContext->SavedDecayTime);\n }\n\n return (uint32_t)ActiveParams.T60;\n}\n",
        "target": 0
    },
    {
        "id": 415,
        "func": "static inline void avg_tpel_pixels_mc22_c(uint8_t *dst, const uint8_t *src, int stride, int width, int height){\n    int i,j;\n    for (i=0; i < height; i++) {\n      for (j=0; j < width; j++) {\n        dst[j] = (dst[j] + ((2731*(2*src[j] + 3*src[j+1] + 3*src[j+stride] + 4*src[j+stride+1] + 6)) >> 15) + 1) >> 1;\n      }\n      src += stride;\n      dst += stride;\n    }\n}",
        "target": 0
    },
    {
        "id": 416,
        "func": "static void check_mm(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tlong x = atomic_long_read(&mm->rss_stat.count[i]);\n\n\t\tif (unlikely(x))\n\t\t\tprintk(KERN_ALERT \"BUG: Bad rss-counter state \"\n\t\t\t\t\t  \"mm:%p idx:%d val:%ld\\n\", mm, i, x);\n\t}\n\n\tif (atomic_long_read(&mm->nr_ptes))\n\t\tpr_alert(\"BUG: non-zero nr_ptes on freeing mm: %ld\\n\",\n\t\t\t\tatomic_long_read(&mm->nr_ptes));\n\tif (mm_nr_pmds(mm))\n\t\tpr_alert(\"BUG: non-zero nr_pmds on freeing mm: %ld\\n\",\n\t\t\t\tmm_nr_pmds(mm));\n\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tVM_BUG_ON_MM(mm->pmd_huge_pte, mm);\n#endif\n}",
        "target": 0
    },
    {
        "id": 417,
        "func": "static void __net_exit ipgre_exit_net(struct net *net)\n{\n\tstruct ipgre_net *ign;\n\tLIST_HEAD(list);\n\n\tign = net_generic(net, ipgre_net_id);\n\trtnl_lock();\n\tipgre_destroy_tunnels(ign, &list);\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}",
        "target": 0
    },
    {
        "id": 418,
        "func": "static int bond_init(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\n\tpr_debug(\"Begin bond_init for %s\\n\", bond_dev->name);\n\n\t/*\n\t * Initialize locks that may be required during\n\t * en/deslave operations.  All of the bond_open work\n\t * (of which this is part) should really be moved to\n\t * a phase prior to dev_open\n\t */\n\tspin_lock_init(&(bond_info->tx_hashtbl_lock));\n\tspin_lock_init(&(bond_info->rx_hashtbl_lock));\n\n\tbond->wq = create_singlethread_workqueue(bond_dev->name);\n\tif (!bond->wq)\n\t\treturn -ENOMEM;\n\n\tbond_set_lockdep_class(bond_dev);\n\n\tbond_create_proc_entry(bond);\n\tlist_add_tail(&bond->bond_list, &bn->dev_list);\n\n\tbond_prepare_sysfs_group(bond);\n\n\tbond_debug_register(bond);\n\n\t__hw_addr_init(&bond->mc_list);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 419,
        "func": "OMX::buffer_id OMXNodeInstance::findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {\n    return (OMX::buffer_id)bufferHeader;\n}\n",
        "target": 1
    },
    {
        "id": 420,
        "func": "static bool CheckEac3(const uint8_t* buffer, int buffer_size) {\n\n  RCHECK(buffer_size > 6);\n\n  int offset = 0;\n  while (offset + 6 < buffer_size) {\n    BitReader reader(buffer + offset, 6);\n\n    RCHECK(ReadBits(&reader, 16) == kAc3SyncWord);\n\n    RCHECK(ReadBits(&reader, 2) != 3);\n\n    reader.SkipBits(3);\n\n    int frame_size = (ReadBits(&reader, 11) + 1) * 2;\n    RCHECK(frame_size >= 7);\n\n    reader.SkipBits(2 + 2 + 3 + 1);\n\n    int bit_stream_id = ReadBits(&reader, 5);\n    RCHECK(bit_stream_id >= 11 && bit_stream_id <= 16);\n\n    offset += frame_size;\n  }\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 421,
        "func": "static inline void enter_lazy(enum paravirt_lazy_mode mode)\n{\n\tBUG_ON(this_cpu_read(paravirt_lazy_mode) != PARAVIRT_LAZY_NONE);\n\n\tthis_cpu_write(paravirt_lazy_mode, mode);\n}",
        "target": 0
    },
    {
        "id": 422,
        "func": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n}",
        "target": 1
    },
    {
        "id": 423,
        "func": "void InspectorPageAgent::setEmulatedMedia(ErrorString*, const String& media)\n{\n    String currentMedia = m_state->getString(PageAgentState::pageAgentEmulatedMedia);\n    if (media == currentMedia)\n        return;\n\n    m_state->setString(PageAgentState::pageAgentEmulatedMedia, media);\n    Document* document = 0;\n    if (m_page->mainFrame())\n        document = m_page->mainFrame()->document();\n    if (document) {\n         document->styleResolverChanged(RecalcStyleImmediately);\n         document->updateLayout();\n     }\n }\n",
        "target": 0
    },
    {
        "id": 424,
        "func": "void ExtensionService::GrantPermissions(const Extension* extension) {\n  CHECK(extension);\n\n  if (extension->CanSilentlyIncreasePermissions())\n    return;\n\n  extension_prefs_->AddGrantedPermissions(extension->id(),\n                                          extension->GetActivePermissions());\n}\n",
        "target": 0
    },
    {
        "id": 425,
        "func": "void RenderViewImpl::OnCut() {\n  if (!webview())\n    return;\n\n  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);\n  webview()->focusedFrame()->executeCommand(WebString::fromUTF8(\"Cut\"));\n}\n",
        "target": 0
    },
    {
        "id": 426,
        "func": "static void nft_chain_commit_update(struct nft_trans *trans)\n{\n\tstruct nft_base_chain *basechain;\n\n\tif (nft_trans_chain_name(trans)[0])\n\t\tstrcpy(trans->ctx.chain->name, nft_trans_chain_name(trans));\n\n\tif (!(trans->ctx.chain->flags & NFT_BASE_CHAIN))\n\t\treturn;\n\n\tbasechain = nft_base_chain(trans->ctx.chain);\n\tnft_chain_stats_replace(basechain, nft_trans_chain_stats(trans));\n\n\tswitch (nft_trans_chain_policy(trans)) {\n\tcase NF_DROP:\n\tcase NF_ACCEPT:\n\t\tbasechain->policy = nft_trans_chain_policy(trans);\n\t\tbreak;\n\t}\n}",
        "target": 0
    },
    {
        "id": 427,
        "func": "status_t MediaPlayerService::Client::start()\n{\n    ALOGV(\"[%d] start\", mConnId);\n    sp<MediaPlayerBase> p = getPlayer();\n if (p == 0) return UNKNOWN_ERROR;\n    p->setLooping(mLoop);\n return p->start();\n}\n",
        "target": 0
    },
    {
        "id": 428,
        "func": "PassRefPtr<AccessibilityUIElement> AccessibilityUIElement::accessibilityElementForTextMarker(AccessibilityTextMarker* marker)\n{\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 429,
        "func": "int bio_alloc_pages(struct bio *bio, gfp_t gfp_mask)\n{\n\tint i;\n\tstruct bio_vec *bv;\n\n\tbio_for_each_segment_all(bv, bio, i) {\n\t\tbv->bv_page = alloc_page(gfp_mask);\n\t\tif (!bv->bv_page) {\n\t\t\twhile (--bv >= bio->bi_io_vec)\n\t\t\t\t__free_page(bv->bv_page);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 430,
        "func": "void FrameworkListener::registerCmd(FrameworkCommand *cmd) {\n    mCommands->push_back(cmd);\n}\n",
        "target": 0
    },
    {
        "id": 431,
        "func": "WebGLRenderingContextBase::~WebGLRenderingContextBase() {\n   destruction_in_progress_ = true;\n \n  DestroyContext();\n\n  RestoreEvictedContext(this);\n}\n",
        "target": 1
    },
    {
        "id": 432,
        "func": "  virtual void AddObserver(Observer* observer) {\n     if (!observers_.size()) {\n       observer->FirstObserverIsAdded(this);\n     }\n     observers_.AddObserver(observer);\n   }\n",
        "target": 1
    },
    {
        "id": 433,
        "func": "void AudioSource::queueInputBuffer_l(MediaBuffer *buffer, int64_t timeUs) {\n const size_t bufferSize = buffer->range_length();\n const size_t frameSize = mRecord->frameSize();\n const int64_t timestampUs =\n                mPrevSampleTimeUs +\n ((1000000LL * (bufferSize / frameSize)) +\n (mSampleRate >> 1)) / mSampleRate;\n\n if (mNumFramesReceived == 0) {\n        buffer->meta_data()->setInt64(kKeyAnchorTime, mStartTimeUs);\n }\n\n    buffer->meta_data()->setInt64(kKeyTime, mPrevSampleTimeUs);\n    buffer->meta_data()->setInt64(kKeyDriftTime, timeUs - mInitialReadTimeUs);\n    mPrevSampleTimeUs = timestampUs;\n    mNumFramesReceived += bufferSize / frameSize;\n    mBuffersReceived.push_back(buffer);\n    mFrameAvailableCondition.signal();\n}\n",
        "target": 0
    },
    {
        "id": 434,
        "func": "  static void  Ins_MPPEM( INS_ARG )\n  {\n    args[0] = CURRENT_Ppem();\n    DBG_PRINT1(\" %d\", args[0]);\n  }\n",
        "target": 0
    },
    {
        "id": 435,
        "func": "nfssvc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n \targs->cookie = ntohl(*p++);\n \targs->count  = ntohl(*p++);\n \targs->count  = min_t(u32, args->count, PAGE_SIZE);\n \targs->buffer = page_address(*(rqstp->rq_next_page++));\n \n\treturn xdr_argsize_check(rqstp, p);\n }\n",
        "target": 1
    },
    {
        "id": 436,
        "func": "bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::OutputPicture(\n    const scoped_refptr<H264Picture>& pic) {\n  scoped_refptr<VaapiDecodeSurface> dec_surface =\n      H264PictureToVaapiDecodeSurface(pic);\n\n  vaapi_dec_->SurfaceReady(dec_surface);\n\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 437,
        "func": "TabContents* Browser::AddTab(TabContentsWrapper* tab_contents,\n                             PageTransition::Type type) {\n  tab_handler_->GetTabStripModel()->AddTabContents(\n      tab_contents, -1, type, TabStripModel::ADD_ACTIVE);\n  return tab_contents->tab_contents();\n}\n",
        "target": 0
    },
    {
        "id": 438,
        "func": "bool IsPrintPreviewEnabled() {\n  return CommandLine::ForCurrentProcess()->HasSwitch(kEnablePrintPreview);\n}\n",
        "target": 0
    },
    {
        "id": 439,
        "func": "void V8Window::namedPropertyGetterCustom(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n\n    DOMWindow* window = V8Window::toNative(info.Holder());\n    if (!window)\n        return;\n\n    Frame* frame = window->frame();\n    if (!frame)\n        return;\n\n    AtomicString propName = toWebCoreAtomicString(name);\n    Frame* child = frame->tree().scopedChild(propName);\n    if (child) {\n        v8SetReturnValueFast(info, child->domWindow(), window);\n        return;\n    }\n\n    if (!info.Holder()->GetRealNamedProperty(name).IsEmpty())\n        return;\n\n     Document* doc = frame->document();\n \n     if (doc && doc->isHTMLDocument()) {\n        if (toHTMLDocument(doc)->hasNamedItem(propName.impl()) || doc->hasElementWithId(propName.impl())) {\n             RefPtr<HTMLCollection> items = doc->windowNamedItems(propName);\n             if (!items->isEmpty()) {\n                 if (items->hasExactlyOneItem()) {\n                    v8SetReturnValueFast(info, items->item(0), window);\n                    return;\n                }\n                v8SetReturnValueFast(info, items.release(), window);\n                return;\n            }\n        }\n    }\n}\n",
        "target": 1
    },
    {
        "id": 440,
        "func": "cpu_util(double pcpu[3])\n{\n    static struct timeval last;\n    static clock_t clast;\n    static struct rusage rlast;\n    struct timeval temp;\n    clock_t ctemp;\n    struct rusage rtemp;\n    double timediff;\n    double userdiff;\n    double systemdiff;\n\n    if (pcpu == NULL) {\n        gettimeofday(&last, NULL);\n        clast = clock();\n\tgetrusage(RUSAGE_SELF, &rlast);\n        return;\n    }\n\n    gettimeofday(&temp, NULL);\n    ctemp = clock();\n    getrusage(RUSAGE_SELF, &rtemp);\n\n    timediff = ((temp.tv_sec * 1000000.0 + temp.tv_usec) -\n                (last.tv_sec * 1000000.0 + last.tv_usec));\n    userdiff = ((rtemp.ru_utime.tv_sec * 1000000.0 + rtemp.ru_utime.tv_usec) -\n                (rlast.ru_utime.tv_sec * 1000000.0 + rlast.ru_utime.tv_usec));\n    systemdiff = ((rtemp.ru_stime.tv_sec * 1000000.0 + rtemp.ru_stime.tv_usec) -\n                  (rlast.ru_stime.tv_sec * 1000000.0 + rlast.ru_stime.tv_usec));\n\n    pcpu[0] = (((ctemp - clast) * 1000000.0 / CLOCKS_PER_SEC) / timediff) * 100;\n    pcpu[1] = (userdiff / timediff) * 100;\n    pcpu[2] = (systemdiff / timediff) * 100;\n}",
        "target": 0
    },
    {
        "id": 441,
        "func": "status_t MediaHTTP::initCheck() const {\n return mInitCheck;\n}\n",
        "target": 0
    },
    {
        "id": 442,
        "func": "MagickExport const Quantum *GetVirtualPixelQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_virtual_pixels_handler !=\n       (GetVirtualPixelsHandler) NULL)\n    return(cache_info->methods.get_virtual_pixels_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));\n}",
        "target": 0
    },
    {
        "id": 443,
        "func": "  static NudgeDelayStrategy GetNudgeDelayStrategy(const ModelType& type) {\n    switch (type) {\n     case syncable::AUTOFILL:\n       return ACCOMPANY_ONLY;\n     case syncable::PREFERENCES:\n     case syncable::SESSIONS:\n       return CUSTOM;\n     default:\n       return IMMEDIATE;\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 444,
        "func": "void RenderViewImpl::OnResize(const ResizeParams& params) {\n  TRACE_EVENT0(\"renderer\", \"RenderViewImpl::OnResize\");\n\n  if (webview()) {\n    webview()->HidePopups();\n    if (send_preferred_size_changes_ &&\n        webview()->MainFrame()->IsWebLocalFrame()) {\n      webview()->MainFrame()->ToWebLocalFrame()->SetCanHaveScrollbars(\n          ShouldDisplayScrollbars(params.new_size.width(),\n                                  params.new_size.height()));\n    }\n    if (display_mode_ != params.display_mode) {\n      display_mode_ = params.display_mode;\n      webview()->SetDisplayMode(display_mode_);\n    }\n  }\n\n  browser_controls_shrink_blink_size_ =\n      params.browser_controls_shrink_blink_size;\n  top_controls_height_ = params.top_controls_height;\n  bottom_controls_height_ = params.bottom_controls_height;\n\n  if (device_scale_factor_for_testing_) {\n    ResizeParams p(params);\n    p.screen_info.device_scale_factor = *device_scale_factor_for_testing_;\n    p.physical_backing_size =\n        gfx::ScaleToCeiledSize(p.new_size, p.screen_info.device_scale_factor);\n    RenderWidget::OnResize(p);\n  } else {\n    RenderWidget::OnResize(params);\n  }\n\n  if (params.scroll_focused_node_into_view)\n    webview()->ScrollFocusedEditableElementIntoView();\n}\n",
        "target": 0
    },
    {
        "id": 445,
        "func": "static int __init tcp_illinois_register(void)\n{\n\tBUILD_BUG_ON(sizeof(struct illinois) > ICSK_CA_PRIV_SIZE);\n\treturn tcp_register_congestion_control(&tcp_illinois);\n}",
        "target": 0
    },
    {
        "id": 446,
        "func": "__ip_vs_get_timeouts(struct net *net, struct ip_vs_timeout_user *u)\n{\n#if defined(CONFIG_IP_VS_PROTO_TCP) || defined(CONFIG_IP_VS_PROTO_UDP)\n\tstruct ip_vs_proto_data *pd;\n#endif\n\n#ifdef CONFIG_IP_VS_PROTO_TCP\n\tpd = ip_vs_proto_data_get(net, IPPROTO_TCP);\n\tu->tcp_timeout = pd->timeout_table[IP_VS_TCP_S_ESTABLISHED] / HZ;\n\tu->tcp_fin_timeout = pd->timeout_table[IP_VS_TCP_S_FIN_WAIT] / HZ;\n#endif\n#ifdef CONFIG_IP_VS_PROTO_UDP\n\tpd = ip_vs_proto_data_get(net, IPPROTO_UDP);\n\tu->udp_timeout =\n\t\t\tpd->timeout_table[IP_VS_UDP_S_NORMAL] / HZ;\n#endif\n}",
        "target": 0
    },
    {
        "id": 447,
        "func": "static void ReflectReflectedNameAttributeTestAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Local<v8::Object> holder = info.Holder();\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V8SetReturnValueFast(info, impl->FastGetAttribute(html_names::kReflectedNameAttributeAttr), impl);\n}\n",
        "target": 0
    },
    {
        "id": 448,
        "func": "    bool crossOriginModeAllowsCookies()\n    {\n        return m_crossOriginMode.isNull() || equalIgnoringCase(m_crossOriginMode, \"use-credentials\");\n    }\n",
        "target": 0
    },
    {
        "id": 449,
        "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    UWORD32     u4_start_code;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n\n    ps_stream      = &ps_dec->s_bit_stream;\n\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {\n            impeg2d_dec_user_data(ps_dec);\n }\n else\n {\n            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);\n switch(u4_start_code)\n {\n case QUANT_MATRIX_EXT_ID:\n                impeg2d_dec_quant_matrix_ext(ps_dec);\n break;\n case COPYRIGHT_EXT_ID:\n                impeg2d_dec_copyright_ext(ps_dec);\n break;\n case PIC_DISPLAY_EXT_ID:\n                impeg2d_dec_pic_disp_ext(ps_dec);\n break;\n case CAMERA_PARAM_EXT_ID:\n                impeg2d_dec_cam_param_ext(ps_dec);\n break;\n case ITU_T_EXT_ID:\n                impeg2d_dec_itu_t_ext(ps_dec);\n break;\n case PIC_SPATIAL_SCALABLE_EXT_ID:\n case PIC_TEMPORAL_SCALABLE_EXT_ID:\n                e_error = IMPEG2D_SCALABLITY_NOT_SUP;\n break;\n default:\n /* In case its a reserved extension code */\n                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);\n                impeg2d_next_start_code(ps_dec);\n break;\n }\n }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n }\n return e_error;\n}\n",
        "target": 1
    },
    {
        "id": 450,
        "func": "static int cg_open(const char *path, struct fuse_file_info *fi)\n{\n\tconst char *cgroup;\n\tchar *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *file_info;\n\tstruct fuse_context *fc = fuse_get_context();\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EIO;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tpath1 = \"/\";\n\t\tpath2 = cgdir;\n\t} else {\n\t\tpath1 = cgdir;\n\t\tpath2 = fpath;\n\t}\n\n\tk = cgfs_get_key(controller, path1, path2);\n\tif (!k) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfree_key(k);\n\n\tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {\n\t\t// should never get here\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\t/* we'll free this at cg_release */\n\tfile_info = malloc(sizeof(*file_info));\n\tif (!file_info) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfile_info->controller = must_copy_string(controller);\n\tfile_info->cgroup = must_copy_string(path1);\n\tfile_info->file = must_copy_string(path2);\n\tfile_info->type = LXC_TYPE_CGFILE;\n\tfile_info->buf = NULL;\n\tfile_info->buflen = 0;\n\n\tfi->fh = (unsigned long)file_info;\n\tret = 0;\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 451,
        "func": "void ContentSettingsStore::ClearContentSettingsForExtension(\n    const std::string& ext_id,\n    ExtensionPrefsScope scope) {\n  bool notify = false;\n   {\n     base::AutoLock lock(lock_);\n     OriginIdentifierValueMap* map = GetValueMap(ext_id, scope);\n      char ext_id_buffer[33];\n      base::strlcpy(ext_id_buffer, ext_id.c_str(), sizeof(ext_id_buffer));\n      base::debug::Alias(ext_id_buffer);\n      CHECK(false);\n     }\n     notify = !map->empty();\n     map->clear();\n  }\n  if (notify) {\n    NotifyOfContentSettingChanged(ext_id, scope != kExtensionPrefsScopeRegular);\n  }\n}\n",
        "target": 1
    },
    {
        "id": 452,
        "func": "static void *mergeable_ctx_to_buf_address(unsigned long mrg_ctx)\n{\n\treturn (void *)(mrg_ctx & -MERGEABLE_BUFFER_ALIGN);\n\n}",
        "target": 0
    },
    {
        "id": 453,
        "func": "static int pfkey_recvmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\tmsg->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 454,
        "func": "static int tty_fasync(int fd, struct file *filp, int on)\n{\n\tint retval;\n\ttty_lock();\n\tretval = __tty_fasync(fd, filp, on);\n\ttty_unlock();\n\treturn retval;\n}",
        "target": 0
    },
    {
        "id": 455,
        "func": "void SocketStream::SetClientSocketFactory(\n    ClientSocketFactory* factory) {\n  DCHECK(factory);\n  factory_ = factory;\n}\n",
        "target": 0
    },
    {
        "id": 456,
        "func": "void SystemClipboard::WriteImage(Image* image,\n                                 const KURL& url,\n                                 const String& title) {\n  DCHECK(image);\n\n  PaintImage paint_image = image->PaintImageForCurrentFrame();\n  SkBitmap bitmap;\n  if (sk_sp<SkImage> sk_image = paint_image.GetSkImage())\n    sk_image->asLegacyBitmap(&bitmap);\n   if (bitmap.isNull())\n     return;\n \n  if (!bitmap.getPixels())\n    return;\n \n   clipboard_->WriteImage(mojom::ClipboardBuffer::kStandard, bitmap);\n \n  if (url.IsValid() && !url.IsEmpty()) {\n#if !defined(OS_MACOSX)\n    clipboard_->WriteBookmark(mojom::ClipboardBuffer::kStandard,\n                              url.GetString(), NonNullString(title));\n#endif\n\n    clipboard_->WriteHtml(mojom::ClipboardBuffer::kStandard,\n                          URLToImageMarkup(url, title), KURL());\n  }\n  clipboard_->CommitWrite(mojom::ClipboardBuffer::kStandard);\n}\n",
        "target": 1
    },
    {
        "id": 457,
        "func": "std::unique_ptr<APIPermission> UnpackPermissionWithArguments(\n    base::StringPiece permission_name,\n    base::StringPiece permission_arg,\n    const std::string& permission_str,\n    std::string* error) {\n  std::unique_ptr<base::Value> permission_json =\n      base::JSONReader::Read(permission_arg);\n  if (!permission_json.get()) {\n    *error = ErrorUtils::FormatErrorMessage(kInvalidParameter, permission_str);\n    return nullptr;\n  }\n\n  std::unique_ptr<APIPermission> permission;\n\n  const APIPermissionInfo* usb_device_permission_info =\n      PermissionsInfo::GetInstance()->GetByID(APIPermission::kUsbDevice);\n  if (permission_name == usb_device_permission_info->name()) {\n    permission =\n        std::make_unique<UsbDevicePermission>(usb_device_permission_info);\n  } else {\n    *error = kUnsupportedPermissionId;\n    return nullptr;\n  }\n\n  CHECK(permission);\n  if (!permission->FromValue(permission_json.get(), nullptr, nullptr)) {\n    *error = ErrorUtils::FormatErrorMessage(kInvalidParameter, permission_str);\n    return nullptr;\n  }\n\n  return permission;\n}\n",
        "target": 0
    },
    {
        "id": 458,
        "func": "tracing_max_lat_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\treturn tracing_nsecs_read(filp->private_data, ubuf, cnt, ppos);\n}\n",
        "target": 0
    },
    {
        "id": 459,
        "func": "static void pcd_req_sense(struct pcd_unit *cd, char *fun)\n{\n\tchar rs_cmd[12] = { 0x03, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[16];\n\tint r, c;\n\n\tr = pcd_command(cd, rs_cmd, 16, \"Request sense\");\n\tmdelay(1);\n\tif (!r)\n\t\tpcd_completion(cd, buf, \"Request sense\");\n\n\tcd->last_sense = -1;\n\tc = 2;\n\tif (!r) {\n\t\tif (fun)\n\t\t\tprintk(\"%s: %s: Sense key: %x, ASC: %x, ASQ: %x\\n\",\n\t\t\t       cd->name, fun, buf[2] & 0xf, buf[12], buf[13]);\n\t\tc = buf[2] & 0xf;\n\t\tcd->last_sense =\n\t\t    c | ((buf[12] & 0xff) << 8) | ((buf[13] & 0xff) << 16);\n\t}\n\tif ((c == 2) || (c == 6))\n\t\tcd->changed = 1;\n}",
        "target": 0
    },
    {
        "id": 460,
        "func": "static gboolean delayed_destroys_process_cb(gpointer user_data)\n{\n  while (g_delayed_destroys != NULL) {\n\tPluginInstance *plugin = (PluginInstance *)g_delayed_destroys->data;\n\tg_delayed_destroys = g_list_delete_link(g_delayed_destroys,\n\t\t\t\t\t\t\t\t\t\t\tg_delayed_destroys);\n\tg_NPP_Destroy_Now(plugin, NULL);\n  }\n\n  if (g_delayed_destroys)\n\treturn TRUE;\n\n  if (g_delayed_destroys_id) {\n\tg_source_remove(g_delayed_destroys_id);\n\tg_delayed_destroys_id = 0;\n  }\n  return FALSE;\n}",
        "target": 0
    },
    {
        "id": 461,
        "func": "static inline bool is_page_fault(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | PF_VECTOR | INTR_INFO_VALID_MASK);\n}",
        "target": 0
    },
    {
        "id": 462,
        "func": "int tty_unregister_ldisc(int disc)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (disc < N_TTY || disc >= NR_LDISCS)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\tif (tty_ldiscs[disc]->refcount)\n\t\tret = -EBUSY;\n\telse\n\t\ttty_ldiscs[disc] = NULL;\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 463,
        "func": "const std::string& AppControllerImpl::MaybeGetAndroidPackageName(\n     const std::string& app_id) {\n   const auto& package_name_it = android_package_map_.find(app_id);\n  if (package_name_it != android_package_map_.end()) {\n    return package_name_it->second;\n  }\n\n  ArcAppListPrefs* arc_prefs_ = ArcAppListPrefs::Get(profile_);\n  if (!arc_prefs_) {\n    return base::EmptyString();\n  }\n  std::unique_ptr<ArcAppListPrefs::AppInfo> arc_info =\n      arc_prefs_->GetApp(app_id);\n  if (!arc_info) {\n    return base::EmptyString();\n  }\n\n  android_package_map_[app_id] = arc_info->package_name;\n  return android_package_map_[app_id];\n}\n",
        "target": 1
    },
    {
        "id": 464,
        "func": "iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    OM_uint32 major_status = GSS_S_COMPLETE;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n\n    if (*context_handle != GSS_C_NO_CONTEXT) {\n        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n            iakerb_release_context(iakerb_ctx);\n            *context_handle = GSS_C_NO_CONTEXT;\n        } else {\n            assert(iakerb_ctx->magic == KG_CONTEXT);\n\n            major_status = krb5_gss_delete_sec_context(minor_status,\n                                                       context_handle,\n                                                       output_token);\n        }\n    }\n\n    return major_status;\n}",
        "target": 1
    },
    {
        "id": 465,
        "func": "void QQuickWebView::mousePressEvent(QMouseEvent* event)\n{\n    Q_D(QQuickWebView);\n    forceActiveFocus();\n    d->pageView->eventHandler()->handleMousePressEvent(event);\n}\n",
        "target": 0
    },
    {
        "id": 466,
        "func": "static inline long decode_twos_comp(ulong c, int prec)\n{\n\tlong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tresult = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));\n\treturn result;\n}",
        "target": 1
    },
    {
        "id": 467,
        "func": "static void red_channel_client_release_item(RedChannelClient *rcc, PipeItem *item, int item_pushed)\n{\n    int handled = TRUE;\n\n    switch (item->type) {\n        case PIPE_ITEM_TYPE_SET_ACK:\n        case PIPE_ITEM_TYPE_EMPTY_MSG:\n        case PIPE_ITEM_TYPE_MIGRATE:\n        case PIPE_ITEM_TYPE_PING:\n            free(item);\n            break;\n        default:\n            handled = FALSE;\n    }\n    if (!handled) {\n        rcc->channel->channel_cbs.release_item(rcc, item, item_pushed);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 468,
        "func": "static int nfs4_xdr_dec_access(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       struct nfs4_accessres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_access(xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server,\n\t\t\t!RPC_IS_ASYNC(rqstp->rq_task));\nout:\n\treturn status;\n}",
        "target": 0
    },
    {
        "id": 469,
        "func": "static int vr_active(struct task_struct *target,\n\t\t     const struct user_regset *regset)\n{\n\tflush_altivec_to_thread(target);\n\treturn target->thread.used_vr ? regset->n : 0;\n}",
        "target": 0
    },
    {
        "id": 470,
        "func": "static CURLcode smtp_state_authplain_resp(struct connectdata *conn,\n                                          int smtpcode,\n                                          smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct SessionHandle *data = conn->data;\n  size_t len = 0;\n  char *plainauth = NULL;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode != 334) {\n    failf(data, \"Access denied: %d\", smtpcode);\n    result = CURLE_LOGIN_DENIED;\n  }\n  else {\n    result = smtp_auth_plain_data(conn, &plainauth, &len);\n\n    if(!result) {\n      if(plainauth) {\n        result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s\", plainauth);\n\n        if(!result)\n          state(conn, SMTP_AUTH);\n      }\n      Curl_safefree(plainauth);\n    }\n  }\n\n  return result;\n}",
        "target": 0
    },
    {
        "id": 471,
        "func": "JSValue jsTestObjCONST_VALUE_13(ExecState* exec, JSValue, const Identifier&)\n{\n    UNUSED_PARAM(exec);\n    return jsNumber(static_cast<int>(0X20));\n}\n",
        "target": 0
    },
    {
        "id": 472,
        "func": "R_API bool r_anal_bb_set_offset(RAnalBlock *bb, int i, ut16 v) {\n\t// the offset 0 of the instruction 0 is not stored because always 0\n\tif (i > 0 && v > 0) {\n\t\tif (i >= bb->op_pos_size) {\n\t\t\tint new_pos_size = i * 2;\n\t\t\tut16 *tmp_op_pos = realloc (bb->op_pos, new_pos_size * sizeof (*bb->op_pos));\n\t\t\tif (!tmp_op_pos) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbb->op_pos_size = new_pos_size;\n\t\t\tbb->op_pos = tmp_op_pos;\n\t\t}\n\t\tbb->op_pos[i - 1] = v;\n\t\treturn true;\n\t}\n\treturn true;\n}",
        "target": 0
    },
    {
        "id": 473,
        "func": " SPL_METHOD(SplFileObject, rewind)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::eof()\n",
        "target": 1
    },
    {
        "id": 474,
        "func": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}",
        "target": 0
    },
    {
        "id": 475,
        "func": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n    state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}",
        "target": 1
    },
    {
        "id": 476,
        "func": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tstruct ipv6_opt_hdr *exthdr =\n\t\t\t\t(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset + 1 <= packet_len) {\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t}\n\n\treturn offset;\n}",
        "target": 1
    },
    {
        "id": 477,
        "func": "static int phar_check_str(const char *fname, const char *ext_str, int ext_len, int executable, int for_create) /* {{{ */\n{\n\tchar test[51];\n\tconst char *pos;\n\n\tif (ext_len >= 50) {\n\t\treturn FAILURE;\n\t}\n\n\tif (executable == 1) {\n\t\t/* copy \".\" as well */\n\t\tmemcpy(test, ext_str - 1, ext_len + 1);\n\t\ttest[ext_len + 1] = '\\0';\n\t\t/* executable phars must contain \".phar\" as a valid extension (phar://.pharmy/oops is invalid) */\n\t\t/* (phar://hi/there/.phar/oops is also invalid) */\n\t\tpos = strstr(test, \".phar\");\n\n\t\tif (pos && (*(pos - 1) != '/')\n\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create);\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* data phars need only contain a single non-\".\" to be valid */\n\tif (!executable) {\n\t\tpos = strstr(ext_str, \".phar\");\n\t\tif (!(pos && (*(pos - 1) != '/')\n\t\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) && *(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create);\n\t\t}\n\t} else {\n\t\tif (*(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create);\n\t\t}\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 478,
        "func": "base::string16 OmniboxEditModel::DisplayTextFromUserText(\n    const base::string16& text) const {\n  return KeywordIsSelected() ?\n      KeywordProvider::SplitReplacementStringFromInput(text, false) : text;\n}\n",
        "target": 0
    },
    {
        "id": 479,
        "func": "static inline MagickOffsetType *ReadPSDRLEOffsets(Image *image,\n  const PSDInfo *psd_info,const size_t size)\n{\n  MagickOffsetType\n    *offsets;\n\n  ssize_t\n    y;\n\n  offsets=(MagickOffsetType *) AcquireQuantumMemory(size,sizeof(*offsets));\n  if(offsets != (MagickOffsetType *) NULL)\n    {\n      for (y=0; y < (ssize_t) size; y++)\n      {\n        if (psd_info->version == 1)\n          offsets[y]=(MagickOffsetType) ReadBlobShort(image);\n        else\n          offsets[y]=(MagickOffsetType) ReadBlobLong(image);\n      }\n    }\n  return offsets;\n}\n",
        "target": 0
    },
    {
        "id": 480,
        "func": "TestRenderWidgetHostView::TestRenderWidgetHostView(RenderWidgetHost* rwh)\n    : rwh_(RenderWidgetHostImpl::From(rwh)),\n      is_showing_(false),\n      is_occluded_(false),\n      did_swap_compositor_frame_(false),\n      background_color_(SK_ColorWHITE) {\n#if defined(OS_ANDROID)\n  frame_sink_id_ = AllocateFrameSinkId();\n  GetSurfaceManager()->RegisterFrameSinkId(frame_sink_id_);\n#else\n  if (ImageTransportFactory::GetInstance()) {\n    frame_sink_id_ = AllocateFrameSinkId();\n    GetSurfaceManager()->RegisterFrameSinkId(frame_sink_id_);\n  }\n#endif\n\n  rwh_->SetView(this);\n}\n",
        "target": 0
    },
    {
        "id": 481,
        "func": "static int bdrv_get_cluster_size(BlockDriverState *bs)\n{\n    BlockDriverInfo bdi;\n    int ret;\n\n    ret = bdrv_get_info(bs, &bdi);\n    if (ret < 0 || bdi.cluster_size == 0) {\n        return bs->request_alignment;\n    } else {\n        return bdi.cluster_size;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 482,
        "func": "static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)\n{\n    uint8_t byte;\n\n    if (bytestream2_get_bytes_left(&s->g) < 5)\n        return AVERROR_INVALIDDATA;\n\n    /*  nreslevels = number of resolution levels\n                   = number of decomposition level +1 */\n    c->nreslevels = bytestream2_get_byteu(&s->g) + 1;\n    if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) {\n        av_log(s->avctx, AV_LOG_ERROR, \"nreslevels %d is invalid\\n\", c->nreslevels);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* compute number of resolution levels to decode */\n    if (c->nreslevels < s->reduction_factor)\n        c->nreslevels2decode = 1;\n    else\n        c->nreslevels2decode = c->nreslevels - s->reduction_factor;\n\n    c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk width\n    c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk height\n\n    if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 ||\n        c->log2_cblk_width + c->log2_cblk_height > 12) {\n        av_log(s->avctx, AV_LOG_ERROR, \"cblk size invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    c->cblk_style = bytestream2_get_byteu(&s->g);\n    if (c->cblk_style != 0) { // cblk style\n        av_log(s->avctx, AV_LOG_WARNING, \"extra cblk styles %X\\n\", c->cblk_style);\n    }\n    c->transform = bytestream2_get_byteu(&s->g); // DWT transformation type\n    /* set integer 9/7 DWT in case of BITEXACT flag */\n    if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))\n        c->transform = FF_DWT97_INT;\n\n    if (c->csty & JPEG2000_CSTY_PREC) {\n        int i;\n        for (i = 0; i < c->nreslevels; i++) {\n            byte = bytestream2_get_byte(&s->g);\n            c->log2_prec_widths[i]  =  byte       & 0x0F;    // precinct PPx\n            c->log2_prec_heights[i] = (byte >> 4) & 0x0F;    // precinct PPy\n        }\n    } else {\n        memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths ));\n        memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights));\n    }\n    return 0;\n}",
        "target": 1
    },
    {
        "id": 483,
        "func": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_mmu_flush_tlb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\treturn 1;\n\t} else {\n\t\tif (is_pae(vcpu)) {\n\t\t\tif (cr3 & CR3_PAE_RESERVED_BITS)\n\t\t\t\treturn 1;\n\t\t\tif (is_paging(vcpu) &&\n\t\t\t    !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\t\t\treturn 1;\n\t\t}\n\t\t/*\n\t\t * We don't check reserved bits in nonpae mode, because\n\t\t * this isn't enforced, and VMware depends on this.\n\t\t */\n\t}\n\n\t/*\n\t * Does the new cr3 value map to physical memory? (Note, we\n\t * catch an invalid cr3 even in real-mode, because it would\n\t * cause trouble later on when we turn on paging anyway.)\n\t *\n\t * A real CPU would silently accept an invalid cr3 and would\n\t * attempt to use it - with largely undefined (and often hard\n\t * to debug) behavior on the guest side.\n\t */\n\tif (unlikely(!gfn_to_memslot(vcpu->kvm, cr3 >> PAGE_SHIFT)))\n\t\treturn 1;\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tvcpu->arch.mmu.new_cr3(vcpu);\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 484,
        "func": "static enum hrtimer_restart perf_cpu_hrtimer_handler(struct hrtimer *hr)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\tint rotations = 0;\n\n\tWARN_ON(!irqs_disabled());\n\n\tcpuctx = container_of(hr, struct perf_cpu_context, hrtimer);\n\n\trotations = perf_rotate_context(cpuctx);\n\n\t/*\n\t * arm timer if needed\n\t */\n\tif (rotations) {\n\t\thrtimer_forward_now(hr, cpuctx->hrtimer_interval);\n\t\tret = HRTIMER_RESTART;\n\t}\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 485,
        "func": "void NavigationController::RemoveEntryAtIndex(int index,\n                                              const GURL& default_url) {\n  bool is_current = index == last_committed_entry_index_;\n   RemoveEntryAtIndexInternal(index);\n  if (is_current) {\n    if (last_committed_entry_index_ != -1) {\n      pending_entry_index_ = last_committed_entry_index_;\n      NavigateToPendingEntry(NO_RELOAD);\n    } else {\n      LoadURL(default_url.is_empty() ? GURL(\"about:blank\") : default_url,\n              content::Referrer(), content::PAGE_TRANSITION_START_PAGE,\n              std::string());\n    }\n  }\n }\n",
        "target": 1
    },
    {
        "id": 486,
        "func": "int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit, r = 1;\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}",
        "target": 0
    },
    {
        "id": 487,
        "func": " bool AXARIAGridCell::isAriaRowHeader() const {\n   const AtomicString& role = getAttribute(HTMLNames::roleAttr);\n  return equalIgnoringCase(role, \"rowheader\");\n }\n",
        "target": 1
    },
    {
        "id": 488,
        "func": "void AddToWidgetInputEventObservers(\n    content::RenderWidgetHost* widget_host,\n    content::RenderWidgetHost::InputEventObserver* observer) {\n  widget_host->RemoveInputEventObserver(observer);\n  widget_host->AddInputEventObserver(observer);\n}\n",
        "target": 0
    },
    {
        "id": 489,
        "func": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n    if (x >= 16 || c >= 256) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n\n    *rval = c & s->cbits;\n\n    return 0;\n}",
        "target": 0
    },
    {
        "id": 490,
        "func": "bool TabsCaptureVisibleTabFunction::RunImpl() {\n  PrefService* service = profile()->GetPrefs();\n  if (service->GetBoolean(prefs::kDisableScreenshots)) {\n    error_ = keys::kScreenshotsDisabled;\n    return false;\n  }\n\n  WebContents* web_contents = NULL;\n  if (!GetTabToCapture(&web_contents))\n    return false;\n\n  image_format_ = FORMAT_JPEG;  // Default format is JPEG.\n  image_quality_ = kDefaultQuality;  // Default quality setting.\n\n  if (HasOptionalArgument(1)) {\n    DictionaryValue* options = NULL;\n    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));\n\n    if (options->HasKey(keys::kFormatKey)) {\n      std::string format;\n      EXTENSION_FUNCTION_VALIDATE(\n          options->GetString(keys::kFormatKey, &format));\n\n      if (format == keys::kFormatValueJpeg) {\n        image_format_ = FORMAT_JPEG;\n      } else if (format == keys::kFormatValuePng) {\n        image_format_ = FORMAT_PNG;\n      } else {\n        EXTENSION_FUNCTION_VALIDATE(0);\n      }\n    }\n\n    if (options->HasKey(keys::kQualityKey)) {\n      EXTENSION_FUNCTION_VALIDATE(\n          options->GetInteger(keys::kQualityKey, &image_quality_));\n     }\n   }\n \n  if (!GetExtension()->CanCaptureVisiblePage(\n        web_contents->GetURL(),\n        SessionID::IdForTab(web_contents),\n        &error_)) {\n     return false;\n   }\n \n  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();\n  content::RenderWidgetHostView* view = render_view_host->GetView();\n  if (!view) {\n    error_ = keys::kInternalVisibleTabCaptureError;\n    return false;\n  }\n  render_view_host->CopyFromBackingStore(\n      gfx::Rect(),\n      view->GetViewBounds().size(),\n      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,\n                 this));\n  return true;\n}\n",
        "target": 1
    },
    {
        "id": 491,
        "func": "void LayoutSVGContainer::layout()\n{\n    ASSERT(needsLayout());\n    LayoutAnalyzer::Scope analyzer(*this);\n\n     calcViewport();\n \n    bool updatedTransform = calculateLocalTransform();\n    m_didScreenScaleFactorChange = updatedTransform || SVGLayoutSupport::screenScaleFactorChanged(parent());\n \n     determineIfLayoutSizeChanged();\n\n    bool layoutSizeChanged = element()->hasRelativeLengths()\n        && SVGLayoutSupport::layoutSizeOfNearestViewportChanged(this);\n\n    SVGLayoutSupport::layoutChildren(firstChild(), false, m_didScreenScaleFactorChange, layoutSizeChanged);\n\n     if (everHadLayout() && needsLayout())\n         SVGResourcesCache::clientLayoutChanged(this);\n \n    if (m_needsBoundariesUpdate || updatedTransform) {\n         updateCachedBoundaries();\n         m_needsBoundariesUpdate = false;\n \n        LayoutSVGModelObject::setNeedsBoundariesUpdate();\n    }\n\n    ASSERT(!m_needsBoundariesUpdate);\n    clearNeedsLayout();\n}\n",
        "target": 1
    },
    {
        "id": 492,
        "func": "static int __init srpt_init_module(void)\n{\n\tint ret;\n\n\tret = -EINVAL;\n\tif (srp_max_req_size < MIN_MAX_REQ_SIZE) {\n\t\tpr_err(\"invalid value %d for kernel module parameter\"\n\t\t       \" srp_max_req_size -- must be at least %d.\\n\",\n\t\t       srp_max_req_size, MIN_MAX_REQ_SIZE);\n\t\tgoto out;\n\t}\n\n\tif (srpt_srq_size < MIN_SRPT_SRQ_SIZE\n\t    || srpt_srq_size > MAX_SRPT_SRQ_SIZE) {\n\t\tpr_err(\"invalid value %d for kernel module parameter\"\n\t\t       \" srpt_srq_size -- must be in the range [%d..%d].\\n\",\n\t\t       srpt_srq_size, MIN_SRPT_SRQ_SIZE, MAX_SRPT_SRQ_SIZE);\n\t\tgoto out;\n\t}\n\n\tret = target_register_template(&srpt_template);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ib_register_client(&srpt_client);\n\tif (ret) {\n\t\tpr_err(\"couldn't register IB client\\n\");\n\t\tgoto out_unregister_target;\n\t}\n\n\treturn 0;\n\nout_unregister_target:\n\ttarget_unregister_template(&srpt_template);\nout:\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 493,
        "func": "int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\txcr0 = xcr;\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0)\n\t\treturn 1;\n\tif (!(xcr0 & XSTATE_FP))\n\t\treturn 1;\n\tif ((xcr0 & XSTATE_YMM) && !(xcr0 & XSTATE_SSE))\n\t\treturn 1;\n\tif (xcr0 & ~host_xcr0)\n\t\treturn 1;\n\tvcpu->arch.xcr0 = xcr0;\n\tvcpu->guest_xcr0_loaded = 0;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 494,
        "func": "void LocalReaderProxy::OnGetContent(scoped_ptr<std::string> data) {\n  NOTREACHED();\n}\n",
        "target": 0
    },
    {
        "id": 495,
        "func": "void RenderView::OnReservePageIDRange(int size_of_range) {\n  next_page_id_ += size_of_range + 1;\n}\n",
        "target": 0
    },
    {
        "id": 496,
        "func": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTga(FILE *fp)\n{\n\tgdImagePtr image;\n\tgdIOCtx* in = gdNewFileCtx(fp);\n\tif (in == NULL) return NULL;\n\timage = gdImageCreateFromTgaCtx(in);\n\tin->gd_free( in );\n\treturn image;\n}",
        "target": 0
    },
    {
        "id": 497,
        "func": "void CmdBufferImageTransportFactory::DestroySharedSurfaceHandle(\n    const gfx::GLSurfaceHandle& handle) {\n  if (!context_->makeContextCurrent()) {\n     NOTREACHED() << \"Failed to make shared graphics context current\";\n     return;\n   }\n  context_->deleteTexture(handle.parent_texture_id[0]);\n  context_->deleteTexture(handle.parent_texture_id[1]);\n  context_->finish();\n }\n",
        "target": 1
    },
    {
        "id": 498,
        "func": "void PrintDialogGtk::OnResponse(GtkWidget* dialog, int response_id) {\n  gtk_widget_hide(dialog_);\n\n  switch (response_id) {\n    case GTK_RESPONSE_OK: {\n      if (gtk_settings_)\n        g_object_unref(gtk_settings_);\n      gtk_settings_ = gtk_print_unix_dialog_get_settings(\n          GTK_PRINT_UNIX_DIALOG(dialog_));\n\n      if (printer_)\n        g_object_unref(printer_);\n      printer_ = gtk_print_unix_dialog_get_selected_printer(\n          GTK_PRINT_UNIX_DIALOG(dialog_));\n      g_object_ref(printer_);\n\n      if (page_setup_)\n        g_object_unref(page_setup_);\n      page_setup_ = gtk_print_unix_dialog_get_page_setup(\n          GTK_PRINT_UNIX_DIALOG(dialog_));\n      g_object_ref(page_setup_);\n\n      PageRanges ranges_vector;\n      gint num_ranges;\n      GtkPageRange* gtk_range =\n          gtk_print_settings_get_page_ranges(gtk_settings_, &num_ranges);\n      if (gtk_range) {\n        for (int i = 0; i < num_ranges; ++i) {\n          printing::PageRange range;\n          range.from = gtk_range[i].start;\n          range.to = gtk_range[i].end;\n          ranges_vector.push_back(range);\n        }\n        g_free(gtk_range);\n      }\n\n      PrintSettings settings;\n      printing::PrintSettingsInitializerGtk::InitPrintSettings(\n          gtk_settings_, page_setup_, ranges_vector, false, &settings);\n      context_->InitWithSettings(settings);\n      callback_->Run(PrintingContextCairo::OK);\n      callback_ = NULL;\n      return;\n    }\n    case GTK_RESPONSE_DELETE_EVENT:  // Fall through.\n    case GTK_RESPONSE_CANCEL: {\n      callback_->Run(PrintingContextCairo::CANCEL);\n      callback_ = NULL;\n      return;\n    }\n    case GTK_RESPONSE_APPLY:\n    default: {\n      NOTREACHED();\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 499,
        "func": "int tg_set_cfs_period(struct task_group *tg, long cfs_period_us)\n{\n\tu64 quota, period;\n\n\tperiod = (u64)cfs_period_us * NSEC_PER_USEC;\n\tquota = tg->cfs_bandwidth.quota;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}",
        "target": 0
    },
    {
        "id": 500,
        "func": "DefragInit(void)\n{\n    intmax_t tracker_pool_size;\n    if (!ConfGetInt(\"defrag.trackers\", &tracker_pool_size)) {\n        tracker_pool_size = DEFAULT_DEFRAG_HASH_SIZE;\n    }\n\n    /* Load the defrag-per-host lookup. */\n    DefragPolicyLoadFromConfig();\n\n    /* Allocate the DefragContext. */\n    defrag_context = DefragContextNew();\n    if (defrag_context == NULL) {\n        SCLogError(SC_ERR_MEM_ALLOC,\n            \"Failed to allocate memory for the Defrag module.\");\n        exit(EXIT_FAILURE);\n    }\n\n    DefragSetDefaultTimeout(defrag_context->timeout);\n    DefragInitConfig(FALSE);\n}",
        "target": 0
    },
    {
        "id": 501,
        "func": "status_t StreamingProcessor::dump(int fd, const Vector<String16>& /*args*/) {\n String8 result;\n\n    result.append(\"  Current requests:\\n\");\n if (mPreviewRequest.entryCount() != 0) {\n        result.append(\"    Preview request:\\n\");\n        write(fd, result.string(), result.size());\n        mPreviewRequest.dump(fd, 2, 6);\n        result.clear();\n } else {\n        result.append(\"    Preview request: undefined\\n\");\n }\n\n if (mRecordingRequest.entryCount() != 0) {\n        result = \"    Recording request:\\n\";\n        write(fd, result.string(), result.size());\n        mRecordingRequest.dump(fd, 2, 6);\n        result.clear();\n } else {\n        result = \"    Recording request: undefined\\n\";\n }\n\n const char* streamTypeString[] = {\n \"none\", \"preview\", \"record\"\n };\n    result.append(String8::format(\"   Active request: %s (paused: %s)\\n\",\n                                  streamTypeString[mActiveRequest],\n                                  mPaused ? \"yes\" : \"no\"));\n\n    write(fd, result.string(), result.size());\n\n return OK;\n}\n",
        "target": 0
    },
    {
        "id": 502,
        "func": "int kvm_arm_sys_reg_set_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\tconst struct sys_reg_desc *r;\n\tvoid __user *uaddr = (void __user *)(unsigned long)reg->addr;\n\n\tif ((reg->id & KVM_REG_ARM_COPROC_MASK) == KVM_REG_ARM_DEMUX)\n\t\treturn demux_c15_set(reg->id, uaddr);\n\n\tif (KVM_REG_SIZE(reg->id) != sizeof(__u64))\n\t\treturn -ENOENT;\n\n\tr = index_to_sys_reg_desc(vcpu, reg->id);\n\tif (!r)\n\t\treturn set_invariant_sys_reg(reg->id, uaddr);\n\n\tif (r->set_user)\n\t\treturn (r->set_user)(vcpu, r, reg, uaddr);\n\n\treturn reg_from_user(&vcpu_sys_reg(vcpu, r->reg), uaddr, reg->id);\n}",
        "target": 0
    },
    {
        "id": 503,
        "func": "auth_card_ctl(struct sc_card *card, unsigned long cmd, void *ptr)\n{\n\tswitch (cmd) {\n\tcase SC_CARDCTL_GET_DEFAULT_KEY:\n\t\treturn auth_get_default_key(card,\n\t\t\t\t(struct sc_cardctl_default_key *) ptr);\n\tcase SC_CARDCTL_OBERTHUR_GENERATE_KEY:\n\t\treturn auth_generate_key(card, 0,\n\t\t\t\t(struct sc_cardctl_oberthur_genkey_info *) ptr);\n\tcase SC_CARDCTL_OBERTHUR_UPDATE_KEY:\n\t\treturn auth_update_key(card,\n\t\t\t\t(struct sc_cardctl_oberthur_updatekey_info *) ptr);\n\tcase SC_CARDCTL_OBERTHUR_CREATE_PIN:\n\t\treturn auth_create_reference_data(card,\n\t\t\t\t(struct sc_cardctl_oberthur_createpin_info *) ptr);\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\treturn auth_get_serialnr(card, (struct sc_serial_number *)ptr);\n\tcase SC_CARDCTL_LIFECYCLE_GET:\n\tcase SC_CARDCTL_LIFECYCLE_SET:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\tdefault:\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 504,
        "func": "void PaletteTray::SessionStateChanged(\n    SessionStateDelegate::SessionState state) {\n  UpdateIconVisibility();\n}\n",
        "target": 0
    },
    {
        "id": 505,
        "func": "void DataReductionProxyConfig::UpdateConfigForTesting(\n    bool enabled,\n    bool secure_proxies_allowed,\n    bool insecure_proxies_allowed) {\n  enabled_by_user_ = enabled;\n  network_properties_manager_->ResetWarmupURLFetchMetrics();\n  network_properties_manager_->SetIsSecureProxyDisallowedByCarrier(\n      !secure_proxies_allowed);\n  if (!insecure_proxies_allowed !=\n          network_properties_manager_->HasWarmupURLProbeFailed(\n              false /* secure_proxy */, true /* is_core_proxy */)) {\n    network_properties_manager_->SetHasWarmupURLProbeFailed(\n        false /* secure_proxy */, true /* is_core_proxy */,\n        !insecure_proxies_allowed);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 506,
        "func": "int test_mod_exp_mont5(BIO *bp, BN_CTX *ctx)\n{\n    BIGNUM *a, *p, *m, *d, *e;\n    BN_MONT_CTX *mont;\n\n    a = BN_new();\n    p = BN_new();\n    m = BN_new();\n    d = BN_new();\n    e = BN_new();\n    mont = BN_MONT_CTX_new();\n\n    BN_bntest_rand(m, 1024, 0, 1); /* must be odd for montgomery */\n    /* Zero exponent */\n    BN_bntest_rand(a, 1024, 0, 0);\n    BN_zero(p);\n    if (!BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL))\n        return 0;\n    if (!BN_is_one(d)) {\n        fprintf(stderr, \"Modular exponentiation test failed!\\n\");\n        return 0;\n    }\n    /* Zero input */\n    BN_bntest_rand(p, 1024, 0, 0);\n    BN_zero(a);\n    if (!BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL))\n        return 0;\n    if (!BN_is_zero(d)) {\n        fprintf(stderr, \"Modular exponentiation test failed!\\n\");\n        return 0;\n    }\n    /*\n     * Craft an input whose Montgomery representation is 1, i.e., shorter\n     * than the modulus m, in order to test the const time precomputation\n     * scattering/gathering.\n     */\n    BN_one(a);\n    BN_MONT_CTX_set(mont, m, ctx);\n    if (!BN_from_montgomery(e, a, mont, ctx))\n        return 0;\n    if (!BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL))\n        return 0;\n    if (!BN_mod_exp_simple(a, e, p, m, ctx))\n        return 0;\n    if (BN_cmp(a, d) != 0) {\n        fprintf(stderr, \"Modular exponentiation test failed!\\n\");\n        return 0;\n    }\n    /* Finally, some regular test vectors. */\n    BN_bntest_rand(e, 1024, 0, 0);\n    if (!BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL))\n        return 0;\n    if (!BN_mod_exp_simple(a, e, p, m, ctx))\n        return 0;\n    if (BN_cmp(a, d) != 0) {\n        fprintf(stderr, \"Modular exponentiation test failed!\\n\");\n        return 0;\n    }\n    BN_MONT_CTX_free(mont);\n    BN_free(a);\n    BN_free(p);\n    BN_free(m);\n    BN_free(d);\n    BN_free(e);\n    return (1);\n}\n",
        "target": 0
    },
    {
        "id": 507,
        "func": "void HTMLFormControlElement::parseAttribute(const QualifiedName& name, const AtomicString& value)\n{\n    if (name == formAttr) {\n        formAttributeChanged();\n        UseCounter::count(document(), UseCounter::FormAttribute);\n    } else if (name == disabledAttr) {\n        bool oldDisabled = m_disabled;\n        m_disabled = !value.isNull();\n        if (oldDisabled != m_disabled)\n            disabledAttributeChanged();\n    } else if (name == readonlyAttr) {\n        bool wasReadOnly = m_isReadOnly;\n         m_isReadOnly = !value.isNull();\n         if (wasReadOnly != m_isReadOnly) {\n             setNeedsWillValidateCheck();\n            setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::fromAttribute(name));\n             if (layoutObject())\n                 LayoutTheme::theme().controlStateChanged(*layoutObject(), ReadOnlyControlState);\n         }\n    } else if (name == requiredAttr) {\n        bool wasRequired = m_isRequired;\n        m_isRequired = !value.isNull();\n        if (wasRequired != m_isRequired)\n            requiredAttributeChanged();\n        UseCounter::count(document(), UseCounter::RequiredAttribute);\n    } else if (name == autofocusAttr) {\n        HTMLElement::parseAttribute(name, value);\n        UseCounter::count(document(), UseCounter::AutoFocusAttribute);\n    } else {\n        HTMLElement::parseAttribute(name, value);\n    }\n}\n",
        "target": 1
    },
    {
        "id": 508,
        "func": "void ExtensionPrefs::UpdateManifest(const Extension* extension) {\n  if (extension->location() != Extension::LOAD) {\n    const DictionaryValue* extension_dict = GetExtensionPref(extension->id());\n    if (!extension_dict)\n      return;\n    DictionaryValue* old_manifest = NULL;\n    bool update_required =\n        !extension_dict->GetDictionary(kPrefManifest, &old_manifest) ||\n        !extension->manifest_value()->Equals(old_manifest);\n    if (update_required) {\n      UpdateExtensionPref(extension->id(), kPrefManifest,\n                          extension->manifest_value()->DeepCopy());\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 509,
        "func": "static inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}",
        "target": 0
    },
    {
        "id": 510,
        "func": "  Valuebuffer* GetValuebuffer(GLuint client_id) {\n    return valuebuffer_manager()->GetValuebuffer(client_id);\n  }\n",
        "target": 0
    },
    {
        "id": 511,
        "func": "asmlinkage void do_be(struct pt_regs *regs)\n{\n\tconst int field = 2 * sizeof(unsigned long);\n\tconst struct exception_table_entry *fixup = NULL;\n\tint data = regs->cp0_cause & 4;\n\tint action = MIPS_BE_FATAL;\n\n\t/* XXX For now.  Fixme, this searches the wrong table ...  */\n\tif (data && !user_mode(regs))\n\t\tfixup = search_dbe_tables(exception_epc(regs));\n\n\tif (fixup)\n\t\taction = MIPS_BE_FIXUP;\n\n\tif (board_be_handler)\n\t\taction = board_be_handler(regs, fixup != NULL);\n\n\tswitch (action) {\n\tcase MIPS_BE_DISCARD:\n\t\treturn;\n\tcase MIPS_BE_FIXUP:\n\t\tif (fixup) {\n\t\t\tregs->cp0_epc = fixup->nextinsn;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Assume it would be too dangerous to continue ...\n\t */\n\tprintk(KERN_ALERT \"%s bus error, epc == %0*lx, ra == %0*lx\\n\",\n\t       data ? \"Data\" : \"Instruction\",\n\t       field, regs->cp0_epc, field, regs->regs[31]);\n\tif (notify_die(DIE_OOPS, \"bus error\", regs, 0, regs_to_trapnr(regs), SIGBUS)\n\t    == NOTIFY_STOP)\n\t\treturn;\n\n\tdie_if_kernel(\"Oops\", regs);\n\tforce_sig(SIGBUS, current);\n}",
        "target": 0
    },
    {
        "id": 512,
        "func": "static void sctp_cmd_adaptation_ind(sctp_cmd_seq_t *commands,\n\t\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sctp_ulpevent *ev;\n\n\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\n\tif (ev)\n\t\tsctp_ulpq_tail_event(&asoc->ulpq, ev);\n}",
        "target": 0
    },
    {
        "id": 513,
        "func": "static ssize_t regulator_print_opmode(char *buf, int mode)\n{\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\treturn sprintf(buf, \"fast\\n\");\n\tcase REGULATOR_MODE_NORMAL:\n\t\treturn sprintf(buf, \"normal\\n\");\n\tcase REGULATOR_MODE_IDLE:\n\t\treturn sprintf(buf, \"idle\\n\");\n\tcase REGULATOR_MODE_STANDBY:\n\t\treturn sprintf(buf, \"standby\\n\");\n\t}\n\treturn sprintf(buf, \"unknown\\n\");\n}",
        "target": 0
    },
    {
        "id": 514,
        "func": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n     double rounded;\n \n     if (code == gs_error_undefinedresult) {\n         /* The CTM is degenerate.\n            Can't know the distance in user space.\n    } else if (code < 0)\n        return code;\n    /* If the distance is very close to integers, round it. */\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}\n",
        "target": 1
    },
    {
        "id": 515,
        "func": "  void MaybeRestoreConnections() {\n    if (IBusConnectionsAreAlive()) {\n      return;\n    }\n    MaybeCreateIBus();\n     MaybeRestoreIBusConfig();\n     if (IBusConnectionsAreAlive()) {\n       ConnectPanelServiceSignals();\n      if (connection_change_handler_) {\n        LOG(INFO) << \"Notifying Chrome that IBus is ready.\";\n        connection_change_handler_(language_library_, true);\n      }\n     }\n   }\n",
        "target": 1
    },
    {
        "id": 516,
        "func": "exp_build_str(const struct nf_expect *exp, int a, struct nethdr *n, int b)\n{\n\tconst char *data = nfexp_get_attr(exp, a);\n\taddattr(n, b, data, strlen(data)+1);\n}\n",
        "target": 0
    },
    {
        "id": 517,
        "func": "get_imm64 (u64 insn_addr)\n{\n\tu64 *p = (u64 *) (insn_addr & -16);\t/* mask out slot number */\n\n\treturn ( (p[1] & 0x0800000000000000UL) << 4)  | /*A*/\n\t\t((p[1] & 0x00000000007fffffUL) << 40) | /*B*/\n\t\t((p[0] & 0xffffc00000000000UL) >> 24) | /*C*/\n\t\t((p[1] & 0x0000100000000000UL) >> 23) | /*D*/\n\t\t((p[1] & 0x0003e00000000000UL) >> 29) | /*E*/\n\t\t((p[1] & 0x07fc000000000000UL) >> 43) | /*F*/\n\t\t((p[1] & 0x000007f000000000UL) >> 36);  /*G*/\n}",
        "target": 0
    },
    {
        "id": 518,
        "func": "static u32 cxusb_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}",
        "target": 0
    },
    {
        "id": 519,
        "func": "EXPORTED int mboxlist_deleteremote(const char *name, struct txn **in_tid)\n{\n    int r;\n    struct txn **tid;\n    struct txn *lcl_tid = NULL;\n    mbentry_t *mbentry = NULL;\n\n    if(in_tid) {\n        tid = in_tid;\n    } else {\n        tid = &lcl_tid;\n    }\n\n retry:\n    r = mboxlist_mylookup(name, &mbentry, tid, 1);\n    switch (r) {\n    case 0:\n        break;\n\n    case IMAP_MAILBOX_NONEXISTENT:\n        r = 0;\n        break;\n\n    case IMAP_AGAIN:\n        goto retry;\n        break;\n\n    default:\n        goto done;\n    }\n\n    if (mbentry && (mbentry->mbtype & MBTYPE_REMOTE) && !mbentry->server) {\n        syslog(LOG_ERR,\n               \"mboxlist_deleteremote called on non-remote mailbox: %s\",\n               name);\n        goto done;\n    }\n\n    r = mboxlist_update_entry(name, NULL, tid);\n    if (r) {\n        syslog(LOG_ERR, \"DBERROR: error deleting %s: %s\",\n               name, cyrusdb_strerror(r));\n        r = IMAP_IOERROR;\n    }\n\n    /* commit db operations, but only if we weren't passed a transaction */\n    if (!in_tid) {\n        r = cyrusdb_commit(mbdb, *tid);\n        if (r) {\n            syslog(LOG_ERR, \"DBERROR: failed on commit: %s\",\n                   cyrusdb_strerror(r));\n            r = IMAP_IOERROR;\n        }\n        tid = NULL;\n    }\n\n done:\n    if (r && !in_tid && tid) {\n        /* Abort the transaction if it is still in progress */\n        cyrusdb_abort(mbdb, *tid);\n    }\n\n    return r;\n}\n",
        "target": 0
    },
    {
        "id": 520,
        "func": "CronTab::CronTab( ClassAd *ad )\n{\n\tfor ( int ctr = 0; ctr < CRONTAB_FIELDS; ctr++ ) {\n\t\tMyString buffer;\n\t\tif ( ad->LookupString( this->attributes[ctr], buffer ) ) {\n\t\t\tdprintf( D_FULLDEBUG, \"CronTab: Pulled out '%s' for %s\\n\",\n\t\t\t\t\t\tbuffer.Value(), this->attributes[ctr] );\n\t\t\tthis->parameters[ctr] = new MyString( buffer.Value() );\n\t\t} else {\n\t\t\tdprintf( D_FULLDEBUG, \"CronTab: No attribute for %s, using wildcard\\n\",\n\t\t\t\t\t\t\tthis->attributes[ctr] );\n\t\t\tthis->parameters[ctr] = new MyString( CRONTAB_WILDCARD );\n\t\t}\n\t} // FOR\n\tthis->init();\n}\n",
        "target": 0
    },
    {
        "id": 521,
        "func": "static inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}\n",
        "target": 0
    },
    {
        "id": 522,
        "func": "set_SUSP_CE(unsigned char *p, int location, int offset, int size)\n{\n\tunsigned char *bp = p -1;\n\t/*  Extend the System Use Area\n\t *   \"CE\" Format:\n\t *               len  ver\n\t *    +----+----+----+----+-----------+-----------+\n\t *    | 'C'| 'E'| 1C | 01 | LOCATION1 | LOCATION2 |\n\t *    +----+----+----+----+-----------+-----------+\n\t *    0    1    2    3    4          12          20\n\t *    +-----------+\n\t *    | LOCATION3 |\n\t *    +-----------+\n\t *   20          28\n\t *   LOCATION1 : Location of Continuation of System Use Area.\n\t *   LOCATION2 : Offset to Start of Continuation.\n\t *   LOCATION3 : Length of the Continuation.\n\t */\n\n\tbp[1] = 'C';\n\tbp[2] = 'E';\n\tbp[3] = RR_CE_SIZE;\t/* length\t*/\n\tbp[4] = 1;\t\t/* version\t*/\n\tset_num_733(bp+5, location);\n\tset_num_733(bp+13, offset);\n\tset_num_733(bp+21, size);\n\treturn (RR_CE_SIZE);\n}\n",
        "target": 0
    },
    {
        "id": 523,
        "func": "void BrowserView::DestroyAnyExclusiveAccessBubble() {\n  exclusive_access_bubble_.reset();\n}\n",
        "target": 0
    },
    {
        "id": 524,
        "func": "void FrameView::prepareForDetach()\n{\n    RELEASE_ASSERT(!isInPerformLayout());\n\n    if (ScrollAnimator* scrollAnimator = existingScrollAnimator())\n        scrollAnimator->cancelAnimations();\n    cancelProgrammaticScrollAnimation();\n\n    detachCustomScrollbars();\n    removeFromAXObjectCache();\n\n    if (m_frame->page()) {\n        if (ScrollingCoordinator* scrollingCoordinator = m_frame->page()->scrollingCoordinator())\n            scrollingCoordinator->willDestroyScrollableArea(this);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 525,
        "func": "void OnDialogResponse(GtkDialog* dialog, gint response_id,\n                      PageInfoWindowGtk* page_info) {\n  if (response_id == RESPONSE_SHOW_CERT_INFO) {\n    page_info->ShowCertDialog();\n  } else {\n    gtk_widget_destroy(GTK_WIDGET(dialog));\n  }\n}\n",
        "target": 0
    },
    {
        "id": 526,
        "func": "void Browser::RenderWidgetShowing() {\n  window_->DisableInactiveFrame();\n}\n",
        "target": 0
    },
    {
        "id": 527,
        "func": "bool RenderProcessHostImpl::Send(IPC::Message* msg) {\n  if (!channel_.get()) {\n    if (!is_initialized_) {\n      queued_messages_.push(msg);\n      return true;\n    } else {\n      delete msg;\n      return false;\n    }\n  }\n\n  if (child_process_launcher_.get() && child_process_launcher_->IsStarting()) {\n    queued_messages_.push(msg);\n    return true;\n  }\n\n  return channel_->Send(msg);\n}\n",
        "target": 0
    },
    {
        "id": 528,
        "func": "static int first_nibble_is_8(RAnal* anal, RAnalOp* op, ut16 code){\n\tif (IS_BT_OR_BF(code)) {\n\t\top->type = R_ANAL_OP_TYPE_CJMP; //Jump if true or jump if false insns\n\t\top->jump = disarm_8bit_offset (op->addr, GET_BTF_OFFSET(code));\n\t\top->fail = op->addr + 2 ;\n\t\top->eob  = true;\n\t\tif (IS_BTS(code) || IS_BFS(code))\n\t\t\top->delay = 1; //Only /S versions have a delay slot\n\t} else if (IS_MOVB_REGDISP_R0(code)) {\n\t\t// 10000100mmmmi4*1 mov.b @(<disp>,<REG_M>),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\top->src[0] = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, BYTE_SIZE);\n\t} else if (IS_MOVW_REGDISP_R0(code)) {\n\t\t// 10000101mmmmi4*2 mov.w @(<disp>,<REG_M>),R0\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\top->dst = anal_fill_ai_rg (anal, 0);\n\t\top->src[0] = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, WORD_SIZE);\n\t} else if (IS_CMPIMM(code)) {\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t//todo : finish implementing\n\t} else if (IS_MOVB_R0_REGDISP(code)) {\n\t\t/* 10000000mmmmi4*1 mov.b R0,@(<disp>,<REG_M>)*/\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\top->dst = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, BYTE_SIZE);\n\t} else if (IS_MOVW_R0_REGDISP(code)) {\n\t\t// 10000001mmmmi4*2 mov.w R0,@(<disp>,<REG_M>))\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\top->src[0] = anal_fill_ai_rg (anal, 0);\n\t\top->dst = anal_fill_reg_disp_mem (anal, GET_SOURCE_REG(code), code&0x0F, WORD_SIZE);\n\t}\n\treturn op->size;\n}",
        "target": 0
    },
    {
        "id": 529,
        "func": "void RendererSchedulerImpl::PauseRendererImpl() {\n  helper_.CheckOnValidThread();\n  if (helper_.IsShutdown())\n    return;\n\n  ++main_thread_only().renderer_pause_count;\n  UpdatePolicy();\n}\n",
        "target": 0
    },
    {
        "id": 530,
        "func": "void AutoFillMetrics::Log(ServerQueryMetric metric) const {\n  DCHECK(metric < NUM_SERVER_QUERY_METRICS);\n\n  UMA_HISTOGRAM_ENUMERATION(\"AutoFill.ServerQueryResponse\", metric,\n                             NUM_SERVER_QUERY_METRICS);\n }\n",
        "target": 0
    },
    {
        "id": 531,
        "func": "static inline bool ipv6_addr_any(const struct in6_addr *a)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul = (const unsigned long *)a;\n\n\treturn (ul[0] | ul[1]) == 0UL;\n#else\n\treturn (a->s6_addr32[0] | a->s6_addr32[1] |\n\t\ta->s6_addr32[2] | a->s6_addr32[3]) == 0;\n#endif\n}",
        "target": 0
    },
    {
        "id": 532,
        "func": "static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\tstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = *data++;\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = *data++;\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\n\treturn NCI_STATUS_OK;\n}",
        "target": 1
    },
    {
        "id": 533,
        "func": "std::unique_ptr<Vector<CSPHeaderAndType>> ContentSecurityPolicy::headers()\n    const {\n  std::unique_ptr<Vector<CSPHeaderAndType>> headers =\n      WTF::wrapUnique(new Vector<CSPHeaderAndType>);\n  for (const auto& policy : m_policies) {\n    CSPHeaderAndType headerAndType(policy->header(), policy->headerType());\n    headers->push_back(headerAndType);\n  }\n  return headers;\n}\n",
        "target": 0
    },
    {
        "id": 534,
        "func": "error::Error GLES2DecoderImpl::HandleSetDisjointValueSyncCHROMIUM(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  const volatile gles2::cmds::SetDisjointValueSyncCHROMIUM& c =\n      *static_cast<const volatile gles2::cmds::SetDisjointValueSyncCHROMIUM*>(\n          cmd_data);\n  int32_t sync_shm_id = static_cast<int32_t>(c.sync_data_shm_id);\n  uint32_t sync_shm_offset = static_cast<uint32_t>(c.sync_data_shm_offset);\n\n  return query_manager_->SetDisjointSync(sync_shm_id, sync_shm_offset);\n}\n",
        "target": 0
    },
    {
        "id": 535,
        "func": "static int channel_is_secondary(RedChannel *channel)\n{\n    int i;\n    for (i = 0 ; i < sizeof(secondary_channels)/sizeof(secondary_channels[0]); ++i) {\n        if (channel->type == secondary_channels[i]) {\n            return TRUE;\n        }\n    }\n    return FALSE;\n}\n",
        "target": 0
    },
    {
        "id": 536,
        "func": " void MockRenderThread::RemoveRoute(int32 routing_id) {\n  EXPECT_EQ(routing_id_, routing_id);\n  widget_ = NULL;\n }\n",
        "target": 1
    },
    {
        "id": 537,
        "func": "static void compute_samples(int mask, short *output, int num_c, float **data, int d_offset, int len)\n{\n   #define BUFFER_SIZE  32\n   float buffer[BUFFER_SIZE];\n   int i,j,o,n = BUFFER_SIZE;\n   check_endianness();\n   for (o = 0; o < len; o += BUFFER_SIZE) {\n      memset(buffer, 0, sizeof(buffer));\n      if (o + n > len) n = len - o;\n      for (j=0; j < num_c; ++j) {\n         if (channel_position[num_c][j] & mask) {\n            for (i=0; i < n; ++i)\n               buffer[i] += data[j][d_offset+o+i];\n         }\n      }\n      for (i=0; i < n; ++i) {\n         FASTDEF(temp);\n         int v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);\n         if ((unsigned int) (v + 32768) > 65535)\n            v = v < 0 ? -32768 : 32767;\n         output[o+i] = v;\n      }\n   }\n}",
        "target": 0
    },
    {
        "id": 538,
        "func": "void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint hstartcol;\n\n\t/* Allocate memory for the join buffer from the heap. */\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE,\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\thstartcol = (numrows + 1 - parity) >> 1;\n\n\t/* Save the samples from the lowpass channel. */\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tsrcptr += stride;\n\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\t/* Copy the samples from the highpass channel into place. */\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\t/* Copy the samples from the lowpass channel into place. */\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\n\t/* If the join buffer was allocated on the heap, free this memory. */\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
        "target": 0
    },
    {
        "id": 539,
        "func": "spnego_gss_acquire_cred_from(OM_uint32 *minor_status,\n\t\t\t     const gss_name_t desired_name,\n\t\t\t     OM_uint32 time_req,\n\t\t\t     const gss_OID_set desired_mechs,\n\t\t\t     gss_cred_usage_t cred_usage,\n\t\t\t     gss_const_key_value_set_t cred_store,\n\t\t\t     gss_cred_id_t *output_cred_handle,\n\t\t\t     gss_OID_set *actual_mechs,\n\t\t\t     OM_uint32 *time_rec)\n{\n\tOM_uint32 status, tmpmin;\n\tgss_OID_set amechs;\n\tgss_cred_id_t mcred = NULL;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tdsyslog(\"Entering spnego_gss_acquire_cred\\n\");\n\n\tif (actual_mechs)\n\t\t*actual_mechs = NULL;\n\n\tif (time_rec)\n\t\t*time_rec = 0;\n\n\t/* We will obtain a mechglue credential and wrap it in a\n\t * spnego_gss_cred_id_rec structure.  Allocate the wrapper. */\n\tstatus = create_spnego_cred(minor_status, mcred, &spcred);\n\tif (status != GSS_S_COMPLETE)\n\t\treturn (status);\n\n\t/*\n\t * Always use get_available_mechs to collect a list of\n\t * mechs for which creds are available.\n\t */\n\tstatus = get_available_mechs(minor_status, desired_name,\n\t\t\t\t     cred_usage, cred_store, &mcred,\n\t\t\t\t     &amechs, time_rec);\n\n\tif (actual_mechs && amechs != GSS_C_NULL_OID_SET) {\n\t\t(void) gssint_copy_oid_set(&tmpmin, amechs, actual_mechs);\n\t}\n\t(void) gss_release_oid_set(&tmpmin, &amechs);\n\n\tif (status == GSS_S_COMPLETE) {\n\t\tspcred->mcred = mcred;\n\t\t*output_cred_handle = (gss_cred_id_t)spcred;\n\t} else {\n\t\tfree(spcred);\n\t\t*output_cred_handle = GSS_C_NO_CREDENTIAL;\n\t}\n\n\tdsyslog(\"Leaving spnego_gss_acquire_cred\\n\");\n\treturn (status);\n}",
        "target": 0
    },
    {
        "id": 540,
        "func": "static int serial_link_irq_chain(struct mp_port *mtpt)\n{\n\tstruct irq_info *i = irq_lists + mtpt->port.irq;\n\tint ret, irq_flags = mtpt->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;\n\tspin_lock_irq(&i->lock);\n\n\tif (i->head) {\n\t\tlist_add(&mtpt->list, i->head);\n\t\tspin_unlock_irq(&i->lock);\n\n\t\tret = 0;\n\t} else {\n\t\tINIT_LIST_HEAD(&mtpt->list);\n\t\ti->head = &mtpt->list;\n\t\tspin_unlock_irq(&i->lock);\n\n\t\tret = request_irq(mtpt->port.irq, multi_interrupt,\n\t\t\t\tirq_flags, \"serial\", i);\n\t\tif (ret < 0)\n\t\t\tserial_do_unlink(i, mtpt);\n\t}\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 541,
        "func": "  void Init(PrintJobWorkerOwner* print_job,\n            JobEventDetails::Type detail_type,\n            PrintedDocument* document,\n            PrintedPage* page) {\n    DCHECK(!print_job_);\n    DCHECK(!details_);\n    print_job_ = print_job;\n    details_ = new JobEventDetails(detail_type, document, page);\n  }\n",
        "target": 0
    },
    {
        "id": 542,
        "func": "static int max_required_rx_slots(struct xenvif *vif)\n{\n\tint max = DIV_ROUND_UP(vif->dev->mtu, PAGE_SIZE);\n\n\tif (vif->can_sg || vif->gso || vif->gso_prefix)\n\t\tmax += MAX_SKB_FRAGS + 1; /* extra_info + frags */\n\n\treturn max;\n}",
        "target": 0
    },
    {
        "id": 543,
        "func": "void *__crypto_dequeue_request(struct crypto_queue *queue, unsigned int offset)\n{\n\tstruct list_head *request;\n\n\tif (unlikely(!queue->qlen))\n\t\treturn NULL;\n\n\tqueue->qlen--;\n\n\tif (queue->backlog != &queue->list)\n\t\tqueue->backlog = queue->backlog->next;\n\n\trequest = queue->list.next;\n\tlist_del(request);\n\n\treturn (char *)list_entry(request, struct crypto_async_request, list) -\n\t       offset;\n}",
        "target": 0
    },
    {
        "id": 544,
        "func": "static ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags)\n{\n\tstruct socket *sock = file->private_data;\n\n\tif (unlikely(!sock->ops->splice_read))\n\t\treturn -EINVAL;\n\n\treturn sock->ops->splice_read(sock, ppos, pipe, len, flags);\n}",
        "target": 0
    },
    {
        "id": 545,
        "func": "void FrameSelection::DidSetSelectionDeprecated(\n    const SetSelectionOptions& options) {\n  const Document& current_document = GetDocument();\n  if (!GetSelectionInDOMTree().IsNone() && !options.DoNotSetFocus()) {\n    SetFocusedNodeIfNeeded();\n    if (!IsAvailable() || GetDocument() != current_document) {\n      NOTREACHED();\n      return;\n    }\n  }\n\n  frame_caret_->StopCaretBlinkTimer();\n  UpdateAppearance();\n\n  x_pos_for_vertical_arrow_navigation_ = NoXPosForVerticalArrowNavigation();\n\n  if (!options.DoNotSetFocus()) {\n    SelectFrameElementInParentIfFullySelected();\n    if (!IsAvailable() || GetDocument() != current_document) {\n      return;\n    }\n  }\n  const SetSelectionBy set_selection_by = options.GetSetSelectionBy();\n  NotifyTextControlOfSelectionChange(set_selection_by);\n  if (set_selection_by == SetSelectionBy::kUser) {\n    const CursorAlignOnScroll align = options.GetCursorAlignOnScroll();\n    ScrollAlignment alignment;\n\n    if (frame_->GetEditor()\n            .Behavior()\n            .ShouldCenterAlignWhenSelectionIsRevealed())\n      alignment = (align == CursorAlignOnScroll::kAlways)\n                      ? ScrollAlignment::kAlignCenterAlways\n                      : ScrollAlignment::kAlignCenterIfNeeded;\n    else\n      alignment = (align == CursorAlignOnScroll::kAlways)\n                      ? ScrollAlignment::kAlignTopAlways\n                      : ScrollAlignment::kAlignToEdgeIfNeeded;\n\n    RevealSelection(alignment, kRevealExtent);\n  }\n\n  NotifyAccessibilityForSelectionChange();\n  NotifyCompositorForSelectionChange();\n  NotifyEventHandlerForSelectionChange();\n  frame_->DomWindow()->EnqueueDocumentEvent(\n      Event::Create(EventTypeNames::selectionchange));\n}\n",
        "target": 0
    },
    {
        "id": 546,
        "func": "int dtls1_listen(SSL *s, struct sockaddr *client)\n {\n     int ret;\n \n     SSL_set_options(s, SSL_OP_COOKIE_EXCHANGE);\n     s->d1->listen = 1;\n\n    (void)BIO_dgram_get_peer(SSL_get_rbio(s), client);\n    return 1;\n}\n",
        "target": 1
    },
    {
        "id": 547,
        "func": "SProcScreenSaverSuspend(ClientPtr client)\n{\n    REQUEST(xScreenSaverSuspendReq);\n\n    swaps(&stuff->length);\n    REQUEST_SIZE_MATCH(xScreenSaverSuspendReq);\n    return ProcScreenSaverSuspend(client);\n}\n",
        "target": 0
    },
    {
        "id": 548,
        "func": "inline static void gdImageSetAAPixelColor(gdImagePtr im, int x, int y, int color, int t)\n{\n\tint dr,dg,db,p,r,g,b;\n\tdr = gdTrueColorGetRed(color);\n\tdg = gdTrueColorGetGreen(color);\n\tdb = gdTrueColorGetBlue(color);\n\n\tp = gdImageGetPixel(im,x,y);\n\tr = gdTrueColorGetRed(p);\n\tg = gdTrueColorGetGreen(p);\n\tb = gdTrueColorGetBlue(p);\n\n\tBLEND_COLOR(t, dr, r, dr);\n\tBLEND_COLOR(t, dg, g, dg);\n\tBLEND_COLOR(t, db, b, db);\n\tim->tpixels[y][x]=gdTrueColorAlpha(dr, dg, db,  gdAlphaOpaque);\n}\n",
        "target": 0
    },
    {
        "id": 549,
        "func": "  DataReductionProxyInterceptorTest()\n      : scoped_task_environment_(\n            base::test::ScopedTaskEnvironment::MainThreadType::IO) {\n    test_context_ =\n        DataReductionProxyTestContext::Builder()\n            .Build();\n    default_context_.reset(new TestURLRequestContextWithDataReductionProxy(\n        test_context_->config()\n            ->test_params()\n            ->proxies_for_http()\n            .front()\n            .proxy_server(),\n        &default_network_delegate_));\n    default_context_->set_network_delegate(&default_network_delegate_);\n    test_context_->config()->test_params()->UseNonSecureProxiesForHttp();\n  }\n",
        "target": 0
    },
    {
        "id": 550,
        "func": "static void conditionalOrLongAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::conditionalOrLongAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 551,
        "func": "FLAC__StreamDecoderWriteStatus FLACParser::write_callback(\n const FLAC__StreamDecoder * /* decoder */, const FLAC__Frame *frame,\n const FLAC__int32 * const buffer[], void *client_data)\n{\n return ((FLACParser *) client_data)->writeCallback(frame, buffer);\n}\n",
        "target": 0
    },
    {
        "id": 552,
        "func": " allocate(struct file *file, int allocate_idat)\n {\n   struct control *control = png_voidcast(struct control*, file->alloc_ptr);\n \n    if (allocate_idat)\n    {\n      assert(file->idat == NULL);\n      IDAT_init(&control->idat, file);\n }\n\n else /* chunk */\n {\n      assert(file->chunk == NULL);\n      chunk_init(&control->chunk, file);\n }\n}\n",
        "target": 1
    },
    {
        "id": 553,
        "func": "poppler_page_get_link_mapping (PopplerPage *page)\n{\n  GList *map_list = NULL;\n  gint i;\n  Links *links;\n  Object obj;\n  double width, height;\n  \n  g_return_val_if_fail (POPPLER_IS_PAGE (page), NULL);\n  \n  links = new Links (page->page->getAnnots (&obj),\n\t\t     page->document->doc->getCatalog ()->getBaseURI ());\n  obj.free ();\n  \n  if (links == NULL)\n    return NULL;\n  \n  poppler_page_get_size (page, &width, &height);\n  \n  for (i = 0; i < links->getNumLinks (); i++)\n    {\n      PopplerLinkMapping *mapping;\n      PopplerRectangle rect;\n      LinkAction *link_action;\n      Link *link;\n      \n      link = links->getLink (i);\n      link_action = link->getAction ();\n      \n      /* Create the mapping */\n      mapping = g_new (PopplerLinkMapping, 1);\n      mapping->action = _poppler_action_new (page->document, link_action, NULL);\n      \n      link->getRect (&rect.x1, &rect.y1, &rect.x2, &rect.y2);\n      \n      switch (page->page->getRotate ())\n        {\n        case 90:\n\t  mapping->area.x1 = rect.y1;\n\t  mapping->area.y1 = height - rect.x2;\n\t  mapping->area.x2 = mapping->area.x1 + (rect.y2 - rect.y1);\n\t  mapping->area.y2 = mapping->area.y1 + (rect.x2 - rect.x1);\n\t  \n\t  break;\n\tcase 180:\n\t  mapping->area.x1 = width - rect.x2;\n\t  mapping->area.y1 = height - rect.y2;\n\t  mapping->area.x2 = mapping->area.x1 + (rect.x2 - rect.x1);\n\t  mapping->area.y2 = mapping->area.y1 + (rect.y2 - rect.y1);\n\t  \n\t  break;\n\tcase 270:\n\t  mapping->area.x1 = width - rect.y2;\n\t  mapping->area.y1 = rect.x1;\n\t  mapping->area.x2 = mapping->area.x1 + (rect.y2 - rect.y1);\n\t  mapping->area.y2 = mapping->area.y1 + (rect.x2 - rect.x1);\n\t  \n\t  break;\n\tdefault:\n\t  mapping->area.x1 = rect.x1;\n\t  mapping->area.y1 = rect.y1;\n\t  mapping->area.x2 = rect.x2;\n\t  mapping->area.y2 = rect.y2;\n\t}\n\t\t\t\n      mapping->area.x1 -= page->page->getCropBox()->x1;\n      mapping->area.x2 -= page->page->getCropBox()->x1;\n      mapping->area.y1 -= page->page->getCropBox()->y1;\n      mapping->area.y2 -= page->page->getCropBox()->y1;\n      \n      map_list = g_list_prepend (map_list, mapping);\n    }\n  \n  delete links;\n  \n  return map_list;\n}\n",
        "target": 0
    },
    {
        "id": 554,
        "func": "bool ContainerNode::appendChild(PassRefPtr<Node> newChild, ExceptionCode& ec, bool shouldLazyAttach)\n{\n    RefPtr<ContainerNode> protect(this);\n\n    ASSERT(refCount() || parentOrHostNode());\n\n    ec = 0;\n\n    checkAddChild(newChild.get(), ec);\n    if (ec)\n        return false;\n\n    if (newChild == m_lastChild) // nothing to do\n        return newChild;\n\n    NodeVector targets;\n    collectChildrenAndRemoveFromOldParent(newChild.get(), targets, ec);\n    if (ec)\n        return false;\n\n    if (targets.isEmpty())\n        return true;\n\n    InspectorInstrumentation::willInsertDOMNode(document(), this);\n\n#if ENABLE(MUTATION_OBSERVERS)\n    ChildListMutationScope mutation(this);\n#endif\n\n    for (NodeVector::const_iterator it = targets.begin(); it != targets.end(); ++it) {\n        Node* child = it->get();\n\n        if (child->parentNode())\n            break;\n\n        treeScope()->adoptIfNeeded(child);\n\n        forbidEventDispatch();\n        appendChildToContainer(child, this);\n        allowEventDispatch();\n\n        updateTreeAfterInsertion(this, child, shouldLazyAttach);\n    }\n\n    dispatchSubtreeModifiedEvent();\n    return true;\n}\n",
        "target": 0
    },
    {
        "id": 555,
        "func": "ZSTD_compress_insertDictionary(ZSTD_compressedBlockState_t* bs,\n                               ZSTD_matchState_t* ms,\n                         const ZSTD_CCtx_params* params,\n                         const void* dict, size_t dictSize,\n                               ZSTD_dictContentType_e dictContentType,\n                               ZSTD_dictTableLoadMethod_e dtlm,\n                               void* workspace)\n{\n    DEBUGLOG(4, \"ZSTD_compress_insertDictionary (dictSize=%u)\", (U32)dictSize);\n    if ((dict==NULL) || (dictSize<=8)) return 0;\n\n    ZSTD_reset_compressedBlockState(bs);\n\n    /* dict restricted modes */\n    if (dictContentType == ZSTD_dct_rawContent)\n        return ZSTD_loadDictionaryContent(ms, params, dict, dictSize, dtlm);\n\n    if (MEM_readLE32(dict) != ZSTD_MAGIC_DICTIONARY) {\n        if (dictContentType == ZSTD_dct_auto) {\n            DEBUGLOG(4, \"raw content dictionary detected\");\n            return ZSTD_loadDictionaryContent(ms, params, dict, dictSize, dtlm);\n        }\n        if (dictContentType == ZSTD_dct_fullDict)\n            return ERROR(dictionary_wrong);\n        assert(0);   /* impossible */\n    }\n\n    /* dict as full zstd dictionary */\n    return ZSTD_loadZstdDictionary(bs, ms, params, dict, dictSize, dtlm, workspace);\n}\n",
        "target": 0
    },
    {
        "id": 556,
        "func": "ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(Navigator& navigator, ExceptionState& exceptionState)\n {\n     return NavigatorServiceWorker::from(navigator).serviceWorker(exceptionState);\n }\n",
        "target": 1
    },
    {
        "id": 557,
        "func": "QTNCopy(QTNode *in)\n{\n\tQTNode\t   *out;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tout = (QTNode *) palloc(sizeof(QTNode));\n\n\t*out = *in;\n\tout->valnode = (QueryItem *) palloc(sizeof(QueryItem));\n\t*(out->valnode) = *(in->valnode);\n\tout->flags |= QTN_NEEDFREE;\n\n\tif (in->valnode->type == QI_VAL)\n\t{\n\t\tout->word = palloc(in->valnode->qoperand.length + 1);\n\t\tmemcpy(out->word, in->word, in->valnode->qoperand.length);\n\t\tout->word[in->valnode->qoperand.length] = '\\0';\n\t\tout->flags |= QTN_WORDFREE;\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tout->child = (QTNode **) palloc(sizeof(QTNode *) * in->nchild);\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tout->child[i] = QTNCopy(in->child[i]);\n\t}\n\n\treturn out;\n}",
        "target": 0
    },
    {
        "id": 558,
        "func": "static void spl_object_storage_dtor(zval *element) /* {{{ */\n{\n\tspl_SplObjectStorageElement *el = Z_PTR_P(element);\n\tzval_ptr_dtor(&el->obj);\n\tzval_ptr_dtor(&el->inf);\n\tefree(el);\n} /* }}} */",
        "target": 0
    },
    {
        "id": 559,
        "func": "static void a2dp_open_ctrl_path(struct a2dp_stream_common *common)\n{\n int i;\n\n /* retry logic to catch any timing variations on control channel */\n for (i = 0; i < CTRL_CHAN_RETRY_COUNT; i++)\n {\n /* connect control channel if not already connected */\n if ((common->ctrl_fd = skt_connect(A2DP_CTRL_PATH, common->buffer_sz)) > 0)\n {\n /* success, now check if stack is ready */\n if (check_a2dp_ready(common) == 0)\n\n                 break;\n \n             ERROR(\"error : a2dp not ready, wait 250 ms and retry\");\n            usleep(250000);\n             skt_disconnect(common->ctrl_fd);\n             common->ctrl_fd = AUDIO_SKT_DISCONNECTED;\n         }\n \n         /* ctrl channel not ready, wait a bit */\n        usleep(250000);\n     }\n }\n",
        "target": 1
    },
    {
        "id": 560,
        "func": " bool asn1_write_BOOLEAN_context(struct asn1_data *data, bool v, int context)\n {\n       asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(context));\n       asn1_write_uint8(data, v ? 0xFF : 0);\n       asn1_pop_tag(data);\n       return !data->has_error;\n }\n",
        "target": 1
    },
    {
        "id": 561,
        "func": "mld6_print(netdissect_options *ndo, const u_char *bp)\n{\n\tconst struct mld6_hdr *mp = (const struct mld6_hdr *)bp;\n\tconst u_char *ep;\n\n\t/* 'ep' points to the end of available data. */\n\tep = ndo->ndo_snapend;\n\n\tif ((const u_char *)mp + sizeof(*mp) > ep)\n\t\treturn;\n\n\tND_PRINT((ndo,\"max resp delay: %d \", EXTRACT_16BITS(&mp->mld6_maxdelay)));\n\tND_PRINT((ndo,\"addr: %s\", ip6addr_string(ndo, &mp->mld6_addr)));\n}",
        "target": 0
    },
    {
        "id": 562,
        "func": "bool netlink_capable(const struct sk_buff *skb, int cap)\n{\n\treturn netlink_ns_capable(skb, &init_user_ns, cap);\n}",
        "target": 0
    },
    {
        "id": 563,
        "func": "void __audit_seccomp(unsigned long syscall, long signr, int code)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_SECCOMP);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\",\n\t\t\t signr, syscall_get_arch(), syscall,\n\t\t\t in_compat_syscall(), KSTK_EIP(current), code);\n\taudit_log_end(ab);\n}",
        "target": 0
    },
    {
        "id": 564,
        "func": "establish_signal_handlers (void)\n{\n        struct sigaction exit_action, ign_action;\n\n        /* Set up the structure to specify the exit action. */\n        exit_action.sa_handler = deadly_handler;\n        sigemptyset (&exit_action.sa_mask);\n        exit_action.sa_flags = 0;\n\n        /* Set up the structure to specify the ignore action. */\n        ign_action.sa_handler = SIG_IGN;\n        sigemptyset (&ign_action.sa_mask);\n        ign_action.sa_flags = 0;\n\n        sigaction (SIGTERM, &exit_action, NULL);\n\n        sigaction (SIGINT, &ign_action, NULL); \n        sigaction (SIGHUP, &ign_action, NULL);\n\t\tsigaction (SIGQUIT, &ign_action, NULL);\n        sigaction (SIGALRM, &ign_action, NULL);\n        sigaction (SIGUSR1, &ign_action, NULL);\n        sigaction (SIGUSR2, &ign_action, NULL);\n        sigaction (SIGPIPE, &ign_action, NULL);\n}",
        "target": 0
    },
    {
        "id": 565,
        "func": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}",
        "target": 1
    },
    {
        "id": 566,
        "func": "void CommandBufferProxyImpl::SignalSyncToken(const gpu::SyncToken& sync_token,\n                                             const base::Closure& callback) {\n  CheckLock();\n  base::AutoLock lock(last_state_lock_);\n  if (last_state_.error != gpu::error::kNoError)\n    return;\n\n  uint32_t signal_id = next_signal_id_++;\n  Send(new GpuCommandBufferMsg_SignalSyncToken(route_id_, sync_token,\n                                               signal_id));\n  signal_tasks_.insert(std::make_pair(signal_id, callback));\n}\n",
        "target": 0
    },
    {
        "id": 567,
        "func": "void GLES2Implementation::DrawElementsInstancedANGLE(GLenum mode,\n                                                     GLsizei count,\n                                                     GLenum type,\n                                                     const void* indices,\n                                                     GLsizei primcount) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] glDrawElementsInstancedANGLE(\"\n                     << GLES2Util::GetStringDrawMode(mode) << \", \" << count\n                     << \", \" << GLES2Util::GetStringIndexType(type) << \", \"\n                     << static_cast<const void*>(indices) << \", \" << primcount\n                     << \")\");\n  if (count < 0) {\n    SetGLError(GL_INVALID_VALUE, \"glDrawElementsInstancedANGLE\",\n               \"count less than 0.\");\n    return;\n  }\n  if (primcount < 0) {\n    SetGLError(GL_INVALID_VALUE, \"glDrawElementsInstancedANGLE\",\n               \"primcount < 0\");\n    return;\n  }\n  GLuint offset = 0;\n  bool simulated = false;\n  if (count > 0 && primcount > 0) {\n    if (vertex_array_object_manager_->bound_element_array_buffer() != 0 &&\n        !ValidateOffset(\"glDrawElementsInstancedANGLE\",\n                        reinterpret_cast<GLintptr>(indices))) {\n      return;\n    }\n    if (!vertex_array_object_manager_->SetupSimulatedIndexAndClientSideBuffers(\n            \"glDrawElementsInstancedANGLE\", this, helper_, count, type,\n            primcount, indices, &offset, &simulated)) {\n      return;\n    }\n  }\n  helper_->DrawElementsInstancedANGLE(mode, count, type, offset, primcount);\n  RestoreElementAndArrayBuffers(simulated);\n  CheckGLError();\n}\n",
        "target": 0
    },
    {
        "id": 568,
        "func": "BIGNUM *SRP_Calc_x(BIGNUM *s, const char *user, const char *pass)\n\t{\n\tunsigned char dig[SHA_DIGEST_LENGTH];\n\tEVP_MD_CTX ctxt;\n\tunsigned char *cs;\n\n\tif ((s == NULL) ||\n\t\t(user == NULL) ||\n\t\t(pass == NULL))\n\t\treturn NULL;\n\n\tif ((cs = OPENSSL_malloc(BN_num_bytes(s))) == NULL)\n\t\treturn NULL;\n\n\tEVP_MD_CTX_init(&ctxt);\n\tEVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);\n\tEVP_DigestUpdate(&ctxt, user, strlen(user));\n\tEVP_DigestUpdate(&ctxt, \":\", 1);\n\tEVP_DigestUpdate(&ctxt, pass, strlen(pass));\n\tEVP_DigestFinal_ex(&ctxt, dig, NULL);\n\n\tEVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);\n\tBN_bn2bin(s,cs);\n\tEVP_DigestUpdate(&ctxt, cs, BN_num_bytes(s));\n\tOPENSSL_free(cs);\n\tEVP_DigestUpdate(&ctxt, dig, sizeof(dig));\n\tEVP_DigestFinal_ex(&ctxt, dig, NULL);\n\tEVP_MD_CTX_cleanup(&ctxt);\n\n\treturn BN_bin2bn(dig, sizeof(dig), NULL);\n\t}\n",
        "target": 0
    },
    {
        "id": 569,
        "func": "void WebPage::focusPreviousField()\n{\n    d->m_inputHandler->focusPreviousField();\n}\n",
        "target": 0
    },
    {
        "id": 570,
        "func": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}",
        "target": 1
    },
    {
        "id": 571,
        "func": "void btif_dm_hh_open_failed(bt_bdaddr_t *bdaddr)\n{\n if (pairing_cb.state == BT_BOND_STATE_BONDING &&\n            bdcmp(bdaddr->address, pairing_cb.bd_addr) == 0)\n {\n        bond_state_changed(BT_STATUS_FAIL, bdaddr, BT_BOND_STATE_NONE);\n }\n}\n",
        "target": 0
    },
    {
        "id": 572,
        "func": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!data)\n\t\treturn 1;\n\n\tif (report->id == REPORT_KEY_STATE) {\n\t\tif (data->input_keys)\n\t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\t/*\n\t\t * We let the caller of picolcd_send_and_wait() check if the\n\t\t * report we got is one of the expected ones or not.\n\t\t */\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}",
        "target": 1
    },
    {
        "id": 573,
        "func": " void SendTabToSelfInfoBarDelegate::OpenTab() {\n  NOTIMPLEMENTED();\n }\n",
        "target": 1
    },
    {
        "id": 574,
        "func": "bool Element::hasFlagsSetDuringStylingOfChildren() const\n{\n    if (!hasRareData())\n        return false;\n    return rareDataChildrenAffectedByHover()\n        || rareDataChildrenAffectedByActive()\n        || rareDataChildrenAffectedByDrag()\n        || rareDataChildrenAffectedByFirstChildRules()\n        || rareDataChildrenAffectedByLastChildRules()\n        || rareDataChildrenAffectedByDirectAdjacentRules()\n        || rareDataChildrenAffectedByForwardPositionalRules()\n        || rareDataChildrenAffectedByBackwardPositionalRules();\n}\n",
        "target": 0
    },
    {
        "id": 575,
        "func": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\n  /* the imap struct is already inited in imap_connect() */\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  int len;\n\n  if(!*path)\n    path = \"INBOX\";\n\n  /* url decode the path and use this mailbox */\n  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n  if(!imapc->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}",
        "target": 1
    },
    {
        "id": 576,
        "func": "static int nfs_fattr3_to_stat(uint32_t *p, struct inode *inode)\n{\n\tuint32_t mode;\n\tsize_t i;\n\n\tif (!inode)\n\t\treturn 0;\n\n\t/* offsetof(struct fattr3, type) = 0 */\n\tswitch (ntoh32(net_read_uint32(p + 0))) {\n\tcase NF3REG:\n\t\tinode->i_mode = S_IFREG;\n\t\tbreak;\n\tcase NF3DIR:\n\t\tinode->i_mode = S_IFDIR;\n\t\tbreak;\n\tcase NF3BLK:\n\t\tinode->i_mode = S_IFBLK;\n\t\tbreak;\n\tcase NF3CHR:\n\t\tinode->i_mode = S_IFCHR;\n\t\tbreak;\n\tcase NF3LNK:\n\t\tinode->i_mode = S_IFLNK;\n\t\tbreak;\n\tcase NF3SOCK:\n\t\tinode->i_mode = S_IFSOCK;\n\t\tbreak;\n\tcase NF3FIFO:\n\t\tinode->i_mode = S_IFIFO;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid mode %x\\n\",\n\t\t\t\t__func__, ntoh32(net_read_uint32(p + 0)));\n\t\treturn -EIO;\n\t}\n\n\t/* offsetof(struct fattr3, mode) = 4 */\n\tmode = ntoh32(net_read_uint32(p + 1));\n\tfor (i = 0; i < ARRAY_SIZE(nfs3_mode_bits); ++i) {\n\t\tif (mode & nfs3_mode_bits[i].nfsmode)\n\t\t\tinode->i_mode |= nfs3_mode_bits[i].statmode;\n\t}\n\n\t/* offsetof(struct fattr3, size) = 20 */\n\tinode->i_size = ntoh64(net_read_uint64(p + 5));\n\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 577,
        "func": " void PrintPreviewUI::OnPrintPreviewRequest(int request_id) {\n  g_print_preview_request_id_map.Get().Set(preview_ui_addr_str_, request_id);\n }\n",
        "target": 1
    },
    {
        "id": 578,
        "func": "static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tconst unsigned char *b = buf;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint c;\n\tssize_t retval = 0;\n\n\t/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */\n\tif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\t/* Write out any echoed characters that are still pending */\n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr > 0) {\n\t\t\t\tssize_t num = process_output_block(tty, b, nr);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *b;\n\t\t\t\tif (process_output(c, tty) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n\t\t\tif (tty->ops->flush_chars)\n\t\t\t\ttty->ops->flush_chars(tty);\n\t\t} else {\n\t\t\twhile (nr > 0) {\n\t\t\t\tc = tty->ops->write(tty, b, nr);\n\t\t\t\tif (c < 0) {\n\t\t\t\t\tretval = c;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t\tb += c;\n\t\t\t\tnr -= c;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&tty->termios_rwsem);\n\n\t\tschedule();\n\n\t\tdown_read(&tty->termios_rwsem);\n\t}\nbreak_out:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (b - buf != nr && tty->fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tup_read(&tty->termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}",
        "target": 1
    },
    {
        "id": 579,
        "func": "void WebGLRenderingContextBase::ForceRestoreContext() {\n  if (!isContextLost()) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"restoreContext\",\n                      \"context not lost\");\n    return;\n  }\n\n  if (!restore_allowed_) {\n    if (context_lost_mode_ == kWebGLLoseContextLostContext)\n      SynthesizeGLError(GL_INVALID_OPERATION, \"restoreContext\",\n                        \"context restoration not allowed\");\n    return;\n  }\n\n  if (!restore_timer_.IsActive())\n    restore_timer_.StartOneShot(TimeDelta(), FROM_HERE);\n}\n",
        "target": 0
    },
    {
        "id": 580,
        "func": "static int out_dump(const struct audio_stream *stream, int fd)\n{\n    UNUSED(fd);\n struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;\n    FNLOG();\n return 0;\n}\n",
        "target": 0
    },
    {
        "id": 581,
        "func": "vips_tracked_free( void *s )\n{\n\t/* Keep the size of the alloc in the previous 16 bytes. Ensures\n\t * alignment rules are kept.\n\t */\n\tvoid *start = (void *) ((char *) s - 16);\n\tsize_t size = *((size_t *) start);\n\n\tg_mutex_lock( vips_tracked_mutex );\n\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_free: %p, %zd bytes\\n\", s, size ); \n#endif /*DEBUG_VERBOSE*/\n\n\tif( vips_tracked_allocs <= 0 ) \n\t\tg_warning( \"%s\", _( \"vips_free: too many frees\" ) );\n\tif( vips_tracked_mem < size )\n\t\tg_warning( \"%s\", _( \"vips_free: too much free\" ) );\n\n\tvips_tracked_mem -= size;\n\tvips_tracked_allocs -= 1;\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\tg_free( start );\n\n\tVIPS_GATE_FREE( size ); \n}",
        "target": 0
    },
    {
        "id": 582,
        "func": "void GLES2Implementation::CoverFillPathInstancedCHROMIUM(\n    GLsizei num_paths,\n    GLenum path_name_type,\n    const GLvoid* paths,\n    GLuint path_base,\n    GLenum cover_mode,\n    GLenum transform_type,\n    const GLfloat* transform_values) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] glCoverFillPathInstancedCHROMIUM(\"\n                     << num_paths << \", \" << path_name_type << \", \" << paths\n                     << \", \" << path_base << \", \" << cover_mode << \", \"\n                     << transform_type << \", \" << transform_values << \")\");\n\n  ScopedTransferBufferPtr buffer(helper_, transfer_buffer_);\n  uint32_t paths_shm_id = 0;\n  uint32_t paths_offset = 0;\n  uint32_t transforms_shm_id = 0;\n  uint32_t transforms_offset = 0;\n  if (!PrepareInstancedPathCommand(\n          \"glCoverFillPathInstancedCHROMIUM\", num_paths, path_name_type, paths,\n          transform_type, transform_values, &buffer, &paths_shm_id,\n          &paths_offset, &transforms_shm_id, &transforms_offset)) {\n    return;\n  }\n\n  helper_->CoverFillPathInstancedCHROMIUM(\n      num_paths, path_name_type, paths_shm_id, paths_offset, path_base,\n      cover_mode, transform_type, transforms_shm_id, transforms_offset);\n\n  CheckGLError();\n}\n",
        "target": 0
    },
    {
        "id": 583,
        "func": "    AutofocusTask() { }\n",
        "target": 0
    },
    {
        "id": 584,
        "func": "pktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tif_printer printer;\n\tconst pktap_header_t *hdr;\n\n\tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\t/*\n\t\t * Claimed header length < structure length.\n\t\t * XXX - does this just mean some fields aren't\n\t\t * being supplied, or is it truly an error (i.e.,\n\t\t * is the length supplied so that the header can\n\t\t * be expanded in the future)?\n\t\t */\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n\n\tcase PKT_REC_PACKET:\n\t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n\t\t} else {\n\t\t\tif (!ndo->ndo_eflag)\n\t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn (hdrlen);\n}",
        "target": 1
    },
    {
        "id": 585,
        "func": "std::set<FilePath> Extension::GetBrowserImages() const {\n  std::set<FilePath> image_paths;\n\n  for (ExtensionIconSet::IconMap::const_iterator iter = icons().map().begin();\n       iter != icons().map().end(); ++iter) {\n    image_paths.insert(FilePath::FromWStringHack(UTF8ToWide(iter->second)));\n  }\n\n  DictionaryValue* theme_images = GetThemeImages();\n  if (theme_images) {\n    for (DictionaryValue::key_iterator it = theme_images->begin_keys();\n         it != theme_images->end_keys(); ++it) {\n      std::string val;\n      if (theme_images->GetStringWithoutPathExpansion(*it, &val))\n        image_paths.insert(FilePath::FromWStringHack(UTF8ToWide(val)));\n    }\n  }\n\n  if (page_action()) {\n    std::vector<std::string>* icon_paths = page_action()->icon_paths();\n    for (std::vector<std::string>::iterator iter = icon_paths->begin();\n         iter != icon_paths->end(); ++iter) {\n      image_paths.insert(FilePath::FromWStringHack(UTF8ToWide(*iter)));\n    }\n  }\n\n  if (browser_action()) {\n    std::vector<std::string>* icon_paths = browser_action()->icon_paths();\n    for (std::vector<std::string>::iterator iter = icon_paths->begin();\n         iter != icon_paths->end(); ++iter) {\n      image_paths.insert(FilePath::FromWStringHack(UTF8ToWide(*iter)));\n    }\n  }\n\n  return image_paths;\n}\n",
        "target": 0
    },
    {
        "id": 586,
        "func": "static void sctp_inet6_event_msgname(struct sctp_ulpevent *event,\n\t\t\t\t     char *msgname, int *addrlen)\n{\n\tunion sctp_addr *addr;\n\tstruct sctp_association *asoc;\n\tunion sctp_addr *paddr;\n\n\tif (!msgname)\n\t\treturn;\n\n\taddr = (union sctp_addr *)msgname;\n\tasoc = event->asoc;\n\tpaddr = &asoc->peer.primary_addr;\n\n\tif (paddr->sa.sa_family == AF_INET) {\n\t\taddr->v4.sin_family = AF_INET;\n\t\taddr->v4.sin_port = htons(asoc->peer.port);\n\t\taddr->v4.sin_addr = paddr->v4.sin_addr;\n\t} else {\n\t\taddr->v6.sin6_family = AF_INET6;\n\t\taddr->v6.sin6_flowinfo = 0;\n\t\tif (ipv6_addr_type(&paddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\taddr->v6.sin6_scope_id = paddr->v6.sin6_scope_id;\n\t\telse\n\t\t\taddr->v6.sin6_scope_id = 0;\n\t\taddr->v6.sin6_port = htons(asoc->peer.port);\n\t\taddr->v6.sin6_addr = paddr->v6.sin6_addr;\n\t}\n\n\t*addrlen = sctp_v6_addr_to_user(sctp_sk(asoc->base.sk), addr);\n}",
        "target": 0
    },
    {
        "id": 587,
        "func": "int ff_mov_read_esds(AVFormatContext *fc, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int tag;\n\n    if (fc->nb_streams < 1)\n        return 0;\n    st = fc->streams[fc->nb_streams-1];\n\n    avio_rb32(pb); /* version + flags */\n    ff_mp4_read_descr(fc, pb, &tag);\n    if (tag == MP4ESDescrTag) {\n        ff_mp4_parse_es_descr(pb, NULL);\n    } else\n        avio_rb16(pb); /* ID */\n\n    ff_mp4_read_descr(fc, pb, &tag);\n    if (tag == MP4DecConfigDescrTag)\n        ff_mp4_read_dec_config_descr(fc, st, pb);\n    return 0;\n}",
        "target": 0
    },
    {
        "id": 588,
        "func": "bt_status_t btif_storage_add_device_to_autopair_blacklist(bt_bdaddr_t *remote_bd_addr)\n{\n int ret;\n bdstr_t bdstr;\n char linebuf[BTIF_STORAGE_MAX_LINE_SZ+20];\n char input_value [20];\n\n    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));\n    strlcpy(input_value, (char*)bdstr, sizeof(input_value));\n    strlcat(input_value,BTIF_AUTO_PAIR_CONF_VALUE_SEPARATOR, sizeof(input_value));\n\n int line_size = sizeof(linebuf);\n if(btif_config_get_str(BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST,\n                            BTIF_STORAGE_KEY_AUTOPAIR_DYNAMIC_BLACKLIST_ADDR, linebuf, &line_size))\n {\n /* Append this address to the dynamic List of BD address  */\n        strncat (linebuf, input_value, BTIF_STORAGE_MAX_LINE_SZ);\n }\n else\n {\n        strncpy( linebuf,input_value, BTIF_STORAGE_MAX_LINE_SZ);\n }\n\n /* Write back the key value */\n    ret = btif_config_set_str(BTIF_STORAGE_PATH_AUTOPAIR_BLACKLIST,\n                        BTIF_STORAGE_KEY_AUTOPAIR_DYNAMIC_BLACKLIST_ADDR, linebuf);\n\n return ret ? BT_STATUS_SUCCESS:BT_STATUS_FAIL;\n}\n",
        "target": 0
    },
    {
        "id": 589,
        "func": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}",
        "target": 1
    },
    {
        "id": 590,
        "func": "read_PackInfo(struct archive_read *a, struct _7z_pack_info *pi)\n{\n\tconst unsigned char *p;\n\tunsigned i;\n\n\tmemset(pi, 0, sizeof(*pi));\n\n\t/*\n\t * Read PackPos.\n\t */\n\tif (parse_7zip_uint64(a, &(pi->pos)) < 0)\n\t\treturn (-1);\n\n\t/*\n\t * Read NumPackStreams.\n\t */\n\tif (parse_7zip_uint64(a, &(pi->numPackStreams)) < 0)\n\t\treturn (-1);\n\tif (pi->numPackStreams == 0)\n\t\treturn (-1);\n\tif (UMAX_ENTRY < pi->numPackStreams)\n\t\treturn (-1);\n\n\t/*\n\t * Read PackSizes[num]\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kEnd)\n\t\t/* PackSizes[num] are not present. */\n\t\treturn (0);\n\tif (*p != kSize)\n\t\treturn (-1);\n\tpi->sizes = calloc((size_t)pi->numPackStreams, sizeof(uint64_t));\n\tpi->positions = calloc((size_t)pi->numPackStreams, sizeof(uint64_t));\n\tif (pi->sizes == NULL || pi->positions == NULL)\n\t\treturn (-1);\n\n\tfor (i = 0; i < pi->numPackStreams; i++) {\n\t\tif (parse_7zip_uint64(a, &(pi->sizes[i])) < 0)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Read PackStreamDigests[num]\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kEnd) {\n\t\t/* PackStreamDigests[num] are not present. */\n\t\tpi->digest.defineds =\n\t\t    calloc((size_t)pi->numPackStreams, sizeof(*pi->digest.defineds));\n\t\tpi->digest.digests =\n\t\t    calloc((size_t)pi->numPackStreams, sizeof(*pi->digest.digests));\n\t\tif (pi->digest.defineds == NULL || pi->digest.digests == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\n\tif (*p != kSize)\n\t\treturn (-1);\n\n\tif (read_Digests(a, &(pi->digest), (size_t)pi->numPackStreams) < 0)\n\t\treturn (-1);\n\n\t/*\n\t *  Must be marked by kEnd.\n\t */\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p != kEnd)\n\t\treturn (-1);\n\treturn (0);\n}",
        "target": 0
    },
    {
        "id": 591,
        "func": "void DownloadFileManager::CancelDownloadOnRename(\n    DownloadId global_id, net::Error rename_error) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n  DownloadFile* download_file = GetDownloadFile(global_id);\n  if (!download_file)\n    return;\n  DownloadManager* download_manager = download_file->GetDownloadManager();\n  DCHECK(download_manager);\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::Bind(&DownloadManager::OnDownloadInterrupted,\n                 download_manager,\n                 global_id.local(),\n                 download_file->BytesSoFar(),\n                 download_file->GetHashState(),\n                 content::ConvertNetErrorToInterruptReason(\n                     rename_error,\n                     content::DOWNLOAD_INTERRUPT_FROM_DISK)));\n}\n",
        "target": 1
    },
    {
        "id": 592,
        "func": "void RenderView::OnGetAllSavableResourceLinksForCurrentPage(\n    const GURL& page_url) {\n  std::vector<GURL> resources_list;\n  std::vector<GURL> referrers_list;\n  std::vector<GURL> frames_list;\n  webkit_glue::SavableResourcesResult result(&resources_list,\n                                             &referrers_list,\n                                             &frames_list);\n\n  if (!webkit_glue::GetAllSavableResourceLinksForCurrentPage(\n          webview(),\n          page_url,\n          &result,\n          chrome::kSavableSchemes)) {\n    referrers_list.clear();\n    resources_list.clear();\n    frames_list.clear();\n  }\n\n  Send(new ViewHostMsg_SendCurrentPageAllSavableResourceLinks(routing_id_,\n                                                              resources_list,\n                                                              referrers_list,\n                                                              frames_list));\n}\n",
        "target": 0
    },
    {
        "id": 593,
        "func": "OperationID FileSystemOperationRunner::CopyFileLocal(\n    const FileSystemURL& src_url,\n    const FileSystemURL& dest_url,\n    CopyOrMoveOption option,\n    const CopyFileProgressCallback& progress_callback,\n    StatusCallback callback) {\n  base::File::Error error = base::File::FILE_OK;\n  std::unique_ptr<FileSystemOperation> operation = base::WrapUnique(\n      file_system_context_->CreateFileSystemOperation(src_url, &error));\n  FileSystemOperation* operation_raw = operation.get();\n  OperationID id = BeginOperation(std::move(operation));\n  base::AutoReset<bool> beginning(&is_beginning_operation_, true);\n  if (!operation_raw) {\n    DidFinish(id, std::move(callback), error);\n    return id;\n  }\n  PrepareForRead(id, src_url);\n  PrepareForWrite(id, dest_url);\n  operation_raw->CopyFileLocal(\n      src_url, dest_url, option, progress_callback,\n      base::BindOnce(&FileSystemOperationRunner::DidFinish, weak_ptr_, id,\n                     std::move(callback)));\n  return id;\n}\n",
        "target": 0
    },
    {
        "id": 594,
        "func": " static void locationReplaceableAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n {\n     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());\n    TestNode* imp = WTF::getPtr(proxyImp->locationReplaceable());\n     if (!imp)\n         return;\n     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);\n    imp->setHref(cppValue);\n}\n",
        "target": 1
    },
    {
        "id": 595,
        "func": "void qeth_qdio_start_poll(struct ccw_device *ccwdev, int queue,\n\t\tunsigned long card_ptr)\n{\n\tstruct qeth_card *card = (struct qeth_card *)card_ptr;\n\n\tif (card->dev && (card->dev->flags & IFF_UP))\n\t\tnapi_schedule(&card->napi);\n}",
        "target": 0
    },
    {
        "id": 596,
        "func": "MediaBuffer *FLACParser::readBuffer(bool doSeek, FLAC__uint64 sample)\n{\n    mWriteRequested = true;\n    mWriteCompleted = false;\n if (doSeek) {\n if (!FLAC__stream_decoder_seek_absolute(mDecoder, sample)) {\n            ALOGE(\"FLACParser::readBuffer seek to sample %lld failed\", (long long)sample);\n return NULL;\n }\n        ALOGV(\"FLACParser::readBuffer seek to sample %lld succeeded\", (long long)sample);\n } else {\n if (!FLAC__stream_decoder_process_single(mDecoder)) {\n            ALOGE(\"FLACParser::readBuffer process_single failed\");\n return NULL;\n }\n }\n if (!mWriteCompleted) {\n        ALOGV(\"FLACParser::readBuffer write did not complete\");\n return NULL;\n }\n unsigned blocksize = mWriteHeader.blocksize;\n if (blocksize == 0 || blocksize > getMaxBlockSize()) {\n        ALOGE(\"FLACParser::readBuffer write invalid blocksize %u\", blocksize);\n return NULL;\n }\n if (mWriteHeader.sample_rate != getSampleRate() ||\n        mWriteHeader.channels != getChannels() ||\n        mWriteHeader.bits_per_sample != getBitsPerSample()) {\n        ALOGE(\"FLACParser::readBuffer write changed parameters mid-stream: %d/%d/%d -> %d/%d/%d\",\n                getSampleRate(), getChannels(), getBitsPerSample(),\n                mWriteHeader.sample_rate, mWriteHeader.channels, mWriteHeader.bits_per_sample);\n return NULL;\n }\n    CHECK(mGroup != NULL);\n MediaBuffer *buffer;\n status_t err = mGroup->acquire_buffer(&buffer);\n if (err != OK) {\n return NULL;\n }\n size_t bufferSize = blocksize * getChannels() * sizeof(short);\n    CHECK(bufferSize <= mMaxBufferSize);\n short *data = (short *) buffer->data();\n    buffer->set_range(0, bufferSize);\n (*mCopy)(data, mWriteBuffer, blocksize, getChannels());\n    CHECK(mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);\n    FLAC__uint64 sampleNumber = mWriteHeader.number.sample_number;\n int64_t timeUs = (1000000LL * sampleNumber) / getSampleRate();\n    buffer->meta_data()->setInt64(kKeyTime, timeUs);\n    buffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);\n return buffer;\n}\n",
        "target": 0
    },
    {
        "id": 597,
        "func": "static int megasas_handle_abort(MegasasState *s, MegasasCmd *cmd)\n{\n    uint64_t abort_ctx = le64_to_cpu(cmd->frame->abort.abort_context);\n    hwaddr abort_addr, addr_hi, addr_lo;\n    MegasasCmd *abort_cmd;\n\n    addr_hi = le32_to_cpu(cmd->frame->abort.abort_mfi_addr_hi);\n    addr_lo = le32_to_cpu(cmd->frame->abort.abort_mfi_addr_lo);\n    abort_addr = ((uint64_t)addr_hi << 32) | addr_lo;\n\n    abort_cmd = megasas_lookup_frame(s, abort_addr);\n    if (!abort_cmd) {\n        trace_megasas_abort_no_cmd(cmd->index, abort_ctx);\n        s->event_count++;\n        return MFI_STAT_OK;\n    }\n    if (!megasas_use_queue64(s)) {\n        abort_ctx &= (uint64_t)0xFFFFFFFF;\n    }\n    if (abort_cmd->context != abort_ctx) {\n        trace_megasas_abort_invalid_context(cmd->index, abort_cmd->index,\n                                            abort_cmd->context);\n        s->event_count++;\n        return MFI_STAT_ABORT_NOT_POSSIBLE;\n    }\n    trace_megasas_abort_frame(cmd->index, abort_cmd->index);\n    megasas_abort_command(abort_cmd);\n    if (!s->event_cmd || abort_cmd != s->event_cmd) {\n        s->event_cmd = NULL;\n    }\n    s->event_count++;\n    return MFI_STAT_OK;\n}\n",
        "target": 0
    },
    {
        "id": 598,
        "func": "XmlConfigParser* XmlConfigParser::FromContext(void* ctx) {\n  return static_cast<XmlConfigParser*>(ctx);\n}\n",
        "target": 0
    },
    {
        "id": 599,
        "func": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->tm_orig_msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}",
        "target": 0
    },
    {
        "id": 600,
        "func": "static int cdrom_ioctl_volctrl(struct cdrom_device_info *cdi,\n\t\tvoid __user *argp)\n{\n\tstruct cdrom_volctrl volume;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLCTRL\\n\");\n\n\tif (!CDROM_CAN(CDC_PLAY_AUDIO))\n\t\treturn -ENOSYS;\n\tif (copy_from_user(&volume, argp, sizeof(volume)))\n\t\treturn -EFAULT;\n\treturn cdi->ops->audio_ioctl(cdi, CDROMVOLCTRL, &volume);\n}",
        "target": 0
    },
    {
        "id": 601,
        "func": "void* ipc_alloc(int size)\n{\n\tvoid* out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}",
        "target": 1
    },
    {
        "id": 602,
        "func": "AutocompleteProvider::~AutocompleteProvider() {\n  Stop();\n}\n",
        "target": 1
    },
    {
        "id": 603,
        "func": "\t\tvoid CWebServer::Cmd_DeleteMobileDevice(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\tif (session.rights != 2)\n\t\t\t{\n\t\t\t\tsession.reply_status = reply::forbidden;\n\t\t\t\treturn; //Only admin user allowed\n\t\t\t}\n\t\t\tstd::string suuid = request::findValue(&req, \"uuid\");\n\t\t\tif (suuid.empty())\n\t\t\t\treturn;\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_query(\"SELECT ID FROM MobileDevices WHERE (UUID=='%q')\", suuid.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\tm_sql.safe_query(\"DELETE FROM MobileDevices WHERE (UUID == '%q')\", suuid.c_str());\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"DeleteMobileDevice\";\n\t\t}",
        "target": 0
    },
    {
        "id": 604,
        "func": "SProcXFixesCreatePointerBarrier(ClientPtr client)\n{\n    REQUEST(xXFixesCreatePointerBarrierReq);\n    int i;\n     int i;\n     CARD16 *in_devices = (CARD16 *) &stuff[1];\n \n    REQUEST_AT_LEAST_SIZE(xXFixesCreatePointerBarrierReq);\n\n     swaps(&stuff->length);\n     swaps(&stuff->num_devices);\n     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));\n    swaps(&stuff->x1);\n    swaps(&stuff->y1);\n    swaps(&stuff->x2);\n    swaps(&stuff->y2);\n    swapl(&stuff->directions);\n    for (i = 0; i < stuff->num_devices; i++) {\n        swaps(in_devices + i);\n    }\n\n    return ProcXFixesVector[stuff->xfixesReqType] (client);\n}\n",
        "target": 0
    },
    {
        "id": 605,
        "func": "const std::string& CSPInfo::GetContentSecurityPolicy(\n    const Extension* extension) {\n  CSPInfo* csp_info = static_cast<CSPInfo*>(\n          extension->GetManifestData(keys::kContentSecurityPolicy));\n  return csp_info ? csp_info->content_security_policy : base::EmptyString();\n}\n",
        "target": 0
    },
    {
        "id": 606,
        "func": "static inline bool vfio_pci_is_vga(struct pci_dev *pdev)\n{\n\treturn (pdev->class >> 8) == PCI_CLASS_DISPLAY_VGA;\n}",
        "target": 0
    },
    {
        "id": 607,
        "func": "void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item )\n{\n\tif ( ! item )\n\t\treturn;\n\tif ( item->string )\n\t\tcJSON_free( item->string );\n\titem->string = cJSON_strdup( string );\n\tcJSON_AddItemToArray( object, item );\n}",
        "target": 1
    },
    {
        "id": 608,
        "func": "static int check_stack_read(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_verifier_state *state, int off, int size,\n\t\t\t    int value_regno)\n{\n\tint i, slot = -off - 1, spi = slot / BPF_REG_SIZE;\n\tu8 *stype;\n\n\tif (state->allocated_stack <= slot) {\n\t\tverbose(env, \"invalid read from stack off %d+0 size %d\\n\",\n\t\t\toff, size);\n\t\treturn -EACCES;\n\t}\n\tstype = state->stack[spi].slot_type;\n\n\tif (stype[0] == STACK_SPILL) {\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose(env, \"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tfor (i = 1; i < BPF_REG_SIZE; i++) {\n\t\t\tif (stype[(slot - i) % BPF_REG_SIZE] != STACK_SPILL) {\n\t\t\t\tverbose(env, \"corrupted spill memory\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\n\t\tif (value_regno >= 0) {\n\t\t\t/* restore register state from stack */\n\t\t\tstate->regs[value_regno] = state->stack[spi].spilled_ptr;\n\t\t\tmark_stack_slot_read(state, spi);\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (stype[(slot - i) % BPF_REG_SIZE] != STACK_MISC) {\n\t\t\t\tverbose(env, \"invalid read from stack off %d+%d size %d\\n\",\n\t\t\t\t\toff, i, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\t\tif (value_regno >= 0)\n\t\t\t/* have read misc data from the stack */\n\t\t\tmark_reg_unknown(env, state->regs, value_regno);\n\t\treturn 0;\n\t}\n}",
        "target": 0
    },
    {
        "id": 609,
        "func": "void DocumentWriter::setDocumentWasLoadedAsPartOfNavigation()\n{\n    ASSERT(!m_parser->isStopped());\n    m_parser->setDocumentWasLoadedAsPartOfNavigation();\n}\n",
        "target": 0
    },
    {
        "id": 610,
        "func": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 611,
        "func": "  virtual const ImePropertyList& current_ime_properties() const {\n     return current_ime_properties_;\n   }\n",
        "target": 1
    },
    {
        "id": 612,
        "func": "void RenderThreadImpl::OnTempCrashWithData(const GURL& data) {\n  content::GetContentClient()->SetActiveURL(data);\n  CHECK(false);\n}\n",
        "target": 0
    },
    {
        "id": 613,
        "func": "void __init ipc_init_proc_interface(const char *path, const char *header,\n\t\tint ids, int (*show)(struct seq_file *, void *))\n{\n\tstruct proc_dir_entry *pde;\n\tstruct ipc_proc_iface *iface;\n\n\tiface = kmalloc(sizeof(*iface), GFP_KERNEL);\n\tif (!iface)\n\t\treturn;\n\tiface->path\t= path;\n\tiface->header\t= header;\n\tiface->ids\t= ids;\n\tiface->show\t= show;\n\n\tpde = proc_create_data(path,\n\t\t\t       S_IRUGO,        /* world readable */\n\t\t\t       NULL,           /* parent dir */\n\t\t\t       &sysvipc_proc_fops,\n\t\t\t       iface);\n\tif (!pde)\n\t\tkfree(iface);\n}",
        "target": 0
    },
    {
        "id": 614,
        "func": "xfs_queue_cowblocks(\n\tstruct xfs_mount *mp)\n{\n\trcu_read_lock();\n\tif (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_COWBLOCKS_TAG))\n\t\tqueue_delayed_work(mp->m_eofblocks_workqueue,\n\t\t\t\t   &mp->m_cowblocks_work,\n\t\t\t\t   msecs_to_jiffies(xfs_cowb_secs * 1000));\n\trcu_read_unlock();\n}",
        "target": 0
    },
    {
        "id": 615,
        "func": "  static void TearDownTestCase() {\n    io_runner.reset();\n    background_thread.reset();\n    scoped_task_environment.reset();\n  }\n",
        "target": 0
    },
    {
        "id": 616,
        "func": "String Location::search() const {\n  return DOMURLUtilsReadOnly::search(Url());\n}\n",
        "target": 0
    },
    {
        "id": 617,
        "func": "trad_enc_update_keys(struct trad_enc_ctx *ctx, uint8_t c)\n{\n\tuint8_t t;\n#define CRC32(c, b) (crc32(c ^ 0xffffffffUL, &b, 1) ^ 0xffffffffUL)\n\n\tctx->keys[0] = CRC32(ctx->keys[0], c);\n\tctx->keys[1] = (ctx->keys[1] + (ctx->keys[0] & 0xff)) * 134775813L + 1;\n\tt = (ctx->keys[1] >> 24) & 0xff;\n\tctx->keys[2] = CRC32(ctx->keys[2], t);\n#undef CRC32\n}",
        "target": 0
    },
    {
        "id": 618,
        "func": "bool ChromeClientImpl::RequestPointerLock(LocalFrame* frame) {\n  LocalFrame& local_root = frame->LocalFrameRoot();\n  return WebLocalFrameImpl::FromFrame(&local_root)\n      ->FrameWidget()\n      ->Client()\n      ->RequestPointerLock();\n}\n",
        "target": 0
    },
    {
        "id": 619,
        "func": "bool FrameLoader::ShouldTreatURLAsSrcdocDocument(const KURL& url) const {\n  if (!url.IsAboutSrcdocURL())\n    return false;\n  HTMLFrameOwnerElement* owner_element = frame_->DeprecatedLocalOwner();\n  if (!IsHTMLIFrameElement(owner_element))\n    return false;\n  return owner_element->FastHasAttribute(kSrcdocAttr);\n}\n",
        "target": 0
    },
    {
        "id": 620,
        "func": "ProcRenderTrapezoids(ClientPtr client)\n{\n    int rc, ntraps;\n    PicturePtr pSrc, pDst;\n    PictFormatPtr pFormat;\n\n    REQUEST(xRenderTrapezoidsReq);\n\n    REQUEST_AT_LEAST_SIZE(xRenderTrapezoidsReq);\n    if (!PictOpValid(stuff->op)) {\n        client->errorValue = stuff->op;\n        return BadValue;\n    }\n    VERIFY_PICTURE(pSrc, stuff->src, client, DixReadAccess);\n    VERIFY_PICTURE(pDst, stuff->dst, client, DixWriteAccess);\n    if (!pDst->pDrawable)\n        return BadDrawable;\n    if (pSrc->pDrawable && pSrc->pDrawable->pScreen != pDst->pDrawable->pScreen)\n        return BadMatch;\n    if (stuff->maskFormat) {\n        rc = dixLookupResourceByType((void **) &pFormat, stuff->maskFormat,\n                                     PictFormatType, client, DixReadAccess);\n        if (rc != Success)\n            return rc;\n    }\n    else\n        pFormat = 0;\n    ntraps = (client->req_len << 2) - sizeof(xRenderTrapezoidsReq);\n    if (ntraps % sizeof(xTrapezoid))\n        return BadLength;\n    ntraps /= sizeof(xTrapezoid);\n    if (ntraps)\n        CompositeTrapezoids(stuff->op, pSrc, pDst, pFormat,\n                            stuff->xSrc, stuff->ySrc,\n                            ntraps, (xTrapezoid *) &stuff[1]);\n    return Success;\n}\n",
        "target": 0
    },
    {
        "id": 621,
        "func": "static int mt_ioctl_trans(unsigned int fd, unsigned int cmd, void __user *argp)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct mtget get;\n\tstruct mtget32 __user *umget32;\n\tstruct mtpos pos;\n\tstruct mtpos32 __user *upos32;\n\tunsigned long kcmd;\n\tvoid *karg;\n\tint err = 0;\n\n\tswitch(cmd) {\n\tcase MTIOCPOS32:\n\t\tkcmd = MTIOCPOS;\n\t\tkarg = &pos;\n\t\tbreak;\n\tdefault:\t/* MTIOCGET32 */\n\t\tkcmd = MTIOCGET;\n\t\tkarg = &get;\n\t\tbreak;\n\t}\n\tset_fs (KERNEL_DS);\n\terr = sys_ioctl (fd, kcmd, (unsigned long)karg);\n\tset_fs (old_fs);\n\tif (err)\n\t\treturn err;\n\tswitch (cmd) {\n\tcase MTIOCPOS32:\n\t\tupos32 = argp;\n\t\terr = __put_user(pos.mt_blkno, &upos32->mt_blkno);\n\t\tbreak;\n\tcase MTIOCGET32:\n\t\tumget32 = argp;\n\t\terr = __put_user(get.mt_type, &umget32->mt_type);\n\t\terr |= __put_user(get.mt_resid, &umget32->mt_resid);\n\t\terr |= __put_user(get.mt_dsreg, &umget32->mt_dsreg);\n\t\terr |= __put_user(get.mt_gstat, &umget32->mt_gstat);\n\t\terr |= __put_user(get.mt_erreg, &umget32->mt_erreg);\n\t\terr |= __put_user(get.mt_fileno, &umget32->mt_fileno);\n\t\terr |= __put_user(get.mt_blkno, &umget32->mt_blkno);\n\t\tbreak;\n\t}\n\treturn err ? -EFAULT: 0;\n}",
        "target": 0
    },
    {
        "id": 622,
        "func": "static void add_assoc_name_entry(zval * val, char * key, X509_NAME * name, int shortname) /* {{{ */\n{\n\tzval *data;\n\tzval subitem, tmp;\n\tint i;\n\tchar *sname;\n\tint nid;\n\tX509_NAME_ENTRY * ne;\n\tASN1_STRING * str = NULL;\n\tASN1_OBJECT * obj;\n\n\tif (key != NULL) {\n\t\tarray_init(&subitem);\n\t} else {\n\t\tZVAL_COPY_VALUE(&subitem, val);\n\t}\n\n\tfor (i = 0; i < X509_NAME_entry_count(name); i++) {\n\t\tconst unsigned char *to_add = NULL;\n\t\tint to_add_len = 0;\n\t\tunsigned char *to_add_buf = NULL;\n\n\t\tne = X509_NAME_get_entry(name, i);\n\t\tobj = X509_NAME_ENTRY_get_object(ne);\n\t\tnid = OBJ_obj2nid(obj);\n\n\t\tif (shortname) {\n\t\t\tsname = (char *) OBJ_nid2sn(nid);\n\t\t} else {\n\t\t\tsname = (char *) OBJ_nid2ln(nid);\n\t\t}\n\n\t\tstr = X509_NAME_ENTRY_get_data(ne);\n\t\tif (ASN1_STRING_type(str) != V_ASN1_UTF8STRING) {\n\t\t\t/* ASN1_STRING_to_UTF8(3): The converted data is copied into a newly allocated buffer */\n\t\t\tto_add_len = ASN1_STRING_to_UTF8(&to_add_buf, str);\n\t\t\tto_add = to_add_buf;\n\t\t} else {\n\t\t\t/* ASN1_STRING_get0_data(3): Since this is an internal pointer it should not be freed or modified in any way */\n\t\t\tto_add = ASN1_STRING_get0_data(str);\n\t\t\tto_add_len = ASN1_STRING_length(str);\n\t\t}\n\n\t\tif (to_add_len != -1) {\n\t\t\tif ((data = zend_hash_str_find(Z_ARRVAL(subitem), sname, strlen(sname))) != NULL) {\n\t\t\t\tif (Z_TYPE_P(data) == IS_ARRAY) {\n\t\t\t\t\tadd_next_index_stringl(data, (const char *)to_add, to_add_len);\n\t\t\t\t} else if (Z_TYPE_P(data) == IS_STRING) {\n\t\t\t\t\tarray_init(&tmp);\n\t\t\t\t\tadd_next_index_str(&tmp, zend_string_copy(Z_STR_P(data)));\n\t\t\t\t\tadd_next_index_stringl(&tmp, (const char *)to_add, to_add_len);\n\t\t\t\t\tzend_hash_str_update(Z_ARRVAL(subitem), sname, strlen(sname), &tmp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* it might be better to expand it and pass zval from ZVAL_STRING\n\t\t\t\t * to zend_symtable_str_update so we do not silently drop const\n\t\t\t\t * but we need a test to cover this part first */\n\t\t\t\tadd_assoc_stringl(&subitem, sname, (char *)to_add, to_add_len);\n\t\t\t}\n\t\t}\n\n\t\tif (to_add_buf != NULL) {\n\t\t\tOPENSSL_free(to_add_buf);\n\t\t}\n\t}\n\n\tif (key != NULL) {\n\t\tzend_hash_str_update(Z_ARRVAL_P(val), key, strlen(key), &subitem);\n\t}\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 623,
        "func": "BrowserChildProcessHost* BrowserChildProcessHost::Create(\n    content::ProcessType process_type,\n    BrowserChildProcessHostDelegate* delegate,\n    const std::string& service_name) {\n  return new BrowserChildProcessHostImpl(process_type, delegate, service_name);\n}\n",
        "target": 0
    },
    {
        "id": 624,
        "func": "bool IsURLWhitelisted(const GURL& current_url,\n                      const base::Value::ListStorage& whitelisted_urls) {\n  if (!current_url.SchemeIsHTTPOrHTTPS())\n    return false;\n\n  for (auto const& value : whitelisted_urls) {\n    ContentSettingsPattern pattern =\n        ContentSettingsPattern::FromString(value.GetString());\n    if (pattern == ContentSettingsPattern::Wildcard() || !pattern.IsValid())\n      continue;\n    if (pattern.Matches(current_url))\n      return true;\n  }\n\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 625,
        "func": "void GuestViewBase::Destroy() {\n  if (is_being_destroyed_)\n    return;\n\n  is_being_destroyed_ = true;\n\n  StopTrackingEmbedderZoomLevel();\n  owner_web_contents_ = nullptr;\n\n  DCHECK(web_contents());\n\n  WillDestroy();\n\n  weak_ptr_factory_.InvalidateWeakPtrs();\n\n  guest_host_->WillDestroy();\n  guest_host_ = nullptr;\n\n  webcontents_guestview_map.Get().erase(web_contents());\n  GuestViewManager::FromBrowserContextIfAvailable(browser_context_)->\n      RemoveGuest(guest_instance_id_);\n  pending_events_.clear();\n\n  delete web_contents();\n}\n",
        "target": 0
    },
    {
        "id": 626,
        "func": "int hidp_get_conninfo(struct hidp_conninfo *ci)\n{\n\tstruct hidp_session *session;\n\tint err = 0;\n\n\tdown_read(&hidp_session_sem);\n\n\tsession = __hidp_get_session(&ci->bdaddr);\n\tif (session)\n\t\t__hidp_copy_session(session, ci);\n\telse\n\t\terr = -ENOENT;\n\n\tup_read(&hidp_session_sem);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 627,
        "func": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\n\treturn overrun;\n}",
        "target": 1
    },
    {
        "id": 628,
        "func": " void MediaStreamDispatcherHost::CancelAllRequests() {\n  if (!bindings_.empty())\n    return;\n  media_stream_manager_->CancelAllRequests(render_process_id_,\n                                           render_frame_id_);\n }\n",
        "target": 1
    },
    {
        "id": 629,
        "func": "void PageInfo::GetSafeBrowsingStatusByMaliciousContentStatus(\n     security_state::MaliciousContentStatus malicious_content_status,\n    PageInfo::SafeBrowsingStatus* status,\n     base::string16* details) {\n   switch (malicious_content_status) {\n     case security_state::MALICIOUS_CONTENT_STATUS_NONE:\n       NOTREACHED();\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_MALWARE:\n      *status = PageInfo::SAFE_BROWSING_STATUS_MALWARE;\n       *details = l10n_util::GetStringUTF16(IDS_PAGE_INFO_MALWARE_DETAILS);\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_SOCIAL_ENGINEERING:\n      *status = PageInfo::SAFE_BROWSING_STATUS_SOCIAL_ENGINEERING;\n       *details =\n           l10n_util::GetStringUTF16(IDS_PAGE_INFO_SOCIAL_ENGINEERING_DETAILS);\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_UNWANTED_SOFTWARE:\n      *status = PageInfo::SAFE_BROWSING_STATUS_UNWANTED_SOFTWARE;\n       *details =\n           l10n_util::GetStringUTF16(IDS_PAGE_INFO_UNWANTED_SOFTWARE_DETAILS);\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_SIGN_IN_PASSWORD_REUSE:\n #if defined(FULL_SAFE_BROWSING)\n      *status = PageInfo::SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE;\n       *details = password_protection_service_\n                      ? password_protection_service_->GetWarningDetailText(\n                           PasswordReuseEvent::SIGN_IN_PASSWORD)\n                     : base::string16();\n#endif\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_ENTERPRISE_PASSWORD_REUSE:\n #if defined(FULL_SAFE_BROWSING)\n      *status = PageInfo::SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE;\n       *details = password_protection_service_\n                      ? password_protection_service_->GetWarningDetailText(\n                           PasswordReuseEvent::ENTERPRISE_PASSWORD)\n                     : base::string16();\n #endif\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_BILLING:\n      *status = PageInfo::SAFE_BROWSING_STATUS_BILLING;\n       *details = l10n_util::GetStringUTF16(IDS_PAGE_INFO_BILLING_DETAILS);\n       break;\n   }\n}\n",
        "target": 1
    },
    {
        "id": 630,
        "func": "int ft_board_setup(void *blob, bd_t *bd)\n{\n\tphys_addr_t base;\n\tphys_size_t size;\n\n\tft_cpu_setup(blob, bd);\n\n\tbase = env_get_bootm_low();\n\tsize = env_get_bootm_size();\n\n\tfdt_fixup_memory(blob, (u64)base, (u64)size);\n\n#if defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB)\n\tfsl_fdt_fixup_dr_usb(blob, bd);\n#endif\n\n#ifdef CONFIG_PCI\n\tpci_of_setup(blob, bd);\n#endif\n\n\tfdt_fixup_liodn(blob);\n#ifdef CONFIG_SYS_DPAA_FMAN\n\tfdt_fixup_fman_ethernet(blob);\n\tfdt_fixup_fman_mac_addresses(blob);\n#endif\n\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 631,
        "func": "static void Region_destructor(JNIEnv* env, jobject, jlong regionHandle) {\n SkRegion* region = reinterpret_cast<SkRegion*>(regionHandle);\n SkASSERT(region);\n delete region;\n}\n",
        "target": 0
    },
    {
        "id": 632,
        "func": "std::string ShellContentClient::GetUserAgent(bool* overriding) const {\n  *overriding = false;\n  return std::string(\"Chrome/15.16.17.18\");\n}\n",
        "target": 0
    },
    {
        "id": 633,
        "func": "static unsigned long __peek_user(struct task_struct *child, addr_t addr)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset, tmp;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\ttmp = *(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr);\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\t/* Return a clean psw mask. */\n\t\t\ttmp &= PSW_MASK_USER | PSW_MASK_RI;\n\t\t\ttmp |= PSW_USER_BITS;\n\t\t}\n\n\t} else if (addr < (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb reading\n\t\t * from acrs[15]. Result is a 64 bit value. Read the\n\t\t * 32 bit acrs[15] value and shift it by 32. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\ttmp = ((unsigned long) child->thread.acrs[15]) << 32;\n\t\telse\n#endif\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.acrs + offset);\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttmp = (addr_t) task_pt_regs(child)->orig_gpr2;\n\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\t/*\n\t\t * prevent reads of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\ttmp = 0;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/* \n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\ttmp = *(addr_t *)((addr_t) &child->thread.fp_regs + offset);\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\ttmp <<= BITS_PER_LONG - 32;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\ttmp = __peek_user_per(child, addr);\n\n\t} else\n\t\ttmp = 0;\n\n\treturn tmp;\n}",
        "target": 0
    },
    {
        "id": 634,
        "func": " void P2PSocketDispatcherHost::OnAcceptIncomingTcpConnection(\n     const IPC::Message& msg, int listen_socket_id,\n    net::IPEndPoint remote_address, int connected_socket_id) {\n   P2PSocketHost* socket = LookupSocket(msg.routing_id(), listen_socket_id);\n   if (!socket) {\n     LOG(ERROR) << \"Received P2PHostMsg_AcceptIncomingTcpConnection \"\n        \"for invalid socket_id.\";\n    return;\n  }\n  P2PSocketHost* accepted_connection =\n      socket->AcceptIncomingTcpConnection(remote_address, connected_socket_id);\n  if (accepted_connection) {\n    sockets_.insert(std::pair<ExtendedSocketId, P2PSocketHost*>(\n        ExtendedSocketId(msg.routing_id(), connected_socket_id),\n        accepted_connection));\n  }\n}\n",
        "target": 1
    },
    {
        "id": 635,
        "func": "static int mv_probe(AVProbeData *p)\n{\n    if (AV_RB32(p->buf) == MKBETAG('M', 'O', 'V', 'I') &&\n        AV_RB16(p->buf + 4) < 3)\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}",
        "target": 0
    },
    {
        "id": 636,
        "func": "int __trace_puts(unsigned long ip, const char *str, int size)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tstruct print_entry *entry;\n\tunsigned long irq_flags;\n\tint alloc;\n\tint pc;\n\n\tif (!(global_trace.trace_flags & TRACE_ITER_PRINTK))\n\t\treturn 0;\n\n\tpc = preempt_count();\n\n\tif (unlikely(tracing_selftest_running || tracing_disabled))\n\t\treturn 0;\n\n\talloc = sizeof(*entry) + size + 2; /* possible \\n added */\n\n\tlocal_save_flags(irq_flags);\n\tbuffer = global_trace.trace_buffer.buffer;\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_PRINT, alloc, \n\t\t\t\t\t    irq_flags, pc);\n\tif (!event)\n\t\treturn 0;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = ip;\n\n\tmemcpy(&entry->buf, str, size);\n\n\t/* Add a newline if necessary */\n\tif (entry->buf[size - 1] != '\\n') {\n\t\tentry->buf[size] = '\\n';\n\t\tentry->buf[size + 1] = '\\0';\n\t} else\n\t\tentry->buf[size] = '\\0';\n\n\t__buffer_unlock_commit(buffer, event);\n\tftrace_trace_stack(&global_trace, buffer, irq_flags, 4, pc, NULL);\n\n\treturn size;\n}",
        "target": 0
    },
    {
        "id": 637,
        "func": "static int smbXcli_session_destructor(struct smbXcli_session *session)\n{\n\tif (session->conn == NULL) {\n\t\treturn 0;\n\t}\n\n\tDLIST_REMOVE(session->conn->sessions, session);\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 638,
        "func": "static struct dentry *proc_attr_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}",
        "target": 0
    },
    {
        "id": 639,
        "func": "GetPinholePackets(struct upnphttp * h, const char * action, const char * ns)\n{\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<PinholePackets>%u</PinholePackets>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * uid_str;\n\tint n;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tunsigned short iport;\n\tunsigned int packets = 0;\n\tint uid;\n\tint proto;\n\tunsigned int leasetime;\n\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tClearNameValueList(&data);\n\n\tif(uid < 0 || uid > 65535)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\n\t/* Check that client is not getting infos of a pinhole\n\t * it doesn't have access to, because of its public access */\n\tn = upnp_get_pinhole_info(uid, NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          &proto,\n\t                          NULL, 0, /* desc, desclen */\n\t                          &leasetime, &packets);\n\tif (n >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport)<=0)\n\t\t\treturn ;\n\t}\n#if 0\n\telse if(r == -4 || r == -1)\n\t{\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\t}\n#endif\n\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\taction, ns/*\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\"*/,\n\t\t\tpackets, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}",
        "target": 0
    },
    {
        "id": 640,
        "func": "  ConnectionTracker* preconnecting_server_connection_tracker() const {\n    return preconnecting_server_connection_tracker_.get();\n  }\n",
        "target": 0
    },
    {
        "id": 641,
        "func": "void Part::loadArchive()\n{\n    const QString fixedMimeType = arguments().metaData()[QStringLiteral(\"fixedMimeType\")];\n    auto job = m_model->loadArchive(localFilePath(), fixedMimeType, m_model);\n\n    if (job) {\n        registerJob(job);\n        job->start();\n    } else {\n        updateActions();\n    }\n}\n",
        "target": 0
    },
    {
        "id": 642,
        "func": "FilePath GenerateFileName(const GURL& url,\n                          const std::string& content_disposition,\n                          const std::string& referrer_charset,\n                          const std::string& suggested_name,\n                          const std::string& mime_type,\n                          const std::string& default_file_name) {\n  string16 file_name = GetSuggestedFilename(url,\n                                            content_disposition,\n                                            referrer_charset,\n                                            suggested_name,\n                                            mime_type,\n                                            default_file_name);\n\n#if defined(OS_WIN)\n  FilePath generated_name(file_name);\n#else\n  FilePath generated_name(base::SysWideToNativeMB(UTF16ToWide(file_name)));\n#endif\n  DCHECK(!generated_name.empty());\n\n  return generated_name;\n}\n",
        "target": 0
    },
    {
        "id": 643,
        "func": "static void tcp_dsack_set(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_is_sack(tp) && sysctl_tcp_dsack) {\n\t\tint mib_idx;\n\n\t\tif (before(seq, tp->rcv_nxt))\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOLDSENT;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOFOSENT;\n\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\n\t\ttp->rx_opt.dsack = 1;\n\t\ttp->duplicate_sack[0].start_seq = seq;\n\t\ttp->duplicate_sack[0].end_seq = end_seq;\n\t}\n}",
        "target": 0
    },
    {
        "id": 644,
        "func": "void DownloadItemImpl::OnTargetPathSelected(const FilePath& target_path) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK_EQ(TARGET_DISPOSITION_PROMPT, target_disposition_);\n  target_path_ = target_path;\n}\n",
        "target": 0
    },
    {
        "id": 645,
        "func": "void V8TestObject::LimitedToOnlyOtherAttributeAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_limitedToOnlyOtherAttribute_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  test_object_v8_internal::LimitedToOnlyOtherAttributeAttributeSetter(v8_value, info);\n}\n",
        "target": 0
    },
    {
        "id": 646,
        "func": "bool IsSensitiveURL(const GURL& url,\n                    bool is_request_from_browser_or_webui_renderer) {\n  bool sensitive_chrome_url = false;\n  const char kGoogleCom[] = \"google.com\";\n  const char kClient[] = \"clients\";\n  url::Origin origin = url::Origin::Create(url);\n  if (origin.DomainIs(kGoogleCom)) {\n    base::StringPiece host = url.host_piece();\n    while (host.ends_with(\".\"))\n      host.remove_suffix(1u);\n    if (is_request_from_browser_or_webui_renderer) {\n      base::StringPiece::size_type pos = host.rfind(kClient);\n      if (pos != base::StringPiece::npos) {\n        bool match = true;\n        if (pos > 0 && host[pos - 1] != '.') {\n          match = false;\n        } else {\n          for (base::StringPiece::const_iterator\n                   i = host.begin() + pos + strlen(kClient),\n                   end = host.end() - (strlen(kGoogleCom) + 1);\n               i != end; ++i) {\n            if (!isdigit(*i)) {\n              match = false;\n              break;\n            }\n          }\n        }\n        sensitive_chrome_url = sensitive_chrome_url || match;\n      }\n    }\n\n    sensitive_chrome_url = sensitive_chrome_url ||\n                           (url.DomainIs(\"chrome.google.com\") &&\n                             base::StartsWith(url.path_piece(), \"/webstore\",\n                                              base::CompareCase::SENSITIVE));\n   }\n   return sensitive_chrome_url || extension_urls::IsWebstoreUpdateUrl(url) ||\n          extension_urls::IsBlacklistUpdateUrl(url) ||\n          extension_urls::IsSafeBrowsingUrl(origin, url.path_piece());\n}\n",
        "target": 1
    },
    {
        "id": 647,
        "func": "PHP_FUNCTION(dns_check_record)\n{\n#ifndef MAXPACKET\n#define MAXPACKET  8192 /* max packet size used internally by BIND */\n#endif\n\tu_char ans[MAXPACKET];\n\tchar *hostname, *rectype = NULL;\n\tint hostname_len, rectype_len = 0;\n\tint type = T_MX, i;\n#if defined(HAVE_DNS_SEARCH)\n\tstruct sockaddr_storage from;\n\tuint32_t fromsize = sizeof(from);\n\tdns_handle_t handle;\n#elif defined(HAVE_RES_NSEARCH)\n\tstruct __res_state state;\n\tstruct __res_state *handle = &state;\n#endif\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\", &hostname, &hostname_len, &rectype, &rectype_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (hostname_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Host cannot be empty\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rectype) {\n\t\tif (!strcasecmp(\"A\",     rectype)) type = T_A;\n\t\telse if (!strcasecmp(\"NS\",    rectype)) type = DNS_T_NS;\n\t\telse if (!strcasecmp(\"MX\",    rectype)) type = DNS_T_MX;\n\t\telse if (!strcasecmp(\"PTR\",   rectype)) type = DNS_T_PTR;\n\t\telse if (!strcasecmp(\"ANY\",   rectype)) type = DNS_T_ANY;\n\t\telse if (!strcasecmp(\"SOA\",   rectype)) type = DNS_T_SOA;\n\t\telse if (!strcasecmp(\"TXT\",   rectype)) type = DNS_T_TXT;\n\t\telse if (!strcasecmp(\"CNAME\", rectype)) type = DNS_T_CNAME;\n\t\telse if (!strcasecmp(\"AAAA\",  rectype)) type = DNS_T_AAAA;\n\t\telse if (!strcasecmp(\"SRV\",   rectype)) type = DNS_T_SRV;\n\t\telse if (!strcasecmp(\"NAPTR\", rectype)) type = DNS_T_NAPTR;\n\t\telse if (!strcasecmp(\"A6\",    rectype)) type = DNS_T_A6;\n\t\telse {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Type '%s' not supported\", rectype);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n#if defined(HAVE_DNS_SEARCH)\n\thandle = dns_open(NULL);\n\tif (handle == NULL) {\n\t\tRETURN_FALSE;\n\t}\n#elif defined(HAVE_RES_NSEARCH)\n    memset(&state, 0, sizeof(state));\n    if (res_ninit(handle)) {\n\t\t\tRETURN_FALSE;\n\t}\n#else\n\tres_init();\n#endif\n\n\tRETVAL_TRUE;\n\ti = php_dns_search(handle, hostname, C_IN, type, ans, sizeof(ans));\n\n\tif (i < 0) {\n\t\tRETVAL_FALSE;\n\t}\n\n\tphp_dns_free_handle(handle);\n}",
        "target": 0
    },
    {
        "id": 648,
        "func": "int64 MockRenderThread::GetIdleNotificationDelayInMs() const {\n  return 0;\n}\n",
        "target": 0
    },
    {
        "id": 649,
        "func": "bool AudioContext::tryLock()\n{\n    ASSERT(isAudioThread());\n    if (!isAudioThread()) {\n        lock();\n        return true;\n    }\n    return m_contextGraphMutex.tryLock();\n}\n",
        "target": 0
    },
    {
        "id": 650,
        "func": "void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   if (state_ == WORKER_READY) {\n     if (sessions().size() == 1) {\n       BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                              base::BindOnce(&SetDevToolsAttachedOnIO,\n                                             context_weak_, version_id_, true));\n    }\n    session->SetRenderer(worker_process_id_, nullptr);\n    session->AttachToAgent(agent_ptr_);\n  }\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n }\n",
        "target": 1
    },
    {
        "id": 651,
        "func": "void LayoutBlockFlow::deleteLineBoxTree()\n{\n    if (containsFloats())\n        m_floatingObjects->clearLineBoxTreePointers();\n\n    m_lineBoxes.deleteLineBoxTree();\n}\n",
        "target": 0
    },
    {
        "id": 652,
        "func": "isis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}",
        "target": 1
    },
    {
        "id": 653,
        "func": "ZSTD_encodeSequences_bmi2(\n            void* dst, size_t dstCapacity,\n            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,\n            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,\n            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,\n            seqDef const* sequences, size_t nbSeq, int longOffsets)\n{\n    return ZSTD_encodeSequences_body(dst, dstCapacity,\n                                    CTable_MatchLength, mlCodeTable,\n                                    CTable_OffsetBits, ofCodeTable,\n                                    CTable_LitLength, llCodeTable,\n                                    sequences, nbSeq, longOffsets);\n}\n",
        "target": 0
    },
    {
        "id": 654,
        "func": "static bool check_caller_access_to_node(struct fuse* fuse,\n const struct fuse_in_header *hdr, const struct node* node, int mode) {\n return check_caller_access_to_name(fuse, hdr, node->parent, node->name, mode);\n}\n",
        "target": 0
    },
    {
        "id": 655,
        "func": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\n\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n}",
        "target": 1
    },
    {
        "id": 656,
        "func": "static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i < max && buf[i] != eoc) {\n\t\t// TODO: calc the expresion with the bytcode (ESIL?)\n\t\ti += 1;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}",
        "target": 1
    },
    {
        "id": 657,
        "func": "bool WebGL2RenderingContextBase::IsBufferBoundToNonTransformFeedback(\n    WebGLBuffer* buffer) {\n  DCHECK(buffer);\n\n  if (bound_array_buffer_ == buffer ||\n      bound_vertex_array_object_->BoundElementArrayBuffer() == buffer ||\n      bound_copy_read_buffer_ == buffer || bound_copy_write_buffer_ == buffer ||\n      bound_pixel_pack_buffer_ == buffer ||\n      bound_pixel_unpack_buffer_ == buffer || bound_uniform_buffer_ == buffer) {\n    return true;\n  }\n\n  for (size_t i = 0; i <= max_bound_uniform_buffer_index_; ++i) {\n    if (bound_indexed_uniform_buffers_[i] == buffer)\n      return true;\n  }\n\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 658,
        "func": "void StreamTcpSetSessionNoReassemblyFlag (TcpSession *ssn, char direction)\n{\n    ssn->flags |= STREAMTCP_FLAG_APP_LAYER_DISABLED;\n    if (direction) {\n        ssn->server.flags |= STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED;\n    } else {\n        ssn->client.flags |= STREAMTCP_STREAM_FLAG_NEW_RAW_DISABLED;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 659,
        "func": " bool AddInitialUrlToPreconnectPrediction(const GURL& initial_url,\n                                          PreconnectPrediction* prediction) {\n  GURL initial_origin = initial_url.GetOrigin();\n  static const int kMinSockets = 2;\n\n  if (!prediction->requests.empty() &&\n       prediction->requests.front().origin == initial_origin) {\n     prediction->requests.front().num_sockets =\n         std::max(prediction->requests.front().num_sockets, kMinSockets);\n  } else if (initial_origin.is_valid() &&\n             initial_origin.SchemeIsHTTPOrHTTPS()) {\n    url::Origin origin = url::Origin::Create(initial_origin);\n    prediction->requests.emplace(prediction->requests.begin(), initial_origin,\n                                 kMinSockets,\n                                 net::NetworkIsolationKey(origin, origin));\n   }\n \n   return !prediction->requests.empty();\n}\n",
        "target": 1
    },
    {
        "id": 660,
        "func": "\nunsigned char *pskb_put(struct sk_buff *skb, struct sk_buff *tail, int len)\n{\n\tif (tail != skb) {\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t}\n\treturn skb_put(tail, len);",
        "target": 0
    },
    {
        "id": 661,
        "func": "void remount_all_slave(void)\n{\n\t/* walk /proc/mounts and change any shared entries to slave */\n\tFILE *f = fopen(\"/proc/self/mountinfo\", \"r\");\n\tchar *line = NULL;\n\tsize_t len = 0;\n\n\tif (!f) {\n\t\tSYSERROR(\"Failed to open /proc/self/mountinfo to mark all shared\");\n\t\tERROR(\"Continuing container startup...\");\n\t\treturn;\n\t}\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *target, *opts;\n\t\ttarget = get_field(line, 4);\n\t\tif (!target)\n\t\t\tcontinue;\n\t\topts = get_field(target, 2);\n\t\tif (!opts)\n\t\t\tcontinue;\n\t\tnull_endofword(opts);\n\t\tif (!strstr(opts, \"shared\"))\n\t\t\tcontinue;\n\t\tnull_endofword(target);\n\t\tif (mount(NULL, target, NULL, MS_SLAVE, NULL)) {\n\t\t\tSYSERROR(\"Failed to make %s rslave\", target);\n\t\t\tERROR(\"Continuing...\");\n\t\t}\n\t}\n\tfclose(f);\n\tfree(line);\n}",
        "target": 0
    },
    {
        "id": 662,
        "func": "void GamepadProvider::PlayVibrationEffectOnce(\n    int pad_index,\n    mojom::GamepadHapticEffectType type,\n    mojom::GamepadEffectParametersPtr params,\n    mojom::GamepadHapticsManager::PlayVibrationEffectOnceCallback callback) {\n  PadState* pad_state = GetConnectedPadState(pad_index);\n  if (!pad_state) {\n    std::move(callback).Run(\n        mojom::GamepadHapticsResult::GamepadHapticsResultError);\n    return;\n  }\n\n  GamepadDataFetcher* fetcher = GetSourceGamepadDataFetcher(pad_state->source);\n  if (!fetcher) {\n    std::move(callback).Run(\n        mojom::GamepadHapticsResult::GamepadHapticsResultNotSupported);\n    return;\n  }\n\n  fetcher->PlayEffect(pad_state->source_id, type, std::move(params),\n                      std::move(callback));\n}\n",
        "target": 0
    },
    {
        "id": 663,
        "func": "static void fuse_status(struct fuse *fuse, __u64 unique, int err)\n{\n struct fuse_out_header hdr;\n    hdr.len = sizeof(hdr);\n    hdr.error = err;\n    hdr.unique = unique;\n    write(fuse->fd, &hdr, sizeof(hdr));\n}\n",
        "target": 0
    },
    {
        "id": 664,
        "func": "static void tty_ldisc_put(struct tty_ldisc *ld)\n{\n\tif (WARN_ON_ONCE(!ld))\n\t\treturn;\n\n\tput_ldops(ld->ops);\n\tkfree(ld);\n}",
        "target": 0
    },
    {
        "id": 665,
        "func": "GF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t} else {\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 666,
        "func": "   virtual void TearDown() {\n    message_loop_.RunAllPending();\n    client_.Stop();\n   }\n",
        "target": 1
    },
    {
        "id": 667,
        "func": "static v8::Handle<v8::Value> idbKeyCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.idbKey\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(RefPtr<IDBKey>, key, createIDBKeyFromValue(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     imp->idbKey(key.get());\n    return v8::Handle<v8::Value>();\n}\n",
        "target": 1
    },
    {
        "id": 668,
        "func": "  TexSubCoord3D(int _xoffset, int _yoffset, int _zoffset,\n                int _width, int _height, int _depth)\n      : xoffset(_xoffset),\n        yoffset(_yoffset),\n        zoffset(_zoffset),\n        width(_width),\n        height(_height),\n        depth(_depth) {}\n",
        "target": 0
    },
    {
        "id": 669,
        "func": "mm_auth_password(Authctxt *authctxt, char *password)\n{\n\tBuffer m;\n\tint authenticated = 0;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tbuffer_init(&m);\n\tbuffer_put_cstring(&m, password);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTHPASSWORD, &m);\n\n\tdebug3(\"%s: waiting for MONITOR_ANS_AUTHPASSWORD\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_AUTHPASSWORD, &m);\n\n\tauthenticated = buffer_get_int(&m);\n\n\tbuffer_free(&m);\n\n\tdebug3(\"%s: user %sauthenticated\",\n\t    __func__, authenticated ? \"\" : \"not \");\n\treturn (authenticated);\n}",
        "target": 0
    },
    {
        "id": 670,
        "func": "  const VertexAttribInfoList& GetEnabledVertexAttribInfos() const {\n    return enabled_vertex_attribs_;\n  }\n",
        "target": 0
    },
    {
        "id": 671,
        "func": "void PageSerializer::addFontToResources(FontResource* font)\n{\n    if (!font || !shouldAddURL(font->url()) || !font->isLoaded() || !font->resourceBuffer())\n        return;\n\n    RefPtr<SharedBuffer> data(font->resourceBuffer());\n\n    addToResources(font, data, font->url());\n}\n",
        "target": 0
    },
    {
        "id": 672,
        "func": "idna_strerror (Idna_rc rc)\n{\n  const char *p;\n\n  bindtextdomain (PACKAGE, LOCALEDIR);\n\n  switch (rc)\n    {\n    case IDNA_SUCCESS:\n      p = _(\"Success\");\n      break;\n\n    case IDNA_STRINGPREP_ERROR:\n      p = _(\"String preparation failed\");\n      break;\n\n    case IDNA_PUNYCODE_ERROR:\n      p = _(\"Punycode failed\");\n      break;\n\n    case IDNA_CONTAINS_NON_LDH:\n      p = _(\"Non-digit/letter/hyphen in input\");\n      break;\n\n    case IDNA_CONTAINS_MINUS:\n      p = _(\"Forbidden leading or trailing minus sign (`-')\");\n      break;\n\n    case IDNA_INVALID_LENGTH:\n      p = _(\"Output would be too large or too small\");\n      break;\n\n    case IDNA_NO_ACE_PREFIX:\n      p = _(\"Input does not start with ACE prefix (`xn--')\");\n      break;\n\n    case IDNA_ROUNDTRIP_VERIFY_ERROR:\n      p = _(\"String not idempotent under ToASCII\");\n      break;\n\n    case IDNA_CONTAINS_ACE_PREFIX:\n      p = _(\"Input already contain ACE prefix (`xn--')\");\n       break;\n \n     case IDNA_ICONV_ERROR:\n      p = _(\"System iconv failed\");\n       break;\n \n     case IDNA_MALLOC_ERROR:\n      p = _(\"Cannot allocate memory\");\n      break;\n\n    case IDNA_DLOPEN_ERROR:\n      p = _(\"System dlopen failed\");\n      break;\n\n    default:\n      p = _(\"Unknown error\");\n      break;\n    }\n\n  return p;\n}\n",
        "target": 1
    },
    {
        "id": 673,
        "func": "int ZEXPORT inflateInit_(strm, version, stream_size)\nz_streamp strm;\nconst char *version;\nint stream_size;\n{\n    return inflateInit2_(strm, DEF_WBITS, version, stream_size);\n}",
        "target": 0
    },
    {
        "id": 674,
        "func": "const uint16* GetPortFieldFromAddrinfo(const struct addrinfo* info) {\n  DCHECK(info);\n  const struct sockaddr* address = info->ai_addr;\n  DCHECK(address);\n  DCHECK_EQ(info->ai_family, address->sa_family);\n  return GetPortFieldFromSockaddr(address, info->ai_addrlen);\n}\n",
        "target": 0
    },
    {
        "id": 675,
        "func": "int SpdyProxyClientSocket::DoGenerateAuthToken() {\n  next_state_ = STATE_GENERATE_AUTH_TOKEN_COMPLETE;\n  return auth_->MaybeGenerateAuthToken(\n      &request_,\n      base::Bind(&SpdyProxyClientSocket::OnIOComplete,\n                 weak_factory_.GetWeakPtr()),\n      net_log_);\n}\n",
        "target": 0
    },
    {
        "id": 676,
        "func": "void SimulateNetworkServiceCrash() {\n  CHECK(base::FeatureList::IsEnabled(network::features::kNetworkService));\n  CHECK(!IsNetworkServiceRunningInProcess())\n      << \"Can't crash the network service if it's running in-process!\";\n  network::mojom::NetworkServiceTestPtr network_service_test;\n  ServiceManagerConnection::GetForProcess()->GetConnector()->BindInterface(\n      mojom::kNetworkServiceName, &network_service_test);\n\n  base::RunLoop run_loop(base::RunLoop::Type::kNestableTasksAllowed);\n  network_service_test.set_connection_error_handler(run_loop.QuitClosure());\n\n  network_service_test->SimulateCrash();\n  run_loop.Run();\n\n  FlushNetworkServiceInstanceForTesting();\n}\n",
        "target": 0
    },
    {
        "id": 677,
        "func": "void CoordinatorImpl::UnregisterClientProcess(\n    mojom::ClientProcess* client_process) {\n  QueuedRequest* request = GetCurrentRequest();\n  if (request != nullptr) {\n    auto it = request->pending_responses.begin();\n    while (it != request->pending_responses.end()) {\n      std::set<QueuedRequest::PendingResponse>::iterator current = it++;\n      if (current->client != client_process)\n        continue;\n      RemovePendingResponse(client_process, current->type);\n      request->failed_memory_dump_count++;\n    }\n    FinalizeGlobalMemoryDumpIfAllManagersReplied();\n  }\n\n  for (auto& pair : in_progress_vm_region_requests_) {\n    QueuedVmRegionRequest* request = pair.second.get();\n    auto it = request->pending_responses.begin();\n    while (it != request->pending_responses.end()) {\n      auto current = it++;\n      if (*current == client_process) {\n        request->pending_responses.erase(current);\n      }\n    }\n  }\n\n  for (auto& pair : in_progress_vm_region_requests_) {\n    base::SequencedTaskRunnerHandle::Get()->PostTask(\n         FROM_HERE,\n         base::BindOnce(\n             &CoordinatorImpl::FinalizeVmRegionDumpIfAllManagersReplied,\n            base::Unretained(this), pair.second->dump_guid));\n   }\n \n   size_t num_deleted = clients_.erase(client_process);\n  DCHECK(num_deleted == 1);\n}\n",
        "target": 1
    },
    {
        "id": 678,
        "func": " int fpga_reset(void)\n {\n\tif (!check_boco2()) {\n\t\t/* we do not have BOCO2, this is not really used */\n\t\treturn 0;\n\t}\n\tprintf(\"PCIe reset through GPIO7: \");\n\t/* apply PCIe reset via GPIO */\n\tkw_gpio_set_valid(KM_PEX_RST_GPIO_PIN, 1);\n\tkw_gpio_direction_output(KM_PEX_RST_GPIO_PIN, 1);\n\tkw_gpio_set_value(KM_PEX_RST_GPIO_PIN, 0);\n\tudelay(1000*10);\n\tkw_gpio_set_value(KM_PEX_RST_GPIO_PIN, 1);\n\tprintf(\" done\\n\");\n \treturn 0;\n }\n",
        "target": 1
    },
    {
        "id": 679,
        "func": "base::string16 CardUnmaskPromptViews::GetWindowTitle() const {\n  return controller_->GetWindowTitle();\n}\n",
        "target": 0
    },
    {
        "id": 680,
        "func": "Touch* Document::createTouch(DOMWindow* window,\n                             EventTarget* target,\n                             int identifier,\n                             double page_x,\n                             double page_y,\n                             double screen_x,\n                             double screen_y,\n                             double radius_x,\n                             double radius_y,\n                             float rotation_angle,\n                             float force) const {\n  if (!std::isfinite(page_x))\n    page_x = 0;\n  if (!std::isfinite(page_y))\n    page_y = 0;\n  if (!std::isfinite(screen_x))\n    screen_x = 0;\n  if (!std::isfinite(screen_y))\n    screen_y = 0;\n  if (!std::isfinite(radius_x))\n    radius_x = 0;\n  if (!std::isfinite(radius_y))\n    radius_y = 0;\n  if (!std::isfinite(rotation_angle))\n    rotation_angle = 0;\n  if (!std::isfinite(force))\n    force = 0;\n\n  if (radius_x || radius_y || rotation_angle || force) {\n    UseCounter::Count(*this,\n                      WebFeature::kDocumentCreateTouchMoreThanSevenArguments);\n  }\n\n  LocalFrame* frame = window && window->IsLocalDOMWindow()\n                          ? blink::ToLocalDOMWindow(window)->GetFrame()\n                          : GetFrame();\n  return Touch::Create(\n      frame, target, identifier, FloatPoint(screen_x, screen_y),\n      FloatPoint(page_x, page_y), FloatSize(radius_x, radius_y), rotation_angle,\n      force, String());\n}\n",
        "target": 0
    },
    {
        "id": 681,
        "func": "void llc_sk_reset(struct sock *sk)\n{\n\tstruct llc_sock *llc = llc_sk(sk);\n\n\tllc_conn_ac_stop_all_timers(sk, NULL);\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&llc->pdu_unack_q);\n\tllc->remote_busy_flag\t= 0;\n\tllc->cause_flag\t\t= 0;\n\tllc->retry_count\t= 0;\n\tllc_conn_set_p_flag(sk, 0);\n\tllc->f_flag\t\t= 0;\n\tllc->s_flag\t\t= 0;\n\tllc->ack_pf\t\t= 0;\n\tllc->first_pdu_Ns\t= 0;\n\tllc->ack_must_be_send\t= 0;\n\tllc->dec_step\t\t= 1;\n\tllc->inc_cntr\t\t= 2;\n\tllc->dec_cntr\t\t= 2;\n\tllc->X\t\t\t= 0;\n\tllc->failed_data_req\t= 0 ;\n\tllc->last_nr\t\t= 0;\n}",
        "target": 0
    },
    {
        "id": 682,
        "func": "static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect)\n{\n    HTTPContext *s = h->priv_data;\n    URLContext *old_hd = s->hd;\n    int64_t old_off = s->off;\n    uint8_t old_buf[BUFFER_SIZE];\n    int old_buf_size, ret;\n    AVDictionary *options = NULL;\n\n    if (whence == AVSEEK_SIZE)\n        return s->filesize;\n    else if (!force_reconnect &&\n             ((whence == SEEK_CUR && off == 0) ||\n              (whence == SEEK_SET && off == s->off)))\n        return s->off;\n    else if ((s->filesize == -1 && whence == SEEK_END))\n        return AVERROR(ENOSYS);\n\n    if (whence == SEEK_CUR)\n        off += s->off;\n    else if (whence == SEEK_END)\n        off += s->filesize;\n    else if (whence != SEEK_SET)\n        return AVERROR(EINVAL);\n    if (off < 0)\n        return AVERROR(EINVAL);\n    s->off = off;\n\n    if (s->off && h->is_streamed)\n        return AVERROR(ENOSYS);\n\n    /* we save the old context in case the seek fails */\n    old_buf_size = s->buf_end - s->buf_ptr;\n    memcpy(old_buf, s->buf_ptr, old_buf_size);\n    s->hd = NULL;\n\n    /* if it fails, continue on old connection */\n    if ((ret = http_open_cnx(h, &options)) < 0) {\n        av_dict_free(&options);\n        memcpy(s->buffer, old_buf, old_buf_size);\n        s->buf_ptr = s->buffer;\n        s->buf_end = s->buffer + old_buf_size;\n        s->hd      = old_hd;\n        s->off     = old_off;\n        return ret;\n    }\n    av_dict_free(&options);\n    ffurl_close(old_hd);\n    return off;\n}",
        "target": 1
    },
    {
        "id": 683,
        "func": "bool HTMLInputElement::RangeOverflow() const {\n  return willValidate() && input_type_->RangeOverflow(value());\n}\n",
        "target": 0
    },
    {
        "id": 684,
        "func": "static int snd_timer_s_start(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long njiff;\n\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tnjiff = (priv->last_jiffies = jiffies);\n\tif (priv->correction > timer->sticks - 1) {\n\t\tpriv->correction -= timer->sticks - 1;\n\t\tnjiff++;\n\t} else {\n\t\tnjiff += timer->sticks - priv->correction;\n\t\tpriv->correction = 0;\n\t}\n\tpriv->last_expires = njiff;\n\tmod_timer(&priv->tlist, njiff);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 685,
        "func": "static jlong GetAwDrawGLFunction(JNIEnv* env, const JavaParamRef<jclass>&) {\n  return reinterpret_cast<intptr_t>(&DrawGLFunction);\n}\n",
        "target": 0
    },
    {
        "id": 686,
        "func": "  ~ScopedMMap() {\n    if (munmap(mem_, len_) == -1) {\n      LOG_ERRNO(\"%s: munmap failed when trying to unmap zip file\\n\",\n                __FUNCTION__);\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 687,
        "func": "static void swevent_hlist_put(struct perf_event *event)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tswevent_hlist_put_cpu(event, cpu);\n}",
        "target": 0
    },
    {
        "id": 688,
        "func": "static void unix_destruct_scm(struct sk_buff *skb)\n{\n\tstruct scm_cookie scm;\n\tmemset(&scm, 0, sizeof(scm));\n\tscm.pid  = UNIXCB(skb).pid;\n\tscm.cred = UNIXCB(skb).cred;\n\tif (UNIXCB(skb).fp)\n\t\tunix_detach_fds(&scm, skb);\n\n\t/* Alas, it calls VFS */\n\t/* So fscking what? fput() had been SMP-safe since the last Summer */\n\tscm_destroy(&scm);\n\tsock_wfree(skb);\n}",
        "target": 0
    },
    {
        "id": 689,
        "func": "int ZEXPORT inflateReset(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    state->wsize = 0;\n    state->whave = 0;\n    state->wnext = 0;\n    return inflateResetKeep(strm);\n}",
        "target": 0
    },
    {
        "id": 690,
        "func": "void ResourceDispatcherHost::BeginRequestInternal(URLRequest* request) {\n  DCHECK(!request->is_pending());\n  ResourceDispatcherHostRequestInfo* info = InfoForRequest(request);\n\n  info->set_memory_cost(CalculateApproximateMemoryCost(request));\n  int memory_cost = IncrementOutstandingRequestsMemoryCost(info->memory_cost(),\n                                                           info->child_id());\n\n  if (memory_cost > max_outstanding_requests_cost_per_process_) {\n    request->SimulateError(net::ERR_INSUFFICIENT_RESOURCES);\n\n    GlobalRequestID global_id(info->child_id(), info->request_id());\n    pending_requests_[global_id] = request;\n    OnResponseCompleted(request);\n    return;\n  }\n\n  std::pair<int, int> pair_id(info->child_id(), info->route_id());\n  BlockedRequestMap::const_iterator iter = blocked_requests_map_.find(pair_id);\n  if (iter != blocked_requests_map_.end()) {\n    iter->second->push_back(request);\n    return;\n  }\n\n  GlobalRequestID global_id(info->child_id(), info->request_id());\n  pending_requests_[global_id] = request;\n\n  bool defer_start = false;\n  if (!info->resource_handler()->OnWillStart(\n          info->request_id(), request->url(),\n          &defer_start)) {\n    CancelRequest(info->child_id(), info->request_id(), false);\n    return;\n  }\n\n  if (!defer_start)\n    InsertIntoResourceQueue(request, *info);\n}\n",
        "target": 0
    },
    {
        "id": 691,
        "func": "cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)\n{\n    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));\n\n    if (v == NULL) return NULL;\n\n    v ->List      = NULL;\n    v ->nColors   = 0;\n    v ->ContextID  = ContextID;\n\n    while (v -> Allocated < n)\n        GrowNamedColorList(v);\n\n    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));\n    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));\n    v->Prefix[32] = v->Suffix[32] = 0;\n\n    v -> ColorantCount = ColorantCount;\n\n    return v;\n}",
        "target": 1
    },
    {
        "id": 692,
        "func": "int32 CommandBufferProxyImpl::CreateTransferBuffer(\n    size_t size, int32 id_request) {\n  if (last_state_.error != gpu::error::kNoError)\n    return -1;\n\n  scoped_ptr<base::SharedMemory> shm(\n      channel_->factory()->AllocateSharedMemory(size));\n  if (!shm.get())\n     return -1;\n \n   base::SharedMemoryHandle handle = shm->handle();\n#if defined(OS_POSIX)\n   DCHECK(!handle.auto_close);\n #endif\n \n  int32 id;\n  if (!Send(new GpuCommandBufferMsg_RegisterTransferBuffer(route_id_,\n                                                           handle,\n                                                           size,\n                                                           id_request,\n                                                           &id))) {\n    return -1;\n  }\n\n  return id;\n}\n",
        "target": 1
    },
    {
        "id": 693,
        "func": "mojom::CommitResult FrameLoader::CommitSameDocumentNavigation(\n    const KURL& url,\n    WebFrameLoadType frame_load_type,\n    HistoryItem* history_item,\n    ClientRedirectPolicy client_redirect_policy,\n    Document* origin_document,\n    bool has_event,\n    std::unique_ptr<WebDocumentLoader::ExtraData> extra_data) {\n  DCHECK(!IsReloadLoadType(frame_load_type));\n  DCHECK(frame_->GetDocument());\n\n  if (in_stop_all_loaders_)\n    return mojom::CommitResult::Aborted;\n\n  bool history_navigation = IsBackForwardLoadType(frame_load_type);\n\n  if (!frame_->IsNavigationAllowed() && history_navigation)\n    return mojom::CommitResult::Aborted;\n\n  if (!history_navigation) {\n    if (!url.HasFragmentIdentifier() ||\n        !EqualIgnoringFragmentIdentifier(frame_->GetDocument()->Url(), url) ||\n        frame_->GetDocument()->IsFrameSet()) {\n      return mojom::CommitResult::RestartCrossDocument;\n    }\n  }\n\n  DCHECK(history_item || !history_navigation);\n  scoped_refptr<SerializedScriptValue> state_object =\n      history_navigation ? history_item->StateObject() : nullptr;\n\n  if (!history_navigation) {\n    document_loader_->SetNavigationType(\n        DetermineNavigationType(frame_load_type, false, has_event));\n    if (ShouldTreatURLAsSameAsCurrent(url))\n      frame_load_type = WebFrameLoadType::kReplaceCurrentItem;\n  }\n\n  LoadInSameDocument(url, state_object, frame_load_type, history_item,\n                     client_redirect_policy, origin_document,\n                     std::move(extra_data));\n  return mojom::CommitResult::Ok;\n}\n",
        "target": 0
    },
    {
        "id": 694,
        "func": " xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    if (cur != NULL) {\n        if ((cur->type == XML_ATTRIBUTE_NODE) ||\n            (cur->type == XML_NAMESPACE_DECL))\n             return(NULL);\n        if (cur->children != NULL)\n            return cur->children ;\n     }\n    if (cur == NULL) cur = ctxt->context->node;\n     if (cur == NULL) return(NULL) ; /* ERROR */\n     if (cur->next != NULL) return(cur->next) ;\n     do {\n        cur = cur->parent;\n        if (cur == NULL) break;\n        if (cur == (xmlNodePtr) ctxt->context->doc) return(NULL);\n        if (cur->next != NULL) return(cur->next);\n    } while (cur != NULL);\n    return(cur);\n}\n",
        "target": 1
    },
    {
        "id": 695,
        "func": "GpuChannel::GpuChannel(GpuChannelManager* gpu_channel_manager,\n                       GpuWatchdog* watchdog,\n                       gfx::GLShareGroup* share_group,\n                       int client_id,\n                        bool software)\n     : gpu_channel_manager_(gpu_channel_manager),\n       client_id_(client_id),\n      renderer_process_(base::kNullProcessHandle),\n      renderer_pid_(base::kNullProcessId),\n       share_group_(share_group ? share_group : new gfx::GLShareGroup),\n       watchdog_(watchdog),\n       software_(software),\n      handle_messages_scheduled_(false),\n      processed_get_state_fast_(false),\n      num_contexts_preferring_discrete_gpu_(0),\n      weak_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {\n  DCHECK(gpu_channel_manager);\n  DCHECK(client_id);\n\n  channel_id_ = IPC::Channel::GenerateVerifiedChannelID(\"gpu\");\n  const CommandLine* command_line = CommandLine::ForCurrentProcess();\n  log_messages_ = command_line->HasSwitch(switches::kLogPluginMessages);\n  disallowed_features_.multisampling =\n      command_line->HasSwitch(switches::kDisableGLMultisampling);\n  disallowed_features_.driver_bug_workarounds =\n      command_line->HasSwitch(switches::kDisableGpuDriverBugWorkarounds);\n }\n",
        "target": 1
    },
    {
        "id": 696,
        "func": "long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct file *eventfp, *filep = NULL;\n\tstruct eventfd_ctx *ctx = NULL;\n\tu64 p;\n\tlong r;\n\tint i, fd;\n\n\t/* If you are not the owner, you can become one */\n\tif (ioctl == VHOST_SET_OWNER) {\n\t\tr = vhost_dev_set_owner(d);\n\t\tgoto done;\n\t}\n\n\t/* You must be the owner to do anything else */\n\tr = vhost_dev_check_owner(d);\n\tif (r)\n\t\tgoto done;\n\n\tswitch (ioctl) {\n\tcase VHOST_SET_MEM_TABLE:\n\t\tr = vhost_set_memory(d, argp);\n\t\tbreak;\n\tcase VHOST_SET_LOG_BASE:\n\t\tif (copy_from_user(&p, argp, sizeof p)) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif ((u64)(unsigned long)p != p) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < d->nvqs; ++i) {\n\t\t\tstruct vhost_virtqueue *vq;\n\t\t\tvoid __user *base = (void __user *)(unsigned long)p;\n\t\t\tvq = d->vqs + i;\n\t\t\tmutex_lock(&vq->mutex);\n\t\t\t/* If ring is inactive, will check when it's enabled. */\n\t\t\tif (vq->private_data && !vq_log_access_ok(d, vq, base))\n\t\t\t\tr = -EFAULT;\n\t\t\telse\n\t\t\t\tvq->log_base = base;\n\t\t\tmutex_unlock(&vq->mutex);\n\t\t}\n\t\tbreak;\n\tcase VHOST_SET_LOG_FD:\n\t\tr = get_user(fd, (int __user *)argp);\n\t\tif (r < 0)\n\t\t\tbreak;\n\t\teventfp = fd == -1 ? NULL : eventfd_fget(fd);\n\t\tif (IS_ERR(eventfp)) {\n\t\t\tr = PTR_ERR(eventfp);\n\t\t\tbreak;\n\t\t}\n\t\tif (eventfp != d->log_file) {\n\t\t\tfilep = d->log_file;\n\t\t\tctx = d->log_ctx;\n\t\t\td->log_ctx = eventfp ?\n\t\t\t\teventfd_ctx_fileget(eventfp) : NULL;\n\t\t} else\n\t\t\tfilep = eventfp;\n\t\tfor (i = 0; i < d->nvqs; ++i) {\n\t\t\tmutex_lock(&d->vqs[i].mutex);\n\t\t\td->vqs[i].log_ctx = d->log_ctx;\n\t\t\tmutex_unlock(&d->vqs[i].mutex);\n\t\t}\n\t\tif (ctx)\n\t\t\teventfd_ctx_put(ctx);\n\t\tif (filep)\n\t\t\tfput(filep);\n\t\tbreak;\n\tdefault:\n\t\tr = vhost_set_vring(d, ioctl, argp);\n\t\tbreak;\n\t}\ndone:\n\treturn r;\n}",
        "target": 0
    },
    {
        "id": 697,
        "func": "long __sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = ___sys_recvmsg(sock, msg, &msg_sys, flags, 0);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 698,
        "func": "  virtual InputMethodDescriptors* GetActiveInputMethods() {\n     return GetInputMethodDescriptorsForTesting();\n   }\n",
        "target": 1
    },
    {
        "id": 699,
        "func": "WebFileSystem* LocalFileSystem::fileSystem() const\n{\n    Platform* platform = Platform::current();\n    if (!platform)\n        return nullptr;\n    return Platform::current()->fileSystem();\n}\n",
        "target": 0
    },
    {
        "id": 700,
        "func": "void hci_uart_set_flow_control(struct hci_uart *hu, bool enable)\n{\n\tstruct tty_struct *tty = hu->tty;\n\tstruct ktermios ktermios;\n\tint status;\n\tunsigned int set = 0;\n\tunsigned int clear = 0;\n\n\tif (hu->serdev) {\n\t\tserdev_device_set_flow_control(hu->serdev, !enable);\n\t\tserdev_device_set_rts(hu->serdev, !enable);\n\t\treturn;\n\t}\n\n\tif (enable) {\n\t\t/* Disable hardware flow control */\n\t\tktermios = tty->termios;\n\t\tktermios.c_cflag &= ~CRTSCTS;\n\t\tstatus = tty_set_termios(tty, &ktermios);\n\t\tBT_DBG(\"Disabling hardware flow control: %s\",\n\t\t       status ? \"failed\" : \"success\");\n\n\t\t/* Clear RTS to prevent the device from sending */\n\t\t/* Most UARTs need OUT2 to enable interrupts */\n\t\tstatus = tty->driver->ops->tiocmget(tty);\n\t\tBT_DBG(\"Current tiocm 0x%x\", status);\n\n\t\tset &= ~(TIOCM_OUT2 | TIOCM_RTS);\n\t\tclear = ~set;\n\t\tset &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t       TIOCM_OUT2 | TIOCM_LOOP;\n\t\tclear &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t\t TIOCM_OUT2 | TIOCM_LOOP;\n\t\tstatus = tty->driver->ops->tiocmset(tty, set, clear);\n\t\tBT_DBG(\"Clearing RTS: %s\", status ? \"failed\" : \"success\");\n\t} else {\n\t\t/* Set RTS to allow the device to send again */\n\t\tstatus = tty->driver->ops->tiocmget(tty);\n\t\tBT_DBG(\"Current tiocm 0x%x\", status);\n\n\t\tset |= (TIOCM_OUT2 | TIOCM_RTS);\n\t\tclear = ~set;\n\t\tset &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t       TIOCM_OUT2 | TIOCM_LOOP;\n\t\tclear &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t\t TIOCM_OUT2 | TIOCM_LOOP;\n\t\tstatus = tty->driver->ops->tiocmset(tty, set, clear);\n\t\tBT_DBG(\"Setting RTS: %s\", status ? \"failed\" : \"success\");\n\n\t\t/* Re-enable hardware flow control */\n\t\tktermios = tty->termios;\n\t\tktermios.c_cflag |= CRTSCTS;\n\t\tstatus = tty_set_termios(tty, &ktermios);\n\t\tBT_DBG(\"Enabling hardware flow control: %s\",\n\t\t       status ? \"failed\" : \"success\");\n\t}\n}",
        "target": 0
    },
    {
        "id": 701,
        "func": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tstruct user_struct *user;\n\tint ret;\n\n\t/* Check the IN_* constants for consistency.  */\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tuser = get_current_user();\n\tif (unlikely(atomic_read(&user->inotify_devs) >=\n\t\t\tinotify_max_user_instances)) {\n\t\tret = -EMFILE;\n\t\tgoto out_free_uid;\n\t}\n\n\t/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */\n\tgroup = inotify_new_group(user, inotify_max_queued_events);\n\tif (IS_ERR(group)) {\n\t\tret = PTR_ERR(group);\n\t\tgoto out_free_uid;\n\t}\n\n\tatomic_inc(&user->inotify_devs);\n\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\nout_free_uid:\n\tfree_uid(user);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 702,
        "func": "static inline struct ipv6_opt_hdr *ip6_opt_dup(struct ipv6_opt_hdr *src,\n\t\t\t\t\t       gfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}",
        "target": 0
    },
    {
        "id": 703,
        "func": "void RTCPeerConnectionHandler::associateWithFrame(blink::WebLocalFrame* frame) {\n  DCHECK(task_runner_->RunsTasksInCurrentSequence());\n  DCHECK(frame);\n  frame_ = frame;\n}\n",
        "target": 0
    },
    {
        "id": 704,
        "func": "void __init hugetlb_add_hstate(unsigned order)\n{\n\tstruct hstate *h;\n\tunsigned long i;\n\n\tif (size_to_hstate(PAGE_SIZE << order)) {\n\t\tprintk(KERN_WARNING \"hugepagesz= specified twice, ignoring\\n\");\n\t\treturn;\n\t}\n\tBUG_ON(max_hstate >= HUGE_MAX_HSTATE);\n\tBUG_ON(order == 0);\n\th = &hstates[max_hstate++];\n\th->order = order;\n\th->mask = ~((1ULL << (order + PAGE_SHIFT)) - 1);\n\th->nr_huge_pages = 0;\n\th->free_huge_pages = 0;\n\tfor (i = 0; i < MAX_NUMNODES; ++i)\n\t\tINIT_LIST_HEAD(&h->hugepage_freelists[i]);\n\th->next_nid_to_alloc = first_node(node_states[N_HIGH_MEMORY]);\n\th->next_nid_to_free = first_node(node_states[N_HIGH_MEMORY]);\n\tsnprintf(h->name, HSTATE_NAME_LEN, \"hugepages-%lukB\",\n\t\t\t\t\thuge_page_size(h)/1024);\n\n\tparsed_hstate = h;\n}",
        "target": 0
    },
    {
        "id": 705,
        "func": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 706,
        "func": "void BaseRenderingContext2D::Reset() {\n  ValidateStateStack();\n  UnwindStateStack();\n  state_stack_.resize(1);\n  state_stack_.front() = CanvasRenderingContext2DState::Create();\n  path_.Clear();\n  if (PaintCanvas* c = ExistingDrawingCanvas()) {\n    DCHECK_EQ(c->getSaveCount(), 2);\n    c->restore();\n    c->save();\n    DCHECK(c->getTotalMatrix().isIdentity());\n#if DCHECK_IS_ON()\n    SkIRect clip_bounds;\n    DCHECK(c->getDeviceClipBounds(&clip_bounds));\n    DCHECK(clip_bounds == c->imageInfo().bounds());\n #endif\n   }\n   ValidateStateStack();\n  origin_tainted_by_content_ = false;\n }\n",
        "target": 0
    },
    {
        "id": 707,
        "func": "FormAssociatedElement::FormAssociatedElement()\n    : m_form(0)\n{\n}\n",
        "target": 0
    },
    {
        "id": 708,
        "func": "int32_t PepperFlashRendererHost::OnGetProxyForURL(\n    ppapi::host::HostMessageContext* host_context,\n    const std::string& url) {\n  GURL gurl(url);\n  if (!gurl.is_valid())\n    return PP_ERROR_FAILED;\n  std::string proxy;\n  bool result = content::RenderThread::Get()->ResolveProxy(gurl, &proxy);\n  if (!result)\n    return PP_ERROR_FAILED;\n  host_context->reply_msg = PpapiPluginMsg_Flash_GetProxyForURLReply(proxy);\n  return PP_OK;\n}\n",
        "target": 0
    },
    {
        "id": 709,
        "func": "static VOID ParaNdis_DeviceFiltersUpdateRxMode(PARANDIS_ADAPTER *pContext)\n{\n    u8 val;\n    ULONG f = pContext->PacketFilter;\n    val = (f & NDIS_PACKET_TYPE_ALL_MULTICAST) ? 1 : 0;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_ALLMULTI, &val, sizeof(val), NULL, 0, 2);\n    //SendControlMessage(pContext, VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_ALLUNI, &val, sizeof(val), NULL, 0, 2);\n    val = (f & (NDIS_PACKET_TYPE_MULTICAST | NDIS_PACKET_TYPE_ALL_MULTICAST)) ? 0 : 1;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_NOMULTI, &val, sizeof(val), NULL, 0, 2);\n    val = (f & NDIS_PACKET_TYPE_DIRECTED) ? 0 : 1;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_NOUNI, &val, sizeof(val), NULL, 0, 2);\n    val = (f & NDIS_PACKET_TYPE_BROADCAST) ? 0 : 1;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_NOBCAST, &val, sizeof(val), NULL, 0, 2);\n    val = (f & NDIS_PACKET_TYPE_PROMISCUOUS) ? 1 : 0;\n    pContext->CXPath.SendControlMessage(VIRTIO_NET_CTRL_RX_MODE, VIRTIO_NET_CTRL_RX_MODE_PROMISC, &val, sizeof(val), NULL, 0, 2);\n}",
        "target": 0
    },
    {
        "id": 710,
        "func": " void PrintPreviewUI::OnReloadPrintersList() {\n   web_ui()->CallJavascriptFunction(\"reloadPrintersList\");\n }\n",
        "target": 0
    },
    {
        "id": 711,
        "func": "static void btif_in_storage_request_copy_cb(UINT16 event,\n char *p_new_buf, char *p_old_buf)\n{\n btif_storage_req_t *new_req = (btif_storage_req_t*)p_new_buf;\n btif_storage_req_t *old_req = (btif_storage_req_t*)p_old_buf;\n\n     BTIF_TRACE_EVENT(\"%s\", __FUNCTION__);\n switch (event)\n {\n case BTIF_CORE_STORAGE_REMOTE_WRITE:\n case BTIF_CORE_STORAGE_ADAPTER_WRITE:\n {\n             bdcpy(new_req->write_req.bd_addr.address, old_req->write_req.bd_addr.address);\n /* Copy the member variables one at a time */\n             new_req->write_req.prop.type = old_req->write_req.prop.type;\n             new_req->write_req.prop.len = old_req->write_req.prop.len;\n\n             new_req->write_req.prop.val = (UINT8 *)(p_new_buf + sizeof(btif_storage_req_t));\n             memcpy(new_req->write_req.prop.val, old_req->write_req.prop.val,\n                    old_req->write_req.prop.len);\n }break;\n }\n}\n",
        "target": 0
    },
    {
        "id": 712,
        "func": "AppModalDialog::AppModalDialog(WebContents* web_contents, const string16& title)\n     : valid_(true),\n       native_dialog_(NULL),\n       title_(title),\n      web_contents_(web_contents) {\n }\n",
        "target": 1
    },
    {
        "id": 713,
        "func": "static void cma_bind_port(struct rdma_bind_list *bind_list,\n\t\t\t  struct rdma_id_private *id_priv)\n{\n\tstruct sockaddr *addr;\n\tstruct sockaddr_ib *sib;\n\tu64 sid, mask;\n\t__be16 port;\n\n\taddr = cma_src_addr(id_priv);\n\tport = htons(bind_list->port);\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *) addr)->sin_port = port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *) addr)->sin6_port = port;\n\t\tbreak;\n\tcase AF_IB:\n\t\tsib = (struct sockaddr_ib *) addr;\n\t\tsid = be64_to_cpu(sib->sib_sid);\n\t\tmask = be64_to_cpu(sib->sib_sid_mask);\n\t\tsib->sib_sid = cpu_to_be64((sid & mask) | (u64) ntohs(port));\n\t\tsib->sib_sid_mask = cpu_to_be64(~0ULL);\n\t\tbreak;\n\t}\n\tid_priv->bind_list = bind_list;\n\thlist_add_head(&id_priv->node, &bind_list->owners);\n}",
        "target": 0
    },
    {
        "id": 714,
        "func": "static inline int check_io_access(struct pt_regs *regs)\n{\n#if defined(CONFIG_PPC_PMAC) && defined(CONFIG_PPC32)\n\tunsigned long msr = regs->msr;\n\tconst struct exception_table_entry *entry;\n\tunsigned int *nip = (unsigned int *)regs->nip;\n\n\tif (((msr & 0xffff0000) == 0 || (msr & (0x80000 | 0x40000)))\n\t    && (entry = search_exception_tables(regs->nip)) != NULL) {\n\t\t/*\n\t\t * Check that it's a sync instruction, or somewhere\n\t\t * in the twi; isync; nop sequence that inb/inw/inl uses.\n\t\t * As the address is in the exception table\n\t\t * we should be able to read the instr there.\n\t\t * For the debug message, we look at the preceding\n\t\t * load or store.\n\t\t */\n\t\tif (*nip == 0x60000000)\t\t/* nop */\n\t\t\tnip -= 2;\n\t\telse if (*nip == 0x4c00012c)\t/* isync */\n\t\t\t--nip;\n\t\tif (*nip == 0x7c0004ac || (*nip >> 26) == 3) {\n\t\t\t/* sync or twi */\n\t\t\tunsigned int rb;\n\n\t\t\t--nip;\n\t\t\trb = (*nip >> 11) & 0x1f;\n\t\t\tprintk(KERN_DEBUG \"%s bad port %lx at %p\\n\",\n\t\t\t       (*nip & 0x100)? \"OUT to\": \"IN from\",\n\t\t\t       regs->gpr[rb] - _IO_BASE, nip);\n\t\t\tregs->msr |= MSR_RI;\n\t\t\tregs->nip = entry->fixup;\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif /* CONFIG_PPC_PMAC && CONFIG_PPC32 */\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 715,
        "func": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 716,
        "func": "ppp_ccp_closed(struct ppp *ppp)\n{\n\tvoid *xstate, *rstate;\n\tstruct compressor *xcomp, *rcomp;\n\n\tppp_lock(ppp);\n\tppp->flags &= ~(SC_CCP_OPEN | SC_CCP_UP);\n\tppp->xstate = 0;\n\txcomp = ppp->xcomp;\n\txstate = ppp->xc_state;\n\tppp->xc_state = NULL;\n\tppp->rstate = 0;\n\trcomp = ppp->rcomp;\n\trstate = ppp->rc_state;\n\tppp->rc_state = NULL;\n\tppp_unlock(ppp);\n\n\tif (xstate) {\n\t\txcomp->comp_free(xstate);\n\t\tmodule_put(xcomp->owner);\n\t}\n\tif (rstate) {\n\t\trcomp->decomp_free(rstate);\n\t\tmodule_put(rcomp->owner);\n\t}\n}",
        "target": 0
    },
    {
        "id": 717,
        "func": " static int copy_cred(struct svc_cred *target, struct svc_cred *source)\n {\n\tint ret;\n \n\tret = strdup_if_nonnull(&target->cr_principal, source->cr_principal);\n\tif (ret)\n\t\treturn ret;\n\tret = strdup_if_nonnull(&target->cr_raw_principal,\n\t\t\t\t\tsource->cr_raw_principal);\n\tif (ret)\n\t\treturn ret;\n \ttarget->cr_flavor = source->cr_flavor;\n \ttarget->cr_uid = source->cr_uid;\n \ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}\n",
        "target": 1
    },
    {
        "id": 718,
        "func": "static unsigned long mmap_legacy_base(unsigned long rnd)\n{\n\tif (mmap_is_ia32())\n\t\treturn TASK_UNMAPPED_BASE;\n\telse\n\t\treturn TASK_UNMAPPED_BASE + rnd;\n}",
        "target": 1
    },
    {
        "id": 719,
        "func": "void InputMethodBase::OnBlur() {\n  DCHECK(system_toplevel_window_focused_);\n  system_toplevel_window_focused_ = false;\n}\n",
        "target": 0
    },
    {
        "id": 720,
        "func": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len && plen > 0); /* XXX */\n\n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}",
        "target": 0
    },
    {
        "id": 721,
        "func": "static sk_sp<SkImage> premulSkImageToUnPremul(SkImage* input) {\n  SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),\n                                       kN32_SkColorType, kUnpremul_SkAlphaType);\n  RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);\n  if (!dstPixels)\n     return nullptr;\n   return newSkImageFromRaster(\n       info, std::move(dstPixels),\n      static_cast<unsigned>(input->width()) * info.bytesPerPixel());\n }\n",
        "target": 0
    },
    {
        "id": 722,
        "func": " bool asn1_read_BOOLEAN_context(struct asn1_data *data, bool *v, int context)\n {\n        uint8_t tmp = 0;\n       asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(context));\n       asn1_read_uint8(data, &tmp);\n        if (tmp == 0xFF) {\n                *v = true;\n       } else {\n               *v = false;\n        }\n       asn1_end_tag(data);\n       return !data->has_error;\n }\n",
        "target": 1
    },
    {
        "id": 723,
        "func": "bool omx_vdec::ts_arr_list::pop_min_ts(OMX_TICKS &ts)\n{\n bool ret = true;\n int min_idx = -1;\n    OMX_TICKS min_ts = 0;\n int idx = 0;\n\n for ( ; idx < MAX_NUM_INPUT_OUTPUT_BUFFERS; idx++) {\n\n if (m_ts_arr_list[idx].valid) {\n if (min_idx < 0) {\n                min_ts = m_ts_arr_list[idx].timestamp;\n                min_idx = idx;\n } else if (m_ts_arr_list[idx].timestamp < min_ts) {\n                min_ts = m_ts_arr_list[idx].timestamp;\n                min_idx = idx;\n }\n }\n\n }\n\n if (min_idx < 0) {\n        DEBUG_PRINT_LOW(\"Timestamp array list is empty. Unsuccessful pop\");\n        ts = 0;\n        ret = false;\n } else {\n        ts = m_ts_arr_list[min_idx].timestamp;\n        m_ts_arr_list[min_idx].valid = false;\n        DEBUG_PRINT_LOW(\"Pop_min_ts:Timestamp (%lld), index(%d)\",\n                ts, min_idx);\n }\n\n return ret;\n\n}\n",
        "target": 0
    },
    {
        "id": 724,
        "func": "void ParaNdis_FreeRxBufferDescriptor(PARANDIS_ADAPTER *pContext, pRxNetDescriptor p)\n{\n    ULONG i;\n    for(i = 0; i < p->PagesAllocated; i++)\n    {\n        ParaNdis_FreePhysicalMemory(pContext, &p->PhysicalPages[i]);\n    }\n\n    if(p->BufferSGArray) NdisFreeMemory(p->BufferSGArray, 0, 0);\n    if(p->PhysicalPages) NdisFreeMemory(p->PhysicalPages, 0, 0);\n    NdisFreeMemory(p, 0, 0);\n}",
        "target": 0
    },
    {
        "id": 725,
        "func": "static void reflectTestInterfaceAttributeAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_VOID(TestInterface*, cppValue, V8TestInterface::toNativeWithTypeCheck(info.GetIsolate(), jsValue));\n    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;\n    imp->setAttribute(HTMLNames::reflecttestinterfaceattributeAttr, WTF::getPtr(cppValue));\n}\n",
        "target": 0
    },
    {
        "id": 726,
        "func": "bool ScriptController::processingUserGesture()\n{\n    return UserGestureIndicator::processingUserGesture();\n}\n",
        "target": 0
    },
    {
        "id": 727,
        "func": "static int iscsi_get_info(BlockDriverState *bs, BlockDriverInfo *bdi)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    bdi->unallocated_blocks_are_zero = iscsilun->lbprz;\n    bdi->can_write_zeroes_with_unmap = iscsilun->lbprz && iscsilun->lbp.lbpws;\n    bdi->cluster_size = iscsilun->cluster_sectors * BDRV_SECTOR_SIZE;\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 728,
        "func": "lzh_make_fake_table(struct huffman *hf, uint16_t c)\n{\n\tif (c >= hf->len_size)\n\t\treturn (0);\n\thf->tbl[0] = c;\n\thf->max_bits = 0;\n\thf->shift_bits = 0;\n\thf->bitlen[hf->tbl[0]] = 0;\n\treturn (1);\n}",
        "target": 0
    },
    {
        "id": 729,
        "func": "void blk_post_runtime_resume(struct request_queue *q, int err)\n{\n\tif (!q->dev)\n\t\treturn;\n\n\tspin_lock_irq(q->queue_lock);\n\tif (!err) {\n\t\tq->rpm_status = RPM_ACTIVE;\n\t\t__blk_run_queue(q);\n\t\tpm_runtime_mark_last_busy(q->dev);\n\t\tpm_request_autosuspend(q->dev);\n\t} else {\n\t\tq->rpm_status = RPM_SUSPENDED;\n\t}\n\tspin_unlock_irq(q->queue_lock);\n}",
        "target": 0
    },
    {
        "id": 730,
        "func": "void MediaControlTimelineElement::defaultEventHandler(Event* event) {\n  if (event->isMouseEvent() &&\n      toMouseEvent(event)->button() !=\n          static_cast<short>(WebPointerProperties::Button::Left))\n    return;\n\n  if (!isConnected() || !document().isActive())\n    return;\n\n  if (event->type() == EventTypeNames::mousedown) {\n    Platform::current()->recordAction(\n        UserMetricsAction(\"Media.Controls.ScrubbingBegin\"));\n    mediaControls().beginScrubbing();\n  }\n\n  if (event->type() == EventTypeNames::mouseup) {\n    Platform::current()->recordAction(\n        UserMetricsAction(\"Media.Controls.ScrubbingEnd\"));\n    mediaControls().endScrubbing();\n  }\n \n   MediaControlInputElement::defaultEventHandler(event);\n \n  if (event->type() == EventTypeNames::mouseover ||\n      event->type() == EventTypeNames::mouseout ||\n      event->type() == EventTypeNames::mousemove)\n     return;\n \n   double time = value().toDouble();\n  if (event->type() == EventTypeNames::input) {\n    if (mediaElement().seekable()->contain(time))\n      mediaElement().setCurrentTime(time);\n  }\n \n   LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject()));\n   if (!slider.isNull() && slider.inDragMode())\n    mediaControls().updateCurrentTimeDisplay();\n}\n",
        "target": 1
    },
    {
        "id": 731,
        "func": "static inline bool is_noncanonical_address(u64 la)\n{\n#ifdef CONFIG_X86_64\n\treturn get_canonical(la) != la;\n#else\n\treturn false;\n#endif\n}",
        "target": 0
    },
    {
        "id": 732,
        "func": "  bool IsAllowed(const scoped_refptr<const Extension>& extension,\n                 const GURL& url,\n                 PermittedFeature feature,\n                 int tab_id) {\n    const PermissionsData* permissions_data = extension->permissions_data();\n    bool script = permissions_data->CanAccessPage(extension.get(), url, tab_id,\n                                                   nullptr) &&\n                   permissions_data->CanRunContentScriptOnPage(\n                       extension.get(), url, tab_id, nullptr);\n    bool capture = permissions_data->CanCaptureVisiblePage(url, extension.get(),\n                                                           tab_id, NULL);\n     switch (feature) {\n       case PERMITTED_SCRIPT_ONLY:\n         return script && !capture;\n      case PERMITTED_CAPTURE_ONLY:\n        return capture && !script;\n      case PERMITTED_BOTH:\n        return script && capture;\n      case PERMITTED_NONE:\n        return !script && !capture;\n    }\n    NOTREACHED();\n    return false;\n  }\n",
        "target": 0
    },
    {
        "id": 733,
        "func": "static int check_port_resume_type(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int port1,\n\t\tint status, u16 portchange, u16 portstatus)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint retries = 3;\n\n retry:\n\t/* Is a warm reset needed to recover the connection? */\n\tif (status == 0 && udev->reset_resume\n\t\t&& hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\t/* pass */;\n\t}\n\t/* Is the device still present? */\n\telse if (status || port_is_suspended(hub, portstatus) ||\n\t\t\t!port_is_power_on(hub, portstatus)) {\n\t\tif (status >= 0)\n\t\t\tstatus = -ENODEV;\n\t} else if (!(portstatus & USB_PORT_STAT_CONNECTION)) {\n\t\tif (retries--) {\n\t\t\tusleep_range(200, 300);\n\t\t\tstatus = hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t\t\t     &portchange);\n\t\t\tgoto retry;\n\t\t}\n\t\tstatus = -ENODEV;\n\t}\n\n\t/* Can't do a normal resume if the port isn't enabled,\n\t * so try a reset-resume instead.\n\t */\n\telse if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume) {\n\t\tif (udev->persist_enabled)\n\t\t\tudev->reset_resume = 1;\n\t\telse\n\t\t\tstatus = -ENODEV;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"status %04x.%04x after resume, %d\\n\",\n\t\t\t\tportchange, portstatus, status);\n\t} else if (udev->reset_resume) {\n\n\t\t/* Late port handoff can set status-change bits */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t}\n\n\treturn status;\n}",
        "target": 0
    },
    {
        "id": 734,
        "func": "void PasswordAutofillManager::OnShowManualFallbackSuggestion(\n    base::i18n::TextDirection text_direction,\n    const gfx::RectF& bounds) {\n  if (!autofill_client_ || !ShouldShowManualFallbackForPreLollipop(\n                               autofill_client_->GetSyncService()))\n    return;\n  if (!password_client_ ||\n      !password_client_->IsFillingFallbackEnabledForCurrentPage())\n    return;\n  std::vector<autofill::Suggestion> suggestions;\n  autofill::Suggestion all_saved_passwords(\n      l10n_util::GetStringUTF8(IDS_AUTOFILL_SHOW_ALL_SAVED_FALLBACK),\n      std::string(), std::string(),\n      autofill::POPUP_ITEM_ID_ALL_SAVED_PASSWORDS_ENTRY);\n  suggestions.push_back(all_saved_passwords);\n\n  show_all_saved_passwords_shown_context_ =\n      metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_MANUAL_FALLBACK;\n  metrics_util::LogContextOfShowAllSavedPasswordsShown(\n      show_all_saved_passwords_shown_context_);\n\n  if (base::FeatureList::IsEnabled(\n          password_manager::features::kEnableManualFallbacksGeneration) &&\n      password_manager_util::GetPasswordSyncState(\n          autofill_client_->GetSyncService()) == SYNCING_NORMAL_ENCRYPTION) {\n    AddSimpleSuggestionWithSeparatorOnTop(\n        IDS_AUTOFILL_GENERATE_PASSWORD_FALLBACK,\n        autofill::POPUP_ITEM_ID_GENERATE_PASSWORD_ENTRY, &suggestions);\n  }\n  autofill_client_->ShowAutofillPopup(bounds, text_direction, suggestions,\n                                      weak_ptr_factory_.GetWeakPtr());\n}\n",
        "target": 0
    },
    {
        "id": 735,
        "func": "DH *ssl_get_auto_dh(SSL *s)\n\t{\n\tint dh_secbits = 80;\n\tif (s->cert->dh_tmp_auto == 2)\n\t\treturn DH_get_1024_160();\n\tif (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)\n\t\t{\n\t\tif (s->s3->tmp.new_cipher->strength_bits == 256)\n\t\t\tdh_secbits = 128;\n\t\telse\n\t\t\tdh_secbits = 80;\n\t\t}\n\telse\n\t\t{\n\t\tCERT_PKEY *cpk = ssl_get_server_send_pkey(s);\n\t\tdh_secbits = EVP_PKEY_security_bits(cpk->privatekey);\n\t\t}\n\n\tif (dh_secbits >= 128)\n\t\t{\n\t\tDH *dhp = DH_new();\n\t\tif (!dhp)\n\t\t\treturn NULL;\n\t\tdhp->g = BN_new();\n\t\tif (dhp->g)\n\t\t\tBN_set_word(dhp->g, 2);\n\t\tif (dh_secbits >= 192)\n\t\t\tdhp->p = get_rfc3526_prime_8192(NULL);\n\t\telse\n\t\t\tdhp->p = get_rfc3526_prime_3072(NULL);\n\t\tif (!dhp->p || !dhp->g)\n\t\t\t{\n\t\t\tDH_free(dhp);\n\t\t\treturn NULL;\n\t\t\t}\n\t\treturn dhp;\n\t\t}\n\tif (dh_secbits >= 112)\n\t\treturn DH_get_2048_224();\n\treturn DH_get_1024_160();\n\t}\n",
        "target": 0
    },
    {
        "id": 736,
        "func": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t}\n\telse if (rc == -ENODATA)\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\treturn rc;\n}",
        "target": 1
    },
    {
        "id": 737,
        "func": " transform_range_check(png_const_structp pp, unsigned int r, unsigned int g,\n    unsigned int b, unsigned int a, unsigned int in_digitized, double in,\n    unsigned int out, png_byte sample_depth, double err, double limit,\n   PNG_CONST char *name, double digitization_error)\n {\n    /* Compare the scaled, digitzed, values of our local calculation (in+-err)\n     * with the digitized values libpng produced;  'sample_depth' is the actual\n    * digitization depth of the libpng output colors (the bit depth except for\n    * palette images where it is always 8.)  The check on 'err' is to detect\n    * internal errors in pngvalid itself.\n    */\n unsigned int max = (1U<<sample_depth)-1;\n double in_min = ceil((in-err)*max - digitization_error);\n double in_max = floor((in+err)*max + digitization_error);\n if (err > limit || !(out >= in_min && out <= in_max))\n {\n char message[256];\n size_t pos;\n\n      pos = safecat(message, sizeof message, 0, name);\n      pos = safecat(message, sizeof message, pos, \" output value error: rgba(\");\n      pos = safecatn(message, sizeof message, pos, r);\n      pos = safecat(message, sizeof message, pos, \",\");\n      pos = safecatn(message, sizeof message, pos, g);\n      pos = safecat(message, sizeof message, pos, \",\");\n      pos = safecatn(message, sizeof message, pos, b);\n      pos = safecat(message, sizeof message, pos, \",\");\n      pos = safecatn(message, sizeof message, pos, a);\n      pos = safecat(message, sizeof message, pos, \"): \");\n      pos = safecatn(message, sizeof message, pos, out);\n      pos = safecat(message, sizeof message, pos, \" expected: \");\n      pos = safecatn(message, sizeof message, pos, in_digitized);\n      pos = safecat(message, sizeof message, pos, \" (\");\n      pos = safecatd(message, sizeof message, pos, (in-err)*max, 3);\n      pos = safecat(message, sizeof message, pos, \"..\");\n      pos = safecatd(message, sizeof message, pos, (in+err)*max, 3);\n      pos = safecat(message, sizeof message, pos, \")\");\n\n      png_error(pp, message);\n }\n}\n",
        "target": 1
    },
    {
        "id": 738,
        "func": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
        "target": 0
    },
    {
        "id": 739,
        "func": "void RenderViewTest::GoForward(const PageState& state) {\n  GoToOffset(1, state);\n}\n",
        "target": 0
    },
    {
        "id": 740,
        "func": "void LayerTreeHostImpl::SetContextVisibility(bool is_visible) {\n  if (!compositor_frame_sink_)\n    return;\n\n  auto* compositor_context = compositor_frame_sink_->context_provider();\n  if (compositor_context && is_visible != !!compositor_context_visibility_) {\n    if (is_visible) {\n      compositor_context_visibility_ =\n          compositor_context->CacheController()->ClientBecameVisible();\n    } else {\n      compositor_context->CacheController()->ClientBecameNotVisible(\n          std::move(compositor_context_visibility_));\n    }\n  }\n\n  auto* worker_context = compositor_frame_sink_->worker_context_provider();\n  if (worker_context && is_visible != !!worker_context_visibility_) {\n    ContextProvider::ScopedContextLock hold(worker_context);\n    if (is_visible) {\n      worker_context_visibility_ =\n          worker_context->CacheController()->ClientBecameVisible();\n    } else {\n      worker_context->CacheController()->ClientBecameNotVisible(\n          std::move(worker_context_visibility_));\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 741,
        "func": "  FT_Face_GetCharVariantIndex( FT_Face   face,\n                               FT_ULong  charcode,\n                               FT_ULong  variantSelector )\n  {\n    FT_UInt  result = 0;\n\n\n    if ( face && face->charmap &&\n        face->charmap->encoding == FT_ENCODING_UNICODE )\n    {\n      FT_CharMap  charmap = find_variant_selector_charmap( face );\n      FT_CMap     ucmap = FT_CMAP( face->charmap );\n\n\n      if ( charmap != NULL )\n      {\n        FT_CMap  vcmap = FT_CMAP( charmap );\n\n\n        if ( charcode > 0xFFFFFFFFUL )\n        {\n          FT_TRACE1(( \"FT_Get_Char_Index: too large charcode\" ));\n          FT_TRACE1(( \" 0x%x is truncated\\n\", charcode ));\n        }\n        if ( variantSelector > 0xFFFFFFFFUL )\n        {\n          FT_TRACE1(( \"FT_Get_Char_Index: too large variantSelector\" ));\n          FT_TRACE1(( \" 0x%x is truncated\\n\", variantSelector ));\n        }\n\n        result = vcmap->clazz->char_var_index( vcmap, ucmap,\n                                               (FT_UInt32)charcode,\n                                               (FT_UInt32)variantSelector );\n      }\n    }\n\n    return result;\n  }\n",
        "target": 0
    },
    {
        "id": 742,
        "func": "void sspi_CopyAuthIdentity(SEC_WINNT_AUTH_IDENTITY* identity, SEC_WINNT_AUTH_IDENTITY* srcIdentity)\n{\n\tif (identity->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)\n\t{\n\t\tsspi_SetAuthIdentity(identity, (char*) srcIdentity->User,\n\t\t\t\t(char*) srcIdentity->Domain, (char*) srcIdentity->Password);\n\n\t\tidentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n\n\t\treturn;\n\t}\n\n\tidentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n\n\tidentity->User = identity->Domain = identity->Password = NULL;\n\n\tidentity->UserLength = srcIdentity->UserLength;\n\n\tif (identity->UserLength > 0)\n\t{\n\t\tidentity->User = (UINT16*) malloc((identity->UserLength + 1) * sizeof(WCHAR));\n\t\tCopyMemory(identity->User, srcIdentity->User, identity->UserLength * sizeof(WCHAR));\n\t\tidentity->User[identity->UserLength] = 0;\n\t}\n\n\tidentity->DomainLength = srcIdentity->DomainLength;\n\n\tif (identity->DomainLength > 0)\n\t{\n\t\tidentity->Domain = (UINT16*) malloc((identity->DomainLength + 1) * sizeof(WCHAR));\n\t\tCopyMemory(identity->Domain, srcIdentity->Domain, identity->DomainLength * sizeof(WCHAR));\n\t\tidentity->Domain[identity->DomainLength] = 0;\n\t}\n\n\tidentity->PasswordLength = srcIdentity->PasswordLength;\n\n\tif (identity->PasswordLength > 0)\n\t{\n\t\tidentity->Password = (UINT16*) malloc((identity->PasswordLength + 1) * sizeof(WCHAR));\n\t\tCopyMemory(identity->Password, srcIdentity->Password, identity->PasswordLength * sizeof(WCHAR));\n\t\tidentity->Password[identity->PasswordLength] = 0;\n\t}\n}",
        "target": 0
    },
    {
        "id": 743,
        "func": "void Browser::OnDevToolsAvailabilityChanged() {\n  using DTPH = policy::DeveloperToolsPolicyHandler;\n  if (DTPH::GetDevToolsAvailability(profile_->GetPrefs()) ==\n      DTPH::Availability::kDisallowed) {\n    content::DevToolsAgentHost::DetachAllClients();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 744,
        "func": "static void __perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\t\t struct perf_sample_data *data,\n\t\t\t\t\t struct perf_event *event)\n{\n\tu64 sample_type = event->attr.sample_type;\n\n\tdata->type = sample_type;\n\theader->size += event->id_header_size;\n\n\tif (sample_type & PERF_SAMPLE_TID) {\n\t\t/* namespace issues */\n\t\tdata->tid_entry.pid = perf_event_pid(event, current);\n\t\tdata->tid_entry.tid = perf_event_tid(event, current);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tdata->time = perf_clock();\n\n\tif (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))\n\t\tdata->id = primary_event_id(event);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tdata->stream_id = event->id;\n\n\tif (sample_type & PERF_SAMPLE_CPU) {\n\t\tdata->cpu_entry.cpu\t = raw_smp_processor_id();\n\t\tdata->cpu_entry.reserved = 0;\n\t}\n}",
        "target": 0
    },
    {
        "id": 745,
        "func": "nm_device_ipv6_sysctl_set (NMDevice *self, const char *property, const char *value)\n{\n\treturn nm_platform_sysctl_set (nm_utils_ip6_property_path (nm_device_get_ip_iface (self), property), value);\n \treturn nm_platform_sysctl_set (nm_utils_ip6_property_path (nm_device_get_ip_iface (self), property), value);\n }\n",
        "target": 0
    },
    {
        "id": 746,
        "func": "void check_tmp_dir(){\n#if !defined(WIN32)\n\tif (!RmFlag) return;\n\n\tconst char *tmpDir = NULL;\n\tbool newLock = param_boolean(\"CREATE_LOCKS_ON_LOCAL_DISK\", true);\n\tif (newLock) {\n\t\tFileLock *lock = new FileLock(-1, NULL, NULL);\n\t\ttmpDir = lock->GetTempPath();\t\n\t\tdelete lock;\n\t\trec_lock_cleanup(tmpDir, 3);\n\t\tif (tmpDir != NULL)\n\t\t\tdelete []tmpDir;\n\t}\n  \n#endif\t\n}\n",
        "target": 0
    },
    {
        "id": 747,
        "func": "static void reflectedClassAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;\n    TestObjectPythonV8Internal::reflectedClassAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 748,
        "func": "static u32 svc_rdma_get_inv_rkey(struct rpcrdma_msg *rdma_argp,\n\t\t\t\t struct rpcrdma_write_array *wr_ary,\n\t\t\t\t struct rpcrdma_write_array *rp_ary)\n {\n\tstruct rpcrdma_read_chunk *rd_ary;\n\tstruct rpcrdma_segment *arg_ch;\n \n\trd_ary = (struct rpcrdma_read_chunk *)&rdma_argp->rm_body.rm_chunks[0];\n\tif (rd_ary->rc_discrim != xdr_zero)\n\t\treturn be32_to_cpu(rd_ary->rc_target.rs_handle);\n \n\tif (wr_ary && be32_to_cpu(wr_ary->wc_nchunks)) {\n\t\targ_ch = &wr_ary->wc_array[0].wc_target;\n\t\treturn be32_to_cpu(arg_ch->rs_handle);\n\t}\n \n\tif (rp_ary && be32_to_cpu(rp_ary->wc_nchunks)) {\n\t\targ_ch = &rp_ary->wc_array[0].wc_target;\n\t\treturn be32_to_cpu(arg_ch->rs_handle);\n\t}\n \n \treturn 0;\n }\n",
        "target": 1
    },
    {
        "id": 749,
        "func": "unsigned long long Track::GetUid() const\n{\n    return m_info.uid;\n}\n",
        "target": 1
    },
    {
        "id": 750,
        "func": "bool GLES2Implementation::GetSamplerParameterivHelper(GLuint /* sampler */,\n                                                      GLenum /* pname */,\n                                                      GLint* /* params */) {\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 751,
        "func": "  content::RenderFrameHost* GetMainFrame() {\n    return GetWebContents()->GetMainFrame();\n  }\n",
        "target": 0
    },
    {
        "id": 752,
        "func": " void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n     shared_buffer_handle_.reset();\n   }\n }\n",
        "target": 1
    },
    {
        "id": 753,
        "func": "static void btrfs_submit_direct(int rw, struct bio *bio, struct inode *inode,\n\t\t\t\tloff_t file_offset)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_dio_private *dip;\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tint skip_sum;\n\tint write = rw & REQ_WRITE;\n\tint ret = 0;\n\n\tskip_sum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\n\tdip = kmalloc(sizeof(*dip), GFP_NOFS);\n\tif (!dip) {\n\t\tret = -ENOMEM;\n\t\tgoto free_ordered;\n\t}\n\n\tdip->private = bio->bi_private;\n\tdip->inode = inode;\n\tdip->logical_offset = file_offset;\n\n\tdip->bytes = 0;\n\tdo {\n\t\tdip->bytes += bvec->bv_len;\n\t\tbvec++;\n\t} while (bvec <= (bio->bi_io_vec + bio->bi_vcnt - 1));\n\n\tdip->disk_bytenr = (u64)bio->bi_sector << 9;\n\tbio->bi_private = dip;\n\tdip->errors = 0;\n\tdip->orig_bio = bio;\n\tatomic_set(&dip->pending_bios, 0);\n\n\tif (write)\n\t\tbio->bi_end_io = btrfs_endio_direct_write;\n\telse\n\t\tbio->bi_end_io = btrfs_endio_direct_read;\n\n\tret = btrfs_submit_direct_hook(rw, dip, skip_sum);\n\tif (!ret)\n\t\treturn;\nfree_ordered:\n\t/*\n\t * If this is a write, we need to clean up the reserved space and kill\n\t * the ordered extent.\n\t */\n\tif (write) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tordered = btrfs_lookup_ordered_extent(inode, file_offset);\n\t\tif (!test_bit(BTRFS_ORDERED_PREALLOC, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_NOCOW, &ordered->flags))\n\t\t\tbtrfs_free_reserved_extent(root, ordered->start,\n\t\t\t\t\t\t   ordered->disk_len);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\tbio_endio(bio, ret);\n}",
        "target": 0
    },
    {
        "id": 754,
        "func": "OMX::node_id OMX::makeNodeID(OMXNodeInstance *instance) {\n\n    node_id node = (node_id)++mNodeCounter;\n    mNodeIDToInstance.add(node, instance);\n\n return node;\n}\n",
        "target": 0
    },
    {
        "id": 755,
        "func": "bool omx_vdec::release_done(void)\n{\n bool bRet = false;\n\n if (release_input_done()) {\n if (release_output_done()) {\n            bRet = true;\n }\n }\n return bRet;\n}\n",
        "target": 0
    },
    {
        "id": 756,
        "func": "TabStrip::TabStrip(std::unique_ptr<TabStripController> controller)\n    : controller_(std::move(controller)),\n      layout_helper_(std::make_unique<TabStripLayoutHelper>()),\n      drag_context_(std::make_unique<TabDragContextImpl>(this)) {\n  Init();\n  SetEventTargeter(std::make_unique<views::ViewTargeter>(this));\n  md_observer_.Add(MD::GetInstance());\n}\n",
        "target": 0
    },
    {
        "id": 757,
        "func": "  void Start() {\n    DVLOG(2) << \"Starting SafeBrowsing download check for: \"\n             << item_->DebugString(true);\n    DCHECK_CURRENTLY_ON(BrowserThread::UI);\n    DownloadCheckResultReason reason = REASON_MAX;\n    if (!IsSupportedDownload(\n        *item_, item_->GetTargetFilePath(), &reason, &type_)) {\n      switch (reason) {\n        case REASON_EMPTY_URL_CHAIN:\n        case REASON_INVALID_URL:\n        case REASON_UNSUPPORTED_URL_SCHEME:\n          PostFinishTask(UNKNOWN, reason);\n          return;\n\n        case REASON_NOT_BINARY_FILE:\n          RecordFileExtensionType(item_->GetTargetFilePath());\n          PostFinishTask(UNKNOWN, reason);\n          return;\n\n        default:\n          NOTREACHED();\n      }\n    }\n    RecordFileExtensionType(item_->GetTargetFilePath());\n\n     if (item_->GetTargetFilePath().MatchesExtension(\n         FILE_PATH_LITERAL(\".zip\"))) {\n       StartExtractZipFeatures();\n#if defined(OS_MACOSX)\n    } else if (item_->GetTargetFilePath().MatchesExtension(\n                  FILE_PATH_LITERAL(\".dmg\"))) {\n      StartExtractDmgFeatures();\n#endif\n     } else {\n       DCHECK(!download_protection_util::IsArchiveFile(\n           item_->GetTargetFilePath()));\n      StartExtractFileFeatures();\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 758,
        "func": "long long mkvparser::UnserializeUInt(IMkvReader* pReader, long long pos,\n                                     long long size) {\n  assert(pReader);\n  assert(pos >= 0);\n  if ((size <= 0) || (size > 8))\n     return E_FILE_FORMAT_INVALID;\n \n   long long result = 0;\n\n for (long long i = 0; i < size; ++i) {\n unsigned char b;\n\n const long status = pReader->Read(pos, 1, &b);\n\n if (status < 0)\n return status;\n\n    result <<= 8;\n    result |= b;\n\n ++pos;\n }\n\n\n   return result;\n }\n",
        "target": 1
    },
    {
        "id": 759,
        "func": "static char *unserialize_str(const unsigned char **p, size_t *len, size_t maxlen)\n{\n\tsize_t i, j;\n\tchar *str = safe_emalloc(*len, 1, 1);\n\tunsigned char *end = *(unsigned char **)p+maxlen;\n\n\tif (end < *p) {\n\t\tefree(str);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < *len; i++) {\n\t\tif (*p >= end) {\n\t\t\tefree(str);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (**p != '\\\\') {\n\t\t\tstr[i] = (char)**p;\n\t\t} else {\n\t\t\tunsigned char ch = 0;\n\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t(*p)++;\n\t\t\t\tif (**p >= '0' && **p <= '9') {\n\t\t\t\t\tch = (ch << 4) + (**p -'0');\n\t\t\t\t} else if (**p >= 'a' && **p <= 'f') {\n\t\t\t\t\tch = (ch << 4) + (**p -'a'+10);\n\t\t\t\t} else if (**p >= 'A' && **p <= 'F') {\n\t\t\t\t\tch = (ch << 4) + (**p -'A'+10);\n\t\t\t\t} else {\n\t\t\t\t\tefree(str);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr[i] = (char)ch;\n\t\t}\n\t\t(*p)++;\n\t}\n\tstr[i] = 0;\n\t*len = i;\n\treturn str;\n}",
        "target": 0
    },
    {
        "id": 760,
        "func": "String HTMLSelectElement::validationMessage() const\n{\n    if (!willValidate())\n        return String();\n    if (customError())\n        return customValidationMessage();\n    if (valueMissing())\n        return locale().queryString(blink::WebLocalizedString::ValidationValueMissingForSelect);\n    return String();\n}\n",
        "target": 0
    },
    {
        "id": 761,
        "func": "void AudioRendererHost::OnFlushStream(const IPC::Message& msg, int stream_id) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n\n  AudioEntry* entry = LookupById(msg.routing_id(), stream_id);\n  if (!entry) {\n    SendErrorMessage(msg.routing_id(), stream_id);\n    return;\n  }\n\n  entry->controller->Flush();\n}\n",
        "target": 0
    },
    {
        "id": 762,
        "func": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndOptionalArg(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     int nonOpt(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n\n    size_t argsCount = exec->argumentCount();\n    if (argsCount <= 1) {\n        impl->methodWithNonOptionalArgAndOptionalArg(nonOpt);\n        return JSValue::encode(jsUndefined());\n    }\n\n    int opt(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toInt32(exec));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    impl->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);\n    return JSValue::encode(jsUndefined());\n}\n",
        "target": 1
    },
    {
        "id": 763,
        "func": "bool AXLayoutObject::isSelected() const {\n  if (!getLayoutObject() || !getNode())\n     return false;\n \n   const AtomicString& ariaSelected = getAttribute(aria_selectedAttr);\n  if (equalIgnoringCase(ariaSelected, \"true\"))\n     return true;\n \n   AXObject* focusedObject = axObjectCache().focusedObject();\n  if (ariaRoleAttribute() == ListBoxOptionRole && focusedObject &&\n      focusedObject->activeDescendant() == this) {\n    return true;\n  }\n\n  if (isTabItem() && isTabItemSelected())\n    return true;\n\n  return false;\n}\n",
        "target": 1
    },
    {
        "id": 764,
        "func": "__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tloff_t size = i_size_read(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + PAGE_CACHE_SIZE <= size) {\n\t\tinarg->size = PAGE_CACHE_SIZE;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size & (PAGE_CACHE_SIZE - 1);\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}",
        "target": 0
    },
    {
        "id": 765,
        "func": "static void atusb_xmit_complete(struct urb *urb)\n{\n\tdev_dbg(&urb->dev->dev, \"atusb_xmit urb completed\");\n}",
        "target": 0
    },
    {
        "id": 766,
        "func": "static void usb_debugfs_cleanup(void)\n{\n\tdebugfs_remove_recursive(usb_debug_root);\n}",
        "target": 0
    },
    {
        "id": 767,
        "func": "TabGroupData::TabGroupData() {\n  static int next_placeholder_title_number = 1;\n  title_ = base::ASCIIToUTF16(\n      \"Group \" + base::NumberToString(next_placeholder_title_number));\n   ++next_placeholder_title_number;\n \n   static SkRandom rand;\n  stroke_color_ = rand.nextU() | 0xff000000;\n }\n",
        "target": 1
    },
    {
        "id": 768,
        "func": "void DistillerNativeJavaScript::DistillerSendFeedback(bool good) {\n  EnsureServiceConnected();\n  distiller_js_service_->HandleDistillerFeedbackCall(good);\n}\n",
        "target": 1
    },
    {
        "id": 769,
        "func": "SVGSVGElement* SVGDocumentExtensions::rootElement(const Document& document)\n{\n    Element* elem = document.documentElement();\n    return isSVGSVGElement(elem) ? toSVGSVGElement(elem) : 0;\n}\n",
        "target": 0
    },
    {
        "id": 770,
        "func": "void AXTree::RemoveObserver(const AXTreeObserver* observer) {\n  observers_.RemoveObserver(observer);\n}\n",
        "target": 0
    },
    {
        "id": 771,
        "func": "void DocumentLoader::SetSourceLocation(\n    std::unique_ptr<SourceLocation> source_location) {\n  source_location_ = std::move(source_location);\n}\n",
        "target": 0
    },
    {
        "id": 772,
        "func": "struct rxe_mem *lookup_mem(struct rxe_pd *pd, int access, u32 key,\n\t\t\t   enum lookup_type type)\n{\n\tstruct rxe_mem *mem;\n\tstruct rxe_dev *rxe = to_rdev(pd->ibpd.device);\n\tint index = key >> 8;\n\n\tif (index >= RXE_MIN_MR_INDEX && index <= RXE_MAX_MR_INDEX) {\n\t\tmem = rxe_pool_get_index(&rxe->mr_pool, index);\n\t\tif (!mem)\n\t\t\tgoto err1;\n\t} else {\n\t\tgoto err1;\n\t}\n\n\tif ((type == lookup_local && mem->lkey != key) ||\n\t    (type == lookup_remote && mem->rkey != key))\n\t\tgoto err2;\n\n\tif (mem->pd != pd)\n\t\tgoto err2;\n\n\tif (access && !(access & mem->access))\n\t\tgoto err2;\n\n\tif (mem->state != RXE_MEM_STATE_VALID)\n\t\tgoto err2;\n\n\treturn mem;\n\nerr2:\n\trxe_drop_ref(mem);\nerr1:\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 773,
        "func": "  _iup_worker_shift( IUP_Worker  worker,\n                     FT_UInt     p1,\n                     FT_UInt     p2,\n                     FT_UInt     p )\n  {\n    FT_UInt     i;\n    FT_F26Dot6  dx;\n\n\n    dx = SUB_LONG( worker->curs[p].x, worker->orgs[p].x );\n    if ( dx != 0 )\n    {\n      for ( i = p1; i < p; i++ )\n        worker->curs[i].x = ADD_LONG( worker->curs[i].x, dx );\n\n      for ( i = p + 1; i <= p2; i++ )\n        worker->curs[i].x = ADD_LONG( worker->curs[i].x, dx );\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 774,
        "func": "static bool MagicCmp(const char* magic_entry, const char* content, size_t len) {\n  while (len) {\n    if ((*magic_entry != '.') && (*magic_entry != *content))\n      return false;\n    ++magic_entry;\n    ++content;\n    --len;\n  }\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 775,
        "func": "static int vmci_transport_notify_recv_pre_dequeue(\n\tstruct vsock_sock *vsk,\n\tsize_t target,\n\tstruct vsock_transport_recv_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->recv_pre_dequeue(\n\t\t\t&vsk->sk, target,\n\t\t\t(struct vmci_transport_recv_notify_data *)data);\n}",
        "target": 0
    },
    {
        "id": 776,
        "func": "ExtensionDevToolsInfoBar::ExtensionDevToolsInfoBar(\n    const std::string& extension_id,\n    const std::string& extension_name)\n    : extension_id_(extension_id) {\n  g_extension_info_bars.Get()[extension_id] = this;\n\n  auto delegate = std::make_unique<ExtensionDevToolsInfoBarDelegate>(\n      base::Bind(&ExtensionDevToolsInfoBar::InfoBarDismissed,\n                 base::Unretained(this)),\n      extension_name);\n  infobar_ = GlobalConfirmInfoBar::Show(std::move(delegate));\n}\n",
        "target": 0
    },
    {
        "id": 777,
        "func": "void OxideQQuickWebView::dragEnterEvent(QDragEnterEvent* event) {\n  Q_D(OxideQQuickWebView);\n\n  QQuickItem::dragEnterEvent(event);\n  d->contents_view_->handleDragEnterEvent(event);\n}\n",
        "target": 0
    },
    {
        "id": 778,
        "func": "xlate_to_uni(const unsigned char *name, int len, unsigned char *outname,\n\t     int *longlen, int *outlen, int escape, int utf8,\n\t     struct nls_table *nls)\n{\n\tconst unsigned char *ip;\n\tunsigned char nc;\n\tunsigned char *op;\n\tunsigned int ec;\n\tint i, k, fill;\n\tint charlen;\n\n\tif (utf8) {\n\t\t*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) outname, FAT_LFN_LEN + 2);\n\t\tif (*outlen < 0)\n\t\t\treturn *outlen;\n\t\telse if (*outlen > FAT_LFN_LEN)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\top = &outname[*outlen * sizeof(wchar_t)];\n\t} else {\n\t\tif (nls) {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     *outlen += 1)\n\t\t\t{\n\t\t\t\tif (escape && (*ip == ':')) {\n\t\t\t\t\tif (i > len - 5)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tec = 0;\n\t\t\t\t\tfor (k = 1; k < 5; k++) {\n\t\t\t\t\t\tnc = ip[k];\n\t\t\t\t\t\tec <<= 4;\n\t\t\t\t\t\tif (nc >= '0' && nc <= '9') {\n\t\t\t\t\t\t\tec |= nc - '0';\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'a' && nc <= 'f') {\n\t\t\t\t\t\t\tec |= nc - ('a' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nc >= 'A' && nc <= 'F') {\n\t\t\t\t\t\t\tec |= nc - ('A' - 10);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t\t*op++ = ec & 0xFF;\n\t\t\t\t\t*op++ = ec >> 8;\n\t\t\t\t\tip += 5;\n\t\t\t\t\ti += 5;\n\t\t\t\t} else {\n\t\t\t\t\tif ((charlen = nls->char2uni(ip, len - i, (wchar_t *)op)) < 0)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tip += charlen;\n\t\t\t\t\ti += charlen;\n\t\t\t\t\top += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t} else {\n\t\t\tfor (i = 0, ip = name, op = outname, *outlen = 0;\n\t\t\t     i < len && *outlen <= FAT_LFN_LEN;\n\t\t\t     i++, *outlen += 1)\n\t\t\t{\n\t\t\t\t*op++ = *ip++;\n\t\t\t\t*op++ = 0;\n\t\t\t}\n\t\t\tif (i < len)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t}\n\t}\n\n\t*longlen = *outlen;\n\tif (*outlen % 13) {\n\t\t*op++ = 0;\n\t\t*op++ = 0;\n\t\t*outlen += 1;\n\t\tif (*outlen % 13) {\n\t\t\tfill = 13 - (*outlen % 13);\n\t\t\tfor (i = 0; i < fill; i++) {\n\t\t\t\t*op++ = 0xff;\n\t\t\t\t*op++ = 0xff;\n\t\t\t}\n\t\t\t*outlen += fill;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 779,
        "func": "void stream_int_unregister_handler(struct stream_interface *si)\n{\n\tsi_detach(si);\n}\n",
        "target": 0
    },
    {
        "id": 780,
        "func": "IsParent(WindowPtr a, WindowPtr b)\n{\n    for (b = b->parent; b; b = b->parent)\n        if (b == a)\n            return TRUE;\n    return FALSE;\n}\n",
        "target": 0
    },
    {
        "id": 781,
        "func": "static void OctetMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  V8SetReturnValueUnsigned(info, impl->octetMethod());\n}\n",
        "target": 0
    },
    {
        "id": 782,
        "func": "void WebContentsViewAura::PrepareOverscrollNavigationOverlay() {\n  OverscrollWindowDelegate* delegate = static_cast<OverscrollWindowDelegate*>(\n      overscroll_window_->delegate());\n  overscroll_window_->SchedulePaintInRect(\n      gfx::Rect(overscroll_window_->bounds().size()));\n  overscroll_window_->SetBounds(gfx::Rect(window_->bounds().size()));\n  overscroll_window_->SetTransform(gfx::Transform());\n  navigation_overlay_->SetOverlayWindow(overscroll_window_.Pass(),\n                                        delegate);\n  navigation_overlay_->StartObservingView(ToRenderWidgetHostViewAura(\n      web_contents_->GetRenderWidgetHostView()));\n}\n",
        "target": 0
    },
    {
        "id": 783,
        "func": "static void pdf_run_bstar(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_path(ctx, pr, 1, 1, 1, 1);\n}\n",
        "target": 0
    },
    {
        "id": 784,
        "func": "HRESULT EnrollToGoogleMdmIfNeeded(const base::DictionaryValue& properties) {\n  USES_CONVERSION;\n  LOGFN(INFO);\n\n  base::string16 email = GetDictString(&properties, kKeyEmail);\n  base::string16 token = GetDictString(&properties, kKeyMdmIdToken);\n\n  if (email.empty()) {\n    LOGFN(ERROR) << \"Email is empty\";\n    return E_INVALIDARG;\n  }\n\n  if (token.empty()) {\n    LOGFN(ERROR) << \"MDM id token is empty\";\n    return E_INVALIDARG;\n  }\n\n  base::string16 mdm_url = GetMdmUrl();\n  if (mdm_url.empty())\n    return S_OK;\n\n  LOGFN(INFO) << \"MDM_URL=\" << mdm_url\n              << \" token=\" << base::string16(token.c_str(), 10);\n\n  base::string16 serial_number =\n      base::win::WmiComputerSystemInfo::Get().serial_number();\n\n  if (serial_number.empty()) {\n    LOGFN(ERROR) << \"Failed to get serial number.\";\n    return -1;\n  }\n\n  base::DictionaryValue registration_data;\n  registration_data.SetString(\"serial_number\", serial_number);\n  registration_data.SetString(\"id_token\", token);\n  std::string registration_data_str;\n  if (!base::JSONWriter::Write(registration_data, &registration_data_str)) {\n    LOGFN(ERROR) << \"JSONWriter::Write(registration_data)\";\n    return E_FAIL;\n  }\n\n  HRESULT hr =\n      RegisterWithGoogleDeviceManagement(mdm_url, email, registration_data_str);\n  if (FAILED(hr))\n    LOGFN(ERROR) << \"RegisterWithGoogleDeviceManagement hr=\" << putHR(hr);\n\n  return hr;\n}\n",
        "target": 0
    },
    {
        "id": 785,
        "func": "void SyncManager::SyncInternal::UpdateCredentials(\n    const SyncCredentials& credentials) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  DCHECK_EQ(credentials.email, share_.name);\n  DCHECK(!credentials.email.empty());\n  DCHECK(!credentials.sync_token.empty());\n\n  observing_ip_address_changes_ = true;\n  if (connection_manager()->set_auth_token(credentials.sync_token)) {\n     sync_notifier_->UpdateCredentials(\n         credentials.email, credentials.sync_token);\n     if (!setup_for_test_mode_) {\n      CheckServerReachable();\n     }\n   }\n }\n",
        "target": 1
    },
    {
        "id": 786,
        "func": "static int try_to_merge_one_page(struct vm_area_struct *vma,\n\t\t\t\t struct page *page, struct page *kpage)\n{\n\tpte_t orig_pte = __pte(0);\n\tint err = -EFAULT;\n\n\tif (page == kpage)\t\t\t/* ksm page forked */\n\t\treturn 0;\n\n\tif (!(vma->vm_flags & VM_MERGEABLE))\n\t\tgoto out;\n\tif (PageTransCompound(page) && page_trans_compound_anon_split(page))\n\t\tgoto out;\n\tBUG_ON(PageTransCompound(page));\n\tif (!PageAnon(page))\n\t\tgoto out;\n\n\t/*\n\t * We need the page lock to read a stable PageSwapCache in\n\t * write_protect_page().  We use trylock_page() instead of\n\t * lock_page() because we don't want to wait here - we\n\t * prefer to continue scanning and merging different pages,\n\t * then come back to this page when it is unlocked.\n\t */\n\tif (!trylock_page(page))\n\t\tgoto out;\n\t/*\n\t * If this anonymous page is mapped only here, its pte may need\n\t * to be write-protected.  If it's mapped elsewhere, all of its\n\t * ptes are necessarily already write-protected.  But in either\n\t * case, we need to lock and check page_count is not raised.\n\t */\n\tif (write_protect_page(vma, page, &orig_pte) == 0) {\n\t\tif (!kpage) {\n\t\t\t/*\n\t\t\t * While we hold page lock, upgrade page from\n\t\t\t * PageAnon+anon_vma to PageKsm+NULL stable_node:\n\t\t\t * stable_tree_insert() will update stable_node.\n\t\t\t */\n\t\t\tset_page_stable_node(page, NULL);\n\t\t\tmark_page_accessed(page);\n\t\t\terr = 0;\n\t\t} else if (pages_identical(page, kpage))\n\t\t\terr = replace_page(vma, page, kpage, orig_pte);\n\t}\n\n\tif ((vma->vm_flags & VM_LOCKED) && kpage && !err) {\n\t\tmunlock_vma_page(page);\n\t\tif (!PageMlocked(kpage)) {\n\t\t\tunlock_page(page);\n\t\t\tlock_page(kpage);\n\t\t\tmlock_vma_page(kpage);\n\t\t\tpage = kpage;\t\t/* for final unlock */\n\t\t}\n\t}\n\n\tunlock_page(page);\nout:\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 787,
        "func": "write_VD_boot_record(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660;\n\tunsigned char *bp;\n\n\tiso9660 = a->format_data;\n\tbp = wb_buffptr(a) -1;\n\t/* Volume Descriptor Type */\n\tset_VD_bp(bp, VDT_BOOT_RECORD, 1);\n\t/* Boot System Identifier */\n\tmemcpy(bp+8, \"EL TORITO SPECIFICATION\", 23);\n\tset_unused_field_bp(bp, 8+23, 39);\n\t/* Unused */\n\tset_unused_field_bp(bp, 40, 71);\n\t/* Absolute pointer to first sector of Boot Catalog */\n\tset_num_731(bp+72,\n\t    iso9660->el_torito.catalog->file->content.location);\n\t/* Unused */\n\tset_unused_field_bp(bp, 76, LOGICAL_BLOCK_SIZE);\n\n\treturn (wb_consume(a, LOGICAL_BLOCK_SIZE));\n}\n",
        "target": 0
    },
    {
        "id": 788,
        "func": "ExtensionSettings* ExtensionService::extension_settings() {\n  return extension_settings_;\n}\n",
        "target": 0
    },
    {
        "id": 789,
        "func": "WebKitWebWindowFeatures* webkit_web_view_get_window_features(WebKitWebView* webView)\n{\n    g_return_val_if_fail(WEBKIT_IS_WEB_VIEW(webView), 0);\n    return webView->priv->webWindowFeatures.get();\n}\n",
        "target": 0
    },
    {
        "id": 790,
        "func": "int main(int argc, char *argv[])\n{\n    char buff[1024];\n    int fd, nr, nw;\n    if (argc < 2) {\n        fprintf(stderr,\n                \"usage: %s output-filename\\n\"\n                \"       %s |output-command\\n\"\n                \"       %s :host:port\\n\", argv[0], argv[0], argv[0]);\n        return 1;\n    }\n    fd = open_gen_fd(argv[1]);\n    if (fd < 0) {\n        perror(\"open_gen_fd\");\n        exit(EXIT_FAILURE);\n    }\n    while ((nr = read(0, buff, sizeof (buff))) != 0) {\n        if (nr < 0) {\n            if (errno == EINTR)\n                continue;\n            perror(\"read\");\n            exit(EXIT_FAILURE);\n        }\n        nw = write(fd, buff, nr);\n        if (nw < 0) {\n            perror(\"write\");\n             exit(EXIT_FAILURE);\n         }\n     }\n     return 0;\n }\n",
        "target": 1
    },
    {
        "id": 791,
        "func": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\t/* Allow zero-byte read from NULL, regardless of pointer type */\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\n\t/* Only allow fixed-offset stack reads */\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n\t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n\t\t\tregno, tn_buf);\n\t}\n\toff = regs[regno].off + regs[regno].var_off.value;\n\tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 792,
        "func": " void PlatformSensorProviderBase::FreeResourcesIfNeeded() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (sensor_map_.empty() && requests_map_.empty()) {\n     FreeResources();\n    shared_buffer_mapping_.reset();\n     shared_buffer_handle_.reset();\n   }\n }\n",
        "target": 0
    },
    {
        "id": 793,
        "func": "void RenderWidgetHostImpl::SetIsLoading(bool is_loading) {\n  if (owner_delegate_)\n    owner_delegate_->RenderWidgetWillSetIsLoading(is_loading);\n\n  is_loading_ = is_loading;\n  if (view_)\n    view_->SetIsLoading(is_loading);\n}\n",
        "target": 0
    },
    {
        "id": 794,
        "func": "bitcmp(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\tint32\t\tresult;\n\n\tresult = bit_cmp(arg1, arg2);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}",
        "target": 0
    },
    {
        "id": 795,
        "func": "ShareableElementData::~ShareableElementData()\n{\n    for (unsigned i = 0; i < m_arraySize; ++i)\n        m_attributeArray[i].~Attribute();\n}\n",
        "target": 0
    },
    {
        "id": 796,
        "func": "call_reserve(struct rpc_task *task)\n{\n\tdprint_status(task);\n\n\ttask->tk_status  = 0;\n\ttask->tk_action  = call_reserveresult;\n\txprt_reserve(task);\n}",
        "target": 0
    },
    {
        "id": 797,
        "func": "void hns_ppe_get_stats(struct hns_ppe_cb *ppe_cb, u64 *data)\n{\n\tu64 *regs_buff = data;\n\tstruct hns_ppe_hw_stats *hw_stats = &ppe_cb->hw_stats;\n\n\tregs_buff[0] = hw_stats->rx_pkts_from_sw;\n\tregs_buff[1] = hw_stats->rx_pkts;\n\tregs_buff[2] = hw_stats->rx_drop_no_bd;\n\tregs_buff[3] = hw_stats->rx_alloc_buf_fail;\n\tregs_buff[4] = hw_stats->rx_alloc_buf_wait;\n\tregs_buff[5] = hw_stats->rx_drop_no_buf;\n\tregs_buff[6] = hw_stats->rx_err_fifo_full;\n\n\tregs_buff[7] = hw_stats->tx_bd_form_rcb;\n\tregs_buff[8] = hw_stats->tx_pkts_from_rcb;\n\tregs_buff[9] = hw_stats->tx_pkts;\n\tregs_buff[10] = hw_stats->tx_err_fifo_empty;\n\tregs_buff[11] = hw_stats->tx_err_checksum;\n}",
        "target": 0
    },
    {
        "id": 798,
        "func": "irc_server_outqueue_free (struct t_irc_server *server,\n                          int priority,\n                          struct t_irc_outqueue *outqueue)\n{\n    struct t_irc_outqueue *new_outqueue;\n    \n    /* remove outqueue message */\n    if (server->last_outqueue[priority] == outqueue)\n        server->last_outqueue[priority] = outqueue->prev_outqueue;\n    if (outqueue->prev_outqueue)\n    {\n        (outqueue->prev_outqueue)->next_outqueue = outqueue->next_outqueue;\n        new_outqueue = server->outqueue[priority];\n    }\n    else\n        new_outqueue = outqueue->next_outqueue;\n    \n    if (outqueue->next_outqueue)\n        (outqueue->next_outqueue)->prev_outqueue = outqueue->prev_outqueue;\n    \n    /* free data */\n    if (outqueue->command)\n        free (outqueue->command);\n    if (outqueue->message_before_mod)\n        free (outqueue->message_before_mod);\n    if (outqueue->message_after_mod)\n        free (outqueue->message_after_mod);\n    if (outqueue->tags)\n        free (outqueue->tags);\n    free (outqueue);\n    server->outqueue[priority] = new_outqueue;\n}\n",
        "target": 0
    },
    {
        "id": 799,
        "func": "void WebLocalFrameImpl::CollectGarbage() {\n  if (!GetFrame())\n    return;\n  if (!GetFrame()->GetSettings()->GetScriptEnabled())\n    return;\n  V8GCController::CollectGarbage(v8::Isolate::GetCurrent());\n}\n",
        "target": 0
    },
    {
        "id": 800,
        "func": "static int buf_to_pages_noslab(const void *buf, size_t buflen,\n\t\tstruct page **pages, unsigned int *pgbase)\n{\n\tstruct page *newpage, **spages;\n\tint rc = 0;\n\tsize_t len;\n\tspages = pages;\n\n\tdo {\n\t\tlen = min_t(size_t, PAGE_SIZE, buflen);\n\t\tnewpage = alloc_page(GFP_KERNEL);\n\n\t\tif (newpage == NULL)\n\t\t\tgoto unwind;\n\t\tmemcpy(page_address(newpage), buf, len);\n                buf += len;\n                buflen -= len;\n\t\t*pages++ = newpage;\n\t\trc++;\n\t} while (buflen != 0);\n\n\treturn rc;\n\nunwind:\n\tfor(; rc > 0; rc--)\n\t\t__free_page(spages[rc-1]);\n\treturn -ENOMEM;\n}",
        "target": 0
    },
    {
        "id": 801,
        "func": "static void intel_pmu_flush_branch_stack(void)\n{\n\t/*\n\t * Intel LBR does not tag entries with the\n\t * PID of the current task, then we need to\n\t * flush it on ctxsw\n\t * For now, we simply reset it\n\t */\n\tif (x86_pmu.lbr_nr)\n\t\tintel_pmu_lbr_reset();\n}",
        "target": 0
    },
    {
        "id": 802,
        "func": "int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tunsigned int nr;\n\tstruct task_struct *reaper;\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns;\n\n\tif (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\tgoto out_no_task;\n\tnr = filp->f_pos - FIRST_PROCESS_ENTRY;\n\n\treaper = get_proc_task(filp->f_path.dentry->d_inode);\n\tif (!reaper)\n\t\tgoto out_no_task;\n\n\tfor (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {\n\t\tconst struct pid_entry *p = &proc_base_stuff[nr];\n\t\tif (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)\n\t\t\tgoto out;\n\t}\n\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\titer.task = NULL;\n\titer.tgid = filp->f_pos - TGID_OFFSET;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tfilp->f_pos = iter.tgid + TGID_OFFSET;\n\t\tif (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {\n\t\t\tput_task_struct(iter.task);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfilp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;\nout:\n\tput_task_struct(reaper);\nout_no_task:\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 803,
        "func": "long long VideoTrack::GetWidth() const\n{\n    return m_width;\n}\n",
        "target": 1
    },
    {
        "id": 804,
        "func": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpreempt_disable();\n\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\n\tpreempt_enable();\n}",
        "target": 1
    },
    {
        "id": 805,
        "func": "void V8TestObject::VoidMethodByteStringArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_voidMethodByteStringArg\");\n\n  test_object_v8_internal::VoidMethodByteStringArgMethod(info);\n}\n",
        "target": 0
    },
    {
        "id": 806,
        "func": "v8::Local<v8::Value> WebLocalFrameImpl::ExecuteScriptAndReturnValue(\n    const WebScriptSource& source) {\n  DCHECK(GetFrame());\n\n  return GetFrame()\n      ->GetScriptController()\n      .ExecuteScriptInMainWorldAndReturnValue(source);\n}\n",
        "target": 0
    },
    {
        "id": 807,
        "func": "vips_tracked_init( void )\n{\n\tstatic GOnce vips_tracked_once = G_ONCE_INIT;\n\n\tVIPS_ONCE( &vips_tracked_once, \n\t\t(GThreadFunc) vips_tracked_init_mutex, NULL );\n}",
        "target": 0
    },
    {
        "id": 808,
        "func": "void RenderWidgetHostImpl::Focus() {\n  is_focused_ = true;\n\n  Send(new InputMsg_SetFocus(routing_id_, true));\n\n  if (RenderViewHost::From(this) && delegate_)\n    delegate_->ReplicatePageFocus(true);\n}\n",
        "target": 0
    },
    {
        "id": 809,
        "func": "g_NPN_GetStringIdentifier(const NPUTF8 *name)\n{\n  if (!thread_check()) {\n\tnpw_printf(\"WARNING: NPN_GetStringIdentifier not called from the main thread\\n\");\n\treturn NULL;\n  }\n\n  if (name == NULL)\n\treturn NULL;\n\n  D(bugiI(\"NPN_GetStringIdentifier name='%s'\\n\", name));\n  NPIdentifier ret = cached_NPN_GetStringIdentifier(name);\n  D(bugiD(\"NPN_GetStringIdentifier return: %p\\n\", ret));\n  return ret;\n}",
        "target": 0
    },
    {
        "id": 810,
        "func": "static ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tvoid *page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tpage = memdup_user(buf, count);\n\tif (IS_ERR(page)) {\n\t\tlength = PTR_ERR(page);\n\t\tgoto out;\n\t}\n\n\t/* Guard against adverse ptrace interaction */\n\tlength = mutex_lock_interruptible(&task->signal->cred_guard_mutex);\n\tif (length < 0)\n\t\tgoto out_free;\n\n\tlength = security_setprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      page, count);\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout_free:\n\tkfree(page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}",
        "target": 0
    },
    {
        "id": 811,
        "func": "void AutomationInternalCustomBindings::OnSubtreeWillBeDeleted(\n    ui::AXTree* tree,\n    ui::AXNode* node) {\n}\n",
        "target": 0
    },
    {
        "id": 812,
        "func": "void sched_offline_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\tint i;\n\n\t/* end participation in shares distribution */\n\tfor_each_possible_cpu(i)\n\t\tunregister_fair_sched_group(tg, i);\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_del_rcu(&tg->list);\n\tlist_del_rcu(&tg->siblings);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n}",
        "target": 0
    },
    {
        "id": 813,
        "func": "static void dumpV8Message(v8::Local<v8::Context> context, v8::Local<v8::Message> message)\n{\n    if (message.IsEmpty())\n        return;\n\n    message->GetScriptOrigin();\n    v8::Maybe<int> unused = message->GetLineNumber(context);\n    ALLOW_UNUSED_LOCAL(unused);\n\n    v8::Local<v8::Value> resourceName = message->GetScriptOrigin().ResourceName();\n    String fileName = \"Unknown JavaScript file\";\n    if (!resourceName.IsEmpty() && resourceName->IsString())\n        fileName = toCoreString(v8::Local<v8::String>::Cast(resourceName));\n    int lineNumber = 0;\n    v8Call(message->GetLineNumber(context), lineNumber);\n    v8::Local<v8::String> errorMessage = message->Get();\n    fprintf(stderr, \"%s (line %d): %s\\n\", fileName.utf8().data(), lineNumber, toCoreString(errorMessage).utf8().data());\n}\n",
        "target": 0
    },
    {
        "id": 814,
        "func": "bool HTMLScriptRunner::executeScriptsWaitingForParsing()\n{\n    while (!m_scriptsToExecuteAfterParsing.isEmpty()) {\n        ASSERT(!isExecutingScript());\n        ASSERT(!hasParserBlockingScript());\n        ASSERT(m_scriptsToExecuteAfterParsing.first().resource());\n        if (!m_scriptsToExecuteAfterParsing.first().isReady()) {\n            m_scriptsToExecuteAfterParsing.first().watchForLoad(this);\n            return false;\n        }\n        PendingScript first = m_scriptsToExecuteAfterParsing.takeFirst();\n        executePendingScriptAndDispatchEvent(first, PendingScript::Deferred);\n        if (!m_document)\n            return false;\n    }\n    return true;\n}\n",
        "target": 0
    },
    {
        "id": 815,
        "func": "void ecryptfs_put_lower_file(struct inode *inode)\n{\n\tstruct ecryptfs_inode_info *inode_info;\n\n\tinode_info = ecryptfs_inode_to_private(inode);\n\tif (atomic_dec_and_mutex_lock(&inode_info->lower_file_count,\n\t\t\t\t      &inode_info->lower_file_mutex)) {\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t\tfput(inode_info->lower_file);\n\t\tinode_info->lower_file = NULL;\n\t\tmutex_unlock(&inode_info->lower_file_mutex);\n\t}\n}",
        "target": 0
    },
    {
        "id": 816,
        "func": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}",
        "target": 1
    },
    {
        "id": 817,
        "func": "static void nfs4_xdr_enc_locku(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       struct nfs_locku_args *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_locku(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}",
        "target": 0
    },
    {
        "id": 818,
        "func": "MagickExport ImageType GetImageType(const Image *image,ExceptionInfo *exception)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->colorspace == CMYKColorspace)\n    {\n      if (image->matte == MagickFalse)\n        return(ColorSeparationType);\n      return(ColorSeparationMatteType);\n    }\n  if (IsMonochromeImage(image,exception) != MagickFalse)\n    return(BilevelType);\n  if (IsGrayImage(image,exception) != MagickFalse)\n    {\n      if (image->matte != MagickFalse)\n        return(GrayscaleMatteType);\n      return(GrayscaleType);\n    }\n  if (IsPaletteImage(image,exception) != MagickFalse)\n    {\n      if (image->matte != MagickFalse)\n        return(PaletteMatteType);\n      return(PaletteType);\n    }\n  if (image->matte != MagickFalse)\n    return(TrueColorMatteType);\n  return(TrueColorType);\n}\n",
        "target": 0
    },
    {
        "id": 819,
        "func": "static int instance_mkdir(const char *name)\n{\n\tstruct trace_array *tr;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = -ENOMEM;\n\ttr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\tif (!tr)\n\t\tgoto out_unlock;\n\n\ttr->name = kstrdup(name, GFP_KERNEL);\n\tif (!tr->name)\n\t\tgoto out_free_tr;\n\n\tif (!alloc_cpumask_var(&tr->tracing_cpumask, GFP_KERNEL))\n\t\tgoto out_free_tr;\n\n\ttr->trace_flags = global_trace.trace_flags & ~ZEROED_TRACE_FLAGS;\n\n\tcpumask_copy(tr->tracing_cpumask, cpu_all_mask);\n\n\traw_spin_lock_init(&tr->start_lock);\n\n\ttr->max_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\n\ttr->current_trace = &nop_trace;\n\n\tINIT_LIST_HEAD(&tr->systems);\n\tINIT_LIST_HEAD(&tr->events);\n\tINIT_LIST_HEAD(&tr->hist_vars);\n\n\tif (allocate_trace_buffers(tr, trace_buf_size) < 0)\n\t\tgoto out_free_tr;\n\n\ttr->dir = tracefs_create_dir(name, trace_instance_dir);\n\tif (!tr->dir)\n\t\tgoto out_free_tr;\n\n\tret = event_trace_add_tracer(tr->dir, tr);\n\tif (ret) {\n\t\ttracefs_remove_recursive(tr->dir);\n\t\tgoto out_free_tr;\n\t}\n\n\tftrace_init_trace_array(tr);\n\n\tinit_tracer_tracefs(tr, tr->dir);\n\tinit_trace_flags_index(tr);\n\t__update_tracer_options(tr);\n\n\tlist_add(&tr->list, &ftrace_trace_arrays);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n\n out_free_tr:\n\tfree_trace_buffers(tr);\n\tfree_cpumask_var(tr->tracing_cpumask);\n\tkfree(tr->name);\n\tkfree(tr);\n\n out_unlock:\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n\n}\n",
        "target": 0
    },
    {
        "id": 820,
        "func": "Status IndexedDBDatabase::DeleteIndexOperation(\n    int64_t object_store_id,\n    int64_t index_id,\n    IndexedDBTransaction* transaction) {\n  IDB_TRACE1(\n      \"IndexedDBDatabase::DeleteIndexOperation\", \"txn.id\", transaction->id());\n\n  IndexedDBIndexMetadata index_metadata =\n      RemoveIndex(object_store_id, index_id);\n\n  Status s = metadata_coding_->DeleteIndex(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), object_store_id, index_metadata);\n\n  if (!s.ok())\n    return s;\n\n  s = backing_store_->ClearIndex(transaction->BackingStoreTransaction(),\n                                 transaction->database()->id(), object_store_id,\n                                 index_id);\n  if (!s.ok()) {\n    AddIndex(object_store_id, std::move(index_metadata),\n             IndexedDBIndexMetadata::kInvalidId);\n    return s;\n  }\n\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::DeleteIndexAbortOperation, this,\n                     object_store_id, std::move(index_metadata)));\n  return s;\n}\n",
        "target": 0
    },
    {
        "id": 821,
        "func": "String PresentationConnection::binaryType() const {\n  switch (m_binaryType) {\n    case BinaryTypeBlob:\n      return \"blob\";\n    case BinaryTypeArrayBuffer:\n      return \"arraybuffer\";\n  }\n  ASSERT_NOT_REACHED();\n  return String();\n}\n",
        "target": 0
    },
    {
        "id": 822,
        "func": "static inline CanvasImageSource* ToImageSourceInternal(\n    const CanvasImageSourceUnion& value,\n    ExceptionState& exception_state) {\n  if (value.IsCSSImageValue()) {\n    if (RuntimeEnabledFeatures::CSSPaintAPIEnabled())\n      return value.GetAsCSSImageValue();\n    exception_state.ThrowTypeError(\"CSSImageValue is not yet supported\");\n    return nullptr;\n  }\n  if (value.IsHTMLImageElement())\n    return value.GetAsHTMLImageElement();\n  if (value.IsHTMLVideoElement()) {\n    HTMLVideoElement* video = value.GetAsHTMLVideoElement();\n    video->VideoWillBeDrawnToCanvas();\n    return video;\n  }\n  if (value.IsSVGImageElement())\n    return value.GetAsSVGImageElement();\n  if (value.IsHTMLCanvasElement())\n    return value.GetAsHTMLCanvasElement();\n  if (value.IsImageBitmap()) {\n    if (static_cast<ImageBitmap*>(value.GetAsImageBitmap())->IsNeutered()) {\n      exception_state.ThrowDOMException(\n          kInvalidStateError, String::Format(\"The image source is detached\"));\n      return nullptr;\n    }\n    return value.GetAsImageBitmap();\n  }\n  if (value.IsOffscreenCanvas()) {\n    if (static_cast<OffscreenCanvas*>(value.GetAsOffscreenCanvas())\n            ->IsNeutered()) {\n      exception_state.ThrowDOMException(\n          kInvalidStateError, String::Format(\"The image source is detached\"));\n      return nullptr;\n    }\n    return value.GetAsOffscreenCanvas();\n  }\n  NOTREACHED();\n  return nullptr;\n}\n",
        "target": 0
    },
    {
        "id": 823,
        "func": "static struct samldb_ctx *samldb_ctx_init(struct ldb_module *module,\n\t\t\t\t\t  struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\n\tldb = ldb_module_get_ctx(module);\n\n\tac = talloc_zero(req, struct samldb_ctx);\n\tif (ac == NULL) {\n\t\tldb_oom(ldb);\n\t\treturn NULL;\n\t}\n\n\tac->module = module;\n\tac->req = req;\n\n\treturn ac;\n}\n",
        "target": 0
    },
    {
        "id": 824,
        "func": "sf_writef_float\t(SNDFILE *sndfile, const float *ptr, sf_count_t frames)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tif (psf->file.mode == SFM_READ)\n\t{\tpsf->error = SFE_NOT_WRITEMODE ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->write_float == NULL || psf->seek == NULL)\n\t{\tpsf->error = SFE_UNIMPLEMENTED ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_WRITE)\n\t\tif (psf->seek (psf, SFM_WRITE, psf->write_current) < 0)\n\t\t\treturn 0 ;\n\n\tif (psf->have_written == SF_FALSE && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_FALSE) ;\n\tpsf->have_written = SF_TRUE ;\n\n\tcount = psf->write_float (psf, ptr, frames * psf->sf.channels) ;\n\n\tpsf->write_current += count / psf->sf.channels ;\n\n\tpsf->last_op = SFM_WRITE ;\n\n\tif (psf->write_current > psf->sf.frames)\n\t{\tpsf->sf.frames = psf->write_current ;\n\t\tpsf->dataend = 0 ;\n\t\t} ;\n\n\tif (psf->auto_header && psf->write_header != NULL)\n\t\tpsf->write_header (psf, SF_TRUE) ;\n\n\treturn count / psf->sf.channels ;\n} /* sf_writef_float */",
        "target": 0
    },
    {
        "id": 825,
        "func": "void PanelBrowserView::AnimationEnded(const ui::Animation* animation) {\n  panel_->manager()->OnPanelAnimationEnded(panel_.get());\n}\n",
        "target": 0
    },
    {
        "id": 826,
        "func": "void SplitStringAlongWhitespace(const std::string& str,\n                                std::vector<std::string>* result) {\n  SplitStringAlongWhitespaceT(str, result);\n}\n",
        "target": 0
    },
    {
        "id": 827,
        "func": "BOOL CALLBACK ShowWindowsCallback(HWND window, LPARAM param) {\n  RenderWidgetHostViewAura* widget =\n      reinterpret_cast<RenderWidgetHostViewAura*>(param);\n\n  if (GetProp(window, kWidgetOwnerProperty) == widget &&\n      widget->GetNativeView()->GetDispatcher()) {\n    HWND parent = widget->GetNativeView()->GetDispatcher()->host()->\n        GetAcceleratedWidget();\n    SetParent(window, parent);\n  }\n  return TRUE;\n}\n",
        "target": 0
    },
    {
        "id": 828,
        "func": "Segment::Segment(IMkvReader* pReader, long long elem_start,\n long long start, long long size)\n : m_pReader(pReader),\n      m_element_start(elem_start),\n      m_start(start),\n      m_size(size),\n      m_pos(start),\n      m_pUnknownSize(0),\n      m_pSeekHead(NULL),\n      m_pInfo(NULL),\n\n       m_pTracks(NULL),\n       m_pCues(NULL),\n       m_pChapters(NULL),\n       m_clusters(NULL),\n       m_clusterCount(0),\n       m_clusterPreloadCount(0),\n      m_clusterSize(0) {}\n",
        "target": 1
    },
    {
        "id": 829,
        "func": "static void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}",
        "target": 0
    },
    {
        "id": 830,
        "func": "static int l_open_channel (lua_State *L) {\n    ssh_userdata *state = (ssh_userdata *)lua_touserdata(L, 1);\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **)lua_newuserdata(L, sizeof(LIBSSH2_CHANNEL *));\n\n    while ((*channel = libssh2_channel_open_session(state->session)) == NULL\n    && libssh2_session_last_errno(state->session) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, finish_open_channel);\n    }\n\n    return l_setup_channel(L);\n}",
        "target": 0
    },
    {
        "id": 831,
        "func": "static int nf_tables_delrule(struct sock *nlsk, struct sk_buff *skb,\n\t\t\t     const struct nlmsghdr *nlh,\n\t\t\t     const struct nlattr * const nla[])\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\n\tstruct nft_af_info *afi;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nft_table *table;\n\tstruct nft_chain *chain = NULL;\n\tstruct nft_rule *rule;\n\tint family = nfmsg->nfgen_family, err = 0;\n\tstruct nft_ctx ctx;\n\n\tafi = nf_tables_afinfo_lookup(net, family, false);\n\tif (IS_ERR(afi))\n\t\treturn PTR_ERR(afi);\n\n\ttable = nf_tables_table_lookup(afi, nla[NFTA_RULE_TABLE]);\n\tif (IS_ERR(table))\n\t\treturn PTR_ERR(table);\n\tif (table->flags & NFT_TABLE_INACTIVE)\n\t\treturn -ENOENT;\n\n\tif (nla[NFTA_RULE_CHAIN]) {\n\t\tchain = nf_tables_chain_lookup(table, nla[NFTA_RULE_CHAIN]);\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t}\n\n\tnft_ctx_init(&ctx, skb, nlh, afi, table, chain, nla);\n\n\tif (chain) {\n\t\tif (nla[NFTA_RULE_HANDLE]) {\n\t\t\trule = nf_tables_rule_lookup(chain,\n\t\t\t\t\t\t     nla[NFTA_RULE_HANDLE]);\n\t\t\tif (IS_ERR(rule))\n\t\t\t\treturn PTR_ERR(rule);\n\n\t\t\terr = nft_delrule(&ctx, rule);\n\t\t} else {\n\t\t\terr = nft_delrule_by_chain(&ctx);\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(chain, &table->chains, list) {\n\t\t\tctx.chain = chain;\n\t\t\terr = nft_delrule_by_chain(&ctx);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 832,
        "func": "static void  Free_PosRuleSet( HB_PosRuleSet*  prs )\n{\n  HB_UShort     n, count;\n\n  HB_PosRule*  pr;\n\n\n  if ( prs->PosRule )\n  {\n    count = prs->PosRuleCount;\n    pr    = prs->PosRule;\n\n    for ( n = 0; n < count; n++ )\n      Free_PosRule( &pr[n] );\n\n    FREE( pr );\n  }\n}\n",
        "target": 0
    },
    {
        "id": 833,
        "func": "entry_guards_update_all(guard_selection_t *gs)\n{\n  sampled_guards_update_from_consensus(gs);\n  entry_guards_update_filtered_sets(gs);\n  entry_guards_update_confirmed(gs);\n  entry_guards_update_primary(gs);\n  return 0;\n}",
        "target": 0
    },
    {
        "id": 834,
        "func": "String FormAssociatedElement::customValidationMessage() const\n{\n    return m_customValidationMessage;\n}\n",
        "target": 0
    },
    {
        "id": 835,
        "func": "static bool HasTextContent(Resource* cached_resource) {\n  Resource::Type type = cached_resource->GetType();\n  return type == Resource::kCSSStyleSheet || type == Resource::kXSLStyleSheet ||\n         type == Resource::kScript || type == Resource::kRaw ||\n         type == Resource::kImportResource || type == Resource::kMainResource;\n}\n",
        "target": 0
    },
    {
        "id": 836,
        "func": "hstore_recv(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tint32\t\ti;\n\tint32\t\tpcount;\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tpcount = pq_getmsgint(buf, 4);\n\n\tif (pcount == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n\t\tPG_RETURN_POINTER(out);\n\t}\n\n\tif (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t pcount, (int) (MaxAllocSize / sizeof(Pairs)))));\n\tpairs = palloc(pcount * sizeof(Pairs));\n\n\tfor (i = 0; i < pcount; ++i)\n\t{\n\t\tint\t\t\trawlen = pq_getmsgint(buf, 4);\n\t\tint\t\t\tlen;\n\n\t\tif (rawlen < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\n\t\tpairs[i].key = pq_getmsgtext(buf, rawlen, &len);\n\t\tpairs[i].keylen = hstoreCheckKeyLen(len);\n\t\tpairs[i].needfree = true;\n\n\t\trawlen = pq_getmsgint(buf, 4);\n\t\tif (rawlen < 0)\n\t\t{\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].vallen = 0;\n\t\t\tpairs[i].isnull = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].val = pq_getmsgtext(buf, rawlen, &len);\n\t\t\tpairs[i].vallen = hstoreCheckValLen(len);\n\t\t\tpairs[i].isnull = false;\n\t\t}\n\t}\n\n\tpcount = hstoreUniquePairs(pairs, pcount, &buflen);\n\n\tout = hstorePairs(pairs, pcount, buflen);\n\n\tPG_RETURN_POINTER(out);\n}",
        "target": 0
    },
    {
        "id": 837,
        "func": "static __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}\n",
        "target": 0
    },
    {
        "id": 838,
        "func": "error::Error GLES2DecoderImpl::HandleGetAttachedShaders(\n    uint32 immediate_data_size, const cmds::GetAttachedShaders& c) {\n  uint32 result_size = c.result_size;\n  GLuint program_id = static_cast<GLuint>(c.program);\n  Program* program = GetProgramInfoNotShader(\n      program_id, \"glGetAttachedShaders\");\n  if (!program) {\n    return error::kNoError;\n  }\n  typedef cmds::GetAttachedShaders::Result Result;\n  uint32 max_count = Result::ComputeMaxResults(result_size);\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.result_shm_id, c.result_shm_offset, Result::ComputeSize(max_count));\n  if (!result) {\n    return error::kOutOfBounds;\n  }\n  if (result->size != 0) {\n    return error::kInvalidArguments;\n  }\n  GLsizei count = 0;\n  glGetAttachedShaders(\n      program->service_id(), max_count, &count, result->GetData());\n  for (GLsizei ii = 0; ii < count; ++ii) {\n    if (!shader_manager()->GetClientId(result->GetData()[ii],\n                                       &result->GetData()[ii])) {\n      NOTREACHED();\n      return error::kGenericError;\n    }\n  }\n  result->SetNumResults(count);\n  return error::kNoError;\n}\n",
        "target": 0
    },
    {
        "id": 839,
        "func": "CIFSSMBQFSUnixInfo(const int xid, struct cifs_tcon *tcon)\n{\n/* level 0x200  SMB_QUERY_CIFS_UNIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_UNIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSUnixInfo\");\nQFSUnixRetry:\n\trc = smb_init_no_reconnect(SMB_COM_TRANSACTION2, 15, tcon,\n\t\t\t\t   (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_CIFS_UNIX_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in QFSUnixInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_UNIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsUnixInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_UNIX_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSUnixRetry;\n\n\n\treturn rc;\n}",
        "target": 0
    },
    {
        "id": 840,
        "func": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\twhile (bytes) {\n\t\t\tint copy = min(bytes, iov->iov_len - base);\n\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}",
        "target": 1
    },
    {
        "id": 841,
        "func": "void WebMediaPlayerImpl::OnError(PipelineStatus status) {\n  DVLOG(1) << __func__;\n  DCHECK(main_task_runner_->BelongsToCurrentThread());\n  DCHECK_NE(status, PIPELINE_OK);\n\n  if (suppress_destruction_errors_)\n    return;\n \n #if defined(OS_ANDROID)\n   if (status == PipelineStatus::DEMUXER_ERROR_DETECTED_HLS) {\n     renderer_factory_selector_->SetUseMediaPlayer(true);\n \n     pipeline_controller_.Stop();\n    SetMemoryReportingState(false);\n\n    main_task_runner_->PostTask(\n        FROM_HERE, base::Bind(&WebMediaPlayerImpl::StartPipeline, AsWeakPtr()));\n    return;\n  }\n#endif\n\n  ReportPipelineError(load_type_, status, media_log_.get());\n  media_log_->AddEvent(media_log_->CreatePipelineErrorEvent(status));\n  media_metrics_provider_->OnError(status);\n  if (watch_time_reporter_)\n    watch_time_reporter_->OnError(status);\n\n  if (ready_state_ == WebMediaPlayer::kReadyStateHaveNothing) {\n    SetNetworkState(WebMediaPlayer::kNetworkStateFormatError);\n  } else {\n    SetNetworkState(PipelineErrorToNetworkState(status));\n  }\n\n  pipeline_controller_.Stop();\n\n  UpdatePlayState();\n}\n",
        "target": 1
    },
    {
        "id": 842,
        "func": "static int nested_svm_intercept_ioio(struct vcpu_svm *svm)\n{\n\tunsigned port, size, iopm_len;\n\tu16 val, mask;\n\tu8 start_bit;\n\tu64 gpa;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_IOIO_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tport = svm->vmcb->control.exit_info_1 >> 16;\n\tsize = (svm->vmcb->control.exit_info_1 & SVM_IOIO_SIZE_MASK) >>\n\t\tSVM_IOIO_SIZE_SHIFT;\n\tgpa  = svm->nested.vmcb_iopm + (port / 8);\n\tstart_bit = port % 8;\n\tiopm_len = (start_bit + size > 8) ? 2 : 1;\n\tmask = (0xf >> (4 - size)) << start_bit;\n\tval = 0;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, gpa, &val, iopm_len))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (val & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}",
        "target": 0
    },
    {
        "id": 843,
        "func": "int sock_no_getsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\treturn -EOPNOTSUPP;\n}",
        "target": 0
    },
    {
        "id": 844,
        "func": "int InternalPageInfoBubbleView::GetDialogButtons() const {\n  return ui::DIALOG_BUTTON_NONE;\n}\n",
        "target": 1
    },
    {
        "id": 845,
        "func": "bool FindSearchTermsInPath(const std::string& path,\n                           url::Component* parameter_position) {\n  DCHECK(parameter_position);\n  parameter_position->reset();\n  const size_t begin = path.find(kSearchTermsParameterFullEscaped);\n  if (begin == std::string::npos)\n    return false;\n  parameter_position->begin = begin;\n  parameter_position->len = arraysize(kSearchTermsParameterFullEscaped) - 1;\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 846,
        "func": "static void __f2fs_submit_merged_bio(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct inode *inode, struct page *page,\n\t\t\t\tnid_t ino, enum page_type type, int rw)\n{\n\tenum page_type btype = PAGE_TYPE_OF_BIO(type);\n\tstruct f2fs_bio_info *io;\n\n\tio = is_read_io(rw) ? &sbi->read_io : &sbi->write_io[btype];\n\n\tdown_write(&io->io_rwsem);\n\n\tif (!__has_merged_page(io, inode, page, ino))\n\t\tgoto out;\n\n\t/* change META to META_FLUSH in the checkpoint procedure */\n\tif (type >= META_FLUSH) {\n\t\tio->fio.type = META_FLUSH;\n\t\tio->fio.op = REQ_OP_WRITE;\n\t\tio->fio.op_flags = REQ_PREFLUSH | REQ_META | REQ_PRIO;\n\t\tif (!test_opt(sbi, NOBARRIER))\n\t\t\tio->fio.op_flags |= REQ_FUA;\n\t}\n\t__submit_merged_bio(io);\nout:\n\tup_write(&io->io_rwsem);\n}",
        "target": 0
    },
    {
        "id": 847,
        "func": "htmlErrMemory(xmlParserCtxtPtr ctxt, const char *extra)\n{\n    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&\n        (ctxt->instate == XML_PARSER_EOF))\n\treturn;\n    if (ctxt != NULL) {\n        ctxt->errNo = XML_ERR_NO_MEMORY;\n        ctxt->instate = XML_PARSER_EOF;\n        ctxt->disableSAX = 1;\n    }\n    if (extra)\n        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,\n                        XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,\n                        NULL, NULL, 0, 0,\n                        \"Memory allocation failed : %s\\n\", extra);\n    else\n        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,\n                        XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,\n                        NULL, NULL, 0, 0, \"Memory allocation failed\\n\");\n}\n",
        "target": 0
    },
    {
        "id": 848,
        "func": "poppler_page_get_image_mapping (PopplerPage *page)\n{\n  GList *map_list = NULL;\n  CairoImageOutputDev *out;\n  gint i;\n  \n  g_return_val_if_fail (POPPLER_IS_PAGE (page), NULL);\n\n  out = poppler_page_get_image_output_dev (page, NULL, NULL);\n\n  for (i = 0; i < out->getNumImages (); i++) {\n    PopplerImageMapping *mapping;\n    CairoImage *image;\n\n    image = out->getImage (i);\n\n    /* Create the mapping */\n    mapping = g_new (PopplerImageMapping, 1);\n\n    image->getRect (&(mapping->area.x1), &(mapping->area.y1),\n\t\t    &(mapping->area.x2), &(mapping->area.y2));\n    mapping->image_id = i;\n    \n    mapping->area.x1 -= page->page->getCropBox()->x1;\n    mapping->area.x2 -= page->page->getCropBox()->x1;\n    mapping->area.y1 -= page->page->getCropBox()->y1;\n    mapping->area.y2 -= page->page->getCropBox()->y1;\n\n    map_list = g_list_prepend (map_list, mapping);\n  }\n\n  delete out;\n\n  return map_list;\t\n}\n",
        "target": 0
    },
    {
        "id": 849,
        "func": "bool extractResFilePathParts(const StringPiece16& path, StringPiece16* outPrefix,\n StringPiece16* outEntry, StringPiece16* outSuffix) {\n if (!stringStartsWith<char16_t>(path, u\"res/\")) {\n return false;\n }\n\n StringPiece16::const_iterator lastOccurence = path.end();\n for (auto iter = path.begin() + StringPiece16(u\"res/\").size(); iter != path.end(); ++iter) {\n if (*iter == u'/') {\n            lastOccurence = iter;\n }\n }\n\n if (lastOccurence == path.end()) {\n return false;\n }\n\n auto iter = std::find(lastOccurence, path.end(), u'.');\n *outSuffix = StringPiece16(iter, path.end() - iter);\n *outEntry = StringPiece16(lastOccurence + 1, iter - lastOccurence - 1);\n *outPrefix = StringPiece16(path.begin(), lastOccurence - path.begin() + 1);\n return true;\n}\n",
        "target": 0
    },
    {
        "id": 850,
        "func": "GaiaScreenHandler* OobeUI::GetGaiaScreenActor() {\n  return gaia_screen_handler_;\n}\n",
        "target": 0
    },
    {
        "id": 851,
        "func": "GF_Box *hdlr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_HandlerBox, GF_ISOM_BOX_TYPE_HDLR);\n\treturn (GF_Box *)tmp;\n}",
        "target": 0
    },
    {
        "id": 852,
        "func": "static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n    /* Absolute error permitted in linear values - affected by the bit depth of\n     * the calculations.\n    */\n if (pm->assume_16_bit_calculations ||\n (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n return pm->maxabs16;\n else\n\n       return pm->maxabs8;\n }\n",
        "target": 1
    },
    {
        "id": 853,
        "func": "static void encode_open(struct xdr_stream *xdr, const struct nfs_openargs *arg, struct compound_hdr *hdr)\n{\n\tencode_openhdr(xdr, arg);\n\tencode_opentype(xdr, arg);\n\tswitch (arg->claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tencode_claim_null(xdr, arg->name);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tencode_claim_previous(xdr, arg->u.delegation_type);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tencode_claim_delegate_cur(xdr, arg->name, &arg->u.delegation);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\thdr->nops++;\n\thdr->replen += decode_open_maxsz;\n}",
        "target": 0
    },
    {
        "id": 854,
        "func": "static void nfs4_xdr_enc_fsinfo(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs4_fsinfo_arg *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_fsinfo(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}",
        "target": 0
    },
    {
        "id": 855,
        "func": "int rand_neg(void)\n\t{\n\tstatic unsigned int neg=0;\n\tstatic int sign[8]={0,0,0,1,1,0,1,1};\n\n\treturn(sign[(neg++)%8]);\n\t}\n",
        "target": 0
    },
    {
        "id": 856,
        "func": "void RenderViewImpl::OnResetPageEncodingToDefault() {\n  WebString no_encoding;\n  webview()->setPageEncoding(no_encoding);\n}\n",
        "target": 0
    },
    {
        "id": 857,
        "func": "void Document::addIconURL(const String& url, const String&, const String&, IconType iconType)\n{\n    if (url.isEmpty())\n        return;\n\n    Frame* f = frame();\n    if (!f)\n        return;\n\n    f->loader()->didChangeIcons(iconType);\n}\n",
        "target": 0
    },
    {
        "id": 858,
        "func": "const char *OBJ_nid2ln(int n)\n\t{\n\tADDED_OBJ ad,*adp;\n\tASN1_OBJECT ob;\n\n\tif ((n >= 0) && (n < NUM_NID))\n\t\t{\n\t\tif ((n != NID_undef) && (nid_objs[n].nid == NID_undef))\n\t\t\t{\n\t\t\tOBJerr(OBJ_F_OBJ_NID2LN,OBJ_R_UNKNOWN_NID);\n\t\t\treturn(NULL);\n\t\t\t}\n\t\treturn(nid_objs[n].ln);\n\t\t}\n\telse if (added == NULL)\n\t\treturn(NULL);\n\telse\n\t\t{\n\t\tad.type=ADDED_NID;\n\t\tad.obj= &ob;\n\t\tob.nid=n;\n\t\tadp=lh_ADDED_OBJ_retrieve(added,&ad);\n\t\tif (adp != NULL)\n\t\t\treturn(adp->obj->ln);\n\t\telse\n\t\t\t{\n\t\t\tOBJerr(OBJ_F_OBJ_NID2LN,OBJ_R_UNKNOWN_NID);\n\t\t\treturn(NULL);\n\t\t\t}\n\t\t}\n\t}\n",
        "target": 0
    },
    {
        "id": 859,
        "func": "void touch_softlockup_watchdog(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, 0);\n}",
        "target": 0
    },
    {
        "id": 860,
        "func": "void TestController::didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef, const void* clientInfo)\n{\n    static_cast<TestController*>(const_cast<void*>(clientInfo))->didFinishLoadForFrame(page, frame);\n}\n",
        "target": 0
    },
    {
        "id": 861,
        "func": "  explicit NetworkStateObserver(Document& document)\n      : ContextLifecycleObserver(&document) {\n    GetNetworkStateNotifier().AddOnLineObserver(\n        this,\n        TaskRunnerHelper::Get(TaskType::kNetworking, GetExecutionContext()));\n  }\n",
        "target": 0
    },
    {
        "id": 862,
        "func": "bool SessionModelAssociator::SyncModelHasUserCreatedNodes(bool* has_nodes) {\n  DCHECK(CalledOnValidThread());\n  CHECK(has_nodes);\n  *has_nodes = false;\n  sync_api::ReadTransaction trans(FROM_HERE, sync_service_->GetUserShare());\n  sync_api::ReadNode root(&trans);\n  if (!root.InitByTagLookup(kSessionsTag)) {\n    LOG(ERROR) << kNoSessionsFolderError;\n    return false;\n  }\n  *has_nodes = root.GetFirstChildId() != sync_api::kInvalidId;\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 863,
        "func": "atol8(const char *p, unsigned char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\treturn (l);\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}\n",
        "target": 0
    },
    {
        "id": 864,
        "func": "NavigateParams::NavigateParams(\n    Browser* a_browser,\n    const GURL& a_url,\n    content::PageTransition a_transition)\n    : url(a_url),\n      target_contents(NULL),\n       source_contents(NULL),\n       disposition(CURRENT_TAB),\n       transition(a_transition),\n       tabstrip_index(-1),\n       tabstrip_add_types(TabStripModel::ADD_ACTIVE),\n       window_action(NO_ACTION),\n      user_gesture(true),\n      path_behavior(RESPECT),\n      ref_behavior(IGNORE_REF),\n      browser(a_browser),\n      profile(NULL) {\n}\n",
        "target": 1
    },
    {
        "id": 865,
        "func": "static void ldap_encode_response(struct asn1_data *data, struct ldap_Result *result)\n {\n       asn1_write_enumerated(data, result->resultcode);\n       asn1_write_OctetString(data, result->dn,\n                              (result->dn) ? strlen(result->dn) : 0);\n       asn1_write_OctetString(data, result->errormessage,\n                               (result->errormessage) ?\n                              strlen(result->errormessage) : 0);\n        if (result->referral) {\n               asn1_push_tag(data, ASN1_CONTEXT(3));\n               asn1_write_OctetString(data, result->referral,\n                                      strlen(result->referral));\n               asn1_pop_tag(data);\n        }\n }\n",
        "target": 1
    },
    {
        "id": 866,
        "func": "std::string SharedWorkerDevToolsAgentHost::GetTitle() {\n  return instance_->name();\n}\n",
        "target": 0
    },
    {
        "id": 867,
        "func": "void ChromeContentBrowserClient::RecordURLMetric(const std::string& metric,\n                                                 const GURL& url) {\n  if (url.is_valid()) {\n    rappor::SampleDomainAndRegistryFromGURL(g_browser_process->rappor_service(),\n                                            metric, url);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 868,
        "func": "static void set_sig_seg(struct mlx5_rwqe_sig *sig, int size)\n{\n\tsig->signature = calc_sig(sig, size);\n}",
        "target": 0
    },
    {
        "id": 869,
        "func": "static void string_cleanup(char** out)\n{\n  free(*out);\n  *out = NULL;\n}\n",
        "target": 0
    },
    {
        "id": 870,
        "func": "static void tg3_write_sig_post_reset(struct tg3 *tp, int kind)\n{\n\tif (tg3_flag(tp, ASF_NEW_HANDSHAKE)) {\n\t\tswitch (kind) {\n\t\tcase RESET_KIND_INIT:\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\n\t\t\t\t      DRV_STATE_START_DONE);\n\t\t\tbreak;\n\n\t\tcase RESET_KIND_SHUTDOWN:\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\n\t\t\t\t      DRV_STATE_UNLOAD_DONE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (kind == RESET_KIND_SHUTDOWN)\n\t\ttg3_ape_driver_state_change(tp, kind);\n}",
        "target": 0
    },
    {
        "id": 871,
        "func": "const Cues* Segment::GetCues() const\n{\n    return m_pCues;\n}\n",
        "target": 1
    },
    {
        "id": 872,
        "func": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\n\tif (size_left == 0)\n\t\treturn 0;\n\n\tbuf = (char *) match32;\n\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\n\t\t/* add padding before match->data (if any) */\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\n\t\tsize_left -= match32->match_size;\n\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tBUG_ON(ret < match32->match_size);\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\n\treturn growth;\n}",
        "target": 0
    },
    {
        "id": 873,
        "func": "test_bson_validate_dbpointer (void)\n{\n   /* { \"a\": DBPointer(ObjectId(...), Collection=\"b\") }, implicit NULL at end */\n   uint8_t data[] = \"\\x1A\\x00\\x00\\x00\\x0C\\x61\\x00\\x02\\x00\\x00\\x00\\x62\\x00\"\n                    \"\\x56\\xE1\\xFC\\x72\\xE0\\xC9\\x17\\xE9\\xC4\\x71\\x41\\x61\";\n\n   bson_t bson;\n   bson_iter_t iter;\n   size_t err_offset = 0;\n   uint32_t collection_len;\n   const char *collection;\n   const bson_oid_t *oid;\n\n   ASSERT (bson_init_static (&bson, data, sizeof data));\n   ASSERT (bson_validate (&bson, BSON_VALIDATE_NONE, &err_offset));\n   ASSERT (bson_iter_init (&iter, &bson));\n   ASSERT (bson_iter_next (&iter));\n   ASSERT (BSON_ITER_HOLDS_DBPOINTER (&iter));\n   bson_iter_dbpointer (&iter, &collection_len, &collection, &oid);\n   ASSERT_CMPSTR (collection, \"b\");\n   ASSERT_CMPINT (collection_len, ==, 1);\n\n   /* replace the NULL terminator of \"b\" with 255 */\n   ASSERT (data[12] == '\\0');\n   data[12] = (uint8_t) '\\xff';\n\n   ASSERT (bson_init_static (&bson, data, sizeof data));\n   ASSERT (!bson_validate (&bson, BSON_VALIDATE_NONE, &err_offset));\n   ASSERT_CMPSIZE_T (err_offset, ==, (size_t) 12);\n\n   ASSERT (bson_iter_init (&iter, &bson));\n   ASSERT (!bson_iter_next (&iter));\n}",
        "target": 0
    },
    {
        "id": 874,
        "func": " bool DebuggerFunction::InitAgentHost() {\n   if (debuggee_.tab_id) {\n     WebContents* web_contents = NULL;\n     bool result = ExtensionTabUtil::GetTabById(*debuggee_.tab_id,\n                                               GetProfile(),\n                                               include_incognito(),\n                                               NULL,\n                                               NULL,\n                                                &web_contents,\n                                                NULL);\n     if (result && web_contents) {\n      if (content::HasWebUIScheme(web_contents->GetURL())) {\n        error_ = ErrorUtils::FormatErrorMessage(\n            keys::kAttachToWebUIError,\n            web_contents->GetURL().scheme());\n         return false;\n      }\n       agent_host_ = DevToolsAgentHost::GetOrCreateFor(web_contents);\n     }\n   } else if (debuggee_.extension_id) {\n    ExtensionHost* extension_host =\n        ExtensionSystem::Get(GetProfile())\n             ->process_manager()\n             ->GetBackgroundHostForExtension(*debuggee_.extension_id);\n     if (extension_host) {\n       agent_host_ = DevToolsAgentHost::GetOrCreateFor(\n           extension_host->render_view_host());\n     }\n  } else if (debuggee_.target_id) {\n    agent_host_ = DevToolsAgentHost::GetForId(*debuggee_.target_id);\n  } else {\n    error_ = keys::kInvalidTargetError;\n    return false;\n  }\n\n  if (!agent_host_.get()) {\n    FormatErrorMessage(keys::kNoTargetError);\n    return false;\n  }\n  return true;\n}\n",
        "target": 1
    },
    {
        "id": 875,
        "func": "static void add_stream_to_programs(AVFormatContext *s, struct playlist *pls, AVStream *stream)\n{\n    HLSContext *c = s->priv_data;\n    int i, j;\n    int bandwidth = -1;\n\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n\n        for (j = 0; j < v->n_playlists; j++) {\n            if (v->playlists[j] != pls)\n                continue;\n\n            av_program_add_stream_index(s, i, stream->index);\n\n            if (bandwidth < 0)\n                bandwidth = v->bandwidth;\n            else if (bandwidth != v->bandwidth)\n                bandwidth = -1; /* stream in multiple variants with different bandwidths */\n        }\n    }\n\n    if (bandwidth >= 0)\n        av_dict_set_int(&stream->metadata, \"variant_bitrate\", bandwidth, 0);\n}",
        "target": 0
    },
    {
        "id": 876,
        "func": "static void GCC_FMT_ATTR(2, 3) dprint(int level, const char *fmt, ...)\n{\n    va_list args;\n\n    if (level <= debug) {\n        va_start(args, fmt);\n        vfprintf(stderr, fmt, args);\n        va_end(args);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 877,
        "func": "long long BlockGroup::GetNextTimeCode() const\n",
        "target": 0
    },
    {
        "id": 878,
        "func": "static void perf_event_free_bpf_handler(struct perf_event *event)\n{\n}",
        "target": 0
    },
    {
        "id": 879,
        "func": " DevToolsDomainHandler::~DevToolsDomainHandler() {\n }\n",
        "target": 0
    },
    {
        "id": 880,
        "func": "void PDFiumEngine::StartFind(const std::string& text, bool case_sensitive) {\n  DCHECK(!text.empty());\n\n  if (pages_.empty())\n    return;\n\n  bool first_search = (current_find_text_ != text);\n  int character_to_start_searching_from = 0;\n  if (first_search) {\n    std::vector<PDFiumRange> old_selection = selection_;\n    StopFind();\n    current_find_text_ = text;\n\n    if (old_selection.empty()) {\n      next_page_to_search_ = 0;\n      last_page_to_search_ = pages_.size() - 1;\n      last_character_index_to_search_ = -1;\n    } else {\n      next_page_to_search_ = old_selection[0].page_index();\n      last_character_index_to_search_ = old_selection[0].char_index();\n      character_to_start_searching_from = old_selection[0].char_index();\n      last_page_to_search_ = next_page_to_search_;\n    }\n  }\n\n  int current_page = next_page_to_search_;\n\n  if (pages_[current_page]->available()) {\n    base::string16 str = base::UTF8ToUTF16(text);\n    if (0) {\n      SearchUsingPDFium(str, case_sensitive, first_search,\n                        character_to_start_searching_from, current_page);\n    } else {\n      SearchUsingICU(str, case_sensitive, first_search,\n                     character_to_start_searching_from, current_page);\n    }\n\n    if (!IsPageVisible(current_page))\n      pages_[current_page]->Unload();\n  }\n\n  if (next_page_to_search_ != last_page_to_search_ ||\n      (first_search && last_character_index_to_search_ != -1)) {\n    ++next_page_to_search_;\n  }\n\n  if (next_page_to_search_ == static_cast<int>(pages_.size()))\n    next_page_to_search_ = 0;\n  bool end_of_search =\n      next_page_to_search_ == last_page_to_search_ &&\n      ((pages_.size() == 1 && last_character_index_to_search_ == -1) ||\n       (pages_.size() == 1 && !first_search) ||\n       (pages_.size() > 1 && current_page == next_page_to_search_));\n\n  if (end_of_search) {\n    client_->NotifyNumberOfFindResultsChanged(find_results_.size(), true);\n  } else {\n    pp::CompletionCallback callback =\n        find_factory_.NewCallback(&PDFiumEngine::ContinueFind);\n    pp::Module::Get()->core()->CallOnMainThread(0, callback,\n                                                case_sensitive ? 1 : 0);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 881,
        "func": "int recover_inode_page(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct f2fs_inode *src, *dst;\n\tnid_t ino = ino_of_node(page);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *ipage;\n\n\tget_node_info(sbi, ino, &old_ni);\n\n\tif (unlikely(old_ni.blk_addr != NULL_ADDR))\n\t\treturn -EINVAL;\nretry:\n\tipage = f2fs_grab_cache_page(NODE_MAPPING(sbi), ino, false);\n\tif (!ipage) {\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\tgoto retry;\n\t}\n\n\t/* Should not use this inode from free nid list */\n\tremove_free_nid(sbi, ino);\n\n\tif (!PageUptodate(ipage))\n\t\tSetPageUptodate(ipage);\n\tfill_node_footer(ipage, ino, ino, 0, true);\n\n\tsrc = F2FS_INODE(page);\n\tdst = F2FS_INODE(ipage);\n\n\tmemcpy(dst, src, (unsigned long)&src->i_ext - (unsigned long)src);\n\tdst->i_size = 0;\n\tdst->i_blocks = cpu_to_le64(1);\n\tdst->i_links = cpu_to_le32(1);\n\tdst->i_xattr_nid = 0;\n\tdst->i_inline = src->i_inline & F2FS_INLINE_XATTR;\n\n\tnew_ni = old_ni;\n\tnew_ni.ino = ino;\n\n\tif (unlikely(!inc_valid_node_count(sbi, NULL)))\n\t\tWARN_ON(1);\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\tinc_valid_inode_count(sbi);\n\tset_page_dirty(ipage);\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 882,
        "func": "void CSSStyleSheet::deleteRule(unsigned index, ExceptionCode& ec)\n{\n    if (index >= length()) {\n        ec = INDEX_SIZE_ERR;\n        return;\n    }\n\n    ec = 0;\n    remove(index);\n    styleSheetChanged();\n}\n",
        "target": 0
    },
    {
        "id": 883,
        "func": "startParsing(XML_Parser parser) {\n  /* hash functions must be initialized before setContext() is called */\n  if (parser->m_hash_secret_salt == 0)\n    parser->m_hash_secret_salt = generate_hash_secret_salt(parser);\n  if (parser->m_ns) {\n    /* implicit context only set for root parser, since child\n       parsers (i.e. external entity parsers) will inherit it\n    */\n    return setContext(parser, implicitContext);\n  }\n  return XML_TRUE;\n}",
        "target": 0
    },
    {
        "id": 884,
        "func": "static void adapter_state_change_callback(bt_state_t status) {\n if (!checkCallbackThread()) {\n       ALOGE(\"Callback: '%s' is not called on the correct thread\", __FUNCTION__);\n return;\n }\n    ALOGV(\"%s: Status is: %d\", __FUNCTION__, status);\n\n    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_stateChangeCallback, (jint)status);\n\n    checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);\n}\n",
        "target": 0
    },
    {
        "id": 885,
        "func": "bool ChildProcessLauncherHelper::TerminateProcess(const base::Process& process,\n                                                  int exit_code) {\n  GetProcessLauncherTaskRunner()->PostTask(\n      FROM_HERE, base::BindOnce(&StopChildProcess, process.Handle()));\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 886,
        "func": "grub_disk_cache_fetch (unsigned long dev_id, unsigned long disk_id,\n\t\t       grub_disk_addr_t sector)\n{\n  struct grub_disk_cache *cache;\n  unsigned index;\n\n  index = grub_disk_cache_get_index (dev_id, disk_id, sector);\n  cache = grub_disk_cache_table + index;\n\n  if (cache->dev_id == dev_id && cache->disk_id == disk_id\n      && cache->sector == sector)\n    {\n      cache->lock = 1;\n#if 0\n      grub_disk_cache_hits++;\n#endif\n      return cache->data;\n    }\n\n#if 0\n  grub_disk_cache_misses++;\n#endif\n\n  return 0;\n}",
        "target": 0
    },
    {
        "id": 887,
        "func": "static void run_event_gtk_error(const char *error_line, void *param)\n{\n    update_command_run_log(error_line, (struct analyze_event_data *)param);\n}",
        "target": 0
    },
    {
        "id": 888,
        "func": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *graydata;\n\n  XCFPixelInfo\n    *xcfdata,\n    *xcfodata;\n\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  /* used by gray and indexed */\n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}",
        "target": 1
    },
    {
        "id": 889,
        "func": " SPL_METHOD(FilesystemIterator, key)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (SPL_FILE_DIR_KEY(intern, SPL_FILE_DIR_KEY_AS_FILENAME)) {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t} else {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t}\n}\n",
        "target": 1
    },
    {
        "id": 890,
        "func": "void LayerTreeHostImpl::CreatePendingTree() {\n  CHECK(!pending_tree_);\n  if (recycle_tree_) {\n    recycle_tree_.swap(pending_tree_);\n  } else {\n    pending_tree_ = base::MakeUnique<LayerTreeImpl>(\n        this, active_tree()->page_scale_factor(),\n        active_tree()->top_controls_shown_ratio(),\n        active_tree()->elastic_overscroll());\n  }\n\n  client_->OnCanDrawStateChanged(CanDraw());\n  TRACE_EVENT_ASYNC_BEGIN0(\"cc\", \"PendingTree:waiting\", pending_tree_.get());\n\n  DCHECK(!pending_tree_duration_timer_);\n  pending_tree_duration_timer_.reset(new PendingTreeDurationHistogramTimer());\n}\n",
        "target": 0
    },
    {
        "id": 891,
        "func": "void HTMLMediaElement::didNotifySubtreeInsertionsToDocument() {\n  updateControlsVisibility();\n}\n",
        "target": 0
    },
    {
        "id": 892,
        "func": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\n\t/* Get a buffer. */\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\t/* We have no choice but to commit suicide in this case. */\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\t// ORIGINAL (WRONG): m = (parity) ? hstartcol : (numrows - hstartcol);\n\t\tm = numrows - hstartcol;\n\n\t\t/* Save the samples destined for the highpass channel. */\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the appropriate samples into the lowpass channel. */\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\t/* Copy the saved samples into the highpass channel. */\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\n\t/* If the split buffer was allocated on the heap, free this memory. */\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n\n}",
        "target": 1
    },
    {
        "id": 893,
        "func": "XML_SetUnknownEncodingHandler(XML_Parser parser,\n                              XML_UnknownEncodingHandler handler, void *data) {\n  if (parser == NULL)\n    return;\n  parser->m_unknownEncodingHandler = handler;\n  parser->m_unknownEncodingHandlerData = data;\n}",
        "target": 0
    },
    {
        "id": 894,
        "func": " bool PermissionsContainsFunction::RunImpl() {\n   scoped_ptr<Contains::Params> params(Contains::Params::Create(*args_));\n \n   scoped_refptr<PermissionSet> permissions =\n      helpers::UnpackPermissionSet(params->permissions, &error_);\n   if (!permissions.get())\n     return false;\n \n  results_ = Contains::Results::Create(\n      GetExtension()->GetActivePermissions()->Contains(*permissions));\n  return true;\n}\n",
        "target": 1
    },
    {
        "id": 895,
        "func": "blink::mojom::BlobURLTokenPtrInfo CloneBlobURLToken(\n    mojo::MessagePipeHandle handle) {\n  if (!handle.is_valid())\n    return nullptr;\n  blink::mojom::BlobURLTokenPtrInfo result;\n  blink::mojom::BlobURLTokenPtr token(\n      blink::mojom::BlobURLTokenPtrInfo(mojo::ScopedMessagePipeHandle(handle),\n                                        blink::mojom::BlobURLToken::Version_));\n  token->Clone(MakeRequest(&result));\n  ignore_result(token.PassInterface().PassHandle().release());\n  return result;\n}\n",
        "target": 0
    },
    {
        "id": 896,
        "func": "static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty) && !L_EXTPROC(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}",
        "target": 0
    },
    {
        "id": 897,
        "func": "ChromeContentBrowserClient::~ChromeContentBrowserClient() {\n  for (int i = static_cast<int>(extra_parts_.size()) - 1; i >= 0; --i)\n    delete extra_parts_[i];\n  extra_parts_.clear();\n}\n",
        "target": 0
    },
    {
        "id": 898,
        "func": "void HTMLConstructionSite::insertComment(AtomicHTMLToken& token)\n{\n    ASSERT(token.type() == HTMLToken::Comment);\n    attach(currentElement(), Comment::create(m_document, token.comment()));\n}\n",
        "target": 0
    },
    {
        "id": 899,
        "func": "bool PageLayoutIsEqual(const PrintMsg_PrintPages_Params& oldParams,\n                       const PrintMsg_PrintPages_Params& newParams) {\n  return oldParams.params.content_size == newParams.params.content_size &&\n         oldParams.params.printable_area == newParams.params.printable_area &&\n         oldParams.params.page_size == newParams.params.page_size &&\n         oldParams.params.margin_top == newParams.params.margin_top &&\n         oldParams.params.margin_left == newParams.params.margin_left &&\n         oldParams.params.desired_dpi == newParams.params.desired_dpi &&\n         oldParams.params.dpi == newParams.params.dpi;\n}\n",
        "target": 0
    },
    {
        "id": 900,
        "func": "void GLES2DecoderImpl::ReleaseCurrent() {\n  if (context_.get())\n    context_->ReleaseCurrent(surface_.get());\n}\n",
        "target": 0
    },
    {
        "id": 901,
        "func": "int _gnutls_user_hello_func( gnutls_session session, gnutls_protocol_t adv_version)\n{\nint ret;\n\n  if (session->internals.user_hello_func != NULL) \n    {\n      ret = session->internals.user_hello_func( session);\n      if (ret < 0) \n        {\n          gnutls_assert();\n          return ret;\n        }\n      /* Here we need to renegotiate the version since the callee might\n       * have disabled some TLS versions.\n       */\n      ret = _gnutls_negotiate_version( session, adv_version);\n      if (ret < 0) {\n        gnutls_assert();\n        return ret;\n      }\n    }\n  return 0;\n}\n",
        "target": 0
    },
    {
        "id": 902,
        "func": "void macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}",
        "target": 1
    },
    {
        "id": 903,
        "func": "list_del_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tstruct perf_cpu_context *cpuctx;\n\n\tWARN_ON_ONCE(event->ctx != ctx);\n\tlockdep_assert_held(&ctx->lock);\n\n\t/*\n\t * We can have double detach due to exit/hot-unplug + close.\n\t */\n\tif (!(event->attach_state & PERF_ATTACH_CONTEXT))\n\t\treturn;\n\n\tevent->attach_state &= ~PERF_ATTACH_CONTEXT;\n\n\tif (is_cgroup_event(event)) {\n\t\tctx->nr_cgroups--;\n\t\tcpuctx = __get_cpu_context(ctx);\n\t\t/*\n\t\t * if there are no more cgroup events\n\t\t * then cler cgrp to avoid stale pointer\n\t\t * in update_cgrp_time_from_cpuctx()\n\t\t */\n\t\tif (!ctx->nr_cgroups)\n\t\t\tcpuctx->cgrp = NULL;\n\t}\n\n\tctx->nr_events--;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat--;\n\n\tlist_del_rcu(&event->event_entry);\n\n\tif (event->group_leader == event)\n\t\tlist_del_init(&event->group_entry);\n\n\tupdate_group_times(event);\n\n\t/*\n\t * If event was in error state, then keep it\n\t * that way, otherwise bogus counts will be\n\t * returned on read(). The only way to get out\n\t * of error state is by explicit re-enabling\n\t * of the event\n\t */\n\tif (event->state > PERF_EVENT_STATE_OFF)\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\n\tctx->generation++;\n}",
        "target": 0
    },
    {
        "id": 904,
        "func": "void WebPage::addCompositingThreadOverlay(WebOverlay* overlay)\n{\n#if USE(ACCELERATED_COMPOSITING)\n    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());\n    if (!d->compositor())\n        return;\n\n    overlay->d->setPage(d);\n    d->compositor()->addOverlay(overlay->d->layerCompositingThread());\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 905,
        "func": "static void dump_header(struct task_struct *p, gfp_t gfp_mask, int order,\n\t\t\tstruct mem_cgroup *mem, const nodemask_t *nodemask)\n{\n\ttask_lock(current);\n\tpr_warning(\"%s invoked oom-killer: gfp_mask=0x%x, order=%d, \"\n\t\t\"oom_adj=%d, oom_score_adj=%d\\n\",\n\t\tcurrent->comm, gfp_mask, order, current->signal->oom_adj,\n\t\tcurrent->signal->oom_score_adj);\n\tcpuset_print_task_mems_allowed(current);\n\ttask_unlock(current);\n\tdump_stack();\n\tmem_cgroup_print_oom_info(mem, p);\n\tshow_mem(SHOW_MEM_FILTER_NODES);\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(mem, nodemask);\n}\n",
        "target": 0
    },
    {
        "id": 906,
        "func": "php_libxml_input_buffer_create_filename(const char *URI, xmlCharEncoding enc)\n{\n\txmlParserInputBufferPtr ret;\n\tvoid *context = NULL;\n\tTSRMLS_FETCH();\n\n\tif (LIBXML(entity_loader_disabled)) {\n\t\treturn NULL;\n\t}\n\n\tif (URI == NULL)\n\t\treturn(NULL);\n\n\tcontext = php_libxml_streams_IO_open_read_wrapper(URI);\n\n\tif (context == NULL) {\n\t\treturn(NULL);\n\t}\n\n\t/* Allocate the Input buffer front-end. */\n\tret = xmlAllocParserInputBuffer(enc);\n\tif (ret != NULL) {\n\t\tret->context = context;\n\t\tret->readcallback = php_libxml_streams_IO_read;\n\t\tret->closecallback = php_libxml_streams_IO_close;\n\t} else\n\t\tphp_libxml_streams_IO_close(context);\n\n\treturn(ret);\n}\n",
        "target": 0
    },
    {
        "id": 907,
        "func": "  MockPasswordAccessoryView* view() {\n    return static_cast<MockPasswordAccessoryView*>(controller()->view());\n  }\n",
        "target": 0
    },
    {
        "id": 908,
        "func": "static void timelib_eat_spaces(char **ptr)\n{\n\twhile (**ptr == ' ' || **ptr == '\\t') {\n\t\t++*ptr;\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 909,
        "func": "logclose(Image *image, FILE *f, const char *name, const char *operation)\n{\n int e = errno;\n\n   fclose(f);\n return logerror(image, name, operation, strerror(e));\n}\n",
        "target": 0
    },
    {
        "id": 910,
        "func": "zend_bool php_openssl_pkey_init_dsa(DSA *dsa, zval *data)\n{\n\tBIGNUM *p, *q, *g, *priv_key, *pub_key;\n\tconst BIGNUM *priv_key_const, *pub_key_const;\n\n\tOPENSSL_PKEY_SET_BN(data, p);\n\tOPENSSL_PKEY_SET_BN(data, q);\n\tOPENSSL_PKEY_SET_BN(data, g);\n\tif (!p || !q || !g || !DSA_set0_pqg(dsa, p, q, g)) {\n\t\treturn 0;\n\t}\n\n\tOPENSSL_PKEY_SET_BN(data, pub_key);\n\tOPENSSL_PKEY_SET_BN(data, priv_key);\n\tif (pub_key) {\n\t\treturn DSA_set0_key(dsa, pub_key, priv_key);\n\t}\n\n\t/* generate key */\n\tPHP_OPENSSL_RAND_ADD_TIME();\n\tif (!DSA_generate_key(dsa)) {\n\t\tphp_openssl_store_errors();\n\t\treturn 0;\n\t}\n\n\t/* if BN_mod_exp return -1, then DSA_generate_key succeed for failed key\n\t * so we need to double check that public key is created */\n\tDSA_get0_key(dsa, &pub_key_const, &priv_key_const);\n\tif (!pub_key_const || BN_is_zero(pub_key_const)) {\n\t\treturn 0;\n\t}\n\t/* all good */\n\treturn 1;\n}\n",
        "target": 0
    },
    {
        "id": 911,
        "func": "static int __net_init xt_net_init(struct net *net)\n{\n\tint i;\n\n\tfor (i = 0; i < NFPROTO_NUMPROTO; i++)\n\t\tINIT_LIST_HEAD(&net->xt.tables[i]);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 912,
        "func": "DECLAREcpFunc(cpSeparate2ContigByRow)\n{\n\ttsize_t scanlinesizein = TIFFScanlineSize(in);\n\ttsize_t scanlinesizeout = TIFFScanlineSize(out);\n\ttdata_t inbuf;\n\ttdata_t outbuf;\n\tregister uint8 *inp, *outp;\n \tregister uint32 n;\n \tuint32 row;\n \ttsample_t s;\n \n \tinbuf = _TIFFmalloc(scanlinesizein);\n \toutbuf = _TIFFmalloc(scanlinesizeout);\n\tif (!inbuf || !outbuf)\n                goto bad;\n\t_TIFFmemset(inbuf, 0, scanlinesizein);\n\t_TIFFmemset(outbuf, 0, scanlinesizeout);\n\tfor (row = 0; row < imagelength; row++) {\n\t\t/* merge channels */\n\t\tfor (s = 0; s < spp; s++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, s) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tinp = (uint8*)inbuf;\n\t\t\toutp = ((uint8*)outbuf) + s;\n\t\t\tfor (n = imagewidth; n-- > 0;) {\n\t\t\t\t*outp = *inp++;\n\t\t\t\toutp += spp;\n\t\t\t}\n\t\t}\n\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0) {\n\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t    \"Error, can't write scanline %lu\",\n\t\t\t    (unsigned long) row);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 1;\nbad:\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 0;\n}\n",
        "target": 1
    },
    {
        "id": 913,
        "func": "bool WebPage::isAtInitialZoom() const\n{\n    return (d->currentScale() == d->initialScale()) || !d->isUserScalable();\n}\n",
        "target": 0
    },
    {
        "id": 914,
        "func": "RenderMenuList::~RenderMenuList()\n{\n    if (m_popup)\n        m_popup->disconnectClient();\n    m_popup = 0;\n}\n",
        "target": 0
    },
    {
        "id": 915,
        "func": "static int hns_nic_notifier_action(struct notifier_block *nb,\n\t\t\t\t   unsigned long action, void *data)\n{\n\tstruct hns_nic_priv *priv =\n\t\tcontainer_of(nb, struct hns_nic_priv, notifier_block);\n\n\tassert(action == HNAE_AE_REGISTER);\n\n\tif (!hns_nic_try_get_ae(priv->netdev)) {\n\t\thnae_unregister_notifier(&priv->notifier_block);\n\t\tpriv->notifier_block.notifier_call = NULL;\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 916,
        "func": "static inline void sem_getref_and_unlock(struct sem_array *sma)\n{\n\tWARN_ON_ONCE(!ipc_rcu_getref(sma));\n\tsem_unlock(sma, -1);\n}",
        "target": 0
    },
    {
        "id": 917,
        "func": "IntSize PaintLayerScrollableArea::OffsetFromResizeCorner(\n    const IntPoint& absolute_point) const {\n  IntSize element_size = Layer()->PixelSnappedSize();\n  if (GetLayoutBox()->ShouldPlaceBlockDirectionScrollbarOnLogicalLeft())\n    element_size.SetWidth(0);\n  IntPoint resizer_point = IntPoint(element_size);\n  IntPoint local_point = RoundedIntPoint(GetLayoutBox()->AbsoluteToLocal(\n      FloatPoint(absolute_point), kUseTransforms));\n  return local_point - resizer_point;\n}\n",
        "target": 0
    },
    {
        "id": 918,
        "func": "void SelectionController::UpdateSelectionForMouseDrag(\n    Node* mouse_press_node,\n    const LayoutPoint& drag_start_pos,\n    const IntPoint& last_known_mouse_position) {\n  LocalFrameView* view = frame_->View();\n  if (!view)\n    return;\n  LayoutViewItem layout_item = frame_->ContentLayoutItem();\n  if (layout_item.IsNull())\n    return;\n\n  HitTestRequest request(HitTestRequest::kReadOnly | HitTestRequest::kActive |\n                         HitTestRequest::kMove);\n  HitTestResult result(request,\n                       view->RootFrameToContents(last_known_mouse_position));\n  layout_item.HitTest(result);\n  UpdateSelectionForMouseDrag(result, mouse_press_node, drag_start_pos,\n                              last_known_mouse_position);\n}\n",
        "target": 0
    },
    {
        "id": 919,
        "func": "link_info_start (NautilusDirectory *directory,\n                 NautilusFile      *file,\n                 gboolean          *doing_io)\n{\n    GFile *location;\n    gboolean nautilus_style_link;\n    LinkInfoReadState *state;\n\n    if (directory->details->link_info_read_state != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_link_info,\n                   REQUEST_LINK_INFO))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    /* Figure out if it is a link. */\n    nautilus_style_link = nautilus_file_is_nautilus_link (file);\n    location = nautilus_file_get_location (file);\n\n    /* If it's not a link we are done. If it is, we need to read it. */\n    if (!nautilus_style_link)\n    {\n        link_info_done (directory, file, NULL, NULL, NULL, FALSE, FALSE);\n    }\n    else\n    {\n        if (!async_job_start (directory, \"link info\"))\n        {\n            g_object_unref (location);\n            return;\n        }\n\n        state = g_new0 (LinkInfoReadState, 1);\n        state->directory = directory;\n        state->file = file;\n        state->cancellable = g_cancellable_new ();\n\n        directory->details->link_info_read_state = state;\n\n        g_file_load_contents_async (location,\n                                    state->cancellable,\n                                    link_info_nautilus_link_read_callback,\n                                    state);\n    }\n    g_object_unref (location);\n}",
        "target": 0
    },
    {
        "id": 920,
        "func": "void WebPluginDelegatePepper::DidFinishManualLoading() {\n  instance()->DidFinishManualLoading();\n}\n",
        "target": 0
    },
    {
        "id": 921,
        "func": "ZEND_API void zend_fcall_info_args_clear(zend_fcall_info *fci, int free_mem) /* {{{ */\n{\n\tif (fci->params) {\n\t\tif (free_mem) {\n\t\t\tefree(fci->params);\n\t\t\tfci->params = NULL;\n\t\t}\n\t}\n\tfci->param_count = 0;\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 922,
        "func": "void StoragePartitionImpl::SetURLRequestContext(\n    net::URLRequestContextGetter* url_request_context) {\n  url_request_context_ = url_request_context;\n}\n",
        "target": 0
    },
    {
        "id": 923,
        "func": "static int mboxlist_read(const char *name, const char **dataptr, size_t *datalenptr,\n                         struct txn **tid, int wrlock)\n{\n    int namelen = strlen(name);\n    int r;\n\n    if (!namelen)\n        return IMAP_MAILBOX_NONEXISTENT;\n\n    if (wrlock) {\n        r = cyrusdb_fetchlock(mbdb, name, namelen, dataptr, datalenptr, tid);\n    } else {\n        r = cyrusdb_fetch(mbdb, name, namelen, dataptr, datalenptr, tid);\n    }\n\n    switch (r) {\n    case CYRUSDB_OK:\n        /* no entry required, just checking if it exists */\n        return 0;\n        break;\n\n    case CYRUSDB_AGAIN:\n        return IMAP_AGAIN;\n        break;\n\n    case CYRUSDB_NOTFOUND:\n        return IMAP_MAILBOX_NONEXISTENT;\n        break;\n\n    default:\n        syslog(LOG_ERR, \"DBERROR: error fetching mboxlist %s: %s\",\n               name, cyrusdb_strerror(r));\n        return IMAP_IOERROR;\n        break;\n    }\n\n    /* never get here */\n}\n",
        "target": 0
    },
    {
        "id": 924,
        "func": " randomize(void *pv, size_t size)\n {\n static png_uint_32 random_seed[2] = {0x56789abc, 0xd};\n   make_random_bytes(random_seed, pv, size);\n\n }\n",
        "target": 0
    },
    {
        "id": 925,
        "func": "static v8::Handle<v8::Value> enabledAtRuntimeMethod1Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.enabledAtRuntimeMethod1\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->enabledAtRuntimeMethod1(intArg);\n    return v8::Handle<v8::Value>();\n}\n",
        "target": 1
    },
    {
        "id": 926,
        "func": "uiserver_set_fd (engine_uiserver_t uiserver, fd_type_t fd_type, const char *opt)\n{\n  gpg_error_t err = 0;\n  char line[COMMANDLINELEN];\n  char *which;\n  iocb_data_t *iocb_data;\n  int dir;\n\n  switch (fd_type)\n    {\n    case INPUT_FD:\n      which = \"INPUT\";\n      iocb_data = &uiserver->input_cb;\n      break;\n\n    case OUTPUT_FD:\n      which = \"OUTPUT\";\n      iocb_data = &uiserver->output_cb;\n      break;\n\n    case MESSAGE_FD:\n      which = \"MESSAGE\";\n      iocb_data = &uiserver->message_cb;\n      break;\n\n    default:\n      return gpg_error (GPG_ERR_INV_VALUE);\n    }\n\n  dir = iocb_data->dir;\n\n  /* We try to short-cut the communication by giving UISERVER direct\n     access to the file descriptor, rather than using a pipe.  */\n  iocb_data->server_fd = _gpgme_data_get_fd (iocb_data->data);\n  if (iocb_data->server_fd < 0)\n    {\n      int fds[2];\n\n      if (_gpgme_io_pipe (fds, 0) < 0)\n\treturn gpg_error_from_syserror ();\n\n      iocb_data->fd = dir ? fds[0] : fds[1];\n      iocb_data->server_fd = dir ? fds[1] : fds[0];\n\n      if (_gpgme_io_set_close_notify (iocb_data->fd,\n\t\t\t\t      close_notify_handler, uiserver))\n\t{\n\t  err = gpg_error (GPG_ERR_GENERAL);\n\t  goto leave_set_fd;\n\t}\n    }\n\n  err = assuan_sendfd (uiserver->assuan_ctx, iocb_data->server_fd);\n  if (err)\n    goto leave_set_fd;\n\n  _gpgme_io_close (iocb_data->server_fd);\n  iocb_data->server_fd = -1;\n\n  if (opt)\n    snprintf (line, COMMANDLINELEN, \"%s FD %s\", which, opt);\n  else\n    snprintf (line, COMMANDLINELEN, \"%s FD\", which);\n\n  err = uiserver_assuan_simple_command (uiserver->assuan_ctx, line, NULL, NULL);\n\n leave_set_fd:\n  if (err)\n    {\n      _gpgme_io_close (iocb_data->fd);\n      iocb_data->fd = -1;\n      if (iocb_data->server_fd != -1)\n        {\n          _gpgme_io_close (iocb_data->server_fd);\n          iocb_data->server_fd = -1;\n        }\n    }\n\n  return err;\n}\n",
        "target": 0
    },
    {
        "id": 927,
        "func": "void TitleWatcher::TitleWasSet(NavigationEntry* entry) {\n  TestTitle();\n}\n",
        "target": 0
    },
    {
        "id": 928,
        "func": "GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(\n    content::CauseForGpuLaunch cause_for_gpu_launch) {\n  if (gpu_channel_.get()) {\n    if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||\n        gpu_channel_->state() == GpuChannelHost::kConnected)\n      return GetGpuChannel();\n\n    gpu_channel_ = NULL;\n  }\n\n   int client_id = 0;\n   IPC::ChannelHandle channel_handle;\n  base::ProcessHandle renderer_process_for_gpu;\n   content::GPUInfo gpu_info;\n   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,\n                                                &client_id,\n                                                &channel_handle,\n                                               &renderer_process_for_gpu,\n                                                &gpu_info)) ||\n      channel_handle.name.empty() ||\n #if defined(OS_POSIX)\n       channel_handle.socket.fd == -1 ||\n #endif\n      renderer_process_for_gpu == base::kNullProcessHandle) {\n     gpu_channel_ = NULL;\n     return NULL;\n  }\n\n  gpu_channel_ = new GpuChannelHost(this, 0, client_id);\n  gpu_channel_->set_gpu_info(gpu_info);\n   content::GetContentClient()->SetGpuInfo(gpu_info);\n \n  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);\n \n   return GetGpuChannel();\n }\n",
        "target": 1
    },
    {
        "id": 929,
        "func": "void encodeBase64(\n const void *_data, size_t size, AString *out) {\n    out->clear();\n\n const uint8_t *data = (const uint8_t *)_data;\n\n size_t i;\n for (i = 0; i < (size / 3) * 3; i += 3) {\n uint8_t x1 = data[i];\n uint8_t x2 = data[i + 1];\n uint8_t x3 = data[i + 2];\n\n        out->append(encode6Bit(x1 >> 2));\n        out->append(encode6Bit((x1 << 4 | x2 >> 4) & 0x3f));\n        out->append(encode6Bit((x2 << 2 | x3 >> 6) & 0x3f));\n        out->append(encode6Bit(x3 & 0x3f));\n }\n switch (size % 3) {\n case 0:\n break;\n case 2:\n {\n uint8_t x1 = data[i];\n uint8_t x2 = data[i + 1];\n            out->append(encode6Bit(x1 >> 2));\n            out->append(encode6Bit((x1 << 4 | x2 >> 4) & 0x3f));\n            out->append(encode6Bit((x2 << 2) & 0x3f));\n            out->append('=');\n break;\n }\n default:\n {\n uint8_t x1 = data[i];\n            out->append(encode6Bit(x1 >> 2));\n            out->append(encode6Bit((x1 << 4) & 0x3f));\n            out->append(\"==\");\n break;\n }\n }\n}\n",
        "target": 0
    },
    {
        "id": 930,
        "func": "OpenTabsUIDelegate* GetOpenTabsUIDelegate(Profile* profile) {\n  sync_sessions::SessionSyncService* service =\n      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);\n\n  if (!service)\n    return NULL;\n\n  return service->GetOpenTabsUIDelegate();\n}\n",
        "target": 0
    },
    {
        "id": 931,
        "func": "static int process_bf_mask(struct iwbmprcontext *rctx, int k)\n{\n\t// The bits representing the mask for each channel are required to be\n\t// contiguous, so all we need to do is find the highest and lowest bit.\n\trctx->bf_high_bit[k] = find_high_bit(rctx->bf_mask[k]);\n\trctx->bf_low_bit[k] = find_low_bit(rctx->bf_mask[k]);\n\trctx->bf_bits_count[k] = 1+rctx->bf_high_bit[k]-rctx->bf_low_bit[k];\n\n\t// Check if the mask specifies an invalid bit\n\tif(rctx->bf_high_bit[k] > (int)(rctx->bitcount-1)) return 0;\n\n\tif(rctx->bf_bits_count[k]>16) {\n\t\t// We only support up to 16 bits. Ignore any bits after the 16th.\n\t\trctx->bf_low_bit[k] = rctx->bf_high_bit[k]-15;\n\t\trctx->bf_bits_count[k] = 16;\n\t}\n\n\tif(rctx->bf_bits_count[k]>8) {\n\t\trctx->need_16bit = 1;\n\t}\n\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 932,
        "func": "static int windows_abort_transfers(struct usbi_transfer *itransfer)\n{\n\tstruct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);\n\tstruct windows_device_priv *priv = _device_priv(transfer->dev_handle->dev);\n\n\treturn priv->apib->abort_transfers(SUB_API_NOTSET, itransfer);\n}\n",
        "target": 0
    },
    {
        "id": 933,
        "func": "AllViewsStoppedLoadingObserver::AllViewsStoppedLoadingObserver(\n    AutomationProvider* automation,\n    IPC::Message* reply_message,\n    ExtensionProcessManager* extension_process_manager)\n    : automation_(automation->AsWeakPtr()),\n      reply_message_(reply_message),\n      extension_process_manager_(extension_process_manager) {\n  registrar_.Add(this,\n                 chrome::NOTIFICATION_APP_MODAL_DIALOG_SHOWN,\n                 content::NotificationService::AllSources());\n  registrar_.Add(this,\n                 content::NOTIFICATION_LOAD_STOP,\n                 content::NotificationService::AllSources());\n  for (BrowserList::const_iterator iter = BrowserList::begin();\n       iter != BrowserList::end();\n       ++iter) {\n    Browser* browser = *iter;\n    for (int i = 0; i < browser->tab_count(); ++i) {\n      WebContents* web_contents = chrome::GetWebContentsAt(browser, i);\n      AutomationTabHelper* automation_tab_helper =\n          AutomationTabHelper::FromWebContents(web_contents);\n      StartObserving(automation_tab_helper);\n      if (automation_tab_helper->has_pending_loads())\n        pending_tabs_.insert(web_contents);\n    }\n  }\n  CheckIfNoMorePendingLoads();\n}\n",
        "target": 0
    },
    {
        "id": 934,
        "func": "RenderFrameProxyHost* RenderFrameHostManager::GetProxyToParent() {\n  if (frame_tree_node_->IsMainFrame())\n    return nullptr;\n\n  return GetRenderFrameProxyHost(frame_tree_node_->parent()\n                                     ->render_manager()\n                                     ->current_frame_host()\n                                     ->GetSiteInstance());\n}\n",
        "target": 0
    },
    {
        "id": 935,
        "func": "void HTMLInputElement::stepDown(int n, ExceptionState& exceptionState)\n{\n    m_inputType->stepUp(-n, exceptionState);\n}\n",
        "target": 0
    },
    {
        "id": 936,
        "func": "static uint32_t out_get_sample_rate(const struct audio_stream *stream)\n{\n struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;\n\n    DEBUG(\"rate %\" PRIu32,out->common.cfg.rate);\n\n return out->common.cfg.rate;\n}\n",
        "target": 0
    },
    {
        "id": 937,
        "func": "static int misaligned_store(struct pt_regs *regs,\n\t\t\t    __u32 opcode,\n\t\t\t    int displacement_not_indexed,\n\t\t\t    int width_shift)\n{\n\t/* Return -1 for a fault, 0 for OK */\n\tint error;\n\tint srcreg;\n\t__u64 address;\n\n\terror = generate_and_check_address(regs, opcode,\n\t\t\tdisplacement_not_indexed, width_shift, &address);\n\tif (error < 0) {\n\t\treturn error;\n\t}\n\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);\n\n\tsrcreg = (opcode >> 4) & 0x3f;\n\tif (user_mode(regs)) {\n\t\t__u64 buffer;\n\n\t\tif (!access_ok(VERIFY_WRITE, (unsigned long) address, 1UL<<width_shift)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tswitch (width_shift) {\n\t\tcase 1:\n\t\t\t*(__u16 *) &buffer = (__u16) regs->regs[srcreg];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*(__u32 *) &buffer = (__u32) regs->regs[srcreg];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbuffer = regs->regs[srcreg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\",\n\t\t\t\twidth_shift, (unsigned long) regs->pc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (__copy_user((void *)(int)address, &buffer, (1 << width_shift)) > 0) {\n\t\t\treturn -1; /* fault */\n\t\t}\n\t} else {\n\t\t/* kernel mode - we can take short cuts since if we fault, it's a genuine bug */\n\t\t__u64 val = regs->regs[srcreg];\n\n\t\tswitch (width_shift) {\n\t\tcase 1:\n\t\t\tmisaligned_kernel_word_store(address, val);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tasm (\"stlo.l %1, 0, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tasm (\"sthi.l %1, 3, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tasm (\"stlo.q %1, 0, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tasm (\"sthi.q %1, 7, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\",\n\t\t\t\twidth_shift, (unsigned long) regs->pc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}",
        "target": 1
    },
    {
        "id": 938,
        "func": "int ras_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[RAS_MAGICLEN];\n\tint i;\n\tint n;\n\tuint_fast32_t magic;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Put the validation data back onto the stream, so that the\n\t  stream position will not be changed. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Did we read enough data? */\n\tif (n < RAS_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\t/* Is the signature correct for the Sun Rasterfile format? */\n\tif (magic != RAS_MAGIC) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 939,
        "func": "buf_finalize(StringInfo buf)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) buf->data;\n\n\tSET_VARSIZE(snap, buf->len);\n\n\t/* buf is not needed anymore */\n\tbuf->data = NULL;\n\tpfree(buf);\n\n\treturn snap;\n}",
        "target": 0
    },
    {
        "id": 940,
        "func": "void ManifestUmaUtil::FetchFailed(FetchFailureReason reason) {\n  ManifestFetchResultType fetch_result_type = MANIFEST_FETCH_RESULT_TYPE_COUNT;\n  switch (reason) {\n     case FETCH_EMPTY_URL:\n       fetch_result_type = MANIFEST_FETCH_ERROR_EMPTY_URL;\n       break;\n     case FETCH_UNSPECIFIED_REASON:\n       fetch_result_type = MANIFEST_FETCH_ERROR_UNSPECIFIED;\n       break;\n  }\n  DCHECK_NE(fetch_result_type, MANIFEST_FETCH_RESULT_TYPE_COUNT);\n\n  UMA_HISTOGRAM_ENUMERATION(kUMANameFetchResult,\n                            fetch_result_type,\n                            MANIFEST_FETCH_RESULT_TYPE_COUNT);\n}\n",
        "target": 1
    },
    {
        "id": 941,
        "func": "void WebContentsImpl::RenderViewTerminated(RenderViewHost* rvh,\n                                           base::TerminationStatus status,\n                                           int error_code) {\n  if (rvh != GetRenderViewHost()) {\n    return;\n  }\n\n  if (IsFullscreenForCurrentTab())\n    ExitFullscreenMode(false);\n\n  CancelActiveAndPendingDialogs();\n\n  audio_stream_monitor_.RenderProcessGone(rvh->GetProcess()->GetID());\n\n  ResetLoadProgressState();\n  NotifyDisconnected();\n  SetIsCrashed(status, error_code);\n\n  for (auto& observer : observers_)\n    observer.RenderProcessGone(GetCrashedStatus());\n}\n",
        "target": 0
    },
    {
        "id": 942,
        "func": "void NavigationControllerImpl::GoForward() {\n  GoToIndex(GetIndexForOffset(1));\n}\n",
        "target": 0
    },
    {
        "id": 943,
        "func": "sctp_disposition_t sctp_sf_do_5_2_1_siminit(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\t/* Call helper to do the real work for both simulataneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}",
        "target": 0
    },
    {
        "id": 944,
        "func": "static int unsupported_open(int sub_api, struct libusb_device_handle *dev_handle) {\n\tPRINT_UNSUPPORTED_API(open);\n}\n",
        "target": 0
    },
    {
        "id": 945,
        "func": "void NavigatorImpl::CancelNavigation(FrameTreeNode* frame_tree_node,\n                                     bool inform_renderer) {\n  CHECK(IsBrowserSideNavigationEnabled());\n  if (frame_tree_node->navigation_request() &&\n      frame_tree_node->navigation_request()->navigation_handle()) {\n    frame_tree_node->navigation_request()\n        ->navigation_handle()\n        ->set_net_error_code(net::ERR_ABORTED);\n  }\n  frame_tree_node->ResetNavigationRequest(false, inform_renderer);\n  if (frame_tree_node->IsMainFrame())\n    navigation_data_.reset();\n}\n",
        "target": 0
    },
    {
        "id": 946,
        "func": "  void LoadAuthExtension() {\n    base::DictionaryValue params;\n\n    const std::string& app_locale = g_browser_process->GetApplicationLocale();\n    params.SetString(\"hl\", app_locale);\n    params.SetString(\"gaiaUrl\", GaiaUrls::GetInstance()->gaia_url().spec());\n\n    web_ui()->CallJavascriptFunction(\"inline.login.loadAuthExtension\", params);\n  }\n",
        "target": 0
    },
    {
        "id": 947,
        "func": "void TabStrip::OnMouseMoved(const ui::MouseEvent& event) {\n  UpdateLayoutTypeFromMouseEvent(this, event);\n}\n",
        "target": 0
    },
    {
        "id": 948,
        "func": "  const url::Origin& origin() const { return origin_; }\n",
        "target": 0
    },
    {
        "id": 949,
        "func": "zip_get_local_file_header_size(struct archive_read *a, size_t extra)\n{\n\tconst char *p;\n\tssize_t filename_length, extra_length;\n\n\tif ((p = __archive_read_ahead(a, extra + 30, NULL)) == NULL) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated ZIP file header\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tp += extra;\n\n\tif (memcmp(p, \"PK\\003\\004\", 4) != 0) {\n\t\tarchive_set_error(&a->archive, -1, \"Damaged Zip archive\");\n\t\treturn ARCHIVE_WARN;\n\t}\n\tfilename_length = archive_le16dec(p + 26);\n\textra_length = archive_le16dec(p + 28);\n\n\treturn (30 + filename_length + extra_length);\n}",
        "target": 0
    },
    {
        "id": 950,
        "func": "bool isAllowedByAll(const CSPDirectiveListVector& policies,\n                    const CSPHashValue& hashValue,\n                    ContentSecurityPolicy::InlineType type) {\n  bool isAllowed = true;\n  for (const auto& policy : policies)\n    isAllowed &= (policy.get()->*allowed)(hashValue, type);\n  return isAllowed;\n}\n",
        "target": 0
    },
    {
        "id": 951,
        "func": "void ProxyResolverV8TracingFactoryImpl::RemoveJob(\n    ProxyResolverV8TracingFactoryImpl::CreateJob* job) {\n  size_t erased = jobs_.erase(job);\n  DCHECK_EQ(1u, erased);\n}\n",
        "target": 0
    },
    {
        "id": 952,
        "func": "parse_CONJUNCTION(const char *arg, struct ofpbuf *ofpacts,\n                  enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    uint8_t n_clauses;\n    uint8_t clause;\n    uint32_t id;\n    int n;\n\n    if (!ovs_scan(arg, \"%\"SCNi32\" , %\"SCNu8\" / %\"SCNu8\" %n\",\n                  &id, &clause, &n_clauses, &n) || n != strlen(arg)) {\n        return xstrdup(\"\\\"conjunction\\\" syntax is \\\"conjunction(id,i/n)\\\"\");\n    }\n\n    if (n_clauses < 2) {\n        return xstrdup(\"conjunction must have at least 2 clauses\");\n    } else if (n_clauses > 64) {\n        return xstrdup(\"conjunction must have at most 64 clauses\");\n    } else if (clause < 1) {\n        return xstrdup(\"clause index must be positive\");\n    } else if (clause > n_clauses) {\n        return xstrdup(\"clause index must be less than or equal to \"\n                       \"number of clauses\");\n    }\n\n    add_conjunction(ofpacts, id, clause - 1, n_clauses);\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 953,
        "func": "void myseek(int handle,off_t a) {\n\tif (lseek(handle, a, SEEK_SET) < 0) {\n\t\terr(\"Can not seek locally!\\n\");\n\t}\n}",
        "target": 0
    },
    {
        "id": 954,
        "func": "int stb_vorbis_seek_frame(stb_vorbis *f, unsigned int sample_number)\n{\n   uint32 max_frame_samples;\n\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   // fast page-level search\n   if (!seek_to_sample_coarse(f, sample_number))\n      return 0;\n\n   assert(f->current_loc_valid);\n   assert(f->current_loc <= sample_number);\n\n   // linear search for the relevant packet\n   max_frame_samples = (f->blocksize_1*3 - f->blocksize_0) >> 2;\n   while (f->current_loc < sample_number) {\n      int left_start, left_end, right_start, right_end, mode, frame_samples;\n      if (!peek_decode_initial(f, &left_start, &left_end, &right_start, &right_end, &mode))\n         return error(f, VORBIS_seek_failed);\n      // calculate the number of samples returned by the next frame\n      frame_samples = right_start - left_start;\n      if (f->current_loc + frame_samples > sample_number) {\n         return 1; // the next frame will contain the sample\n      } else if (f->current_loc + frame_samples + max_frame_samples > sample_number) {\n         // there's a chance the frame after this could contain the sample\n         vorbis_pump_first_frame(f);\n      } else {\n         // this frame is too early to be relevant\n         f->current_loc += frame_samples;\n         f->previous_length = 0;\n         maybe_start_packet(f);\n         flush_packet(f);\n      }\n   }\n   // the next frame will start with the sample\n   assert(f->current_loc == sample_number);\n   return 1;\n}",
        "target": 0
    },
    {
        "id": 955,
        "func": "evdns_base_resume(struct evdns_base *base)\n{\n\tEVDNS_LOCK(base);\n\tevdns_requests_pump_waiting_queue(base);\n\tEVDNS_UNLOCK(base);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 956,
        "func": "void Document::registerNodeList(const LiveNodeListBase* list)\n{\n#if ENABLE(OILPAN)\n    m_nodeLists[list->invalidationType()].add(list);\n#else\n    m_nodeListCounts[list->invalidationType()]++;\n#endif\n    if (list->isRootedAtTreeScope())\n        m_listsInvalidatedAtDocument.add(list);\n}\n",
        "target": 0
    },
    {
        "id": 957,
        "func": "MojoResult Core::UnmapBuffer(void* buffer) {\n  RequestContext request_context;\n  std::unique_ptr<PlatformSharedBufferMapping> mapping;\n  MojoResult result;\n  {\n    base::AutoLock lock(mapping_table_lock_);\n    result = mapping_table_.RemoveMapping(buffer, &mapping);\n  }\n  return result;\n}\n",
        "target": 0
    },
    {
        "id": 958,
        "func": "static void testEnumAttributeAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);\n    String string = cppValue;\n    if (!(string == \"\" || string == \"EnumValue1\" || string == \"EnumValue2\" || string == \"EnumValue3\"))\n        return;\n    imp->setTestEnumAttribute(cppValue);\n}\n",
        "target": 0
    },
    {
        "id": 959,
        "func": "static void *btif_hh_poll_event_thread(void *arg)\n{\n btif_hh_device_t *p_dev = arg;\n    APPL_TRACE_DEBUG(\"%s: Thread created fd = %d\", __FUNCTION__, p_dev->fd);\n struct pollfd pfds[1];\n int ret;\n\n    pfds[0].fd = p_dev->fd;\n    pfds[0].events = POLLIN;\n\n\n     uhid_set_non_blocking(p_dev->fd);\n \n     while(p_dev->hh_keep_polling){\n        ret = TEMP_FAILURE_RETRY(poll(pfds, 1, 50));\n         if (ret < 0) {\n             APPL_TRACE_ERROR(\"%s: Cannot poll for fds: %s\\n\", __FUNCTION__, strerror(errno));\n             break;\n }\n if (pfds[0].revents & POLLIN) {\n            APPL_TRACE_DEBUG(\"btif_hh_poll_event_thread: POLLIN\");\n            ret = uhid_event(p_dev);\n if (ret){\n break;\n }\n }\n }\n\n    p_dev->hh_poll_thread_id = -1;\n return 0;\n}\n",
        "target": 0
    },
    {
        "id": 960,
        "func": "void FrameFetchContext::DispatchWillSendRequest(\n     unsigned long identifier,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n     const FetchInitiatorInfo& initiator_info) {\n   if (IsDetached())\n     return;\n\n  if (redirect_response.IsNull()) {\n    GetFrame()->Loader().Progress().WillStartLoading(identifier,\n                                                     request.Priority());\n   }\n   probe::willSendRequest(GetFrame()->GetDocument(), identifier,\n                          MasterDocumentLoader(), request, redirect_response,\n                         initiator_info);\n   if (IdlenessDetector* idleness_detector = GetFrame()->GetIdlenessDetector())\n     idleness_detector->OnWillSendRequest();\n   if (GetFrame()->FrameScheduler())\n    GetFrame()->FrameScheduler()->DidStartLoading(identifier);\n}\n",
        "target": 1
    },
    {
        "id": 961,
        "func": "static void CloneFormatEtc(FORMATETC* source, FORMATETC* clone) {\n  *clone = *source;\n  if (source->ptd) {\n    source->ptd =\n        static_cast<DVTARGETDEVICE*>(CoTaskMemAlloc(sizeof(DVTARGETDEVICE)));\n    *(clone->ptd) = *(source->ptd);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 962,
        "func": "void VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          registration->application_parameter, registration->counter));\n   std::move(callback).Run(success);\n }\n",
        "target": 1
    },
    {
        "id": 963,
        "func": "int rxe_mem_init_fast(struct rxe_dev *rxe, struct rxe_pd *pd,\n\t\t      int max_pages, struct rxe_mem *mem)\n{\n\tint err;\n\n\trxe_mem_init(0, mem);\n\n\t/* In fastreg, we also set the rkey */\n\tmem->ibmr.rkey = mem->ibmr.lkey;\n\n\terr = rxe_mem_alloc(rxe, mem, max_pages);\n\tif (err)\n\t\tgoto err1;\n\n\tmem->pd\t\t\t= pd;\n\tmem->max_buf\t\t= max_pages;\n\tmem->state\t\t= RXE_MEM_STATE_FREE;\n\tmem->type\t\t= RXE_MEM_TYPE_MR;\n\n\treturn 0;\n\nerr1:\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 964,
        "func": "static void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_writel(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}",
        "target": 0
    },
    {
        "id": 965,
        "func": "void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\nbool ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   if (state_ == WORKER_READY) {\n     if (sessions().size() == 1) {\n       BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                              base::BindOnce(&SetDevToolsAttachedOnIO,\n                                             context_weak_, version_id_, true));\n    }\n    session->SetRenderer(worker_process_id_, nullptr);\n    session->AttachToAgent(agent_ptr_);\n  }\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n  return true;\n }\n",
        "target": 0
    },
    {
        "id": 966,
        "func": " void RunNestedLoopTask(int* counter) {\n  RunLoop nested_run_loop;\n \n   ThreadTaskRunnerHandle::Get()->PostTask(\n      FROM_HERE, BindOnce(&QuitWhenIdleTask, Unretained(&nested_run_loop),\n                          Unretained(counter)));\n\n   ThreadTaskRunnerHandle::Get()->PostDelayedTask(\n       FROM_HERE, BindOnce(&ShouldNotRunTask), TimeDelta::FromDays(1));\n \n  std::unique_ptr<MessageLoop::ScopedNestableTaskAllower> allower;\n  if (MessageLoop::current()) {\n    allower = base::MakeUnique<MessageLoop::ScopedNestableTaskAllower>(\n        MessageLoop::current());\n  }\n   nested_run_loop.Run();\n \n   ++(*counter);\n}\n",
        "target": 1
    },
    {
        "id": 967,
        "func": "void LayerTreeHostImpl::RemoveRenderPasses(FrameData* frame) {\n  DCHECK_GE(frame->render_passes.size(), 1u);\n\n  std::set<int> pass_exists;\n  base::SmallMap<std::unordered_map<int, int>> pass_references;\n\n  for (size_t i = 0; i < frame->render_passes.size(); ++i) {\n    RenderPass* pass = frame->render_passes[i].get();\n\n    for (auto it = pass->quad_list.begin(); it != pass->quad_list.end();) {\n      if (it->material != DrawQuad::RENDER_PASS) {\n        ++it;\n        continue;\n      }\n      const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(*it);\n      if (pass_exists.count(quad->render_pass_id)) {\n        pass_references[quad->render_pass_id]++;\n        ++it;\n      } else {\n        it = pass->quad_list.EraseAndInvalidateAllPointers(it);\n      }\n    }\n\n    if (i == frame->render_passes.size() - 1) {\n      break;\n    }\n\n    if (pass->quad_list.empty() && pass->copy_requests.empty()) {\n      frame->render_passes.erase(frame->render_passes.begin() + i);\n      --i;\n      continue;\n    }\n\n    pass_exists.insert(pass->id);\n  }\n\n  for (size_t i = 0; i < frame->render_passes.size() - 1; ++i) {\n    RenderPass* pass =\n        frame->render_passes[frame->render_passes.size() - 2 - i].get();\n    if (!pass->copy_requests.empty())\n      continue;\n    if (pass_references[pass->id])\n      continue;\n\n    for (auto it = pass->quad_list.begin(); it != pass->quad_list.end(); ++it) {\n      if (it->material != DrawQuad::RENDER_PASS)\n        continue;\n      const RenderPassDrawQuad* quad = RenderPassDrawQuad::MaterialCast(*it);\n      pass_references[quad->render_pass_id]--;\n    }\n\n    frame->render_passes.erase(frame->render_passes.end() - 2 - i);\n    --i;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 968,
        "func": "static void get_counters(const struct xt_table_info *t,\n\t\t\t struct xt_counters counters[])\n{\n\tstruct arpt_entry *iter;\n\tunsigned int cpu;\n\tunsigned int i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tseqcount_t *s = &per_cpu(xt_recseq, cpu);\n\n\t\ti = 0;\n\t\txt_entry_foreach(iter, t->entries, t->size) {\n\t\t\tstruct xt_counters *tmp;\n\t\t\tu64 bcnt, pcnt;\n\t\t\tunsigned int start;\n\n\t\t\ttmp = xt_get_per_cpu_counter(&iter->counters, cpu);\n\t\t\tdo {\n\t\t\t\tstart = read_seqcount_begin(s);\n\t\t\t\tbcnt = tmp->bcnt;\n\t\t\t\tpcnt = tmp->pcnt;\n\t\t\t} while (read_seqcount_retry(s, start));\n\n\t\t\tADD_COUNTER(counters[i], bcnt, pcnt);\n\t\t\t++i;\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 969,
        "func": "  uint32_t num_requests() { return num_requests_; }\n",
        "target": 0
    },
    {
        "id": 970,
        "func": "RenderWidgetHostImpl* WebContentsImpl::GetFocusedRenderWidgetHost(\n    RenderWidgetHostImpl* receiving_widget) {\n  if (receiving_widget != GetMainFrame()->GetRenderWidgetHost())\n    return receiving_widget;\n\n  WebContentsImpl* focused_contents = GetFocusedWebContents();\n\n  if (focused_contents->ShowingInterstitialPage()) {\n    return static_cast<RenderFrameHostImpl*>(\n               focused_contents->interstitial_page_->GetMainFrame())\n        ->GetRenderWidgetHost();\n  }\n\n  FrameTreeNode* focused_frame = nullptr;\n  if (focused_contents->browser_plugin_guest_ &&\n      !GuestMode::IsCrossProcessFrameGuest(focused_contents)) {\n    focused_frame = frame_tree_.GetFocusedFrame();\n  } else {\n    focused_frame = GetFocusedWebContents()->frame_tree_.GetFocusedFrame();\n  }\n\n  if (!focused_frame)\n    return receiving_widget;\n\n  RenderWidgetHostView* view = focused_frame->current_frame_host()->GetView();\n  if (!view)\n    return nullptr;\n\n  return RenderWidgetHostImpl::From(view->GetRenderWidgetHost());\n}\n",
        "target": 0
    },
    {
        "id": 971,
        "func": "int key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 972,
        "func": "void QtBuiltinBundlePage::didClearWindowForFrame(WKBundlePageRef page, WKBundleFrameRef frame, WKBundleScriptWorldRef world, const void* clientInfo)\n{\n    static_cast<QtBuiltinBundlePage*>(const_cast<void*>(clientInfo))->didClearWindowForFrame(frame, world);\n}\n",
        "target": 0
    },
    {
        "id": 973,
        "func": "   void RunAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n uint32_t max_error = 0;\n\n     int64_t total_error = 0;\n     const int count_test_block = 10000;\n     for (int i = 0; i < count_test_block; ++i) {\n      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        test_input_block[j] = src[j] - dst[j];\n       }\n \n      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,\n                                      test_temp_block, pitch_));\n      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         const uint32_t diff = dst[j] - src[j];\n         const uint32_t error = diff * diff;\n         if (max_error < error)\n           max_error = error;\n        total_error += error;\n\n       }\n     }\n \n    EXPECT_GE(1u, max_error)\n         << \"Error: 16x16 FHT/IHT has an individual round trip error > 1\";\n \n    EXPECT_GE(count_test_block , total_error)\n         << \"Error: 16x16 FHT/IHT has average round trip error > 1 per block\";\n   }\n",
        "target": 1
    },
    {
        "id": 974,
        "func": "void DownloadItemImplDelegate::DetermineDownloadTarget(\n    DownloadItemImpl* download, const DownloadTargetCallback& callback) {\n  base::FilePath target_path(download->GetForcedFilePath());\n  callback.Run(target_path, DownloadItem::TARGET_DISPOSITION_OVERWRITE,\n               DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS, target_path,\n               DOWNLOAD_INTERRUPT_REASON_NONE);\n}\n",
        "target": 0
    },
    {
        "id": 975,
        "func": "nfsd4_decode_create(struct nfsd4_compoundargs *argp, struct nfsd4_create *create)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tcreate->cr_type = be32_to_cpup(p++);\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tREAD_BUF(4);\n\t\tcreate->cr_datalen = be32_to_cpup(p++);\n\t\tREAD_BUF(create->cr_datalen);\n\t\tcreate->cr_data = svcxdr_dupstr(argp, p, create->cr_datalen);\n\t\tif (!create->cr_data)\n\t\t\treturn nfserr_jukebox;\n\t\tbreak;\n\tcase NF4BLK:\n\tcase NF4CHR:\n\t\tREAD_BUF(8);\n\t\tcreate->cr_specdata1 = be32_to_cpup(p++);\n\t\tcreate->cr_specdata2 = be32_to_cpup(p++);\n\t\tbreak;\n\tcase NF4SOCK:\n\tcase NF4FIFO:\n\tcase NF4DIR:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tREAD_BUF(4);\n\tcreate->cr_namelen = be32_to_cpup(p++);\n\tREAD_BUF(create->cr_namelen);\n\tSAVEMEM(create->cr_name, create->cr_namelen);\n\tif ((status = check_filename(create->cr_name, create->cr_namelen)))\n\t\treturn status;\n\n\tstatus = nfsd4_decode_fattr(argp, create->cr_bmval, &create->cr_iattr,\n\t\t\t\t    &create->cr_acl, &create->cr_label,\n\t\t\t\t    &current->fs->umask);\n\tif (status)\n\t\tgoto out;\n\n\tDECODE_TAIL;\n}\n",
        "target": 0
    },
    {
        "id": 976,
        "func": "static int handle_rst_stream_frame(h2o_http2_conn_t *conn, h2o_http2_frame_t *frame, const char **err_desc)\n{\n    h2o_http2_rst_stream_payload_t payload;\n    h2o_http2_stream_t *stream;\n    int ret;\n\n    if ((ret = h2o_http2_decode_rst_stream_payload(&payload, frame, err_desc)) != 0)\n        return ret;\n    if (is_idle_stream_id(conn, frame->stream_id)) {\n        *err_desc = \"unexpected stream id in RST_STREAM frame\";\n        return H2O_HTTP2_ERROR_PROTOCOL;\n    }\n\n    stream = h2o_http2_conn_get_stream(conn, frame->stream_id);\n    if (stream != NULL) {\n        /* reset the stream */\n        h2o_http2_stream_reset(conn, stream);\n    }\n    /* TODO log */\n\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 977,
        "func": "tracing_write_stub(struct file *filp, const char __user *ubuf,\n\t\t   size_t count, loff_t *ppos)\n{\n\treturn count;\n}\n",
        "target": 0
    },
    {
        "id": 978,
        "func": "void ExtensionDevToolsClientHost::DispatchProtocolMessage(\n    DevToolsAgentHost* agent_host, const std::string& message) {\n  DCHECK(agent_host == agent_host_.get());\n  if (!EventRouter::Get(profile_))\n    return;\n\n  std::unique_ptr<base::Value> result = base::JSONReader::Read(message);\n  if (!result || !result->is_dict())\n    return;\n  base::DictionaryValue* dictionary =\n      static_cast<base::DictionaryValue*>(result.get());\n\n  int id;\n  if (!dictionary->GetInteger(\"id\", &id)) {\n    std::string method_name;\n    if (!dictionary->GetString(\"method\", &method_name))\n      return;\n\n    OnEvent::Params params;\n    base::DictionaryValue* params_value;\n    if (dictionary->GetDictionary(\"params\", &params_value))\n      params.additional_properties.Swap(params_value);\n\n    std::unique_ptr<base::ListValue> args(\n        OnEvent::Create(debuggee_, method_name, params));\n    auto event =\n        std::make_unique<Event>(events::DEBUGGER_ON_EVENT, OnEvent::kEventName,\n                                std::move(args), profile_);\n    EventRouter::Get(profile_)\n        ->DispatchEventToExtension(extension_id_, std::move(event));\n  } else {\n    DebuggerSendCommandFunction* function = pending_requests_[id].get();\n    if (!function)\n      return;\n\n    function->SendResponseBody(dictionary);\n    pending_requests_.erase(id);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 979,
        "func": "void TreeView::CommitEdit() {\n  DCHECK(tree_view_);\n  TreeView_EndEditLabelNow(tree_view_, FALSE);\n}\n",
        "target": 0
    },
    {
        "id": 980,
        "func": "    AuthenticatorInsertAndActivateUsbSheetModel(\n        AuthenticatorRequestDialogModel* dialog_model)\n    : AuthenticatorSheetModelBase(dialog_model),\n      other_transports_menu_model_(std::make_unique<OtherTransportsMenuModel>(\n          dialog_model,\n          AuthenticatorTransport::kUsbHumanInterfaceDevice)) {}\n",
        "target": 0
    },
    {
        "id": 981,
        "func": "fbFetch_r8g8b8 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD8 *pixel = (const CARD8 *)bits + 3*x;\n    const CARD8 *end = pixel + 3*width;\n    while (pixel < end) {\n        CARD32 b = Fetch24(pixel) | 0xff000000;\n        pixel += 3;\n        WRITE(buffer++, b);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 982,
        "func": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\n\t/* Basic sanity checks */\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\t/* Zero out the CB buffer if no options present */\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\n\t/* Check correct handling of SRR option */\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\n\treturn 0;\n\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}",
        "target": 1
    },
    {
        "id": 983,
        "func": "void irc_servers_reconnect_deinit(void)\n{\n\tsignal_remove(\"server connect copy\", (SIGNAL_FUNC) sig_server_connect_copy);\n\tsignal_remove(\"server reconnect save status\", (SIGNAL_FUNC) sig_server_reconnect_save_status);\n\tsignal_remove(\"event connected\", (SIGNAL_FUNC) sig_connected);\n\tsignal_remove(\"event 436\", (SIGNAL_FUNC) event_nick_collision);\n\tsignal_remove(\"event kill\", (SIGNAL_FUNC) event_kill);\n}\n",
        "target": 0
    },
    {
        "id": 984,
        "func": "static unsigned long inq_canon(struct n_tty_data *ldata)\n{\n\tsize_t nr, head, tail;\n\n\tif (ldata->canon_head == ldata->read_tail)\n\t\treturn 0;\n\thead = ldata->canon_head;\n\ttail = ldata->read_tail;\n\tnr = head - tail;\n\t/* Skip EOF-chars.. */\n\twhile (head != tail) {\n\t\tif (test_bit(tail & (N_TTY_BUF_SIZE - 1), ldata->read_flags) &&\n\t\t    read_buf(ldata, tail) == __DISABLED_CHAR)\n\t\t\tnr--;\n\t\ttail++;\n\t}\n\treturn nr;\n}",
        "target": 0
    },
    {
        "id": 985,
        "func": "void ContainerNode::parserInsertBefore(PassRefPtrWillBeRawPtr<Node> newChild, Node& nextChild)\n{\n    ASSERT(newChild);\n    ASSERT(nextChild.parentNode() == this);\n    ASSERT(!newChild->isDocumentFragment());\n    ASSERT(!isHTMLTemplateElement(this));\n\n    if (nextChild.previousSibling() == newChild || &nextChild == newChild) // nothing to do\n        return;\n\n    if (!checkParserAcceptChild(*newChild))\n        return;\n\n    RefPtrWillBeRawPtr<Node> protect(this);\n\n     while (RefPtrWillBeRawPtr<ContainerNode> parent = newChild->parentNode())\n         parent->parserRemoveChild(*newChild);\n \n     if (document() != newChild->document())\n         document().adoptNode(newChild.get(), ASSERT_NO_EXCEPTION);\n \n    {\n        EventDispatchForbiddenScope assertNoEventDispatch;\n        ScriptForbiddenScope forbidScript;\n\n        treeScope().adoptIfNeeded(*newChild);\n        insertBeforeCommon(nextChild, *newChild);\n        newChild->updateAncestorConnectedSubframeCountForInsertion();\n        ChildListMutationScope(*this).childAdded(*newChild);\n    }\n\n    notifyNodeInserted(*newChild, ChildrenChangeSourceParser);\n}\n",
        "target": 1
    },
    {
        "id": 986,
        "func": "blink::WebInputEvent::Type GetTouchEventType(const std::string& type) {\n  if (type == Input::DispatchTouchEvent::TypeEnum::TouchStart)\n    return blink::WebInputEvent::kTouchStart;\n  if (type == Input::DispatchTouchEvent::TypeEnum::TouchEnd)\n    return blink::WebInputEvent::kTouchEnd;\n  if (type == Input::DispatchTouchEvent::TypeEnum::TouchMove)\n    return blink::WebInputEvent::kTouchMove;\n  if (type == Input::DispatchTouchEvent::TypeEnum::TouchCancel)\n    return blink::WebInputEvent::kTouchCancel;\n  return blink::WebInputEvent::kUndefined;\n}\n",
        "target": 0
    },
    {
        "id": 987,
        "func": "void crypto_unregister_rngs(struct rng_alg *algs, int count)\n{\n\tint i;\n\n\tfor (i = count - 1; i >= 0; --i)\n\t\tcrypto_unregister_rng(algs + i);\n}",
        "target": 0
    },
    {
        "id": 988,
        "func": "int arm_dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,\n\t\tenum dma_data_direction dir, struct dma_attrs *attrs)\n{\n\tstruct dma_map_ops *ops = get_dma_ops(dev);\n\tstruct scatterlist *s;\n\tint i, j;\n\n\tfor_each_sg(sg, s, nents, i) {\n#ifdef CONFIG_NEED_SG_DMA_LENGTH\n\t\ts->dma_length = s->length;\n#endif\n\t\ts->dma_address = ops->map_page(dev, sg_page(s), s->offset,\n\t\t\t\t\t\ts->length, dir, attrs);\n\t\tif (dma_mapping_error(dev, s->dma_address))\n\t\t\tgoto bad_mapping;\n\t}\n\treturn nents;\n\n bad_mapping:\n\tfor_each_sg(sg, s, i, j)\n\t\tops->unmap_page(dev, sg_dma_address(s), sg_dma_len(s), dir, attrs);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 989,
        "func": "xsltFreeNamespaceMap(xsltNsMapPtr item)\n{\n    xsltNsMapPtr tmp;\n\n    while (item) {\n\ttmp = item;\n\titem = item->next;\n\txmlFree(tmp);\n    }\n    return;\n}\n",
        "target": 0
    },
    {
        "id": 990,
        "func": "void CoordinatorImpl::GetVmRegionsForHeapProfiler(\n    const std::vector<base::ProcessId>& pids,\n    GetVmRegionsForHeapProfilerCallback callback) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  uint64_t dump_guid = ++next_dump_id_;\n  std::unique_ptr<QueuedVmRegionRequest> request =\n      std::make_unique<QueuedVmRegionRequest>(dump_guid, std::move(callback));\n  in_progress_vm_region_requests_[dump_guid] = std::move(request);\n\n  std::vector<QueuedRequestDispatcher::ClientInfo> clients;\n  for (const auto& kv : clients_) {\n    auto client_identity = kv.second->identity;\n    const base::ProcessId pid = GetProcessIdForClientIdentity(client_identity);\n    clients.emplace_back(kv.second->client.get(), pid, kv.second->process_type);\n  }\n\n  QueuedVmRegionRequest* request_ptr =\n       in_progress_vm_region_requests_[dump_guid].get();\n   auto os_callback =\n       base::BindRepeating(&CoordinatorImpl::OnOSMemoryDumpForVMRegions,\n                          base::Unretained(this), dump_guid);\n   QueuedRequestDispatcher::SetUpAndDispatchVmRegionRequest(request_ptr, clients,\n                                                            pids, os_callback);\n   FinalizeVmRegionDumpIfAllManagersReplied(dump_guid);\n}\n",
        "target": 1
    },
    {
        "id": 991,
        "func": "RenderFrameHostManager::GetSiteInstanceForNavigationRequest(\n    const NavigationRequest& request) {\n  SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();\n  bool no_renderer_swap_allowed = false;\n  bool was_server_redirect = request.navigation_handle() &&\n                             request.navigation_handle()->WasServerRedirect();\n\n  if (frame_tree_node_->IsMainFrame()) {\n    bool can_renderer_initiate_transfer =\n        (request.state() == NavigationRequest::FAILED &&\n         SiteIsolationPolicy::IsErrorPageIsolationEnabled(\n             true /* in_main_frame */)) ||\n        (render_frame_host_->IsRenderFrameLive() &&\n         IsURLHandledByNetworkStack(request.common_params().url) &&\n         IsRendererTransferNeededForNavigation(render_frame_host_.get(),\n                                               request.common_params().url));\n    no_renderer_swap_allowed |=\n        request.from_begin_navigation() && !can_renderer_initiate_transfer;\n  } else {\n     no_renderer_swap_allowed |= !CanSubframeSwapProcess(\n         request.common_params().url, request.source_site_instance(),\n        request.dest_site_instance(), was_server_redirect);\n   }\n \n   if (no_renderer_swap_allowed)\n    return scoped_refptr<SiteInstance>(current_site_instance);\n\n  SiteInstance* candidate_site_instance =\n      speculative_render_frame_host_\n          ? speculative_render_frame_host_->GetSiteInstance()\n          : nullptr;\n\n  scoped_refptr<SiteInstance> dest_site_instance = GetSiteInstanceForNavigation(\n      request.common_params().url, request.source_site_instance(),\n      request.dest_site_instance(), candidate_site_instance,\n      request.common_params().transition,\n      request.state() == NavigationRequest::FAILED,\n      request.restore_type() != RestoreType::NONE, request.is_view_source(),\n      was_server_redirect);\n\n  return dest_site_instance;\n}\n",
        "target": 1
    },
    {
        "id": 992,
        "func": "int sock_wake_async(struct socket_wq *wq, int how, int band)\n{\n\tif (!wq || !wq->fasync_list)\n\t\treturn -1;\n\n\tswitch (how) {\n\tcase SOCK_WAKE_WAITD:\n\t\tif (test_bit(SOCKWQ_ASYNC_WAITDATA, &wq->flags))\n\t\t\tbreak;\n\t\tgoto call_kill;\n\tcase SOCK_WAKE_SPACE:\n\t\tif (!test_and_clear_bit(SOCKWQ_ASYNC_NOSPACE, &wq->flags))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase SOCK_WAKE_IO:\ncall_kill:\n\t\tkill_fasync(&wq->fasync_list, SIGIO, band);\n\t\tbreak;\n\tcase SOCK_WAKE_URG:\n\t\tkill_fasync(&wq->fasync_list, SIGURG, band);\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 993,
        "func": "pp::Instance* Instance::GetInstance() {\n  return this;\n}\n",
        "target": 0
    },
    {
        "id": 994,
        "func": "int netlink_register_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&netlink_chain, nb);\n}",
        "target": 0
    },
    {
        "id": 995,
        "func": "static int get_slot_from_bitmask(int mask, int (*check)(struct module *, int),\n\t\t\t\t struct module *module)\n{\n\tint slot;\n\n\tfor (slot = 0; slot < SNDRV_CARDS; slot++) {\n\t\tif (slot < 32 && !(mask & (1U << slot)))\n\t\t\tcontinue;\n\t\tif (!test_bit(slot, snd_cards_lock)) {\n\t\t\tif (check(module, slot))\n\t\t\t\treturn slot; /* found */\n\t\t}\n\t}\n\treturn mask; /* unchanged */\n}",
        "target": 0
    },
    {
        "id": 996,
        "func": "int use_conf(char *test_path)\n{\n    int ret;\n    size_t flags = 0;\n    char filename[1024], errstr[1024];\n    char *buffer;\n    FILE *infile, *conffile;\n    json_t *json;\n    json_error_t error;\n\n    sprintf(filename, \"%s%cinput\", test_path, dir_sep);\n    if (!(infile = fopen(filename, \"rb\"))) {\n        fprintf(stderr, \"Could not open \\\"%s\\\"\\n\", filename);\n        return 2;\n    }\n\n    sprintf(filename, \"%s%cenv\", test_path, dir_sep);\n    conffile = fopen(filename, \"rb\");\n    if (conffile) {\n        read_conf(conffile);\n        fclose(conffile);\n    }\n\n    if (conf.indent < 0 || conf.indent > 255) {\n        fprintf(stderr, \"invalid value for JSON_INDENT: %d\\n\", conf.indent);\n        return 2;\n    }\n\n    if (conf.indent)\n        flags |= JSON_INDENT(conf.indent);\n\n    if (conf.compact)\n        flags |= JSON_COMPACT;\n\n    if (conf.ensure_ascii)\n        flags |= JSON_ENSURE_ASCII;\n\n    if (conf.preserve_order)\n        flags |= JSON_PRESERVE_ORDER;\n\n    if (conf.sort_keys)\n        flags |= JSON_SORT_KEYS;\n\n    if (conf.strip) {\n        /* Load to memory, strip leading and trailing whitespace */\n        buffer = loadfile(infile);\n        json = json_loads(strip(buffer), 0, &error);\n        free(buffer);\n    }\n    else\n        json = json_loadf(infile, 0, &error);\n\n    fclose(infile);\n\n    if (!json) {\n        sprintf(errstr, \"%d %d %d\\n%s\\n\",\n                error.line, error.column, error.position,\n                error.text);\n\n        ret = cmpfile(errstr, test_path, \"error\");\n        return ret;\n    }\n\n    buffer = json_dumps(json, flags);\n    ret = cmpfile(buffer, test_path, \"output\");\n    free(buffer);\n    json_decref(json);\n\n    return ret;\n}",
        "target": 1
    },
    {
        "id": 997,
        "func": "void WebGLRenderingContextBase::DispatchContextLostEvent(TimerBase*) {\n  WebGLContextEvent* event =\n      WebGLContextEvent::Create(event_type_names::kWebglcontextlost, \"\");\n  Host()->HostDispatchEvent(event);\n  restore_allowed_ = event->defaultPrevented();\n  if (restore_allowed_ && !is_hidden_) {\n    if (auto_recovery_method_ == kAuto)\n      restore_timer_.StartOneShot(TimeDelta(), FROM_HERE);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 998,
        "func": "void RenderViewImpl::SimulateImeSetComposition(\n    const string16& text,\n    const std::vector<WebKit::WebCompositionUnderline>& underlines,\n    int selection_start,\n    int selection_end) {\n  OnImeSetComposition(text, underlines, selection_start, selection_end);\n}\n",
        "target": 0
    },
    {
        "id": 999,
        "func": " void WebPluginDelegateProxy::OnInitiateHTTPRangeRequest(\n    const std::string& url, const std::string& range_info,\n    intptr_t existing_stream, bool notify_needed, intptr_t notify_data) {\n  plugin_->InitiateHTTPRangeRequest(url.c_str(), range_info.c_str(),\n                                    existing_stream, notify_needed,\n                                    notify_data);\n }\n",
        "target": 1
    },
    {
        "id": 1000,
        "func": "Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(\n    ContainerNode& insertion_point) {\n  HTMLElement::InsertedInto(insertion_point);\n  LogAddElementIfIsolatedWorldAndInDocument(\"link\", relAttr, hrefAttr);\n   if (!insertion_point.isConnected())\n     return kInsertionDone;\n   DCHECK(isConnected());\n   if (!ShouldLoadLink() && IsInShadowTree()) {\n     String message = \"HTML element <link> is ignored in shadow tree.\";\n     GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n         kJSMessageSource, kWarningMessageLevel, message));\n     return kInsertionDone;\n   }\n \n  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n   Process();\n \n   if (link_)\n    link_->OwnerInserted();\n\n  return kInsertionDone;\n}\n",
        "target": 1
    },
    {
        "id": 1001,
        "func": "void RenderWidgetHostViewAura::WasShown() {\n  if (!host_->is_hidden())\n    return;\n  host_->WasShown();\n\n  if (!current_surface_ && host_->is_accelerated_compositing_active() &&\n      !released_front_lock_.get()) {\n     released_front_lock_ = GetCompositor()->GetCompositorLock();\n   }\n \n  AdjustSurfaceProtection();\n #if defined(OS_WIN)\n   LPARAM lparam = reinterpret_cast<LPARAM>(this);\n   EnumChildWindows(ui::GetHiddenWindow(), ShowWindowsCallback, lparam);\n#endif\n}\n",
        "target": 1
    },
    {
        "id": 1002,
        "func": "void WebContentsImpl::OnFrameRemoved(RenderFrameHost* render_frame_host) {\n  FOR_EACH_OBSERVER(\n      WebContentsObserver, observers_, FrameDeleted(render_frame_host));\n}\n",
        "target": 0
    },
    {
        "id": 1003,
        "func": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "id": 1004,
        "func": "static int xfrm_get_spdinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct sk_buff *r_skb;\n\tu32 *flags = nlmsg_data(nlh);\n\tu32 spid = NETLINK_CB(skb).pid;\n\tu32 seq = nlh->nlmsg_seq;\n\n\tr_skb = nlmsg_new(xfrm_spdinfo_msgsize(), GFP_ATOMIC);\n\tif (r_skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_spdinfo(r_skb, net, spid, seq, *flags) < 0)\n\t\tBUG();\n\n\treturn nlmsg_unicast(net->xfrm.nlsk, r_skb, spid);\n}",
        "target": 0
    },
    {
        "id": 1005,
        "func": "int sk_wait_data(struct sock *sk, long *timeo, const struct sk_buff *skb)\n{\n\tint rc;\n\tDEFINE_WAIT(wait);\n\n\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\tsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\trc = sk_wait_event(sk, timeo, skb_peek_tail(&sk->sk_receive_queue) != skb);\n\tsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\tfinish_wait(sk_sleep(sk), &wait);\n\treturn rc;\n}",
        "target": 0
    },
    {
        "id": 1006,
        "func": "int SaveCCInfoConfirmInfoBar::GetAvailableWidth() const {\n  int buttons_area_size = save_button_->GetPreferredSize().width() +\n      dont_save_button_->GetPreferredSize().width() + kButtonButtonSpacing +\n      kEndOfLabelSpacing;\n  return std::max(0, link_->x() - buttons_area_size);\n}\n",
        "target": 0
    },
    {
        "id": 1007,
        "func": "void mbedtls_strerror( int ret, char *buf, size_t buflen )\n{\n    ((void) ret);\n\n    if( buflen > 0 )\n        buf[0] = '\\0';\n}",
        "target": 1
    },
    {
        "id": 1008,
        "func": "__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}\n",
        "target": 0
    },
    {
        "id": 1009,
        "func": "void DataReductionProxySettings::MaybeActivateDataReductionProxy(\n    bool at_startup) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  PrefService* prefs = GetOriginalProfilePrefs();\n   if (!prefs)\n     return;\n \n  if (spdy_proxy_auth_enabled_.GetValue() && at_startup) {\n     int64_t last_enabled_time =\n         prefs->GetInt64(prefs::kDataReductionProxyLastEnabledTime);\n    if (last_enabled_time != 0) {\n      RecordDaysSinceEnabledMetric(\n          (clock_->Now() - base::Time::FromInternalValue(last_enabled_time))\n              .InDays());\n    }\n\n    int64_t last_savings_cleared_time = prefs->GetInt64(\n        prefs::kDataReductionProxySavingsClearedNegativeSystemClock);\n    if (last_savings_cleared_time != 0) {\n      int32_t days_since_savings_cleared =\n          (clock_->Now() -\n           base::Time::FromInternalValue(last_savings_cleared_time))\n              .InDays();\n\n      if (days_since_savings_cleared == 0)\n        days_since_savings_cleared = 1;\n      UMA_HISTOGRAM_CUSTOM_COUNTS(\n          \"DataReductionProxy.DaysSinceSavingsCleared.NegativeSystemClock\",\n          days_since_savings_cleared, 1, 365, 50);\n     }\n   }\n \n  if (spdy_proxy_auth_enabled_.GetValue() &&\n       !prefs->GetBoolean(prefs::kDataReductionProxyWasEnabledBefore)) {\n     prefs->SetBoolean(prefs::kDataReductionProxyWasEnabledBefore, true);\n     ResetDataReductionStatistics();\n  }\n  if (!at_startup) {\n    if (IsDataReductionProxyEnabled()) {\n      RecordSettingsEnabledState(DATA_REDUCTION_SETTINGS_ACTION_OFF_TO_ON);\n\n      prefs->SetInt64(prefs::kDataReductionProxyLastEnabledTime,\n                      clock_->Now().ToInternalValue());\n      RecordDaysSinceEnabledMetric(0);\n    } else {\n      RecordSettingsEnabledState(DATA_REDUCTION_SETTINGS_ACTION_ON_TO_OFF);\n    }\n  }\n  if (at_startup && !data_reduction_proxy_service_->Initialized())\n    deferred_initialization_ = true;\n  else\n    UpdateIOData(at_startup);\n}\n",
        "target": 1
    },
    {
        "id": 1010,
        "func": "bool WebContentsImpl::IsConnectedToBluetoothDevice() const {\n  return bluetooth_connected_device_count_ > 0;\n}\n",
        "target": 0
    },
    {
        "id": 1011,
        "func": "static int unix_mkname(struct sockaddr_un *sunaddr, int len, unsigned int *hashp)\n{\n\tif (len <= sizeof(short) || len > sizeof(*sunaddr))\n\t\treturn -EINVAL;\n\tif (!sunaddr || sunaddr->sun_family != AF_UNIX)\n\t\treturn -EINVAL;\n\tif (sunaddr->sun_path[0]) {\n\t\t/*\n\t\t * This may look like an off by one error but it is a bit more\n\t\t * subtle. 108 is the longest valid AF_UNIX path for a binding.\n\t\t * sun_path[108] doesn't as such exist.  However in kernel space\n\t\t * we are guaranteed that it is a valid memory location in our\n\t\t * kernel address buffer.\n\t\t */\n\t\t((char *)sunaddr)[len] = 0;\n\t\tlen = strlen(sunaddr->sun_path)+1+sizeof(short);\n\t\treturn len;\n\t}\n\n\t*hashp = unix_hash_fold(csum_partial(sunaddr, len, 0));\n\treturn len;\n}",
        "target": 0
    },
    {
        "id": 1012,
        "func": "void opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct)\n{\n        OPJ_UINT32 cblkno , l_nb_code_blocks;\n\n        opj_tcd_cblk_dec_t * l_code_block = p_precinct->cblks.dec;\n        if (l_code_block) {\n                /*fprintf(stderr,\"deallocate codeblock:{\\n\");*/\n                /*fprintf(stderr,\"\\t x0=%d, y0=%d, x1=%d, y1=%d\\n\",l_code_block->x0, l_code_block->y0, l_code_block->x1, l_code_block->y1);*/\n                /*fprintf(stderr,\"\\t numbps=%d, numlenbits=%d, len=%d, numnewpasses=%d, real_num_segs=%d, m_current_max_segs=%d\\n \",\n                                l_code_block->numbps, l_code_block->numlenbits, l_code_block->len, l_code_block->numnewpasses, l_code_block->real_num_segs, l_code_block->m_current_max_segs );*/\n\n\n                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t);\n                /*fprintf(stderr,\"nb_code_blocks =%d\\t}\\n\", l_nb_code_blocks);*/\n\n                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {\n\n                        if (l_code_block->data) {\n                                opj_free(l_code_block->data);\n                                l_code_block->data = 00;\n                        }\n\n                        if (l_code_block->segs) {\n                                opj_free(l_code_block->segs );\n                                l_code_block->segs = 00;\n                        }\n\n                        ++l_code_block;\n                }\n\n                opj_free(p_precinct->cblks.dec);\n                p_precinct->cblks.dec = 00;\n        }\n}",
        "target": 0
    },
    {
        "id": 1013,
        "func": "static void ftrace_swap_ips(void *a, void *b, int size)\n{\n\tunsigned long *ipa = a;\n\tunsigned long *ipb = b;\n\tunsigned long t;\n\n\tt = *ipa;\n\t*ipa = *ipb;\n\t*ipb = t;\n}",
        "target": 0
    },
    {
        "id": 1014,
        "func": "bool DownloadManagerImpl::InterceptDownload(\n    const download::DownloadCreateInfo& info) {\n  WebContents* web_contents = WebContentsImpl::FromRenderFrameHostID(\n      info.render_process_id, info.render_frame_id);\n  if (info.is_new_download &&\n      info.result ==\n          download::DOWNLOAD_INTERRUPT_REASON_SERVER_CROSS_ORIGIN_REDIRECT) {\n    if (web_contents) {\n      std::vector<GURL> url_chain(info.url_chain);\n      GURL url = url_chain.back();\n      url_chain.pop_back();\n      NavigationController::LoadURLParams params(url);\n      params.has_user_gesture = info.has_user_gesture;\n      params.referrer = Referrer(\n          info.referrer_url, Referrer::NetReferrerPolicyToBlinkReferrerPolicy(\n                                 info.referrer_policy));\n      params.redirect_chain = url_chain;\n      params.frame_tree_node_id =\n          RenderFrameHost::GetFrameTreeNodeIdForRoutingId(\n              info.render_process_id, info.render_frame_id);\n      web_contents->GetController().LoadURLWithParams(params);\n    }\n    if (info.request_handle)\n      info.request_handle->CancelRequest(false);\n    return true;\n  }\n\n  std::string user_agent = \"\";\n  for (const auto& header : info.request_headers) {\n    if (header.first == net::HttpRequestHeaders::kUserAgent) {\n      user_agent = header.second;\n      break;\n    }\n  }\n\n  if (delegate_ &&\n      delegate_->InterceptDownloadIfApplicable(\n          info.url(), user_agent, info.content_disposition, info.mime_type,\n          info.request_origin, info.total_bytes, web_contents)) {\n    if (info.request_handle)\n      info.request_handle->CancelRequest(false);\n    return true;\n  }\n  content::devtools_instrumentation::WillBeginDownload(\n      info.render_process_id, info.render_frame_id, info.url());\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 1015,
        "func": "SampleTable::~SampleTable() {\n delete[] mSampleToChunkEntries;\n    mSampleToChunkEntries = NULL;\n\n delete[] mSyncSamples;\n    mSyncSamples = NULL;\n\n delete mCompositionDeltaLookup;\n    mCompositionDeltaLookup = NULL;\n\n delete[] mCompositionTimeDeltaEntries;\n    mCompositionTimeDeltaEntries = NULL;\n\n\n     delete[] mSampleTimeEntries;\n     mSampleTimeEntries = NULL;\n \n    delete[] mTimeToSample;\n    mTimeToSample = NULL;\n     delete mSampleIterator;\n     mSampleIterator = NULL;\n }\n",
        "target": 1
    },
    {
        "id": 1016,
        "func": "void WebPagePrivate::toggleTextReflowIfEnabledForBlockZoomOnly(bool shouldEnableTextReflow)\n{\n    if (m_webPage->settings()->textReflowMode() == WebSettings::TextReflowEnabledOnlyForBlockZoom)\n        m_page->settings()->setTextReflowEnabled(shouldEnableTextReflow);\n}\n",
        "target": 0
    },
    {
        "id": 1017,
        "func": "ProcScreenSaverUnsetAttributes(ClientPtr client)\n{\n#ifdef PANORAMIX\n    if (!noPanoramiXExtension) {\n        REQUEST(xScreenSaverUnsetAttributesReq);\n         PanoramiXRes *draw;\n         int rc, i;\n \n         rc = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n         if (rc != Success)\n        for (i = PanoramiXNumScreens - 1; i > 0; i--) {\n            stuff->drawable = draw->info[i].id;\n            ScreenSaverUnsetAttributes(client);\n        }\n\n        stuff->drawable = draw->info[0].id;\n    }\n#endif\n\n    return ScreenSaverUnsetAttributes(client);\n}\n",
        "target": 1
    },
    {
        "id": 1018,
        "func": "void RenderFrameDevToolsAgentHost::GrantPolicy() {\n  if (!frame_host_)\n    return;\n  uint32_t process_id = frame_host_->GetProcess()->GetID();\n  if (base::FeatureList::IsEnabled(network::features::kNetworkService))\n    GetNetworkService()->SetRawHeadersAccess(process_id, true);\n  ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadRawCookies(\n      process_id);\n}\n",
        "target": 0
    },
    {
        "id": 1019,
        "func": "static struct sock *udp6_lib_lookup2(struct net *net,\n\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\tconst struct in6_addr *daddr, unsigned int hnum, int dif,\n\t\tstruct udp_hslot *hslot2, unsigned int slot2)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tint score, badness, matches = 0, reuseport = 0;\n\tu32 hash = 0;\n\nbegin:\n\tresult = NULL;\n\tbadness = -1;\n\tudp_portaddr_for_each_entry_rcu(sk, node, &hslot2->head) {\n\t\tscore = compute_score2(sk, net, saddr, sport,\n\t\t\t\t      daddr, hnum, dif);\n\t\tif (score > badness) {\n\t\t\tresult = sk;\n\t\t\tbadness = score;\n\t\t\treuseport = sk->sk_reuseport;\n\t\t\tif (reuseport) {\n\t\t\t\thash = udp6_ehashfn(net, daddr, hnum,\n\t\t\t\t\t\t    saddr, sport);\n\t\t\t\tmatches = 1;\n\t\t\t}\n\t\t} else if (score == badness && reuseport) {\n\t\t\tmatches++;\n\t\t\tif (reciprocal_scale(hash, matches) == 0)\n\t\t\t\tresult = sk;\n\t\t\thash = next_pseudo_random32(hash);\n\t\t}\n\t}\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (get_nulls_value(node) != slot2)\n\t\tgoto begin;\n\n\tif (result) {\n\t\tif (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(compute_score2(result, net, saddr, sport,\n\t\t\t\t  daddr, hnum, dif) < badness)) {\n\t\t\tsock_put(result);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\treturn result;\n}",
        "target": 0
    },
    {
        "id": 1020,
        "func": "static int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\t__be32 new_saddr;\n\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\n\t/* Query new route. */\n\trt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n\t\t\t      sk->sk_bound_dev_if, sk->sk_protocol,\n\t\t\t      inet->inet_sport, inet->inet_dport, sk, false);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tsk_setup_caps(sk, &rt->dst);\n\n\tnew_saddr = rt->rt_src;\n\n\tif (new_saddr == old_saddr)\n\t\treturn 0;\n\n\tif (sysctl_ip_dynaddr > 1) {\n\t\tprintk(KERN_INFO \"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t       __func__, &old_saddr, &new_saddr);\n\t}\n\n\tinet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n\n\t/*\n\t * XXX The only one ugly spot where we need to\n\t * XXX really change the sockets identity after\n\t * XXX it has entered the hashes. -DaveM\n\t *\n\t * Besides that, it does not check for connection\n\t * uniqueness. Wait for troubles.\n\t */\n\t__sk_prot_rehash(sk);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 1021,
        "func": "int follow_down(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1022,
        "func": "static CURLcode imap_select(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct imap_conn *imapc = &conn->proto.imapc;\n  const char *str;\n\n  str = getcmdid(conn);\n\n  result = imapsendf(conn, str, \"%s SELECT %s\", str,\n                     imapc->mailbox?imapc->mailbox:\"\");\n  if(result)\n    return result;\n\n  state(conn, IMAP_SELECT);\n  return result;\n}",
        "target": 0
    },
    {
        "id": 1023,
        "func": "void MessageLoop::RemoveDestructionObserver(\n    DestructionObserver* destruction_observer) {\n  DCHECK_EQ(this, current());\n  destruction_observers_.RemoveObserver(destruction_observer);\n}\n",
        "target": 0
    },
    {
        "id": 1024,
        "func": "static void __perf_event_exit_context(void *__info)\n{\n\tstruct perf_event_context *ctx = __info;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\tstruct perf_event *event;\n\n\traw_spin_lock(&ctx->lock);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry)\n\t\t__perf_remove_from_context(event, cpuctx, ctx, (void *)DETACH_GROUP);\n\traw_spin_unlock(&ctx->lock);\n}",
        "target": 0
    },
    {
        "id": 1025,
        "func": "WebContents* WebContents::Create(const WebContents::CreateParams& params) {\n  return WebContentsImpl::CreateWithOpener(\n      params, static_cast<WebContentsImpl*>(params.opener));\n}\n",
        "target": 0
    },
    {
        "id": 1026,
        "func": "int createPostgresTimeCompareSimple(const char *timecol, const char *timestring, char *dest, size_t destsize)\n{\n  int timeresolution = msTimeGetResolution(timestring);\n  char timeStamp[100];\n  char *interval;\n  if (timeresolution < 0)\n    return MS_FALSE;\n  postgresTimeStampForTimeString(timestring,timeStamp,100);\n\n  switch(timeresolution) {\n    case TIME_RESOLUTION_YEAR:\n      interval = \"year\";\n      break;\n    case TIME_RESOLUTION_MONTH:\n      interval = \"month\";\n      break;\n    case TIME_RESOLUTION_DAY:\n      interval = \"day\";\n      break;\n    case TIME_RESOLUTION_HOUR:\n      interval = \"hour\";\n      break;\n    case TIME_RESOLUTION_MINUTE:\n      interval = \"minute\";\n      break;\n    case TIME_RESOLUTION_SECOND:\n      interval = \"second\";\n      break;\n    default:\n      return MS_FAILURE;\n  }\n  snprintf(dest, destsize,\"(%s >= date_trunc('%s',%s) and %s < date_trunc('%s',%s) + interval '1 %s')\",\n           timecol, interval, timeStamp, timecol, interval, timeStamp, interval);\n  return MS_SUCCESS;\n}",
        "target": 0
    },
    {
        "id": 1027,
        "func": "static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\toffset;\n\tint\tpkt_len;\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn FALSE;\n\t*data_offset = offset;\n\n\t/* Parse the header */\n\tpkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);\n\tif (pkt_len == -1)\n\t\treturn FALSE;\n\n\t/* Convert the ASCII hex dump to binary data */\n\treturn parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,\n\t    wth->frame_buffer, err, err_info);\n}",
        "target": 1
    },
    {
        "id": 1028,
        "func": "AcpiNsTerminate (\n     void)\n {\n     ACPI_STATUS             Status;\n \n \n     ACPI_FUNCTION_TRACE (NsTerminate);\n \n \n#ifdef ACPI_EXEC_APP\n    {\n        ACPI_OPERAND_OBJECT     *Prev;\n        ACPI_OPERAND_OBJECT     *Next;\n        /* Delete any module-level code blocks */\n \n        Next = AcpiGbl_ModuleCodeList;\n        while (Next)\n        {\n            Prev = Next;\n            Next = Next->Method.Mutex;\n            Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */\n            AcpiUtRemoveReference (Prev);\n        }\n     }\n#endif\n \n     /*\n      * Free the entire namespace -- all nodes and all objects\n     * attached to the nodes\n     */\n    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);\n\n    /* Delete any objects attached to the root node */\n\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_VOID;\n    }\n\n    AcpiNsDeleteNode (AcpiGbl_RootNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, \"Namespace freed\\n\"));\n    return_VOID;\n}\n",
        "target": 1
    },
    {
        "id": 1029,
        "func": "void ClientSession::OnConnectionClosed(\n    protocol::ConnectionToClient* connection) {\n   DCHECK_EQ(connection_.get(), connection);\n   scoped_refptr<ClientSession> self = this;\n   event_handler_->OnSessionClosed(this);\n  Disconnect();\n }\n",
        "target": 1
    },
    {
        "id": 1030,
        "func": "bool Document::HaveRenderBlockingResourcesLoaded() const {\n  if (RuntimeEnabledFeatures::CSSInBodyDoesNotBlockPaintEnabled()) {\n    return HaveImportsLoaded() &&\n           style_engine_->HaveRenderBlockingStylesheetsLoaded();\n  }\n  return HaveImportsLoaded() &&\n         style_engine_->HaveScriptBlockingStylesheetsLoaded();\n}\n",
        "target": 0
    },
    {
        "id": 1031,
        "func": "sg_proc_write_adio(struct file *filp, const char __user *buffer,\n\t\t   size_t count, loff_t *off)\n{\n\tint err;\n\tunsigned long num;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\treturn -EACCES;\n\terr = kstrtoul_from_user(buffer, count, 0, &num);\n\tif (err)\n\t\treturn err;\n\tsg_allow_dio = num ? 1 : 0;\n\treturn count;\n}",
        "target": 0
    },
    {
        "id": 1032,
        "func": "static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\t    struct msghdr *msg, size_t len, int noblock,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n\t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n\t\tlsa->l2tp_flowinfo = 0;\n\t\tlsa->l2tp_scope_id = 0;\n\t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;\n\t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}",
        "target": 1
    },
    {
        "id": 1033,
        "func": "WebGLVertexArrayObject* WebGL2RenderingContextBase::createVertexArray() {\n  if (isContextLost())\n    return nullptr;\n\n  return WebGLVertexArrayObject::Create(\n      this, WebGLVertexArrayObjectBase::kVaoTypeUser);\n}\n",
        "target": 0
    },
    {
        "id": 1034,
        "func": "static uint16_t *plist_utf8_to_utf16(char *unistr, long size, long *items_read, long *items_written)\n{\n\tuint16_t *outbuf = (uint16_t*)malloc(((size*2)+1)*sizeof(uint16_t));\n\tint p = 0;\n\tlong i = 0;\n\n\tunsigned char c0;\n\tunsigned char c1;\n\tunsigned char c2;\n\tunsigned char c3;\n\n\tuint32_t w;\n\n\twhile (i < size) {\n\t\tc0 = unistr[i];\n\t\tc1 = (i < size-1) ? unistr[i+1] : 0;\n\t\tc2 = (i < size-2) ? unistr[i+2] : 0;\n\t\tc3 = (i < size-3) ? unistr[i+3] : 0;\n\t\tif ((c0 >= 0xF0) && (i < size-3) && (c1 >= 0x80) && (c2 >= 0x80) && (c3 >= 0x80)) {\n\t\t\t// 4 byte sequence.  Need to generate UTF-16 surrogate pair\n\t\t\tw = ((((c0 & 7) << 18) + ((c1 & 0x3F) << 12) + ((c2 & 0x3F) << 6) + (c3 & 0x3F)) & 0x1FFFFF) - 0x010000;\n\t\t\toutbuf[p++] = 0xD800 + (w >> 10);\n\t\t\toutbuf[p++] = 0xDC00 + (w & 0x3FF);\n\t\t\ti+=4;\n\t\t} else if ((c0 >= 0xE0) && (i < size-2) && (c1 >= 0x80) && (c2 >= 0x80)) {\n\t\t\t// 3 byte sequence\n\t\t\toutbuf[p++] = ((c2 & 0x3F) + ((c1 & 3) << 6)) + (((c1 >> 2) & 15) << 8) + ((c0 & 15) << 12);\n\t\t\ti+=3;\n\t\t} else if ((c0 >= 0xC0) && (i < size-1) && (c1 >= 0x80)) {\n\t\t\t// 2 byte sequence\n\t\t\toutbuf[p++] = ((c1 & 0x3F) + ((c0 & 3) << 6)) + (((c0 >> 2) & 7) << 8);\n\t\t\ti+=2;\n\t\t} else if (c0 < 0x80) {\n\t\t\t// 1 byte sequence\n\t\t\toutbuf[p++] = c0;\n\t\t\ti+=1;\n\t\t} else {\n\t\t\t// invalid character\n\t\t\tPLIST_BIN_ERR(\"%s: invalid utf8 sequence in string at index %lu\\n\", __func__, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (items_read) {\n\t\t*items_read = i;\n\t}\n\tif (items_written) {\n\t\t*items_written = p;\n\t}\n\toutbuf[p] = 0;\n\n\treturn outbuf;\n\n}",
        "target": 0
    },
    {
        "id": 1035,
        "func": "device_local_get_native_path (Device *device)\n{\n  return device->priv->native_path;\n}\n",
        "target": 0
    },
    {
        "id": 1036,
        "func": "uint32_t GetCompressedFormatRowPitch(const CompressedFormatInfo& info,\n                                     uint32_t width) {\n  uint32_t num_blocks_wide = (width + info.block_size - 1) / info.block_size;\n  return num_blocks_wide * info.bytes_per_block;\n}\n",
        "target": 0
    },
    {
        "id": 1037,
        "func": "__iommu_alloc_remap(struct page **pages, size_t size, gfp_t gfp, pgprot_t prot,\n\t\t    const void *caller)\n{\n\tunsigned int i, nr_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tstruct vm_struct *area;\n\tunsigned long p;\n\n\tarea = get_vm_area_caller(size, VM_ARM_DMA_CONSISTENT | VM_USERMAP,\n\t\t\t\t  caller);\n\tif (!area)\n\t\treturn NULL;\n\n\tarea->pages = pages;\n\tarea->nr_pages = nr_pages;\n\tp = (unsigned long)area->addr;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tphys_addr_t phys = __pfn_to_phys(page_to_pfn(pages[i]));\n\t\tif (ioremap_page_range(p, p + PAGE_SIZE, phys, prot))\n\t\t\tgoto err;\n\t\tp += PAGE_SIZE;\n\t}\n\treturn area->addr;\nerr:\n\tunmap_kernel_range((unsigned long)area->addr, size);\n\tvunmap(area->addr);\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 1038,
        "func": "SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint, addr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint fput_needed;\n\n\tif (len > INT_MAX)\n\t\tlen = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tiov.iov_base = buff;\n\tiov.iov_len = len;\n\tmsg.msg_name = NULL;\n\tiov_iter_init(&msg.msg_iter, WRITE, &iov, 1, len);\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tif (addr) {\n\t\terr = move_addr_to_kernel(addr, addr_len, &address);\n\t\tif (err < 0)\n\t\t\tgoto out_put;\n\t\tmsg.msg_name = (struct sockaddr *)&address;\n\t\tmsg.msg_namelen = addr_len;\n\t}\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tmsg.msg_flags = flags;\n\terr = sock_sendmsg(sock, &msg, len);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 1039,
        "func": "void WebContentsImpl::ResumeLoadingCreatedWebContents() {\n  if (delayed_open_url_params_.get()) {\n    OpenURL(*delayed_open_url_params_.get());\n    delayed_open_url_params_.reset(nullptr);\n    return;\n  }\n\n  if (is_resume_pending_) {\n    is_resume_pending_ = false;\n    GetRenderViewHost()->GetWidget()->Init();\n    GetMainFrame()->Init();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1040,
        "func": "bool WallpaperManager::GetUserWallpaperInfo(const AccountId& account_id,\n                                            WallpaperInfo* info) const {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  if (user_manager::UserManager::Get()->IsUserNonCryptohomeDataEphemeral(\n          account_id)) {\n    *info = current_user_wallpaper_info_;\n\n    return true;\n  }\n\n  const base::DictionaryValue* info_dict;\n  if (!g_browser_process->local_state()\n           ->GetDictionary(wallpaper::kUsersWallpaperInfo)\n           ->GetDictionaryWithoutPathExpansion(account_id.GetUserEmail(),\n                                               &info_dict)) {\n    return false;\n  }\n\n  std::string location;\n  if (!info_dict->GetString(kNewWallpaperLocationNodeName, &location))\n    return false;\n  int layout;\n  if (!info_dict->GetInteger(kNewWallpaperLayoutNodeName, &layout))\n    return false;\n  int type;\n  if (!info_dict->GetInteger(kNewWallpaperTypeNodeName, &type))\n    return false;\n  std::string date_string;\n  if (!info_dict->GetString(kNewWallpaperDateNodeName, &date_string))\n    return false;\n  int64_t date_val;\n  if (!base::StringToInt64(date_string, &date_val))\n    return false;\n\n  info->location = location;\n  info->layout = static_cast<wallpaper::WallpaperLayout>(layout);\n  info->type = static_cast<wallpaper::WallpaperType>(type);\n  info->date = base::Time::FromInternalValue(date_val);\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1041,
        "func": "void FetchManager::Loader::Start() {\n\n\n\n\n\n  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&\n      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(\n          fetch_request_data_->Url())) {\n    PerformNetworkError(\n        \"Refused to connect to '\" + fetch_request_data_->Url().ElidedString() +\n        \"' because it violates the document's Content Security Policy.\");\n    return;\n  }\n\n  if ((SecurityOrigin::Create(fetch_request_data_->Url())\n           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||\n      (fetch_request_data_->Url().ProtocolIsData() &&\n       fetch_request_data_->SameOriginDataURLFlag()) ||\n      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {\n    PerformNetworkError(\"Fetch API cannot load \" +\n                        fetch_request_data_->Url().GetString() +\n                        \". Request mode is \\\"same-origin\\\" but the URL\\'s \"\n                        \"origin is not same as the request origin \" +\n                        fetch_request_data_->Origin()->ToString() + \".\");\n    return;\n  }\n \n   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {\n     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);\n    PerformSchemeFetch();\n    return;\n  }\n\n  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(\n          fetch_request_data_->Url().Protocol())) {\n    PerformNetworkError(\n        \"Fetch API cannot load \" + fetch_request_data_->Url().GetString() +\n        \". URL scheme must be \\\"http\\\" or \\\"https\\\" for CORS request.\");\n    return;\n  }\n\n  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);\n\n  PerformHTTPFetch();\n}\n",
        "target": 1
    },
    {
        "id": 1042,
        "func": "receive_private_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n            \"<body>Private carbon</body>\"\n            \"<private xmlns='urn:xmpp:carbons:2'/>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+Private carbon\"));\n}",
        "target": 0
    },
    {
        "id": 1043,
        "func": " static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)\n {\n\tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,\n\t\t      sizeof(struct nfct_attr_grp_port));\n \tif (!nfct_attr_is_set(ct, ATTR_TCP_STATE))\n \t\treturn;\n \n \tct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);\n \tif (CONFIG(sync).tcp_window_tracking) {\n \t\tct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);\n\t\tct_build_u8(ct, ATTR_TCP_WSCALE_REPL, n, NTA_TCP_WSCALE_REPL);\n\t}\n}\n",
        "target": 1
    },
    {
        "id": 1044,
        "func": "static int _hid_get_report_descriptor(struct hid_device_priv* dev, void *data, size_t *size)\n",
        "target": 0
    },
    {
        "id": 1045,
        "func": "int tipc_sk_rht_init(struct net *net)\n{\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\n\treturn rhashtable_init(&tn->sk_rht, &tsk_rht_params);\n}",
        "target": 0
    },
    {
        "id": 1046,
        "func": "static double outlog(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\nstatic double outlog(const png_modifier *pm, int in_depth, int out_depth)\n {\n    /* The command line parameters are either 8 bit (0..255) or 16 bit (0..65535)\n     * and so must be adjusted for low bit depth grayscale:\n    */\n if (out_depth <= 8)\n {\n if (pm->log8 == 0) /* switched off */\n return 256;\n\n if (out_depth < 8)\n return pm->log8 / 255 * ((1<<out_depth)-1);\n\n return pm->log8;\n }\n\n if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n {\n if (pm->log16 == 0)\n return 65536;\n\n return pm->log16;\n }\n\n /* This is the case where the value was calculated at 8-bit precision then\n    * scaled to 16 bits.\n    */\n if (pm->log8 == 0)\n return 65536;\n\n return pm->log8 * 257;\n}\n",
        "target": 0
    },
    {
        "id": 1047,
        "func": "EncodedJSValue JSC_HOST_CALL jsFloat64ArrayPrototypeFunctionFoo(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSFloat64Array::s_info))\n        return throwVMTypeError(exec);\n    JSFloat64Array* castedThis = jsCast<JSFloat64Array*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSFloat64Array::s_info);\n     Float64Array* impl = static_cast<Float64Array*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     Float32Array* array(toFloat32Array(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->foo(array)));\n    return JSValue::encode(result);\n}\n",
        "target": 1
    },
    {
        "id": 1048,
        "func": "void WriteFromUrlOperation::Download(const base::Closure& continuation) {\n  DCHECK_CURRENTLY_ON(BrowserThread::FILE);\n\n  if (IsCancelled()) {\n    return;\n  }\n\n  download_continuation_ = continuation;\n \n   SetStage(image_writer_api::STAGE_DOWNLOAD);\n \n  url_fetcher_ = net::URLFetcher::Create(url_, net::URLFetcher::GET, this);\n \n   url_fetcher_->SetRequestContext(request_context_);\n   url_fetcher_->SaveResponseToFileAtPath(\n      image_path_, BrowserThread::GetTaskRunnerForThread(BrowserThread::FILE));\n\n  AddCleanUpFunction(\n      base::Bind(&WriteFromUrlOperation::DestroyUrlFetcher, this));\n\n  url_fetcher_->Start();\n}\n",
        "target": 1
    },
    {
        "id": 1049,
        "func": "bool PictureLayerImpl::AllTilesRequiredForDrawAreReadyToDraw() const {\n  if (!layer_tree_impl()->IsActiveTree())\n    return true;\n\n  return AllTilesRequiredAreReadyToDraw(\n      &PictureLayerTiling::IsTileRequiredForDrawIfVisible);\n}\n",
        "target": 0
    },
    {
        "id": 1050,
        "func": "    StateBase* doSerializeArrayBuffer(v8::Handle<v8::Value> arrayBuffer, StateBase* next)\n    {\n        return doSerialize(arrayBuffer, next);\n    }\n",
        "target": 0
    },
    {
        "id": 1051,
        "func": "long kernel_wait4(pid_t upid, int __user *stat_addr, int options,\n\t\t  struct rusage *ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\n\tif (options & ~(WNOHANG|WUNTRACED|WCONTINUED|\n\t\t\t__WNOTHREAD|__WCLONE|__WALL))\n\t\treturn -EINVAL;\n\n\tif (upid == -1)\n\t\ttype = PIDTYPE_MAX;\n\telse if (upid < 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = get_task_pid(current, PIDTYPE_PGID);\n\t} else /* upid > 0 */ {\n\t\ttype = PIDTYPE_PID;\n\t\tpid = find_get_pid(upid);\n\t}\n\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options | WEXITED;\n\two.wo_info\t= NULL;\n\two.wo_stat\t= 0;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\tput_pid(pid);\n\tif (ret > 0 && stat_addr && put_user(wo.wo_stat, stat_addr))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 1052,
        "func": "Strgrow(Str x)\n {\n     char *old = x->ptr;\n     int newlen;\n    newlen = x->length * 6 / 5;\n    if (newlen == x->length)\n \tnewlen += 2;\n     x->ptr = GC_MALLOC_ATOMIC(newlen);\n     x->area_size = newlen;\n    bcopy((void *)old, (void *)x->ptr, x->length);\n    GC_free(old);\n}\n",
        "target": 1
    },
    {
        "id": 1053,
        "func": "uint32_t qemu_fdt_get_phandle(void *fdt, const char *path)\n{\n    uint32_t r;\n\n    r = fdt_get_phandle(fdt, findnode_nofail(fdt, path));\n    if (r == 0) {\n        error_report(\"%s: Couldn't get phandle for %s: %s\", __func__,\n                     path, fdt_strerror(r));\n        exit(1);\n    }\n\n    return r;\n}\n",
        "target": 0
    },
    {
        "id": 1054,
        "func": "const String& DocumentLoader::responseMIMEType() const\n{\n    return m_response.mimeType();\n}\n",
        "target": 0
    },
    {
        "id": 1055,
        "func": "static char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n\n    if (size)\n      *size = 0;\n\n    if (is_stream)\n      *is_stream = 0;\n\n    start = ftell(fp);\n\n    /* Find object */\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n\n    if (!entry)\n      return NULL;\n\n    /* Jump to object start */\n    fseek(fp, entry->offset, SEEK_SET);\n\n    /* Initial allocate */\n    obj_sz = 0;    /* Bytes in object */\n    total_sz = 0;  /* Bytes read in   */\n    n_blks = 1;\n    data = malloc(blk_sz * n_blks);\n    memset(data, 0, blk_sz * n_blks);\n\n    /* Suck in data */\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n\n        *(data + total_sz) = '\\0';\n\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (void *)strstr(data + search, \"endobj\") - (void *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n\n    if (size)\n      *size = obj_sz;\n            \n    if (is_stream)\n      *is_stream = stream;\n\n    return data;\n}",
        "target": 1
    },
    {
        "id": 1056,
        "func": "int kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}",
        "target": 0
    },
    {
        "id": 1057,
        "func": "static ssize_t tracing_splice_read_pipe(struct file *filp,\n\t\t\t\t\tloff_t *ppos,\n\t\t\t\t\tstruct pipe_inode_info *pipe,\n\t\t\t\t\tsize_t len,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct page *pages_def[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial_def[PIPE_DEF_BUFFERS];\n\tstruct trace_iterator *iter = filp->private_data;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages\t\t= pages_def,\n\t\t.partial\t= partial_def,\n\t\t.nr_pages\t= 0, /* This gets updated below. */\n\t\t.nr_pages_max\t= PIPE_DEF_BUFFERS,\n\t\t.ops\t\t= &tracing_pipe_buf_ops,\n\t\t.spd_release\t= tracing_spd_release_pipe,\n\t};\n\tssize_t ret;\n\tsize_t rem;\n\tunsigned int i;\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&iter->mutex);\n\n\tif (iter->trace->splice_read) {\n\t\tret = iter->trace->splice_read(iter, filp,\n\t\t\t\t\t       ppos, pipe, len, flags);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\tret = tracing_wait_pipe(filp);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\n\tif (!iter->ent && !trace_find_next_entry_inc(iter)) {\n\t\tret = -EFAULT;\n\t\tgoto out_err;\n\t}\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(iter->cpu_file);\n\n\t/* Fill as many pages as possible. */\n\tfor (i = 0, rem = len; i < spd.nr_pages_max && rem; i++) {\n\t\tspd.pages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!spd.pages[i])\n\t\t\tbreak;\n\n\t\trem = tracing_fill_pipe_page(rem, iter);\n\n\t\t/* Copy the data into the page, so we can start over. */\n\t\tret = trace_seq_to_buffer(&iter->seq,\n\t\t\t\t\t  page_address(spd.pages[i]),\n\t\t\t\t\t  trace_seq_used(&iter->seq));\n\t\tif (ret < 0) {\n\t\t\t__free_page(spd.pages[i]);\n\t\t\tbreak;\n\t\t}\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].len = trace_seq_used(&iter->seq);\n\n\t\ttrace_seq_init(&iter->seq);\n\t}\n\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n\tmutex_unlock(&iter->mutex);\n\n\tspd.nr_pages = i;\n\n\tif (i)\n\t\tret = splice_to_pipe(pipe, &spd);\n\telse\n\t\tret = 0;\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n\nout_err:\n\tmutex_unlock(&iter->mutex);\n\tgoto out;\n}",
        "target": 0
    },
    {
        "id": 1058,
        "func": "static int nfs4_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\terr = nfs4_set_lock_state(state, request);\n\tif (err != 0)\n\t\treturn err;\n\tdo {\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, NFS_LOCK_EXPIRED);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t\t\terr = 0;\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 1059,
        "func": "RenderView* RenderView::Create(\n    RenderThreadBase* render_thread,\n    gfx::NativeViewId parent_hwnd,\n    int32 opener_id,\n    const RendererPreferences& renderer_prefs,\n    const WebPreferences& webkit_prefs,\n    SharedRenderViewCounter* counter,\n    int32 routing_id,\n    int64 session_storage_namespace_id,\n    const string16& frame_name) {\n  DCHECK(routing_id != MSG_ROUTING_NONE);\n  scoped_refptr<RenderView> view = new RenderView(render_thread, webkit_prefs,\n                                                  session_storage_namespace_id);\n  view->Init(parent_hwnd,\n             opener_id,\n             renderer_prefs,\n             counter,\n             routing_id,\n             frame_name);  // adds reference\n  return view;\n}\n",
        "target": 0
    },
    {
        "id": 1060,
        "func": "void ServiceWorkerContextCore::UnregistrationComplete(\n    const GURL& scope,\n    ServiceWorkerContextCore::UnregistrationCallback callback,\n    int64_t registration_id,\n    blink::ServiceWorkerStatusCode status) {\n  std::move(callback).Run(status);\n  if (status == blink::ServiceWorkerStatusCode::kOk) {\n    observer_list_->Notify(\n        FROM_HERE, &ServiceWorkerContextCoreObserver::OnRegistrationDeleted,\n        registration_id, scope);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1061,
        "func": "static inline void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t\t  struct pt_regs *regs)\n{\n}",
        "target": 1
    },
    {
        "id": 1062,
        "func": "static int copy_strings(int argc, struct user_arg_ptr argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tstruct page *kmapped_page = NULL;\n\tchar *kaddr = NULL;\n\tunsigned long kpos = 0;\n\tint ret;\n\n\twhile (argc-- > 0) {\n\t\tconst char __user *str;\n\t\tint len;\n\t\tunsigned long pos;\n\n\t\tret = -EFAULT;\n\t\tstr = get_user_arg_ptr(argv, argc);\n\t\tif (IS_ERR(str))\n\t\t\tgoto out;\n\n\t\tlen = strnlen_user(str, MAX_ARG_STRLEN);\n\t\tif (!len)\n\t\t\tgoto out;\n\n\t\tret = -E2BIG;\n\t\tif (!valid_arg_len(bprm, len))\n\t\t\tgoto out;\n\n\t\t/* We're going to work our way backwords. */\n\t\tpos = bprm->p;\n\t\tstr += len;\n\t\tbprm->p -= len;\n\n\t\twhile (len > 0) {\n\t\t\tint offset, bytes_to_copy;\n\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tret = -ERESTARTNOHAND;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\toffset = pos % PAGE_SIZE;\n\t\t\tif (offset == 0)\n\t\t\t\toffset = PAGE_SIZE;\n\n\t\t\tbytes_to_copy = offset;\n\t\t\tif (bytes_to_copy > len)\n\t\t\t\tbytes_to_copy = len;\n\n\t\t\toffset -= bytes_to_copy;\n\t\t\tpos -= bytes_to_copy;\n\t\t\tstr -= bytes_to_copy;\n\t\t\tlen -= bytes_to_copy;\n\n\t\t\tif (!kmapped_page || kpos != (pos & PAGE_MASK)) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = get_arg_page(bprm, pos, 1);\n\t\t\t\tif (!page) {\n\t\t\t\t\tret = -E2BIG;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (kmapped_page) {\n\t\t\t\t\tflush_kernel_dcache_page(kmapped_page);\n\t\t\t\t\tkunmap(kmapped_page);\n\t\t\t\t\tput_arg_page(kmapped_page);\n\t\t\t\t}\n\t\t\t\tkmapped_page = page;\n\t\t\t\tkaddr = kmap(kmapped_page);\n\t\t\t\tkpos = pos & PAGE_MASK;\n\t\t\t\tflush_arg_page(bprm, kpos, kmapped_page);\n\t\t\t}\n\t\t\tif (copy_from_user(kaddr+offset, str, bytes_to_copy)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\nout:\n\tif (kmapped_page) {\n\t\tflush_kernel_dcache_page(kmapped_page);\n\t\tkunmap(kmapped_page);\n\t\tput_arg_page(kmapped_page);\n\t}\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1063,
        "func": "static void reflectLongAttributeAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;\n    TestObjectPythonV8Internal::reflectLongAttributeAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 1064,
        "func": "bson_iter_regex (const bson_iter_t *iter, /* IN */\n                 const char **options)    /* IN */\n{\n   const char *ret = NULL;\n   const char *ret_options = NULL;\n\n   BSON_ASSERT (iter);\n\n   if (ITER_TYPE (iter) == BSON_TYPE_REGEX) {\n      ret = (const char *) (iter->raw + iter->d1);\n      ret_options = (const char *) (iter->raw + iter->d2);\n   }\n\n   if (options) {\n      *options = ret_options;\n   }\n\n   return ret;\n}",
        "target": 0
    },
    {
        "id": 1065,
        "func": " virtual status_t detachBuffer(int slot) {\n Parcel data, reply;\n        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());\n        data.writeInt32(slot);\n status_t result = remote()->transact(DETACH_BUFFER, data, &reply);\n if (result != NO_ERROR) {\n return result;\n }\n        result = reply.readInt32();\n return result;\n }\n",
        "target": 0
    },
    {
        "id": 1066,
        "func": "static void jpc_dec_opts_destroy(jpc_dec_importopts_t *opts)\n{\n\tjas_free(opts);\n}",
        "target": 0
    },
    {
        "id": 1067,
        "func": "GURL DevToolsUI::SanitizeFrontendURL(const GURL& url) {\n",
        "target": 0
    },
    {
        "id": 1068,
        "func": "void Browser::FindReply(WebContents* web_contents,\n                        int request_id,\n                        int number_of_matches,\n                        const gfx::Rect& selection_rect,\n                        int active_match_ordinal,\n                        bool final_update) {\n  FindTabHelper* find_tab_helper = FindTabHelper::FromWebContents(web_contents);\n  if (!find_tab_helper)\n    return;\n\n  find_tab_helper->HandleFindReply(request_id,\n                                   number_of_matches,\n                                   selection_rect,\n                                   active_match_ordinal,\n                                   final_update);\n}\n",
        "target": 0
    },
    {
        "id": 1069,
        "func": "void MediaStreamManager::SendMessageToNativeLog(const std::string& message) {\n  if (!BrowserThread::CurrentlyOn(BrowserThread::IO)) {\n    base::PostTaskWithTraits(\n        FROM_HERE, {BrowserThread::IO},\n        base::BindOnce(&MediaStreamManager::SendMessageToNativeLog, message));\n    return;\n  }\n\n  MediaStreamManager* msm = g_media_stream_manager_tls_ptr.Pointer()->Get();\n  if (!msm) {\n    return;\n  }\n\n  msm->AddLogMessageOnIOThread(message);\n}\n",
        "target": 0
    },
    {
        "id": 1070,
        "func": "static int mem_cgroup_move_charge_pte_range(pmd_t *pmd,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tint ret = 0;\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\nretry:\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\tpte_t ptent = *(pte++);\n\t\tunion mc_target target;\n\t\tint type;\n\t\tstruct page *page;\n\t\tstruct page_cgroup *pc;\n\t\tswp_entry_t ent;\n\n\t\tif (!mc.precharge)\n\t\t\tbreak;\n\n\t\ttype = is_target_pte_for_mc(vma, addr, ptent, &target);\n\t\tswitch (type) {\n\t\tcase MC_TARGET_PAGE:\n\t\t\tpage = target.page;\n\t\t\tif (isolate_lru_page(page))\n\t\t\t\tgoto put;\n\t\t\tpc = lookup_page_cgroup(page);\n\t\t\tif (!mem_cgroup_move_account(page, 1, pc,\n\t\t\t\t\t\t     mc.from, mc.to, false)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we uncharge from mc.from later. */\n\t\t\t\tmc.moved_charge++;\n\t\t\t}\n\t\t\tputback_lru_page(page);\nput:\t\t\t/* is_target_pte_for_mc() gets the page */\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\tcase MC_TARGET_SWAP:\n\t\t\tent = target.ent;\n\t\t\tif (!mem_cgroup_move_swap_account(ent,\n\t\t\t\t\t\tmc.from, mc.to, false)) {\n\t\t\t\tmc.precharge--;\n\t\t\t\t/* we fixup refcnts and charges later. */\n\t\t\t\tmc.moved_swap++;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\tif (addr != end) {\n\t\t/*\n\t\t * We have consumed all precharges we got in can_attach().\n\t\t * We try charge one by one, but don't do any additional\n\t\t * charges to mc.to if we have failed in charge once in attach()\n\t\t * phase.\n\t\t */\n\t\tret = mem_cgroup_do_precharge(1);\n\t\tif (!ret)\n\t\t\tgoto retry;\n\t}\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1071,
        "func": "static void rwpng_free_chunks(struct rwpng_chunk *chunk) {\n    if (!chunk) return;\n    rwpng_free_chunks(chunk->next);\n    free(chunk->data);\n    free(chunk);\n}",
        "target": 0
    },
    {
        "id": 1072,
        "func": "int qcow2_snapshot_delete(BlockDriverState *bs,\n                          const char *snapshot_id,\n                          const char *name,\n                          Error **errp)\n{\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot sn;\n    int snapshot_index, ret;\n\n    /* Search the snapshot */\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp, \"Can't find the snapshot\");\n        return -ENOENT;\n    }\n    sn = s->snapshots[snapshot_index];\n\n    /* Remove it from the snapshot list */\n    memmove(s->snapshots + snapshot_index,\n            s->snapshots + snapshot_index + 1,\n            (s->nb_snapshots - snapshot_index - 1) * sizeof(sn));\n    s->nb_snapshots--;\n    ret = qcow2_write_snapshots(bs);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret,\n                         \"Failed to remove snapshot from snapshot list\");\n        return ret;\n    }\n\n    /*\n     * The snapshot is now unused, clean up. If we fail after this point, we\n     * won't recover but just leak clusters.\n     */\n    g_free(sn.id_str);\n    g_free(sn.name);\n\n    /*\n     * Now decrease the refcounts of clusters referenced by the snapshot and\n     * free the L1 table.\n     */\n    ret = qcow2_update_snapshot_refcount(bs, sn.l1_table_offset,\n                                         sn.l1_size, -1);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Failed to free the cluster and L1 table\");\n        return ret;\n    }\n    qcow2_free_clusters(bs, sn.l1_table_offset, sn.l1_size * sizeof(uint64_t),\n                        QCOW2_DISCARD_SNAPSHOT);\n\n    /* must update the copied flag on the current cluster offsets */\n    ret = qcow2_update_snapshot_refcount(bs, s->l1_table_offset, s->l1_size, 0);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret,\n                         \"Failed to update snapshot status in disk\");\n        return ret;\n    }\n\n#ifdef DEBUG_ALLOC\n    {\n        BdrvCheckResult result = {0};\n        qcow2_check_refcounts(bs, &result, 0);\n    }\n#endif\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 1073,
        "func": "bool PermissionsData::CanExecuteScriptEverywhere(const Extension* extension) {\n  if (extension->location() == Manifest::COMPONENT)\n    return true;\n\n  const ExtensionsClient::ScriptingWhitelist& whitelist =\n      ExtensionsClient::Get()->GetScriptingWhitelist();\n\n  return std::find(whitelist.begin(), whitelist.end(), extension->id()) !=\n          whitelist.end();\n }\n",
        "target": 0
    },
    {
        "id": 1074,
        "func": "void GpuCommandBufferStub::OnCreateVideoDecoder(\n    media::VideoCodecProfile profile,\n    IPC::Message* reply_message) {\n  int decoder_route_id = channel_->GenerateRouteID();\n  GpuCommandBufferMsg_CreateVideoDecoder::WriteReplyParams(\n      reply_message, decoder_route_id);\n  GpuVideoDecodeAccelerator* decoder =\n       new GpuVideoDecodeAccelerator(this, decoder_route_id, this);\n   video_decoders_.AddWithID(decoder, decoder_route_id);\n   channel_->AddRoute(decoder_route_id, decoder);\n  decoder->Initialize(profile, reply_message,\n                      channel_->renderer_process());\n }\n",
        "target": 1
    },
    {
        "id": 1075,
        "func": "static inline AtomicString makeIdForStyleResolution(const AtomicString& value, bool inQuirksMode)\n{\n    if (inQuirksMode)\n        return value.lower();\n    return value;\n}\n",
        "target": 0
    },
    {
        "id": 1076,
        "func": "void Browser::Paste() {\n  UserMetrics::RecordAction(UserMetricsAction(\"Paste\"), profile_);\n  window()->Paste();\n}\n",
        "target": 0
    },
    {
        "id": 1077,
        "func": "PPB_Flash_MessageLoop_Impl::PPB_Flash_MessageLoop_Impl(PP_Instance instance)\n    : Resource(ppapi::OBJECT_IS_IMPL, instance), state_(new State()) {}\n",
        "target": 0
    },
    {
        "id": 1078,
        "func": "void RenderWidgetHostImpl::OnMsgGetWindowRect(gfx::Rect* results) {\n  if (view_)\n    *results = view_->GetViewBounds();\n}\n",
        "target": 0
    },
    {
        "id": 1079,
        "func": "static void deprecatedAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    UseCounter::countDeprecation(callingExecutionContext(info.GetIsolate()), UseCounter::Attribute);\n    TestObjectV8Internal::deprecatedAttrAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 1080,
        "func": "void RenderFlexibleBox::resetAutoMarginsAndLogicalTopInCrossAxis(RenderBox* child)\n{\n    if (hasAutoMarginsInCrossAxis(child)) {\n        child->updateLogicalHeight();\n        if (isHorizontalFlow()) {\n            if (child->style()->marginTop().isAuto())\n                child->setMarginTop(0);\n            if (child->style()->marginBottom().isAuto())\n                child->setMarginBottom(0);\n        } else {\n            if (child->style()->marginLeft().isAuto())\n                child->setMarginLeft(0);\n            if (child->style()->marginRight().isAuto())\n                child->setMarginRight(0);\n        }\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1081,
        "func": "void BluetoothDeviceChromeOS::OnRegisterAgentError(\n    const ConnectErrorCallback& error_callback,\n    const std::string& error_name,\n    const std::string& error_message) {\n  if (--num_connecting_calls_ == 0)\n    adapter_->NotifyDeviceChanged(this);\n  DCHECK(num_connecting_calls_ >= 0);\n  LOG(WARNING) << object_path_.value() << \": Failed to register agent: \"\n               << error_name << \": \" << error_message;\n  VLOG(1) << object_path_.value() << \": \" << num_connecting_calls_\n          << \" still in progress\";\n  UnregisterAgent();\n  ConnectErrorCode error_code = ERROR_UNKNOWN;\n  if (error_name == bluetooth_agent_manager::kErrorAlreadyExists)\n    error_code = ERROR_INPROGRESS;\n  RecordPairingResult(error_code);\n  error_callback.Run(error_code);\n}\n",
        "target": 1
    },
    {
        "id": 1082,
        "func": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n         }\n     }\n \n    vmxnet3_validate_interrupts(s);\n\n     return 0;\n }\n",
        "target": 0
    },
    {
        "id": 1083,
        "func": "  Normalize( EXEC_OP_ FT_F26Dot6      Vx,\n                      FT_F26Dot6      Vy,\n                      FT_UnitVector*  R )\n  {\n    FT_F26Dot6  W;\n    FT_Bool     S1, S2;\n\n    FT_UNUSED_EXEC;\n\n\n    if ( FT_ABS( Vx ) < 0x10000L && FT_ABS( Vy ) < 0x10000L )\n    {\n      Vx *= 0x100;\n      Vy *= 0x100;\n\n      W = TT_VecLen( Vx, Vy );\n\n      if ( W == 0 )\n      {\n        /* XXX: UNDOCUMENTED! It seems that it is possible to try   */\n        /*      to normalize the vector (0,0).  Return immediately. */\n        return SUCCESS;\n      }\n\n      R->x = (FT_F2Dot14)FT_MulDiv( Vx, 0x4000L, W );\n      R->y = (FT_F2Dot14)FT_MulDiv( Vy, 0x4000L, W );\n\n      return SUCCESS;\n    }\n\n    W = TT_VecLen( Vx, Vy );\n\n    Vx = FT_MulDiv( Vx, 0x4000L, W );\n    Vy = FT_MulDiv( Vy, 0x4000L, W );\n\n    W = Vx * Vx + Vy * Vy;\n\n    /* Now, we want that Sqrt( W ) = 0x4000 */\n    /* Or 0x10000000 <= W < 0x10004000        */\n\n    if ( Vx < 0 )\n    {\n      Vx = -Vx;\n      S1 = TRUE;\n    }\n    else\n      S1 = FALSE;\n\n    if ( Vy < 0 )\n    {\n      Vy = -Vy;\n      S2 = TRUE;\n    }\n    else\n      S2 = FALSE;\n\n    while ( W < 0x10000000L )\n    {\n      /* We need to increase W by a minimal amount */\n      if ( Vx < Vy )\n        Vx++;\n      else\n        Vy++;\n\n      W = Vx * Vx + Vy * Vy;\n    }\n\n    while ( W >= 0x10004000L )\n    {\n      /* We need to decrease W by a minimal amount */\n      if ( Vx < Vy )\n        Vx--;\n      else\n        Vy--;\n\n      W = Vx * Vx + Vy * Vy;\n    }\n\n    /* Note that in various cases, we can only  */\n    /* compute a Sqrt(W) of 0x3FFF, eg. Vx = Vy */\n\n    if ( S1 )\n      Vx = -Vx;\n\n    if ( S2 )\n      Vy = -Vy;\n\n    R->x = (FT_F2Dot14)Vx;   /* Type conversion */\n    R->y = (FT_F2Dot14)Vy;   /* Type conversion */\n\n    return SUCCESS;\n  }\n",
        "target": 0
    },
    {
        "id": 1084,
        "func": "  bool StartInputMethodDaemon() {\n    should_launch_ime_ = true;\n    return MaybeLaunchInputMethodDaemon();\n   }\n",
        "target": 0
    },
    {
        "id": 1085,
        "func": "void RenderFrameImpl::didStartLoading(bool to_different_document) {\n  bool view_was_loading = render_view_->is_loading();\n  render_view_->FrameDidStartLoading(frame_);\n  if (!view_was_loading)\n    Send(new FrameHostMsg_DidStartLoading(routing_id_, to_different_document));\n}\n",
        "target": 0
    },
    {
        "id": 1086,
        "func": "static void vmx_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)\n{\n\tu32 sec_exec_control;\n\n\t/* Postpone execution until vmcs01 is the current VMCS. */\n\tif (is_guest_mode(vcpu)) {\n\t\tto_vmx(vcpu)->nested.change_vmcs01_virtual_x2apic_mode = true;\n\t\treturn;\n\t}\n\n\tif (!cpu_has_vmx_virtualize_x2apic_mode())\n\t\treturn;\n\n\tif (!cpu_need_tpr_shadow(vcpu))\n\t\treturn;\n\n\tsec_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tif (set) {\n\t\tsec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\tsec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t} else {\n\t\tsec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t\tsec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t}\n\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, sec_exec_control);\n\n\tvmx_set_msr_bitmap(vcpu);\n}",
        "target": 0
    },
    {
        "id": 1087,
        "func": "  static void SaveCardCallback() {}\n",
        "target": 0
    },
    {
        "id": 1088,
        "func": "static void vmcs_load(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\tu8 error;\n\n\tasm volatile (__ex(ASM_VMX_VMPTRLD_RAX) \"; setna %0\"\n\t\t\t: \"=qm\"(error) : \"a\"(&phys_addr), \"m\"(phys_addr)\n\t\t\t: \"cc\", \"memory\");\n\tif (error)\n\t\tprintk(KERN_ERR \"kvm: vmptrld %p/%llx failed\\n\",\n\t\t       vmcs, phys_addr);\n}",
        "target": 0
    },
    {
        "id": 1089,
        "func": "  void RestoreTab(const SessionTab& tab,\n                  const int tab_index,\n                  Browser* browser,\n                  bool schedule_load) {\n    DCHECK(!tab.navigations.empty());\n    int selected_index = tab.current_navigation_index;\n    selected_index = std::max(\n        0,\n        std::min(selected_index,\n                 static_cast<int>(tab.navigations.size() - 1)));\n\n    GURL url = tab.navigations.at(selected_index).virtual_url();\n    if (\n#if defined(OS_CHROMEOS)\n        browser->profile()->GetExtensionService() &&\n#endif\n        browser->profile()->GetExtensionService()->IsInstalledApp(url)) {\n      UMA_HISTOGRAM_ENUMERATION(extension_misc::kAppLaunchHistogram,\n                                extension_misc::APP_LAUNCH_SESSION_RESTORE,\n                                extension_misc::APP_LAUNCH_BUCKET_BOUNDARY);\n    }\n\n    WebContents* web_contents =\n        browser->AddRestoredTab(tab.navigations,\n                                tab_index,\n                                selected_index,\n                                tab.extension_app_id,\n                                false,\n                                tab.pinned,\n                                true,\n                                NULL);\n    if (schedule_load)\n      tab_loader_->ScheduleLoad(&web_contents->GetController());\n  }\n",
        "target": 0
    },
    {
        "id": 1090,
        "func": "void ChromeContentBrowserClient::OnTrustAnchorUsed(\n    const std::string& username_hash) {\n  policy::PolicyCertServiceFactory::SetUsedPolicyCertificates(username_hash);\n}\n",
        "target": 0
    },
    {
        "id": 1091,
        "func": "void WebProcessProxy::updateTextCheckerState()\n{\n    if (canSendMessage())\n        send(Messages::WebProcess::SetTextCheckerState(TextChecker::state()), 0);\n}\n",
        "target": 0
    },
    {
        "id": 1092,
        "func": "static struct menu *pxe_menu_to_menu(struct pxe_menu *cfg)\n{\n\tstruct pxe_label *label;\n\tstruct list_head *pos;\n\tstruct menu *m;\n\tint err;\n\tint i = 1;\n\tchar *default_num = NULL;\n\n\t/*\n\t * Create a menu and add items for all the labels.\n\t */\n\tm = menu_create(cfg->title, DIV_ROUND_UP(cfg->timeout, 10),\n\t\t\tcfg->prompt, label_print, NULL, NULL);\n\n\tif (!m)\n\t\treturn NULL;\n\n\tlist_for_each(pos, &cfg->labels) {\n\t\tlabel = list_entry(pos, struct pxe_label, list);\n\n\t\tsprintf(label->num, \"%d\", i++);\n\t\tif (menu_item_add(m, label->num, label) != 1) {\n\t\t\tmenu_destroy(m);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (cfg->default_label &&\n\t\t    (strcmp(label->name, cfg->default_label) == 0))\n\t\t\tdefault_num = label->num;\n\t}\n\n\t/*\n\t * After we've created items for each label in the menu, set the\n\t * menu's default label if one was specified.\n\t */\n\tif (default_num) {\n\t\terr = menu_default_set(m, default_num);\n\t\tif (err != 1) {\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tmenu_destroy(m);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tprintf(\"Missing default: %s\\n\", cfg->default_label);\n\t\t}\n\t}\n\n\treturn m;\n}\n",
        "target": 0
    },
    {
        "id": 1093,
        "func": "static void rds_inc_addref(struct rds_incoming *inc)\n{\n\trdsdebug(\"addref inc %p ref %d\\n\", inc, atomic_read(&inc->i_refcount));\n\tatomic_inc(&inc->i_refcount);\n}",
        "target": 0
    },
    {
        "id": 1094,
        "func": "static int skt_read(int fd, void *p, size_t len)\n{\n int read;\n struct pollfd pfd;\n struct timespec ts;\n\n    FNLOG();\n\n \n     ts_log(\"skt_read recv\", len, NULL);\n \n    if ((read = recv(fd, p, len, MSG_NOSIGNAL)) == -1)\n     {\n         ERROR(\"write failed with errno=%d\\n\", errno);\n         return -1;\n }\n\n return read;\n}\n",
        "target": 1
    },
    {
        "id": 1095,
        "func": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}",
        "target": 1
    },
    {
        "id": 1096,
        "func": "struct rdma_cm_id *rdma_create_id(rdma_cm_event_handler event_handler,\n\t\t\t\t  void *context, enum rdma_port_space ps,\n\t\t\t\t  enum ib_qp_type qp_type)\n{\n\tstruct rdma_id_private *id_priv;\n\n\tid_priv = kzalloc(sizeof *id_priv, GFP_KERNEL);\n\tif (!id_priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tid_priv->owner = task_pid_nr(current);\n\tid_priv->state = RDMA_CM_IDLE;\n\tid_priv->id.context = context;\n\tid_priv->id.event_handler = event_handler;\n\tid_priv->id.ps = ps;\n\tid_priv->id.qp_type = qp_type;\n\tspin_lock_init(&id_priv->lock);\n\tmutex_init(&id_priv->qp_mutex);\n\tinit_completion(&id_priv->comp);\n\tatomic_set(&id_priv->refcount, 1);\n\tmutex_init(&id_priv->handler_mutex);\n\tINIT_LIST_HEAD(&id_priv->listen_list);\n\tINIT_LIST_HEAD(&id_priv->mc_list);\n\tget_random_bytes(&id_priv->seq_num, sizeof id_priv->seq_num);\n\n\treturn &id_priv->id;\n}",
        "target": 0
    },
    {
        "id": 1097,
        "func": "static u32 __init armv8pmu_read_num_pmnc_events(void)\n{\n\tu32 nb_cnt;\n\n\t/* Read the nb of CNTx counters supported from PMNC */\n\tnb_cnt = (armv8pmu_pmcr_read() >> ARMV8_PMCR_N_SHIFT) & ARMV8_PMCR_N_MASK;\n\n\t/* Add the CPU cycles counter and return */\n\treturn nb_cnt + 1;\n}",
        "target": 0
    },
    {
        "id": 1098,
        "func": "UrlIndex::~UrlIndex() {\n#if DCHECK_IS_ON()\n  auto dcheck_has_one_ref = [](const UrlDataMap::value_type& entry) {\n    DCHECK(entry.second->HasOneRef());\n  };\n  std::for_each(indexed_data_.begin(), indexed_data_.end(), dcheck_has_one_ref);\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 1099,
        "func": "sctp_disposition_t sctp_sf_cookie_echoed_err(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_errhdr_t *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length.\n\t * The parameter walking depends on this as well.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Process the error here */\n\t/* FUTURE FIXME:  When PR-SCTP related and other optional\n\t * parms are emitted, this will have to change to handle multiple\n\t * errors.\n\t */\n\tsctp_walk_errors(err, chunk->chunk_hdr) {\n\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause)\n\t\t\treturn sctp_sf_do_5_2_6_stale(net, ep, asoc, type,\n\t\t\t\t\t\t\targ, commands);\n\t}\n\n\t/* It is possible to have malformed error causes, and that\n\t * will cause us to end the walk early.  However, since\n\t * we are discarding the packet, there should be no adverse\n\t * affects.\n\t */\n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}",
        "target": 0
    },
    {
        "id": 1100,
        "func": "static int hid_scan_report(struct hid_device *hid)\n{\n\tstruct hid_parser *parser;\n\tstruct hid_item item;\n\t__u8 *start = hid->dev_rdesc;\n\t__u8 *end = start + hid->dev_rsize;\n\tstatic int (*dispatch_type[])(struct hid_parser *parser,\n\t\t\t\t      struct hid_item *item) = {\n\t\thid_scan_main,\n\t\thid_parser_global,\n\t\thid_parser_local,\n\t\thid_parser_reserved\n\t};\n\n\tparser = vzalloc(sizeof(struct hid_parser));\n\tif (!parser)\n\t\treturn -ENOMEM;\n\n\tparser->device = hid;\n\thid->group = HID_GROUP_GENERIC;\n\n\t/*\n\t * The parsing is simpler than the one in hid_open_report() as we should\n\t * be robust against hid errors. Those errors will be raised by\n\t * hid_open_report() anyway.\n\t */\n\twhile ((start = fetch_item(start, end, &item)) != NULL)\n\t\tdispatch_type[item.type](parser, &item);\n\n\t/*\n\t * Handle special flags set during scanning.\n\t */\n\tif ((parser->scan_flags & HID_SCAN_FLAG_MT_WIN_8) &&\n\t    (hid->group == HID_GROUP_MULTITOUCH))\n\t\thid->group = HID_GROUP_MULTITOUCH_WIN_8;\n\n\t/*\n\t * Vendor specific handlings\n\t */\n\tswitch (hid->vendor) {\n\tcase USB_VENDOR_ID_WACOM:\n\t\thid->group = HID_GROUP_WACOM;\n\t\tbreak;\n\tcase USB_VENDOR_ID_SYNAPTICS:\n\t\tif (hid->group == HID_GROUP_GENERIC)\n\t\t\tif ((parser->scan_flags & HID_SCAN_FLAG_VENDOR_SPECIFIC)\n\t\t\t    && (parser->scan_flags & HID_SCAN_FLAG_GD_POINTER))\n\t\t\t\t/*\n\t\t\t\t * hid-rmi should take care of them,\n\t\t\t\t * not hid-generic\n\t\t\t\t */\n\t\t\t\thid->group = HID_GROUP_RMI;\n\t\tbreak;\n\t}\n\n\tvfree(parser);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1101,
        "func": "void PluginInfoMessageFilter::Context::GrantAccess(\n     const ChromeViewHostMsg_GetPluginInfo_Status& status,\n     const FilePath& path) const {\n   if (status.value == ChromeViewHostMsg_GetPluginInfo_Status::kAllowed ||\n      status.value == ChromeViewHostMsg_GetPluginInfo_Status::kClickToPlay) {\n    ChromePluginServiceFilter::GetInstance()->AuthorizePlugin(\n        render_process_id_, path);\n  }\n}\n",
        "target": 1
    },
    {
        "id": 1102,
        "func": "bool GLES2DecoderImpl::SetParent(GLES2Decoder* new_parent,\n                                 uint32 new_parent_texture_id) {\n  if (!offscreen_saved_color_texture_.get())\n    return false;\n\n  if (parent_) {\n    GLuint service_id = offscreen_saved_color_texture_->id();\n    GLuint client_id = 0;\n    if (parent_->texture_manager()->GetClientId(service_id, &client_id)) {\n      parent_->texture_manager()->RemoveTextureInfo(feature_info_, client_id);\n    }\n  }\n\n  GLES2DecoderImpl* new_parent_impl = static_cast<GLES2DecoderImpl*>(\n      new_parent);\n  if (new_parent_impl) {\n    GLuint service_id = offscreen_saved_color_texture_->id();\n\n    if (new_parent_impl->texture_manager()->GetTextureInfo(\n            new_parent_texture_id))\n      new_parent_impl->texture_manager()->RemoveTextureInfo(\n          feature_info_, new_parent_texture_id);\n\n    TextureManager::TextureInfo* info =\n        new_parent_impl->CreateTextureInfo(new_parent_texture_id, service_id);\n    info->SetNotOwned();\n    new_parent_impl->texture_manager()->SetInfoTarget(info, GL_TEXTURE_2D);\n\n    parent_ = new_parent_impl->AsWeakPtr();\n\n    UpdateParentTextureInfo();\n  } else {\n    parent_.reset();\n  }\n\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1103,
        "func": "u32 gf_sys_get_argc()\n{\n\treturn gpac_argc;\n}\n",
        "target": 0
    },
    {
        "id": 1104,
        "func": "xmlParse3986PathAbEmpty(xmlURIPtr uri, const char **str)\n{\n const char *cur;\n int ret;\n\n    cur = *str;\n\n while (*cur == '/') {\n        cur++;\n\tret = xmlParse3986Segment(&cur, 0, 1);\n if (ret != 0) return(ret);\n }\n if (uri != NULL) {\n if (uri->path != NULL) xmlFree(uri->path);\n if (*str != cur) {\n if (uri->cleanup & 2)\n                uri->path = STRNDUP(*str, cur - *str);\n else\n                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);\n } else {\n            uri->path = NULL;\n }\n }\n *str = cur;\n return (0);\n}\n",
        "target": 0
    },
    {
        "id": 1105,
        "func": "static void jpc_unk_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\tif (unk->data) {\n\t\tjas_free(unk->data);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1106,
        "func": "static int sctp_skb_pull(struct sk_buff *skb, int len)\n{\n\tstruct sk_buff *list;\n\tint skb_len = skb_headlen(skb);\n\tint rlen;\n\n\tif (len <= skb_len) {\n\t\t__skb_pull(skb, len);\n\t\treturn 0;\n\t}\n\tlen -= skb_len;\n\t__skb_pull(skb, skb_len);\n\n\tskb_walk_frags(skb, list) {\n\t\trlen = sctp_skb_pull(list, len);\n\t\tskb->len -= (len-rlen);\n\t\tskb->data_len -= (len-rlen);\n\n\t\tif (!rlen)\n\t\t\treturn 0;\n\n\t\tlen = rlen;\n\t}\n\n\treturn len;\n}",
        "target": 0
    },
    {
        "id": 1107,
        "func": "int phar_is_tar(char *buf, char *fname) /* {{{ */\n{\n\ttar_header *header = (tar_header *) buf;\n\tphp_uint32 checksum = phar_tar_number(header->checksum, sizeof(header->checksum));\n\tphp_uint32 ret;\n\tchar save[sizeof(header->checksum)];\n\n\t/* assume that the first filename in a tar won't begin with <?php */\n\tif (!strncmp(buf, \"<?php\", sizeof(\"<?php\")-1)) {\n\t\treturn 0;\n\t}\n\n\tmemcpy(save, header->checksum, sizeof(header->checksum));\n\tmemset(header->checksum, ' ', sizeof(header->checksum));\n\tret = (checksum == phar_tar_checksum(buf, 512));\n\tmemcpy(header->checksum, save, sizeof(header->checksum));\n\tif (!ret && strstr(fname, \".tar\")) {\n\t\t/* probably a corrupted tar - so we will pretend it is one */\n\t\treturn 1;\n\t}\n\treturn ret;\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 1108,
        "func": "void GDataCacheMetadata::AssertOnSequencedWorkerPool() {\n  DCHECK(!pool_ || pool_->IsRunningSequenceOnCurrentThread(sequence_token_));\n}\n",
        "target": 0
    },
    {
        "id": 1109,
        "func": "gpc_Gpre(Pixel *out, const Pixel *in, const Background *back)\n{\n (void)back;\n\n if (in->r == in->g && in->g == in->b)\n      out->r = out->g = out->b = ilineara_g22(in->g, in->a);\n\n else\n      out->r = out->g = out->b = u16d(in->a * 257 *\n YfromRGB(g22_to_d[in->r], g22_to_d[in->g], g22_to_d[in->b]));\n\n   out->a = 257 * in->a;\n}\n",
        "target": 0
    },
    {
        "id": 1110,
        "func": "void RenderViewTest::SetFocused(const blink::WebNode& node) {\n  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);\n  impl->focusedNodeChanged(blink::WebNode(), node);\n}\n",
        "target": 0
    },
    {
        "id": 1111,
        "func": "static int sysMapFD(int fd, MemMapping* pMap)\n{\n off_t start;\n size_t length;\n void* memPtr;\n\n    assert(pMap != NULL);\n\n if (getFileStartAndLength(fd, &start, &length) < 0)\n return -1;\n\n    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);\n if (memPtr == MAP_FAILED) {\n        LOGW(\"mmap(%d, R, PRIVATE, %d, %d) failed: %s\\n\", (int) length,\n            fd, (int) start, strerror(errno));\n return -1;\n }\n\n    pMap->addr = memPtr;\n\n     pMap->length = length;\n     pMap->range_count = 1;\n     pMap->ranges = malloc(sizeof(MappedRange));\n     pMap->ranges[0].addr = memPtr;\n     pMap->ranges[0].length = length;\n \n return 0;\n}\n",
        "target": 1
    },
    {
        "id": 1112,
        "func": "void ChromeDownloadManagerDelegate::CheckIfSuggestedPathExists(\n    int32 download_id,\n    const FilePath& unverified_path,\n    bool should_prompt,\n    bool is_forced_path,\n    content::DownloadDangerType danger_type,\n    const FilePath& default_path) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n\n  FilePath target_path(unverified_path);\n\n  file_util::CreateDirectory(default_path);\n\n  FilePath dir = target_path.DirName();\n  FilePath filename = target_path.BaseName();\n  if (!file_util::PathIsWritable(dir)) {\n    VLOG(1) << \"Unable to write to directory \\\"\" << dir.value() << \"\\\"\";\n    should_prompt = true;\n    PathService::Get(chrome::DIR_USER_DOCUMENTS, &dir);\n    target_path = dir.Append(filename);\n  }\n\n\n  bool should_uniquify =\n      (!is_forced_path &&\n       (danger_type == content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS ||\n        should_prompt));\n  bool should_overwrite =\n      (should_uniquify || is_forced_path);\n  bool should_create_marker = (should_uniquify && !should_prompt);\n\n  if (should_uniquify) {\n    // the in-progress rename.  Ditto for \"Forced\" downloads. None of the\n     int uniquifier =\n        download_util::GetUniquePathNumberWithCrDownload(target_path);\n\n    if (uniquifier > 0) {\n      target_path = target_path.InsertBeforeExtensionASCII(\n          StringPrintf(\" (%d)\", uniquifier));\n    } else if (uniquifier == -1) {\n      VLOG(1) << \"Unable to find a unique path for suggested path \\\"\"\n              << target_path.value() << \"\\\"\";\n      should_prompt = true;\n    }\n  }\n\n  if (should_create_marker)\n    file_util::WriteFile(download_util::GetCrDownloadPath(target_path), \"\", 0);\n\n  DownloadItem::TargetDisposition disposition;\n  if (should_prompt)\n    disposition = DownloadItem::TARGET_DISPOSITION_PROMPT;\n  else if (should_overwrite)\n    disposition = DownloadItem::TARGET_DISPOSITION_OVERWRITE;\n  else\n    disposition = DownloadItem::TARGET_DISPOSITION_UNIQUIFY;\n\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::Bind(&ChromeDownloadManagerDelegate::OnPathExistenceAvailable,\n                 this, download_id, target_path, disposition, danger_type));\n}\n",
        "target": 0
    },
    {
        "id": 1113,
        "func": "static void netlink_undo_bind(int group, long unsigned int groups,\n\t\t\t      struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tint undo;\n\n\tif (!nlk->netlink_unbind)\n\t\treturn;\n\n\tfor (undo = 0; undo < group; undo++)\n\t\tif (test_bit(undo, &groups))\n\t\t\tnlk->netlink_unbind(sock_net(sk), undo + 1);\n}",
        "target": 0
    },
    {
        "id": 1114,
        "func": "void RenderFrameHostImpl::SetRenderFrameCreated(bool created) {\n  if (created && delegate_)\n    CHECK(!delegate_->IsBeingDestroyed());\n\n  bool was_created = render_frame_created_;\n  render_frame_created_ = created;\n\n  if (delegate_ && (created != was_created)) {\n    if (created) {\n      SetUpMojoIfNeeded();\n      delegate_->RenderFrameCreated(this);\n    } else {\n      delegate_->RenderFrameDeleted(this);\n    }\n  }\n\n  if (created && render_widget_host_) {\n    mojom::WidgetPtr widget;\n    GetRemoteInterfaces()->GetInterface(&widget);\n    render_widget_host_->SetWidget(std::move(widget));\n\n    if (frame_input_handler_) {\n      mojom::WidgetInputHandlerAssociatedPtr widget_handler;\n      mojom::WidgetInputHandlerHostPtr host;\n      mojom::WidgetInputHandlerHostRequest host_request =\n          mojo::MakeRequest(&host);\n      frame_input_handler_->GetWidgetInputHandler(\n          mojo::MakeRequest(&widget_handler), std::move(host));\n      render_widget_host_->SetWidgetInputHandler(std::move(widget_handler),\n                                                 std::move(host_request));\n    }\n    viz::mojom::InputTargetClientPtr input_target_client;\n    remote_interfaces_->GetInterface(&input_target_client);\n    input_target_client_ = input_target_client.get();\n    render_widget_host_->SetInputTargetClient(std::move(input_target_client));\n    render_widget_host_->InitForFrame();\n  }\n\n  if (enabled_bindings_ && created) {\n    if (!frame_bindings_control_)\n      GetRemoteAssociatedInterfaces()->GetInterface(&frame_bindings_control_);\n    frame_bindings_control_->AllowBindings(enabled_bindings_);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1115,
        "func": "bool NuMediaExtractor::getTotalBitrate(int64_t *bitrate) const {\n if (mTotalBitrate >= 0) {\n *bitrate = mTotalBitrate;\n return true;\n\n     }\n \n     off64_t size;\n    if (mDurationUs >= 0 && mDataSource->getSize(&size) == OK) {\n         *bitrate = size * 8000000ll / mDurationUs;  // in bits/sec\n         return true;\n     }\n\n return false;\n}\n",
        "target": 1
    },
    {
        "id": 1116,
        "func": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\n\t\tASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tunsigned char *buf_in=NULL;\n\tint ret= -1,inl;\n \n        int mdnid, pknid;\n \n        EVP_MD_CTX_init(&ctx);\n \n        /* Convert signature OID into digest and public key OIDs */\n\t\t{\n\t\tif (!pkey->ameth || !pkey->ameth->item_verify)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\n\t\t\tgoto err;\n\t\t\t}\n\t\tret = pkey->ameth->item_verify(&ctx, it, asn, a,\n\t\t\t\t\t\t\tsignature, pkey);\n\t\t/* Return value of 2 means carry on, anything else means we\n\t\t * exit straight away: either a fatal error of the underlying\n\t\t * verification routine handles all verification.\n\t\t */\n\t\tif (ret != 2)\n\t\t\tgoto err;\n\t\tret = -1;\n\t\t}\n\telse\n\t\t{\n\t\tconst EVP_MD *type;\n\t\ttype=EVP_get_digestbynid(mdnid);\n\t\tif (type == NULL)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* Check public key OID matches public key type */\n\t\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tif (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\t\tret=0;\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t}\n\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\t\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tif (!EVP_DigestVerifyUpdate(&ctx,buf_in,inl))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\n\tif (EVP_DigestVerifyFinal(&ctx,signature->data,\n\t\t\t(size_t)signature->length) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\t/* we don't need to zero the 'ctx' because we just checked\n\t * public information */\n\t/* memset(&ctx,0,sizeof(ctx)); */\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}\n",
        "target": 1
    },
    {
        "id": 1117,
        "func": "void WebSocketJob::OnAuthRequired(\n    SocketStream* socket, AuthChallengeInfo* auth_info) {\n  if (delegate_)\n    delegate_->OnAuthRequired(socket, auth_info);\n}\n",
        "target": 0
    },
    {
        "id": 1118,
        "func": "network_end ()\n{\n#ifdef HAVE_GNUTLS\n    if (network_init_ok)\n    {\n        network_init_ok = 0;\n        gnutls_certificate_free_credentials (gnutls_xcred);\n        gnutls_global_deinit();\n    }\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 1119,
        "func": "  IsMacBinary( FT_Library  library,\n               FT_Stream   stream,\n               FT_Long     face_index,\n               FT_Face    *aface )\n  {\n    unsigned char  header[128];\n    FT_Error       error;\n    FT_Long        dlen, offset;\n\n\n    if ( NULL == stream )\n      return FT_Err_Invalid_Stream_Operation;\n\n    error = FT_Stream_Seek( stream, 0 );\n    if ( error )\n      goto Exit;\n\n    error = FT_Stream_Read( stream, (FT_Byte*)header, 128 );\n    if ( error )\n      goto Exit;\n\n    if (            header[ 0] !=  0 ||\n                    header[74] !=  0 ||\n                    header[82] !=  0 ||\n                    header[ 1] ==  0 ||\n                    header[ 1] >  33 ||\n                    header[63] !=  0 ||\n         header[2 + header[1]] !=  0 )\n      return FT_Err_Unknown_File_Format;\n\n    dlen = ( header[0x53] << 24 ) |\n           ( header[0x54] << 16 ) |\n           ( header[0x55] <<  8 ) |\n             header[0x56];\n#if 0\n    rlen = ( header[0x57] << 24 ) |\n           ( header[0x58] << 16 ) |\n           ( header[0x59] <<  8 ) |\n             header[0x5a];\n#endif /* 0 */\n    offset = 128 + ( ( dlen + 127 ) & ~127 );\n\n    return IsMacResource( library, stream, offset, face_index, aface );\n\n  Exit:\n    return error;\n  }\n",
        "target": 0
    },
    {
        "id": 1120,
        "func": "static int dcbnl_bcn_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t    u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tstruct nlattr *data[DCB_BCN_ATTR_MAX + 1];\n\tint i;\n\tint ret;\n\tu8 value_byte;\n\tu32 value_int;\n\n\tif (!tb[DCB_ATTR_BCN])\n\t\treturn -EINVAL;\n\n\tif (!netdev->dcbnl_ops->setbcncfg ||\n\t    !netdev->dcbnl_ops->setbcnrp)\n\t\treturn -EOPNOTSUPP;\n\n\tret = nla_parse_nested(data, DCB_BCN_ATTR_MAX,\n\t                       tb[DCB_ATTR_BCN],\n\t                       dcbnl_pfc_up_nest);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = DCB_BCN_ATTR_RP_0; i <= DCB_BCN_ATTR_RP_7; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue_byte = nla_get_u8(data[i]);\n\t\tnetdev->dcbnl_ops->setbcnrp(netdev,\n\t\t\tdata[i]->nla_type - DCB_BCN_ATTR_RP_0, value_byte);\n\t}\n\n\tfor (i = DCB_BCN_ATTR_BCNA_0; i <= DCB_BCN_ATTR_RI; i++) {\n\t\tif (data[i] == NULL)\n\t\t\tcontinue;\n\t\tvalue_int = nla_get_u32(data[i]);\n\t\tnetdev->dcbnl_ops->setbcncfg(netdev,\n\t                                     i, value_int);\n\t}\n\n\treturn nla_put_u8(skb, DCB_ATTR_BCN, 0);\n}",
        "target": 0
    },
    {
        "id": 1121,
        "func": "void MemoryInstrumentation::BindCoordinatorRequestOnConnectorThread(\n    mojom::CoordinatorRequest coordinator_request) {\n  connector_->BindInterface(service_name_, std::move(coordinator_request));\n}\n",
        "target": 0
    },
    {
        "id": 1122,
        "func": "uarb_print(uarb num, int digits, FILE *out)\n /* Prints 'num' as a decimal if it will fit in an unsigned long, else as a\n    * hexadecimal number.  Notice that the results vary for images over 4GByte\n    * in a system dependent way, and the hexadecimal form doesn't work very well\n    * in awk script input.\n    *\n    *\n    * TODO: write uarb_div10\n    */\n{\n if (digits * sizeof (udigit) > sizeof (unsigned long))\n      uarb_printx(num, digits, out);\n\n else\n {\n unsigned long n = 0;\n\n while (digits > 0)\n         n = (n << 16) + num[--digits];\n\n      fprintf(out, \"%lu\", n);\n }\n}\n",
        "target": 0
    },
    {
        "id": 1123,
        "func": "PerformanceNavigationTiming::PerformanceNavigationTiming(\n    LocalFrame* frame,\n     ResourceTimingInfo* info,\n     TimeTicks time_origin,\n     const WebVector<WebServerTimingInfo>& server_timing)\n    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : \"\",\n                                \"navigation\",\n                                time_origin,\n                                server_timing),\n       ContextClient(frame),\n       resource_timing_info_(info) {\n   DCHECK(frame);\n  DCHECK(info);\n}\n",
        "target": 1
    },
    {
        "id": 1124,
        "func": "BaseSessionService::BaseSessionService(SessionType type,\n                                       Profile* profile,\n                                       const FilePath& path)\n    : profile_(profile),\n      path_(path),\n      ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),\n      pending_reset_(false),\n      commands_since_reset_(0),\n      save_post_data_(false) {\n  if (profile) {\n    DCHECK(!profile->IsOffTheRecord());\n    const CommandLine* command_line = CommandLine::ForCurrentProcess();\n    save_post_data_ =\n        !command_line->HasSwitch(switches::kDisableRestoreSessionState);\n  }\n  backend_ = new SessionBackend(type,\n      profile_ ? profile_->GetPath() : path_);\n  DCHECK(backend_.get());\n\n  if (!RunningInProduction()) {\n    backend_->Init();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1125,
        "func": " void MarkingVisitor::ConservativelyMarkHeader(HeapObjectHeader* header) {\n  const GCInfo* gc_info = ThreadHeap::GcInfo(header->GcInfoIndex());\n   if (gc_info->HasVTable() && !VTableInitialized(header->Payload())) {\n    MarkHeaderNoTracing(header);\n#if DCHECK_IS_ON()\n    DCHECK(IsUninitializedMemory(header->Payload(), header->PayloadSize()));\n#endif\n  } else {\n    MarkHeader(header, gc_info->trace_);\n  }\n}\n",
        "target": 1
    },
    {
        "id": 1126,
        "func": "RenderProcessImpl::RenderProcessImpl()\n     : ALLOW_THIS_IN_INITIALIZER_LIST(shared_mem_cache_cleaner_(\n           FROM_HERE, base::TimeDelta::FromSeconds(5),\n           this, &RenderProcessImpl::ClearTransportDIBCache)),\n      transport_dib_next_sequence_number_(0),\n      enabled_bindings_(0) {\n   in_process_plugins_ = InProcessPlugins();\n   for (size_t i = 0; i < arraysize(shared_mem_cache_); ++i)\n     shared_mem_cache_[i] = NULL;\n\n#if defined(OS_WIN)\n  if (GetModuleHandle(L\"LPK.DLL\") == NULL) {\n    typedef BOOL (__stdcall *GdiInitializeLanguagePack)(int LoadedShapingDLLs);\n    GdiInitializeLanguagePack gdi_init_lpk =\n        reinterpret_cast<GdiInitializeLanguagePack>(GetProcAddress(\n            GetModuleHandle(L\"GDI32.DLL\"),\n            \"GdiInitializeLanguagePack\"));\n    DCHECK(gdi_init_lpk);\n    if (gdi_init_lpk) {\n      gdi_init_lpk(0);\n    }\n  }\n#endif\n\n  webkit_glue::SetJavaScriptFlags(\n      \"--debugger-auto-break\"\n      \" --prof --prof-lazy\");\n\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n  if (command_line.HasSwitch(switches::kJavaScriptFlags)) {\n    webkit_glue::SetJavaScriptFlags(\n        command_line.GetSwitchValueASCII(switches::kJavaScriptFlags));\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1127,
        "func": "  pcf_read_TOC( FT_Stream  stream,\n                PCF_Face   face )\n  {\n    FT_Error   error;\n    PCF_Toc    toc = &face->toc;\n    PCF_Table  tables;\n\n    FT_Memory  memory = FT_FACE( face )->memory;\n    FT_UInt    n;\n\n\n    if ( FT_STREAM_SEEK ( 0 )                          ||\n         FT_STREAM_READ_FIELDS ( pcf_toc_header, toc ) )\n      return FT_THROW( Cannot_Open_Resource );\n\n    if ( toc->version != PCF_FILE_VERSION                 ||\n         toc->count   >  FT_ARRAY_MAX( face->toc.tables ) ||\n         toc->count   == 0                                )\n      return FT_THROW( Invalid_File_Format );\n\n    if ( FT_NEW_ARRAY( face->toc.tables, toc->count ) )\n      return FT_THROW( Out_Of_Memory );\n\n    tables = face->toc.tables;\n    for ( n = 0; n < toc->count; n++ )\n    {\n      if ( FT_STREAM_READ_FIELDS( pcf_table_header, tables ) )\n        goto Exit;\n      tables++;\n    }\n\n    /* Sort tables and check for overlaps.  Because they are almost      */\n    /* always ordered already, an in-place bubble sort with simultaneous */\n    /* boundary checking seems appropriate.                              */\n    tables = face->toc.tables;\n\n    for ( n = 0; n < toc->count - 1; n++ )\n    {\n      FT_UInt  i, have_change;\n\n\n      have_change = 0;\n\n      for ( i = 0; i < toc->count - 1 - n; i++ )\n      {\n        PCF_TableRec  tmp;\n\n\n        if ( tables[i].offset > tables[i + 1].offset )\n        {\n          tmp           = tables[i];\n          tables[i]     = tables[i + 1];\n          tables[i + 1] = tmp;\n\n          have_change = 1;\n        }\n\n        if ( ( tables[i].size   > tables[i + 1].offset )                  ||\n             ( tables[i].offset > tables[i + 1].offset - tables[i].size ) )\n        {\n          error = FT_THROW( Invalid_Offset );\n          goto Exit;\n        }\n      }\n\n      if ( !have_change )\n         break;\n     }\n \n #ifdef FT_DEBUG_LEVEL_TRACE\n \n     {\n\n        FT_TRACE4(( \"  %d: type=%s, format=0x%X, \"\n                    \"size=%ld (0x%lX), offset=%ld (0x%lX)\\n\",\n                    i, name,\n                    tables[i].format,\n                    tables[i].size, tables[i].size,\n                    tables[i].offset, tables[i].offset ));\n      }\n    }\n",
        "target": 1
    },
    {
        "id": 1128,
        "func": "static void floppy_start(void)\n{\n\treschedule_timeout(current_reqD, \"floppy start\");\n\n\tscandrives();\n\tdebug_dcl(DP->flags, \"setting NEWCHANGE in floppy_start\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags);\n\tfloppy_ready();\n}",
        "target": 0
    },
    {
        "id": 1129,
        "func": "void GDataDirectoryService::MoveEntryToDirectory(\n    const FilePath& directory_path,\n    GDataEntry* entry,\n    const FileMoveCallback& callback) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(entry);\n\n  if (entry->parent())\n    entry->parent()->RemoveChild(entry);\n\n  GDataEntry* destination = FindEntryByPathSync(directory_path);\n  FilePath moved_file_path;\n  GDataFileError error = GDATA_FILE_ERROR_FAILED;\n  if (!destination) {\n    error = GDATA_FILE_ERROR_NOT_FOUND;\n  } else if (!destination->AsGDataDirectory()) {\n    error = GDATA_FILE_ERROR_NOT_A_DIRECTORY;\n  } else {\n    destination->AsGDataDirectory()->AddEntry(entry);\n    moved_file_path = entry->GetFilePath();\n    error = GDATA_FILE_OK;\n  }\n  if (!callback.is_null()) {\n    base::MessageLoopProxy::current()->PostTask(\n        FROM_HERE, base::Bind(callback, error, moved_file_path));\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1130,
        "func": "static void oz_urb_cancel_tasklet(unsigned long unused)\n{\n\tunsigned long irq_state;\n\tstruct urb *urb;\n\tstruct oz_urb_link *urbl, *n;\n\tstruct oz_hcd *ozhcd = oz_hcd_claim();\n\n\tif (ozhcd == NULL)\n\t\treturn;\n\tspin_lock_irqsave(&g_tasklet_lock, irq_state);\n\tlist_for_each_entry_safe(urbl, n, &ozhcd->urb_cancel_list, link) {\n\t\tlist_del_init(&urbl->link);\n\t\tspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\n\t\turb = urbl->urb;\n\t\tif (urb->unlinked)\n\t\t\toz_urb_cancel(urbl->port, urbl->ep_num, urb);\n\t\toz_free_urb_link(urbl);\n\t\tspin_lock_irqsave(&g_tasklet_lock, irq_state);\n\t}\n\tspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\n\toz_hcd_put(ozhcd);\n}",
        "target": 0
    },
    {
        "id": 1131,
        "func": "_dbus_header_cache_revalidate (DBusHeader *header)\n{\n  DBusTypeReader array;\n  DBusTypeReader reader;\n  int i;\n\n  i = 0;\n  while (i <= DBUS_HEADER_FIELD_LAST)\n    {\n      header->fields[i].value_pos = _DBUS_HEADER_FIELD_VALUE_NONEXISTENT;\n      ++i;\n    }\n\n  _dbus_type_reader_init (&reader,\n                          header->byte_order,\n                          &_dbus_header_signature_str,\n                          FIELDS_ARRAY_SIGNATURE_OFFSET,\n                          &header->data,\n                          FIELDS_ARRAY_LENGTH_OFFSET);\n\n  _dbus_type_reader_recurse (&reader, &array);\n\n  while (_dbus_type_reader_get_current_type (&array) != DBUS_TYPE_INVALID)\n    {\n      DBusTypeReader sub;\n      DBusTypeReader variant;\n      unsigned char field_code;\n\n      _dbus_type_reader_recurse (&array, &sub);\n\n      _dbus_assert (_dbus_type_reader_get_current_type (&sub) == DBUS_TYPE_BYTE);\n      _dbus_type_reader_read_basic (&sub, &field_code);\n\n      /* Unknown fields should be ignored */\n      if (field_code > DBUS_HEADER_FIELD_LAST)\n        goto next_field;\n\n      _dbus_type_reader_next (&sub);\n\n      _dbus_assert (_dbus_type_reader_get_current_type (&sub) == DBUS_TYPE_VARIANT);\n      _dbus_type_reader_recurse (&sub, &variant);\n\n      _dbus_header_cache_one (header, field_code, &variant);\n\n    next_field:\n      _dbus_type_reader_next (&array);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1132,
        "func": "static void __svc_rdma_free(struct work_struct *work)\n{\n\tstruct svcxprt_rdma *rdma =\n\t\tcontainer_of(work, struct svcxprt_rdma, sc_work);\n\tstruct svc_xprt *xprt = &rdma->sc_xprt;\n\n\tdprintk(\"svcrdma: %s(%p)\\n\", __func__, rdma);\n\n\tif (rdma->sc_qp && !IS_ERR(rdma->sc_qp))\n\t\tib_drain_qp(rdma->sc_qp);\n\n\t/* We should only be called from kref_put */\n\tif (kref_read(&xprt->xpt_ref) != 0)\n\t\tpr_err(\"svcrdma: sc_xprt still in use? (%d)\\n\",\n\t\t       kref_read(&xprt->xpt_ref));\n\n\t/*\n\t * Destroy queued, but not processed read completions. Note\n\t * that this cleanup has to be done before destroying the\n\t * cm_id because the device ptr is needed to unmap the dma in\n\t * svc_rdma_put_context.\n\t */\n\twhile (!list_empty(&rdma->sc_read_complete_q)) {\n\t\tstruct svc_rdma_op_ctxt *ctxt;\n\t\tctxt = list_first_entry(&rdma->sc_read_complete_q,\n\t\t\t\t\tstruct svc_rdma_op_ctxt, list);\n\t\tlist_del(&ctxt->list);\n\t\tsvc_rdma_put_context(ctxt, 1);\n\t}\n\n\t/* Destroy queued, but not processed recv completions */\n\twhile (!list_empty(&rdma->sc_rq_dto_q)) {\n\t\tstruct svc_rdma_op_ctxt *ctxt;\n\t\tctxt = list_first_entry(&rdma->sc_rq_dto_q,\n\t\t\t\t\tstruct svc_rdma_op_ctxt, list);\n\t\tlist_del(&ctxt->list);\n\t\tsvc_rdma_put_context(ctxt, 1);\n\t}\n\n\t/* Warn if we leaked a resource or under-referenced */\n\tif (rdma->sc_ctxt_used != 0)\n\t\tpr_err(\"svcrdma: ctxt still in use? (%d)\\n\",\n\t\t       rdma->sc_ctxt_used);\n\n\t/* Final put of backchannel client transport */\n\tif (xprt->xpt_bc_xprt) {\n\t\txprt_put(xprt->xpt_bc_xprt);\n\t\txprt->xpt_bc_xprt = NULL;\n \t}\n \n \trdma_dealloc_frmr_q(rdma);\n \tsvc_rdma_destroy_ctxts(rdma);\n\tsvc_rdma_destroy_maps(rdma);\n \n \t/* Destroy the QP if present (not a listener) */\n \tif (rdma->sc_qp && !IS_ERR(rdma->sc_qp))\n\t\tib_destroy_qp(rdma->sc_qp);\n\n\tif (rdma->sc_sq_cq && !IS_ERR(rdma->sc_sq_cq))\n\t\tib_free_cq(rdma->sc_sq_cq);\n\n\tif (rdma->sc_rq_cq && !IS_ERR(rdma->sc_rq_cq))\n\t\tib_free_cq(rdma->sc_rq_cq);\n\n\tif (rdma->sc_pd && !IS_ERR(rdma->sc_pd))\n\t\tib_dealloc_pd(rdma->sc_pd);\n\n\t/* Destroy the CM ID */\n\trdma_destroy_id(rdma->sc_cm_id);\n\n\tkfree(rdma);\n}\n",
        "target": 1
    },
    {
        "id": 1133,
        "func": "  explicit ProfilingClientBinder(content::BrowserChildProcessHost* host)\n      : ProfilingClientBinder() {\n    DCHECK(content::BrowserThread::CurrentlyOn(content::BrowserThread::IO));\n    content::BindInterface(host->GetHost(), std::move(request_));\n  }\n",
        "target": 0
    },
    {
        "id": 1134,
        "func": "\nvoid nl80211_send_beacon_hint_event(struct wiphy *wiphy,\n\t\t\t\t    struct ieee80211_channel *channel_before,\n\t\t\t\t    struct ieee80211_channel *channel_after)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *nl_freq;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_BEACON_HINT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\t/*\n\t * Since we are applying the beacon hint to a wiphy we know its\n\t * wiphy_idx is valid\n\t */\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy));\n\n\t/* Before */\n\tnl_freq = nla_nest_start(msg, NL80211_ATTR_FREQ_BEFORE);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\tif (nl80211_msg_put_channel(msg, channel_before))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\t/* After */\n\tnl_freq = nla_nest_start(msg, NL80211_ATTR_FREQ_AFTER);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\tif (nl80211_msg_put_channel(msg, channel_after))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(msg, 0, nl80211_regulatory_mcgrp.id,\n\t\t\t\tGFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);",
        "target": 0
    },
    {
        "id": 1135,
        "func": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = (x >> 56) ;\n\t\tpsf->header [psf->headindex++] = (x >> 48) ;\n\t\tpsf->header [psf->headindex++] = (x >> 40) ;\n\t\tpsf->header [psf->headindex++] = (x >> 32) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_8byte */",
        "target": 1
    },
    {
        "id": 1136,
        "func": "lookup_emem(netdissect_options *ndo, const u_char *ep)\n{\n\tregister u_int i, j, k;\n\tstruct enamemem *tp;\n\n\tk = (ep[0] << 8) | ep[1];\n\tj = (ep[2] << 8) | ep[3];\n\ti = (ep[4] << 8) | ep[5];\n\n\ttp = &enametable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k)\n\t\t\treturn tp;\n\t\telse\n\t\t\ttp = tp->e_nxt;\n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_emem: calloc\");\n\n\treturn tp;\n}",
        "target": 0
    },
    {
        "id": 1137,
        "func": "void blk_rq_unprep_clone(struct request *rq)\n{\n\tstruct bio *bio;\n\n\twhile ((bio = rq->bio) != NULL) {\n\t\trq->bio = bio->bi_next;\n\n\t\tbio_put(bio);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1138,
        "func": "static const String UniqueSimpleSelectorAmongSiblings(Element* element) {\n  DCHECK(element);\n\n  if (element->HasID() &&\n      !element->GetDocument().ContainsMultipleElementsWithId(\n          element->GetIdAttribute())) {\n    StringBuilder builder;\n    builder.Append(\"#\");\n    SerializeIdentifier(element->GetIdAttribute(), builder);\n    return builder.ToAtomicString();\n  }\n\n  if (IsOnlySiblingWithTagName(element)) {\n    StringBuilder builder;\n    SerializeIdentifier(element->TagQName().ToString(), builder);\n    return builder.ToAtomicString();\n  }\n\n  if (element->HasClass()) {\n    AtomicString unique_classname = UniqueClassnameAmongSiblings(element);\n    if (!unique_classname.IsEmpty()) {\n      return AtomicString(\".\") + unique_classname;\n    }\n  }\n\n  return \":nth-child(\" +\n         String::Number(NthIndexCache::NthChildIndex(*element)) + \")\";\n}\n",
        "target": 0
    },
    {
        "id": 1139,
        "func": "\nstatic void __netdev_adjacent_dev_unlink_neighbour(struct net_device *dev,\n\t\t\t\t\t\t   struct net_device *upper_dev)\n{\n\t__netdev_adjacent_dev_unlink(dev, upper_dev);\n\t__netdev_adjacent_dev_unlink_lists(dev, upper_dev,\n\t\t\t\t\t   &dev->adj_list.upper,\n\t\t\t\t\t   &upper_dev->adj_list.lower);",
        "target": 0
    },
    {
        "id": 1140,
        "func": "void RenderViewHostImpl::CreateNewWindow(\n    int route_id,\n    const ViewHostMsg_CreateWindow_Params& params,\n    SessionStorageNamespace* session_storage_namespace) {\n   ViewHostMsg_CreateWindow_Params validated_params(params);\n   ChildProcessSecurityPolicyImpl* policy =\n       ChildProcessSecurityPolicyImpl::GetInstance();\n \n   delegate_->CreateNewWindow(route_id, validated_params,\n                              session_storage_namespace);\n}\n",
        "target": 1
    },
    {
        "id": 1141,
        "func": " const extensions::Extension* GetExtension(Profile* profile,\n                                           const std::string& extension_id) {\n  const ExtensionService* service =\n      extensions::ExtensionSystem::Get(profile)->extension_service();\n   const extensions::Extension* extension =\n      service->GetInstalledExtension(extension_id);\n   return extension;\n }\n",
        "target": 1
    },
    {
        "id": 1142,
        "func": "static inline struct hlist_head *dev_name_hash(struct net *net, const char *name)\n{\n\tunsigned int hash = full_name_hash(net, name, strnlen(name, IFNAMSIZ));\n\n\treturn &net->dev_name_head[hash_32(hash, NETDEV_HASHBITS)];\n}",
        "target": 0
    },
    {
        "id": 1143,
        "func": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\tarch_pick_mmap_layout(current->mm);\n\n\t/* This is the point of no return */\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\tif (uid_eq(current_euid(), current_uid()) && gid_eq(current_egid(), current_gid()))\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\telse\n\t\tset_dumpable(current->mm, suid_dumpable);\n\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* install the new credentials */\n\tif (!uid_eq(bprm->cred->uid, current_euid()) ||\n\t    !gid_eq(bprm->cred->gid, current_egid())) {\n\t\tcurrent->pdeath_signal = 0;\n\t} else {\n\t\twould_dump(bprm, bprm->file);\n\t\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP)\n\t\t\tset_dumpable(current->mm, suid_dumpable);\n\t}\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n\tdo_close_on_exec(current->files);\n}",
        "target": 0
    },
    {
        "id": 1144,
        "func": "static void sctp_wfree(struct sk_buff *skb)\n{\n\tstruct sctp_chunk *chunk = skb_shinfo(skb)->destructor_arg;\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\n\tasoc->sndbuf_used -= SCTP_DATA_SNDSIZE(chunk) +\n\t\t\t\tsizeof(struct sk_buff) +\n\t\t\t\tsizeof(struct sctp_chunk);\n\n\tatomic_sub(sizeof(struct sctp_chunk), &sk->sk_wmem_alloc);\n\n\t/*\n\t * This undoes what is done via sctp_set_owner_w and sk_mem_charge\n\t */\n\tsk->sk_wmem_queued   -= skb->truesize;\n\tsk_mem_uncharge(sk, skb->truesize);\n\n\tsock_wfree(skb);\n\tsctp_wake_up_waiters(sk, asoc);\n\n\tsctp_association_put(asoc);\n}",
        "target": 0
    },
    {
        "id": 1145,
        "func": "void V8TestObject::VoidMethodByteStringOrNullOptionalUSVStringArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_voidMethodByteStringOrNullOptionalUSVStringArg\");\n\n  test_object_v8_internal::VoidMethodByteStringOrNullOptionalUSVStringArgMethod(info);\n}\n",
        "target": 0
    },
    {
        "id": 1146,
        "func": "DownloadManagerImpl::UniqueUrlDownloadHandlerPtr BeginResourceDownload(\n    std::unique_ptr<DownloadUrlParameters> params,\n    std::unique_ptr<ResourceRequest> request,\n    scoped_refptr<URLLoaderFactoryGetter> url_loader_factory_getter,\n    scoped_refptr<storage::FileSystemContext> file_system_context,\n    uint32_t download_id,\n    base::WeakPtr<DownloadManagerImpl> download_manager) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  if (params->render_process_host_id() >= 0 &&\n      !CanRequestURLFromRenderer(params->render_process_host_id(),\n                                 params->url())) {\n    CreateInterruptedDownload(params.get(),\n                              DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST,\n                              download_manager);\n    return nullptr;\n  }\n\n  ResourceRequestInfo::WebContentsGetter getter =\n      base::Bind(&GetWebContents, params->render_process_host_id(),\n                 params->render_frame_host_routing_id(), -1);\n  return DownloadManagerImpl::UniqueUrlDownloadHandlerPtr(\n      ResourceDownloader::BeginDownload(\n          download_manager, std::move(params), std::move(request),\n          url_loader_factory_getter, file_system_context, getter, download_id,\n          false)\n          .release());\n}\n",
        "target": 0
    },
    {
        "id": 1147,
        "func": "void RenderFrameHostManager::OnDidUpdateFrameOwnerProperties(\n    const FrameOwnerProperties& properties) {\n  if (!SiteIsolationPolicy::AreCrossProcessFramesPossible())\n    return;\n\n  CHECK(frame_tree_node_->parent());\n  SiteInstance* parent_instance =\n      frame_tree_node_->parent()->current_frame_host()->GetSiteInstance();\n\n  if (render_frame_host_->GetSiteInstance() != parent_instance) {\n    render_frame_host_->Send(new FrameMsg_SetFrameOwnerProperties(\n        render_frame_host_->GetRoutingID(), properties));\n  }\n\n  for (const auto& pair : proxy_hosts_) {\n    if (pair.second->GetSiteInstance() != parent_instance) {\n      pair.second->Send(new FrameMsg_SetFrameOwnerProperties(\n          pair.second->GetRoutingID(), properties));\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1148,
        "func": "void ExtensionViewGuest::DidInitialize(\n    const base::DictionaryValue& create_params) {\n  ExtensionsAPIClient::Get()->AttachWebContentsHelpers(web_contents());\n\n  ApplyAttributes(create_params);\n}\n",
        "target": 0
    },
    {
        "id": 1149,
        "func": "static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW))\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.pending = events->exception.injected;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\n\tvcpu->arch.interrupt.pending = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu,\n\t\t\t\t\t\t  events->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tkvm_x86_ops->set_nmi_mask(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR)\n\t\tvcpu->arch.sipi_vector = events->sipi_vector;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 1150,
        "func": "void AutomationMouseEventProcessor::InvokeCallback(\n    const automation::Error& error) {\n  if (has_point_)\n    completion_callback_.Run(point_);\n  else\n    error_callback_.Run(error);\n  delete this;\n}\n",
        "target": 0
    },
    {
        "id": 1151,
        "func": "static struct hci_conn *hidp_get_connection(struct hidp_session *session)\n{\n\tbdaddr_t *src = &bt_sk(session->ctrl_sock->sk)->src;\n\tbdaddr_t *dst = &bt_sk(session->ctrl_sock->sk)->dst;\n\tstruct hci_conn *conn;\n\tstruct hci_dev *hdev;\n\n\thdev = hci_get_route(dst, src);\n\tif (!hdev)\n\t\treturn NULL;\n\n\thci_dev_lock(hdev);\n\tconn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);\n\tif (conn)\n\t\thci_conn_hold_device(conn);\n\thci_dev_unlock(hdev);\n\n\thci_dev_put(hdev);\n\n\treturn conn;\n}",
        "target": 0
    },
    {
        "id": 1152,
        "func": "    virtual void runTest()\n    void runTest()\n     {\n        CCLayerTreeHostTest::runTest(true);\n     }\n",
        "target": 0
    },
    {
        "id": 1153,
        "func": "void XMPChunk::write(WEBP_MetaHandler* handler)\n{\n    XMP_IO* file = handler->parent->ioRef;\n    this->size = handler->xmpPacket.size();\n    XIO::WriteUns32_LE(file, this->tag);\n    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);\n    file->Write(handler->xmpPacket.data(), (XMP_Int32) this->size);\n    if (this->size & 1) {\n        const XMP_Uns8 zero = 0;\n        file->Write(&zero, 1);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1154,
        "func": "void ProfileSyncService::Initialize() {\n  InitSettings();\n\n  ClearStaleErrors();\n\n  sync_prefs_.AddSyncPrefObserver(this);\n\n  if (IsManaged()) {\n    DisableForUser();\n    return;\n  }\n\n  RegisterAuthNotifications();\n\n  if (!HasSyncSetupCompleted() || signin_->GetAuthenticatedUsername().empty()) {\n    DisableForUser();\n  }\n\n  TryStart();\n}\n",
        "target": 0
    },
    {
        "id": 1155,
        "func": "void PulseAudioMixer::DoGetVolume(GetVolumeCallback* callback,\n",
        "target": 0
    },
    {
        "id": 1156,
        "func": "void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tkfree(bprm);\n}",
        "target": 1
    },
    {
        "id": 1157,
        "func": "mkvparser::IMkvReader::~IMkvReader()\n{\n//// Disable MSVC warnings that suggest making code non-portable.\n }\n",
        "target": 1
    },
    {
        "id": 1158,
        "func": "Maybe<std::u16string> getFullyQualifiedClassName(const StringPiece16& package,\n const StringPiece16& className) {\n if (className.empty()) {\n return {};\n }\n\n if (util::isJavaClassName(className)) {\n return className.toString();\n }\n\n if (package.empty()) {\n return {};\n }\n\n if (className.data()[0] != u'.') {\n return {};\n }\n\n    std::u16string result(package.data(), package.size());\n    result.append(className.data(), className.size());\n if (!isJavaClassName(result)) {\n return {};\n }\n return result;\n}\n",
        "target": 0
    },
    {
        "id": 1159,
        "func": "openssl_init()\n{\n    static int did_init = 0;\n\n    if (!did_init) {\n        /* initialize openssl routines */\n        CRYPTO_malloc_init();\n        ERR_load_crypto_strings();\n        OpenSSL_add_all_algorithms();\n        did_init++;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1160,
        "func": "static pfunc check_literal(struct jv_parser* p) {\n  if (p->tokenpos == 0) return 0;\n\n  const char* pattern = 0;\n  int plen;\n  jv v;\n  switch (p->tokenbuf[0]) {\n  case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;\n  case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;\n  case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;\n  }\n  if (pattern) {\n    if (p->tokenpos != plen) return \"Invalid literal\";\n    for (int i=0; i<plen; i++)\n      if (p->tokenbuf[i] != pattern[i])\n        return \"Invalid literal\";\n    TRY(value(p, v));\n  } else {\n    // FIXME: better parser\n    p->tokenbuf[p->tokenpos] = 0; // FIXME: invalid\n    char* end = 0;\n    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);\n    if (end == 0 || *end != 0)\n      return \"Invalid numeric literal\";\n    TRY(value(p, jv_number(d)));\n  }\n  p->tokenpos = 0;\n  return 0;\n}",
        "target": 1
    },
    {
        "id": 1161,
        "func": "static int x86_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\t/*\n\t * Some chipsets need to unmask the LVTPC in a particular spot\n\t * inside the nmi handler.  As a result, the unmasking was pushed\n\t * into all the nmi handlers.\n\t *\n\t * This generic handler doesn't seem to have any issues where the\n\t * unmasking occurs so it was left at the top.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\t/*\n\t\t\t * Though we deactivated the counter some cpus\n\t\t\t * might still deliver spurious interrupts still\n\t\t\t * in flight. Catch them:\n\t\t\t */\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (val & (1ULL << (x86_pmu.cntval_bits - 1)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}",
        "target": 1
    },
    {
        "id": 1162,
        "func": "void show_state_filter(unsigned long state_filter)\n{\n\tstruct task_struct *g, *p;\n\n#if BITS_PER_LONG == 32\n\tprintk(KERN_INFO\n\t\t\"  task                PC stack   pid father\\n\");\n#else\n\tprintk(KERN_INFO\n\t\t\"  task                        PC stack   pid father\\n\");\n#endif\n\trcu_read_lock();\n\tdo_each_thread(g, p) {\n\t\t/*\n\t\t * reset the NMI-timeout, listing all files on a slow\n\t\t * console might take a lot of time:\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\tif (!state_filter || (p->state & state_filter))\n\t\t\tsched_show_task(p);\n\t} while_each_thread(g, p);\n\n\ttouch_all_softlockup_watchdogs();\n\n#ifdef CONFIG_SCHED_DEBUG\n\tsysrq_sched_debug_show();\n#endif\n\trcu_read_unlock();\n\t/*\n\t * Only show locks if all tasks are dumped:\n\t */\n\tif (!state_filter)\n\t\tdebug_show_all_locks();\n}",
        "target": 0
    },
    {
        "id": 1163,
        "func": "user_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int auth_attempt, struct sshauthopt **authoptsp)\n{\n\tu_int success, i;\n\tchar *file;\n\tstruct sshauthopt *opts = NULL;\n\tif (authoptsp != NULL)\n\t\t*authoptsp = NULL;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\tif (sshkey_is_cert(key) &&\n\t    auth_key_is_revoked(key->cert->signature_key))\n\t\treturn 0;\n\n\tif ((success = user_cert_trusted_ca(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tif ((success = user_key_command_allowed2(ssh, pw, key, &opts)) != 0)\n\t\tgoto out;\n\tsshauthopt_free(opts);\n\topts = NULL;\n\n\tfor (i = 0; !success && i < options.num_authkeys_files; i++) {\n\t\tif (strcasecmp(options.authorized_keys_files[i], \"none\") == 0)\n\t\t\tcontinue;\n\t\tfile = expand_authorized_keys(\n\t\t    options.authorized_keys_files[i], pw);\n\t\tsuccess = user_key_allowed2(ssh, pw, key, file, &opts);\n\t\tfree(file);\n\t}\n\n out:\n\tif (success && authoptsp != NULL) {\n\t\t*authoptsp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\treturn success;\n}",
        "target": 0
    },
    {
        "id": 1164,
        "func": "MagickExport MagickBooleanType IsImageObject(const Image *image)\n{\n  register const Image\n    *p;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n    if (p->signature != MagickCoreSignature)\n      return(MagickFalse);\n  return(MagickTrue);\n}",
        "target": 0
    },
    {
        "id": 1165,
        "func": "ext_t_0_wml_10(tvbuff_t *tvb, guint32 value, guint32 str_tbl)\n{\n\tchar *str = wmem_strdup_printf(wmem_packet_scope(), \"Variable substitution - escaped: '%s'\",\n\t\t\t\t    tvb_get_const_stringz(tvb, str_tbl + value, NULL));\n\treturn str;\n}\n",
        "target": 0
    },
    {
        "id": 1166,
        "func": "void Part::updateQuickExtractMenu(QAction *extractAction)\n{\n    if (!extractAction) {\n        return;\n    }\n\n    QMenu *menu = extractAction->menu();\n\n    if (!menu) {\n        menu = new QMenu();\n        extractAction->setMenu(menu);\n        connect(menu, &QMenu::triggered,\n                this, &Part::slotQuickExtractFiles);\n\n        QAction *extractTo = menu->addAction(i18n(\"Extract To...\"));\n        extractTo->setIcon(extractAction->icon());\n        extractTo->setToolTip(extractAction->toolTip());\n\n        if (extractAction == m_extractArchiveAction) {\n            connect(extractTo, &QAction::triggered,\n                    this, &Part::slotExtractArchive);\n        } else {\n            connect(extractTo, &QAction::triggered,\n                    this, &Part::slotShowExtractionDialog);\n        }\n\n        menu->addSeparator();\n\n        QAction *header = menu->addAction(i18n(\"Quick Extract To...\"));\n        header->setEnabled(false);\n        header->setIcon(QIcon::fromTheme(QStringLiteral(\"archive-extract\")));\n    }\n\n    while (menu->actions().size() > 3) {\n        menu->removeAction(menu->actions().last());\n    }\n\n    const KConfigGroup conf(KSharedConfig::openConfig(), \"ExtractDialog\");\n    const QStringList dirHistory = conf.readPathEntry(\"DirHistory\", QStringList());\n\n    for (int i = 0; i < qMin(10, dirHistory.size()); ++i) {\n        const QString dir = QUrl(dirHistory.value(i)).toString(QUrl::RemoveScheme | QUrl::NormalizePathSegments | QUrl::PreferLocalFile);\n        if (QDir(dir).exists()) {\n            QAction *newAction = menu->addAction(dir);\n            newAction->setData(dir);\n        }\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1167,
        "func": "user_change_shell_authorized_cb (Daemon                *daemon,\n                                 User                  *user,\n                                 GDBusMethodInvocation *context,\n                                 gpointer               data)\n\n{\n        gchar *shell = data;\n        g_autoptr(GError) error = NULL;\n        const gchar *argv[6];\n\n        if (g_strcmp0 (accounts_user_get_shell (ACCOUNTS_USER (user)), shell) != 0) {\n                sys_log (context,\n                         \"change shell of user '%s' (%d) to '%s'\",\n                         accounts_user_get_user_name (ACCOUNTS_USER (user)),\n                         accounts_user_get_uid (ACCOUNTS_USER (user)),\n                         shell);\n\n                argv[0] = \"/usr/sbin/usermod\";\n                argv[1] = \"-s\";\n                argv[2] = shell;\n                argv[3] = \"--\";\n                argv[4] = accounts_user_get_user_name (ACCOUNTS_USER (user));\n                argv[5] = NULL;\n\n                if (!spawn_with_login_uid (context, argv, &error)) {\n                        throw_error (context, ERROR_FAILED, \"running '%s' failed: %s\", argv[0], error->message);\n                        return;\n                }\n\n                accounts_user_set_shell (ACCOUNTS_USER (user), shell);\n        }\n\n        accounts_user_complete_set_shell (ACCOUNTS_USER (user), context);\n}\n",
        "target": 0
    },
    {
        "id": 1168,
        "func": "static int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\n{\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tstruct posix_acl_entry *pa, *pe;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tpa->e_perm = (mode & S_IRWXU) >> 6;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tgroup_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_MASK:\n\t\t\t\tmask_obj = pa;\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_OTHER:\n\t\t\t\tpa->e_perm = (mode & S_IRWXO);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm = (mode & S_IRWXG) >> 3;\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1169,
        "func": "static void __sk_destruct(struct rcu_head *head)\n{\n\tstruct sock *sk = container_of(head, struct sock, sk_rcu);\n\tstruct sk_filter *filter;\n\n\tif (sk->sk_destruct)\n\t\tsk->sk_destruct(sk);\n\n\tfilter = rcu_dereference_check(sk->sk_filter,\n\t\t\t\t       atomic_read(&sk->sk_wmem_alloc) == 0);\n\tif (filter) {\n\t\tsk_filter_uncharge(sk, filter);\n\t\tRCU_INIT_POINTER(sk->sk_filter, NULL);\n\t}\n\tif (rcu_access_pointer(sk->sk_reuseport_cb))\n\t\treuseport_detach_sock(sk);\n\n\tsock_disable_timestamp(sk, SK_FLAGS_TIMESTAMP);\n\n\tif (atomic_read(&sk->sk_omem_alloc))\n\t\tpr_debug(\"%s: optmem leakage (%d bytes) detected\\n\",\n\t\t\t __func__, atomic_read(&sk->sk_omem_alloc));\n\n\tif (sk->sk_peer_cred)\n\t\tput_cred(sk->sk_peer_cred);\n\tput_pid(sk->sk_peer_pid);\n\tif (likely(sk->sk_net_refcnt))\n\t\tput_net(sock_net(sk));\n\tsk_prot_free(sk->sk_prot_creator, sk);\n}",
        "target": 0
    },
    {
        "id": 1170,
        "func": "smp_fetch_capture_header_req(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                 const struct arg *args, struct sample *smp, const char *kw)\n{\n\tstruct proxy *fe = l4->fe;\n\tstruct http_txn *txn = l7;\n\tint idx;\n\n\tif (!args || args->type != ARGT_UINT)\n\t\treturn 0;\n\n\tidx = args->data.uint;\n\n\tif (idx > (fe->nb_req_cap - 1) || txn->req.cap == NULL || txn->req.cap[idx] == NULL)\n\t\treturn 0;\n\n\tsmp->type = SMP_T_STR;\n\tsmp->flags |= SMP_F_CONST;\n\tsmp->data.str.str = txn->req.cap[idx];\n\tsmp->data.str.len = strlen(txn->req.cap[idx]);\n\n\treturn 1;\n}\n",
        "target": 0
    },
    {
        "id": 1171,
        "func": "static void nfs4_recovery_handle_error(struct nfs_client *clp, int error)\n{\n\tswitch (error) {\n\t\tcase -NFS4ERR_CB_PATH_DOWN:\n\t\t\tnfs_handle_cb_pathdown(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_LEASE_MOVED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_reboot(clp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tset_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);\n\t\t\tnfs4_state_start_reclaim_nograce(clp);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1172,
        "func": "config_t *config_new_clone(const config_t *src) {\n  assert(src != NULL);\n\n config_t *ret = config_new_empty();\n\n  assert(ret != NULL);\n\n for (const list_node_t *node = list_begin(src->sections);\n       node != list_end(src->sections);\n       node = list_next(node)) {\n section_t *sec = list_node(node);\n\n for (const list_node_t *node_entry = list_begin(sec->entries);\n         node_entry != list_end(sec->entries);\n         node_entry = list_next(node_entry)) {\n entry_t *entry = list_node(node_entry);\n\n      config_set_string(ret, sec->name, entry->key, entry->value);\n }\n }\n\n return ret;\n}\n",
        "target": 0
    },
    {
        "id": 1173,
        "func": "int mgr_force_sweep(p_fm_config_conx_hdlt hdl, fm_mgr_type_t mgr, int argc, char *argv[]) {\n\tfm_mgr_config_errno_t\tres;\n\tfm_msg_ret_code_t\t\tret_code;\n\n\tif((res = fm_mgr_simple_query(hdl, FM_ACT_GET, FM_DT_FORCE_SWEEP, mgr, 0, NULL, &ret_code)) != FM_CONF_OK)\n\t{\n\t\tfprintf(stderr, \"mgr_force_sweep: Failed to retrieve data: \\n\"\n\t\t       \"\\tError:(%d) %s \\n\\tRet code:(%d) %s\\n\",\n\t\t       res, fm_mgr_get_error_str(res),ret_code,\n\t\t       fm_mgr_get_resp_error_str(ret_code));\n\t} else {\n\t\tprintf(\"mgr_force_sweep: Successfully sent Force Sweep control to local mgr instance\\n\");\n    }\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 1174,
        "func": "void JankTimeBomb::Alarm(base::PlatformThreadId thread_id) {\n  DCHECK(WatchDogThread::CurrentlyOnWatchDogThread());\n  sampling_profiler_.reset(new base::StackSamplingProfiler(\n      thread_id,\n      GetJankTimeBombSamplingParams(),\n      metrics::CallStackProfileMetricsProvider::GetProfilerCallback(\n          metrics::CallStackProfileMetricsProvider::Params(\n              metrics::CallStackProfileMetricsProvider::JANKY_TASK,\n              true))));\n  sampling_profiler_->Start();\n}\n",
        "target": 0
    },
    {
        "id": 1175,
        "func": "etheraddr_string(netdissect_options *ndo, register const u_char *ep)\n{\n\tregister int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tint oui;\n\tchar buf[BUFSIZE];\n\n\ttp = lookup_emem(ndo, ep);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n#ifdef USE_ETHER_NTOHOST\n\tif (!ndo->ndo_nflag) {\n\t\tchar buf2[BUFSIZE];\n\n\t\tif (ether_ntohost(buf2, (const struct ether_addr *)ep) == 0) {\n\t\t\ttp->e_name = strdup(buf2);\n\t\t\tif (tp->e_name == NULL)\n\t\t\t\t(*ndo->ndo_error)(ndo,\n\t\t\t\t\t\t  \"etheraddr_string: strdup(buf2)\");\n\t\t\treturn (tp->e_name);\n\t\t}\n\t}\n#endif\n\tcp = buf;\n\toui = EXTRACT_24BITS(ep);\n\t*cp++ = hex[*ep >> 4 ];\n\t*cp++ = hex[*ep++ & 0xf];\n\tfor (i = 5; --i >= 0;) {\n\t\t*cp++ = ':';\n\t\t*cp++ = hex[*ep >> 4 ];\n\t\t*cp++ = hex[*ep++ & 0xf];\n\t}\n\n\tif (!ndo->ndo_nflag) {\n\t\tsnprintf(cp, BUFSIZE - (2 + 5*3), \" (oui %s)\",\n\t\t    tok2str(oui_values, \"Unknown\", oui));\n\t} else\n\t\t*cp = '\\0';\n\ttp->e_name = strdup(buf);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"etheraddr_string: strdup(buf)\");\n\treturn (tp->e_name);\n}",
        "target": 0
    },
    {
        "id": 1176,
        "func": "  content::MockDownloadItem& GetMockDownloadItem(int id) {\n    content::MockDownloadItem* itemp = mock_download_item_factory_->GetItem(id);\n\n    DCHECK(itemp);\n    return *itemp;\n  }\n",
        "target": 0
    },
    {
        "id": 1177,
        "func": "hcom_client_destroy_stream\n(\n\tIN\tp_hsm_com_stream_hdl_t\tp_stream_hdl,\n\tIN\tp_hsm_com_client_hdl_t\tp_client_hdl\n)\n{\n\treturn HSM_COM_OK;\n}\n",
        "target": 0
    },
    {
        "id": 1178,
        "func": "const AtomicString& Element::shadowPseudoId() const\n{\n    return pseudo();\n}\n",
        "target": 0
    },
    {
        "id": 1179,
        "func": "void GDataWapiFeedProcessor::AddEntryToDirectoryAndCollectChangedDirectories(\n    GDataEntry* entry,\n    GDataDirectory* directory,\n    GDataDirectoryService* orphaned_dir_service,\n    std::set<FilePath>* changed_dirs) {\n  directory->AddEntry(entry);\n  if (entry->AsGDataDirectory() && directory != orphaned_dir_service->root())\n    changed_dirs->insert(entry->GetFilePath());\n}\n",
        "target": 0
    },
    {
        "id": 1180,
        "func": "bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n  if (url.ProtocolIsData()) {\n    return false;\n  }\n\n  Document* document = GetDocument();\n  if (document && document->GetSecurityOrigin()) {\n    return !document->GetSecurityOrigin()->CanRequest(url);\n  }\n\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1181,
        "func": "    AsOmniboxEventProviderType() const {\n  if (name_ == \"HistoryURL\")\n    return metrics::OmniboxEventProto::HISTORY_URL;\n  if (name_ == \"HistoryContents\")\n    return metrics::OmniboxEventProto::HISTORY_CONTENTS;\n  if (name_ == \"HistoryQuickProvider\")\n    return metrics::OmniboxEventProto::HISTORY_QUICK;\n  if (name_ == \"Search\")\n    return metrics::OmniboxEventProto::SEARCH;\n  if (name_ == \"Keyword\")\n    return metrics::OmniboxEventProto::KEYWORD;\n  if (name_ == \"Builtin\")\n    return metrics::OmniboxEventProto::BUILTIN;\n  if (name_ == \"ShortcutsProvider\")\n    return metrics::OmniboxEventProto::SHORTCUTS;\n  if (name_ == \"ExtensionApps\")\n    return metrics::OmniboxEventProto::EXTENSION_APPS;\n  NOTREACHED();\n  return metrics::OmniboxEventProto::UNKNOWN_PROVIDER;\n}\n",
        "target": 1
    },
    {
        "id": 1182,
        "func": "static void setup_report_key(struct packet_command *cgc, unsigned agid, unsigned type)\n{\n\tcgc->cmd[0] = GPCMD_REPORT_KEY;\n\tcgc->cmd[10] = type | (agid << 6);\n\tswitch (type) {\n\t\tcase 0: case 8: case 5: {\n\t\t\tcgc->buflen = 8;\n\t\t\tbreak;\n\t\t}\n\t\tcase 1: {\n\t\t\tcgc->buflen = 16;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: case 4: {\n\t\t\tcgc->buflen = 12;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcgc->cmd[9] = cgc->buflen;\n\tcgc->data_direction = CGC_DATA_READ;\n}",
        "target": 0
    },
    {
        "id": 1183,
        "func": "void zend_shared_alloc_save_state(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ZSMMG(shared_segments_count); i++) {\n\t\tZSMMG(shared_memory_state).positions[i] = ZSMMG(shared_segments)[i]->pos;\n\t}\n\tZSMMG(shared_memory_state).shared_free = ZSMMG(shared_free);\n}\n",
        "target": 0
    },
    {
        "id": 1184,
        "func": "create_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal((void *)handle,\n                                          &arg->rec, arg->mask,\n                                          arg->passwd);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
        "target": 1
    },
    {
        "id": 1185,
        "func": "void HistoryQuickProvider::Start(const AutocompleteInput& input,\n                                 bool minimal_changes) {\n  matches_.clear();\n  if (disabled_)\n    return;\n\n  if ((input.type() == AutocompleteInput::INVALID) ||\n      (input.type() == AutocompleteInput::FORCED_QUERY) ||\n      (input.matches_requested() == AutocompleteInput::BEST_MATCH &&\n       input.prevent_inline_autocomplete()))\n    return;\n\n  autocomplete_input_ = input;\n\n  if (GetIndex()) {\n    base::TimeTicks start_time = base::TimeTicks::Now();\n    DoAutocomplete();\n    if (input.text().length() < 6) {\n      base::TimeTicks end_time = base::TimeTicks::Now();\n      std::string name = \"HistoryQuickProvider.QueryIndexTime.\" +\n          base::IntToString(input.text().length());\n      base::Histogram* counter = base::Histogram::FactoryGet(\n          name, 1, 1000, 50, base::Histogram::kUmaTargetedHistogramFlag);\n      counter->Add(static_cast<int>((end_time - start_time).InMilliseconds()));\n    }\n    UpdateStarredStateOfMatches();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1186,
        "func": "long Chapters::Display::Parse(IMkvReader* pReader, long long pos,\n long long size) {\n const long long stop = pos + size;\n\n while (pos < stop) {\n long long id, size;\n\n long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) // error\n return status;\n\n if (size == 0) // weird\n continue;\n\n if (id == 0x05) { // ChapterString ID\n      status = UnserializeString(pReader, pos, size, m_string);\n\n if (status)\n return status;\n } else if (id == 0x037C) { // ChapterLanguage ID\n      status = UnserializeString(pReader, pos, size, m_language);\n\n if (status)\n return status;\n } else if (id == 0x037E) { // ChapterCountry ID\n      status = UnserializeString(pReader, pos, size, m_country);\n\n if (status)\n return status;\n\n     }\n \n     pos += size;\n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n   return 0;\n }\n",
        "target": 1
    },
    {
        "id": 1187,
        "func": "static enum virtio_device_endian virtio_default_endian(void)\n{\n    if (target_words_bigendian()) {\n        return VIRTIO_DEVICE_ENDIAN_BIG;\n    } else {\n        return VIRTIO_DEVICE_ENDIAN_LITTLE;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1188,
        "func": "static void reset_bcr(struct kvm_vcpu *vcpu,\n\t\t      const struct sys_reg_desc *rd)\n{\n\tvcpu->arch.vcpu_debug_state.dbg_bcr[rd->reg] = rd->val;\n}",
        "target": 0
    },
    {
        "id": 1189,
        "func": "static void activityLoggedInIsolatedWorldsAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    V8PerContextData* contextData = V8PerContextData::from(info.GetIsolate()->GetCurrentContext());\n    if (contextData && contextData->activityLogger()) {\n        v8::Handle<v8::Value> loggerArg[] = { jsValue };\n        contextData->activityLogger()->log(\"TestObject.activityLoggedInIsolatedWorldsAttr\", 1, &loggerArg[0], \"Setter\");\n    }\n    TestObjectV8Internal::activityLoggedInIsolatedWorldsAttrAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 1190,
        "func": "    void kickInvisibleSpellcheck()\n    {\n        kick(1, 8, WebTextDecorationTypeInvisibleSpellcheck);\n    }\n",
        "target": 0
    },
    {
        "id": 1191,
        "func": "static void dct_unquantize_mpeg1_intra_c(MpegEncContext *s,\n                                   int16_t *block, int n, int qscale)\n{\n    int i, level, nCoeffs;\n    const uint16_t *quant_matrix;\n\n    nCoeffs= s->block_last_index[n];\n\n    block[0] *= n < 4 ? s->y_dc_scale : s->c_dc_scale;\n    /* XXX: only MPEG-1 */\n    quant_matrix = s->intra_matrix;\n    for(i=1;i<=nCoeffs;i++) {\n        int j= s->intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            if (level < 0) {\n                level = -level;\n                level = (int)(level * qscale * quant_matrix[j]) >> 3;\n                level = (level - 1) | 1;\n                level = -level;\n            } else {\n                level = (int)(level * qscale * quant_matrix[j]) >> 3;\n                level = (level - 1) | 1;\n            }\n            block[j] = level;\n        }\n    }\n}",
        "target": 0
    },
    {
        "id": 1192,
        "func": "static void *packet_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\treturn seq_hlist_next_rcu(v, &net->packet.sklist, pos);\n}",
        "target": 0
    },
    {
        "id": 1193,
        "func": " void GCInfoTable::Resize() {\n  const size_t new_limit = (limit_) ? 2 * limit_ : ComputeInitialTableLimit();\n  const size_t old_committed_size = limit_ * kEntrySize;\n  const size_t new_committed_size = new_limit * kEntrySize;\n  CHECK(table_);\n  CHECK_EQ(0u, new_committed_size % base::kPageAllocationGranularity);\n  CHECK_GE(MaxTableSize(), limit_ * kEntrySize);\n\n  // Recommitting and zapping assumes byte-addressable storage.\n  uint8_t* const current_table_end =\n      reinterpret_cast<uint8_t*>(table_) + old_committed_size;\n  const size_t table_size_delta = new_committed_size - old_committed_size;\n\n  // Commit the new size and allow read/write.\n  // TODO(ajwong): SetSystemPagesAccess should be part of RecommitSystemPages to\n  // avoid having two calls here.\n  bool ok = base::SetSystemPagesAccess(current_table_end, table_size_delta,\n                                       base::PageReadWrite);\n  CHECK(ok);\n  ok = base::RecommitSystemPages(current_table_end, table_size_delta,\n                                 base::PageReadWrite);\n  CHECK(ok);\n\n  // Zap unused values.,\n  memset(current_table_end, kGcInfoZapValue, table_size_delta);\n\n  limit_ = new_limit;\n }\n",
        "target": 0
    },
    {
        "id": 1194,
        "func": " static void CopyTransportDIBHandleForMessage(\n     const TransportDIB::Handle& handle_in,\n    TransportDIB::Handle* handle_out) {\n #if defined(OS_MACOSX)\n  if ((handle_out->fd = HANDLE_EINTR(dup(handle_in.fd))) < 0) {\n    PLOG(ERROR) << \"dup()\";\n     return;\n   }\n   handle_out->auto_close = true;\n #else\n   *handle_out = handle_in;\n#endif\n}\n",
        "target": 1
    },
    {
        "id": 1195,
        "func": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* \"unseal\" the token */\n\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n\n    /* that's it.  delete the context */\n\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n}",
        "target": 1
    },
    {
        "id": 1196,
        "func": "xfs_eofblocks_worker(\n\tstruct work_struct *work)\n{\n\tstruct xfs_mount *mp = container_of(to_delayed_work(work),\n\t\t\t\tstruct xfs_mount, m_eofblocks_work);\n\txfs_icache_free_eofblocks(mp, NULL);\n\txfs_queue_eofblocks(mp);\n}",
        "target": 0
    },
    {
        "id": 1197,
        "func": "  bool PaintWithoutCommit(GraphicsLayer& layer, const IntRect* interest_rect) {\n    return layer.PaintWithoutCommit(interest_rect);\n  }\n",
        "target": 0
    },
    {
        "id": 1198,
        "func": "WebBluetoothServiceImpl* RenderFrameHostImpl::CreateWebBluetoothService(\n    blink::mojom::WebBluetoothServiceRequest request) {\n  auto web_bluetooth_service =\n      std::make_unique<WebBluetoothServiceImpl>(this, std::move(request));\n  web_bluetooth_service->SetClientConnectionErrorHandler(\n      base::BindOnce(&RenderFrameHostImpl::DeleteWebBluetoothService,\n                     base::Unretained(this), web_bluetooth_service.get()));\n  web_bluetooth_services_.push_back(std::move(web_bluetooth_service));\n  return web_bluetooth_services_.back().get();\n}\n",
        "target": 0
    },
    {
        "id": 1199,
        "func": "RenderWidgetHostImpl* WebContentsImpl::GetFocusedRenderWidgetHost(\n    RenderWidgetHostImpl* receiving_widget) {\n  if (!SiteIsolationPolicy::AreCrossProcessFramesPossible())\n    return receiving_widget;\n\n  if (receiving_widget != GetMainFrame()->GetRenderWidgetHost())\n    return receiving_widget;\n\n  WebContentsImpl* focused_contents = GetFocusedWebContents();\n\n   if (focused_contents->ShowingInterstitialPage()) {\n     return static_cast<RenderFrameHostImpl*>(\n               focused_contents->GetRenderManager()\n                   ->interstitial_page()\n                   ->GetMainFrame())\n         ->GetRenderWidgetHost();\n   }\n \n  FrameTreeNode* focused_frame = nullptr;\n  if (focused_contents->browser_plugin_guest_ &&\n      !GuestMode::IsCrossProcessFrameGuest(focused_contents)) {\n    focused_frame = frame_tree_.GetFocusedFrame();\n  } else {\n    focused_frame = GetFocusedWebContents()->frame_tree_.GetFocusedFrame();\n  }\n\n  if (!focused_frame)\n    return receiving_widget;\n\n  RenderWidgetHostView* view = focused_frame->current_frame_host()->GetView();\n  if (!view)\n    return nullptr;\n\n  return RenderWidgetHostImpl::From(view->GetRenderWidgetHost());\n}\n",
        "target": 1
    },
    {
        "id": 1200,
        "func": "bool TabletModeWindowManager::IsContainerWindow(aura::Window* window) {\n  return base::Contains(observed_container_windows_, window);\n}\n",
        "target": 0
    },
    {
        "id": 1201,
        "func": "void HTMLInputElement::setIndeterminate(bool new_value) {\n  if (indeterminate() == new_value)\n    return;\n\n  is_indeterminate_ = new_value;\n\n  PseudoStateChanged(CSSSelector::kPseudoIndeterminate);\n\n  if (LayoutObject* o = GetLayoutObject())\n    o->InvalidateIfControlStateChanged(kCheckedControlState);\n}\n",
        "target": 0
    },
    {
        "id": 1202,
        "func": "svc_pool_map_init_percpu(struct svc_pool_map *m)\n{\n\tunsigned int maxpools = nr_cpu_ids;\n\tunsigned int pidx = 0;\n\tunsigned int cpu;\n\tint err;\n\n\terr = svc_pool_map_alloc_arrays(m, maxpools);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_online_cpu(cpu) {\n\t\tBUG_ON(pidx >= maxpools);\n\t\tm->to_pool[cpu] = pidx;\n\t\tm->pool_to[pidx] = cpu;\n\t\tpidx++;\n\t}\n\t/* cpus brought online later all get mapped to pool0, sorry */\n\n\treturn pidx;\n};\n",
        "target": 0
    },
    {
        "id": 1203,
        "func": "string16 AutocompleteInput::FormattedStringWithEquivalentMeaning(\n    const GURL& url,\n    const string16& formatted_url) {\n  if (!net::CanStripTrailingSlash(url))\n    return formatted_url;\n  const string16 url_with_path(formatted_url + char16('/'));\n  return (AutocompleteInput::Parse(formatted_url, string16(), NULL, NULL,\n                                   NULL) ==\n          AutocompleteInput::Parse(url_with_path, string16(), NULL, NULL,\n                                   NULL)) ?\n      formatted_url : url_with_path;\n}\n",
        "target": 0
    },
    {
        "id": 1204,
        "func": "ServiceWorkerContainer* ServiceWorkerContainer::create(ExecutionContext* executionContext)\n{\n    return new ServiceWorkerContainer(executionContext);\n}\n",
        "target": 0
    },
    {
        "id": 1205,
        "func": "dissect_iur_dsch_channel_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                              int offset, struct fp_info *p_fp_info)\n{\n    gboolean is_control_frame;\n\n    /* Header CRC */\n    proto_tree_add_item(tree, hf_fp_header_crc, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    /* Frame Type */\n    is_control_frame = tvb_get_guint8(tvb, offset) & 0x01;\n    proto_tree_add_item(tree, hf_fp_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n\n    col_append_str(pinfo->cinfo, COL_INFO, is_control_frame ? \" [Control] \" : \" [Data] \");\n\n    if (is_control_frame) {\n        dissect_common_control(tvb, pinfo, tree, offset, p_fp_info);\n    }\n    else {\n        /* TODO: DATA */\n    }\n}",
        "target": 0
    },
    {
        "id": 1206,
        "func": "int32_t AXTree::GetNextNegativeInternalNodeId() {\n  int32_t return_value = next_negative_internal_node_id_;\n  next_negative_internal_node_id_--;\n  if (next_negative_internal_node_id_ > 0)\n    next_negative_internal_node_id_ = -1;\n  return return_value;\n}\n",
        "target": 0
    },
    {
        "id": 1207,
        "func": "void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req)\n{\n\t__set_bit(FR_ISREPLY, &req->flags);\n\tif (!test_bit(FR_WAITING, &req->flags)) {\n\t\t__set_bit(FR_WAITING, &req->flags);\n\t\tatomic_inc(&fc->num_waiting);\n\t}\n\t__fuse_request_send(fc, req);\n}\n",
        "target": 0
    },
    {
        "id": 1208,
        "func": "spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\n\t*minor_status = 0;\n\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\n\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n\t\t\t\t      output_token);\n\t(void) release_spnego_ctx(ctx);\n\n\treturn (ret);\n}",
        "target": 0
    },
    {
        "id": 1209,
        "func": "DEFUN(tabA, TAB_LINK, \"Follow current hyperlink in a new tab\")\n{\n    followTab(prec_num ? numTab(PREC_NUM) : NULL);\n}",
        "target": 0
    },
    {
        "id": 1210,
        "func": "xsltExtensionInstructionResultRegister(xsltTransformContextPtr ctxt,\n\t\t\t\t       xmlXPathObjectPtr obj)\n{\n    int i;\n    xmlNodePtr cur;\n    xmlDocPtr doc;\n\n    if ((ctxt == NULL) || (obj == NULL))\n\treturn(-1);\n\n    /*\n    * OPTIMIZE TODO: If no local variables/params and no local tree\n    * fragments were created, then we don't need to analyse the XPath\n    * objects for tree fragments.\n    */\n\n    if ((obj->type != XPATH_NODESET) && (obj->type != XPATH_XSLT_TREE))\n\treturn(0);\n    if ((obj->nodesetval == NULL) || (obj->nodesetval->nodeNr == 0))\n\treturn(0);\n\n    for (i = 0; i < obj->nodesetval->nodeNr; i++) {\n\tcur = obj->nodesetval->nodeTab[i];\n\tif (cur->type == XML_NAMESPACE_DECL) {\n\t    /*\n\t    * The XPath module sets the owner element of a ns-node on\n\t    * the ns->next field.\n\t    */\n\t    if ((((xmlNsPtr) cur)->next != NULL) &&\n\t\t(((xmlNsPtr) cur)->next->type == XML_ELEMENT_NODE))\n\t    {\n\t\tcur = (xmlNodePtr) ((xmlNsPtr) cur)->next;\n\t\tdoc = cur->doc;\n\t    } else {\n\t\txsltTransformError(ctxt, NULL, ctxt->inst,\n\t\t    \"Internal error in \"\n\t\t    \"xsltExtensionInstructionResultRegister(): \"\n\t\t    \"Cannot retrieve the doc of a namespace node.\\n\");\n\t\tgoto error;\n\t    }\n\t} else {\n\t    doc = cur->doc;\n\t}\n\tif (doc == NULL) {\n\t    xsltTransformError(ctxt, NULL, ctxt->inst,\n\t\t\"Internal error in \"\n\t\t\"xsltExtensionInstructionResultRegister(): \"\n\t\t\"Cannot retrieve the doc of a node.\\n\");\n\t    goto error;\n\t}\n\tif (doc->name && (doc->name[0] == ' ')) {\n\t    /*\n\t    * This is a result tree fragment.\n\t    * We'll use the @psvi field for reference counting.\n\t    * TODO: How do we know if this is a value of a\n\t    *  global variable or a doc acquired via the\n\t    *  document() function?\n\t    */\n\t    doc->psvi = (void *) ((long) 1);\n\t}\n    }\n\n    return(0);\nerror:\n    return(-1);\n}\n",
        "target": 0
    },
    {
        "id": 1211,
        "func": "static void arcmsr_hbaC_message_isr(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_C __iomem *reg  = acb->pmuC;\n\t/*clear interrupt and message state*/\n\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);\n\tschedule_work(&acb->arcmsr_do_message_isr_bh);\n}",
        "target": 0
    },
    {
        "id": 1212,
        "func": "void dump_backtrace_entry(unsigned long where, unsigned long from, unsigned long frame)\n{\n#ifdef CONFIG_KALLSYMS\n\tprintk(\"[<%08lx>] (%pS) from [<%08lx>] (%pS)\\n\", where, (void *)where, from, (void *)from);\n#else\n\tprintk(\"Function entered at [<%08lx>] from [<%08lx>]\\n\", where, from);\n#endif\n\n\tif (in_exception_text(where))\n\t\tdump_mem(\"\", \"Exception stack\", frame + 4, frame + 4 + sizeof(struct pt_regs));\n}",
        "target": 0
    },
    {
        "id": 1213,
        "func": "static void __suspend_stratum(struct pool *pool)\n{\n\tclear_sockbuf(pool);\n\tpool->stratum_active = pool->stratum_notify = false;\n\tif (pool->sock)\n\t\tCLOSESOCKET(pool->sock);\n\tpool->sock = 0;\n}",
        "target": 0
    },
    {
        "id": 1214,
        "func": "static void list_slab_objects(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\tconst char *text)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\tDECLARE_BITMAP(map, page->objects);\n\n\tbitmap_zero(map, page->objects);\n\tslab_err(s, page, \"%s\", text);\n\tslab_lock(page);\n\tfor_each_free_object(p, s, page->freelist)\n\t\tset_bit(slab_index(p, s, addr), map);\n\n\tfor_each_object(p, s, addr, page->objects) {\n\n\t\tif (!test_bit(slab_index(p, s, addr), map)) {\n\t\t\tprintk(KERN_ERR \"INFO: Object 0x%p @offset=%tu\\n\",\n\t\t\t\t\t\t\tp, p - addr);\n\t\t\tprint_tracking(s, p);\n\t\t}\n\t}\n\tslab_unlock(page);\n#endif\n}",
        "target": 0
    },
    {
        "id": 1215,
        "func": "CWD_API void realpath_cache_del(const char *path, int path_len TSRMLS_DC) /* {{{ */\n{\n#ifdef PHP_WIN32\n\tunsigned long key = realpath_cache_key(path, path_len TSRMLS_CC);\n#else\n\tunsigned long key = realpath_cache_key(path, path_len);\n#endif\n\tunsigned long n = key % (sizeof(CWDG(realpath_cache)) / sizeof(CWDG(realpath_cache)[0]));\n\trealpath_cache_bucket **bucket = &CWDG(realpath_cache)[n];\n\n\twhile (*bucket != NULL) {\n\t\tif (key == (*bucket)->key && path_len == (*bucket)->path_len &&\n                                        memcmp(path, (*bucket)->path, path_len) == 0) {\n                        realpath_cache_bucket *r = *bucket;\n                        *bucket = (*bucket)->next;\n                        /* if the pointers match then only subtract the length of the path */\n                        if(r->path == r->realpath) {\n                                CWDG(realpath_cache_size) -= sizeof(realpath_cache_bucket) + r->path_len + 1;\n                        } else {\n                                CWDG(realpath_cache_size) -= sizeof(realpath_cache_bucket) + r->path_len + 1 + r->realpath_len + 1;\n                        }\n                        free(r);\n                        return;\n                } else {\n\t\t\tbucket = &(*bucket)->next;\n\t\t}\n\t}\n}\n/* }}} */\n",
        "target": 1
    },
    {
        "id": 1216,
        "func": "void RenderWidgetHostViewAura::EnsureCaretNotInRect(const gfx::Rect& rect) {\n  gfx::Rect rect_in_local_space = ConvertRectFromScreen(rect);\n  gfx::Rect hiding_area_in_this_window =\n      gfx::IntersectRects(rect_in_local_space, window_->bounds());\n\n  if (hiding_area_in_this_window.IsEmpty())\n    return;\n\n  host_->ScrollFocusedEditableNodeIntoRect(\n      gfx::SubtractRects(window_->bounds(), hiding_area_in_this_window));\n}\n",
        "target": 0
    },
    {
        "id": 1217,
        "func": "int cput(int fd, char c) { return write(fd, &c, 1); }",
        "target": 0
    },
    {
        "id": 1218,
        "func": "static u64 vmx_compute_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\treturn target_tsc - native_read_tsc();\n}",
        "target": 0
    },
    {
        "id": 1219,
        "func": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\tif (*begin > strlen (str)) {\n\t\treturn TT_EOF;\n\t}\n\t// Skip whitespace\n\twhile (begin && str[*begin] && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\n\tif (!str[*begin]) {                // null byte\n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t}\n\tif (isalpha ((ut8)str[*begin])) {   // word token\n\t\t*end = *begin;\n\t\twhile (end && str[*end] && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t}\n\tif (isdigit ((ut8)str[*begin])) {   // number token\n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     // accept alphanumeric characters, because hex.\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             // special character: [, ], +, *, ...\n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}",
        "target": 0
    },
    {
        "id": 1220,
        "func": "void snd_seq_device_load_drivers(void)\n{\n\tqueue_autoload_drivers();\n\tflush_work(&autoload_work);\n}",
        "target": 0
    },
    {
        "id": 1221,
        "func": "void CrosMock::InitMockSpeechSynthesisLibrary() {\n  InitMockLibraryLoader();\n  if (mock_speech_synthesis_library_)\n    return;\n  mock_speech_synthesis_library_ =\n      new StrictMock<MockSpeechSynthesisLibrary>();\n  test_api()->SetSpeechSynthesisLibrary(mock_speech_synthesis_library_, true);\n}\n",
        "target": 0
    },
    {
        "id": 1222,
        "func": "  static int TaskTestMain() {\n    int errors = 0;\n#if defined(OS_MACOSX)\n    mac::ScopedNSAutoreleasePool pool;\n#endif\n    const uint32 kDataSize = 1024;\n    SharedMemory memory;\n    bool rv = memory.CreateNamed(s_test_name_, true, kDataSize);\n    EXPECT_TRUE(rv);\n    if (rv != true)\n      errors++;\n    rv = memory.Map(kDataSize);\n    EXPECT_TRUE(rv);\n    if (rv != true)\n      errors++;\n    int *ptr = static_cast<int*>(memory.memory());\n\n    for (int idx = 0; idx < 20; idx++) {\n      memory.Lock();\n      int i = (1 << 16) + idx;\n      *ptr = i;\n      PlatformThread::Sleep(TimeDelta::FromMilliseconds(10));\n      if (*ptr != i)\n        errors++;\n      memory.Unlock();\n    }\n\n    memory.Close();\n    return errors;\n  }\n",
        "target": 0
    },
    {
        "id": 1223,
        "func": "  static void WritesCorrectly(size_t num_chars) {\n    std::string buffer;\n    char kOriginal[] = \"supercali\";\n    strncpy(WriteInto(&buffer, num_chars + 1), kOriginal, num_chars);\n    EXPECT_EQ(std::string(kOriginal,\n                          std::min(num_chars, arraysize(kOriginal) - 1)),\n              std::string(buffer.c_str()));\n    EXPECT_EQ(num_chars, buffer.size());\n  }\n",
        "target": 0
    },
    {
        "id": 1224,
        "func": "void PrintPreviewDialogDelegate::OnCloseContents(WebContents* /* source */,\n                                                 bool* out_close_dialog) {\n  *out_close_dialog = true;\n}\n",
        "target": 0
    },
    {
        "id": 1225,
        "func": "static unsigned int task_scan_min(struct task_struct *p)\n{\n\tunsigned int scan_size = READ_ONCE(sysctl_numa_balancing_scan_size);\n\tunsigned int scan, floor;\n\tunsigned int windows = 1;\n\n\tif (scan_size < MAX_SCAN_WINDOW)\n\t\twindows = MAX_SCAN_WINDOW / scan_size;\n\tfloor = 1000 / windows;\n\n\tscan = sysctl_numa_balancing_scan_period_min / task_nr_scan_windows(p);\n\treturn max_t(unsigned int, floor, scan);\n}",
        "target": 0
    },
    {
        "id": 1226,
        "func": "static inline void bprm_clear_caps(struct linux_binprm *bprm)\n{\n\tcap_clear(bprm->cred->cap_permitted);\n\tbprm->cap_effective = false;\n}",
        "target": 0
    },
    {
        "id": 1227,
        "func": "void StartSync(const StartSyncArgs& args,\n               OneClickSigninSyncStarter::StartSyncMode start_mode) {\n  if (start_mode == OneClickSigninSyncStarter::UNDO_SYNC) {\n    LogOneClickHistogramValue(one_click_signin::HISTOGRAM_UNDO);\n    return;\n  }\n\n  new OneClickSigninSyncStarter(args.profile, args.browser, args.session_index,\n                                args.email, args.password,\n                                \"\" /* oauth_code */, start_mode,\n                                args.web_contents,\n                                args.confirmation_required,\n                                args.callback);\n\n  int action = one_click_signin::HISTOGRAM_MAX;\n  switch (args.auto_accept) {\n    case OneClickSigninHelper::AUTO_ACCEPT_EXPLICIT:\n      break;\n    case OneClickSigninHelper::AUTO_ACCEPT_ACCEPTED:\n      action =\n          start_mode == OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS ?\n              one_click_signin::HISTOGRAM_AUTO_WITH_DEFAULTS :\n              one_click_signin::HISTOGRAM_AUTO_WITH_ADVANCED;\n      break;\n    case OneClickSigninHelper::AUTO_ACCEPT_CONFIGURE:\n      DCHECK(start_mode == OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST);\n      action = one_click_signin::HISTOGRAM_AUTO_WITH_ADVANCED;\n      break;\n    default:\n      NOTREACHED() << \"Invalid auto_accept: \" << args.auto_accept;\n      break;\n  }\n  if (action != one_click_signin::HISTOGRAM_MAX)\n    LogOneClickHistogramValue(action);\n}\n",
        "target": 0
    },
    {
        "id": 1228,
        "func": "static void arcmsr_hbaB_start_bgrb(struct AdapterControlBlock *acb)\n{\n\tstruct MessageUnit_B *reg = acb->pmuB;\n\tacb->acb_flags |= ACB_F_MSG_START_BGRB;\n\twritel(ARCMSR_MESSAGE_START_BGRB, reg->drv2iop_doorbell);\n\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'start adapter background \\\n\t\t\t\trebulid' timeout \\n\",acb->host->host_no);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1229,
        "func": "static bool SocketIsDead(curl_socket_t sock)\n{\n  int sval;\n  bool ret_val = TRUE;\n\n  sval = SOCKET_READABLE(sock, 0);\n  if(sval == 0)\n    /* timeout */\n    ret_val = FALSE;\n\n  return ret_val;\n}",
        "target": 0
    },
    {
        "id": 1230,
        "func": "AXObjectCache* Document::ExistingAXObjectCache() const {\n  auto& cache_owner = AXObjectCacheOwner();\n\n  if (!cache_owner.GetLayoutView())\n    return nullptr;\n\n  return cache_owner.ax_object_cache_.Get();\n}\n",
        "target": 0
    },
    {
        "id": 1231,
        "func": "static STGMEDIUM* GetStorageForFileDescriptor(\n    const base::FilePath& path) {\n   base::string16 file_name = path.value();\n   DCHECK(!file_name.empty());\n   HANDLE hdata = GlobalAlloc(GPTR, sizeof(FILEGROUPDESCRIPTOR));\n  base::win::ScopedHGlobal<FILEGROUPDESCRIPTOR> locked_mem(hdata);\n \n   FILEGROUPDESCRIPTOR* descriptor = locked_mem.get();\n   descriptor->cItems = 1;\n  descriptor->fgd[0].dwFlags = FD_LINKUI;\n  wcsncpy_s(descriptor->fgd[0].cFileName, MAX_PATH, file_name.c_str(),\n            std::min(file_name.size(), static_cast<size_t>(MAX_PATH - 1u)));\n\n  STGMEDIUM* storage = new STGMEDIUM;\n  storage->tymed = TYMED_HGLOBAL;\n  storage->hGlobal = hdata;\n  storage->pUnkForRelease = NULL;\n  return storage;\n}\n",
        "target": 1
    },
    {
        "id": 1232,
        "func": " PHP_FUNCTION(xml_get_current_line_number)\n {\n\txml_parser *parser;\n\tzval *pind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &pind) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(parser,xml_parser *, &pind, -1, \"XML Parser\", le_xml_parser);\n\n\tRETVAL_LONG(XML_GetCurrentLineNumber(parser->parser));\n}\n",
        "target": 0
    },
    {
        "id": 1233,
        "func": "currentURL(void)\n{\n    if (Currentbuf->bufferprop & BP_INTERNAL)\n\treturn Strnew_size(0);\n    return parsedURL2Str(&Currentbuf->currentURL);\n}",
        "target": 0
    },
    {
        "id": 1234,
        "func": "void fib6_clean_all(struct net *net, int (*func)(struct rt6_info *, void *arg),\n\t\t    int prune, void *arg)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\twrite_lock_bh(&table->tb6_lock);\n\t\t\tfib6_clean_tree(net, &table->tb6_root,\n\t\t\t\t\tfunc, prune, arg);\n\t\t\twrite_unlock_bh(&table->tb6_lock);\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
        "target": 0
    },
    {
        "id": 1235,
        "func": "static int vsr_active(struct task_struct *target,\n\t\t      const struct user_regset *regset)\n{\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}",
        "target": 0
    },
    {
        "id": 1236,
        "func": "void BrowserWindowGtk::Minimize() {\n  gtk_window_iconify(window_);\n}\n",
        "target": 0
    },
    {
        "id": 1237,
        "func": "void StatusBubbleGtk::SetFlipHorizontally(bool flip_horizontally) {\n  if (flip_horizontally == flip_horizontally_)\n    return;\n\n  flip_horizontally_ = flip_horizontally;\n\n  bool ltr = !base::i18n::IsRTL();\n  bool on_left = (ltr && !flip_horizontally) || (!ltr && flip_horizontally);\n\n  gtk_alignment_set_padding(GTK_ALIGNMENT(padding_),\n      kInternalTopBottomPadding, kInternalTopBottomPadding,\n      kInternalLeftRightPadding + (on_left ? 0 : kCornerSize),\n      kInternalLeftRightPadding + (on_left ? kCornerSize : 0));\n  gtk_util::SetRoundedWindowEdgesAndBorders(\n      container_.get(),\n      kCornerSize,\n      flip_horizontally ?\n          gtk_util::ROUNDED_TOP_LEFT :\n          gtk_util::ROUNDED_TOP_RIGHT,\n      gtk_util::BORDER_TOP |\n          (flip_horizontally ? gtk_util::BORDER_LEFT : gtk_util::BORDER_RIGHT));\n  gtk_widget_queue_draw(container_.get());\n}\n",
        "target": 0
    },
    {
        "id": 1238,
        "func": "void DownloadManagerImpl::DownloadUrl(\n    std::unique_ptr<download::DownloadUrlParameters> params) {\n  DownloadUrl(std::move(params), nullptr /* blob_data_handle */,\n              nullptr /* blob_url_loader_factory */);\n}\n",
        "target": 0
    },
    {
        "id": 1239,
        "func": "void ImageInputType::setUseFallbackContent()\n{\n    if (m_useFallbackContent)\n        return;\n    m_useFallbackContent = true;\n    if (element().document().inStyleRecalc())\n        return;\n    if (ShadowRoot* root = element().userAgentShadowRoot())\n        root->removeChildren();\n    createShadowSubtree();\n}\n",
        "target": 0
    },
    {
        "id": 1240,
        "func": "static inline ut32 r_read_le32(const void *src) {\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |\n\t\t(((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);\n}",
        "target": 1
    },
    {
        "id": 1241,
        "func": "static inline void quote_string(zval *zv, zend_bool force TSRMLS_DC)\n{\n\tint len = Z_STRLEN_P(zv);\n\n\tZ_STRVAL_P(zv) = php_addcslashes(Z_STRVAL_P(zv), Z_STRLEN_P(zv), &Z_STRLEN_P(zv), 1,\n\t\t\tZEND_STRL(\"\\0..\\37\\173\\\\\\\"\") TSRMLS_CC);\n\n\tif (force || len != Z_STRLEN_P(zv) || strpbrk(Z_STRVAL_P(zv), \"()<>@,;:\\\"[]?={} \")) {\n\t\tzval tmp = *zv;\n\t\tint len = Z_STRLEN_P(zv) + 2;\n\t\tchar *str = emalloc(len + 1);\n\n\t\tstr[0] = '\"';\n\t\tmemcpy(&str[1], Z_STRVAL_P(zv), Z_STRLEN_P(zv));\n\t\tstr[len-1] = '\"';\n\t\tstr[len] = '\\0';\n\n\t\tzval_dtor(&tmp);\n\t\tZVAL_STRINGL(zv, str, len, 0);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1242,
        "func": "void MetricsWebContentsObserver::UnregisterInputEventObserver(\n    content::RenderViewHost* host) {\n  if (host != nullptr)\n    host->GetWidget()->RemoveInputEventObserver(this);\n}\n",
        "target": 0
    },
    {
        "id": 1243,
        "func": "static int udp_lib_lport_inuse(struct net *net, __u16 num,\n\t\t\t       const struct udp_hslot *hslot,\n\t\t\t       unsigned long *bitmap,\n\t\t\t       struct sock *sk,\n\t\t\t       int (*saddr_comp)(const struct sock *sk1,\n\t\t\t\t\t\t const struct sock *sk2),\n\t\t\t       unsigned int log)\n{\n\tstruct sock *sk2;\n\tstruct hlist_nulls_node *node;\n\tkuid_t uid = sock_i_uid(sk);\n\n\tsk_nulls_for_each(sk2, node, &hslot->head)\n\t\tif (net_eq(sock_net(sk2), net) &&\n\t\t    sk2 != sk &&\n\t\t    (bitmap || udp_sk(sk2)->udp_port_hash == num) &&\n\t\t    (!sk2->sk_reuse || !sk->sk_reuse) &&\n\t\t    (!sk2->sk_bound_dev_if || !sk->sk_bound_dev_if ||\n\t\t     sk2->sk_bound_dev_if == sk->sk_bound_dev_if) &&\n\t\t    (!sk2->sk_reuseport || !sk->sk_reuseport ||\n\t\t      !uid_eq(uid, sock_i_uid(sk2))) &&\n\t\t    (*saddr_comp)(sk, sk2)) {\n\t\t\tif (bitmap)\n\t\t\t\t__set_bit(udp_sk(sk2)->udp_port_hash >> log,\n\t\t\t\t\t  bitmap);\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1244,
        "func": "HTMLFormElement::HTMLFormElement(const QualifiedName& tagName, Document& document)\n    : HTMLElement(tagName, document)\n    , m_associatedElementsBeforeIndex(0)\n    , m_associatedElementsAfterIndex(0)\n    , m_wasUserSubmitted(false)\n    , m_isSubmittingOrPreparingForSubmission(false)\n    , m_shouldSubmit(false)\n    , m_isInResetFunction(false)\n    , m_wasDemoted(false)\n    , m_requestAutocompleteTimer(this, &HTMLFormElement::requestAutocompleteTimerFired)\n{\n    ASSERT(hasTagName(formTag));\n    ScriptWrappable::init(this);\n}\n",
        "target": 0
    },
    {
        "id": 1245,
        "func": "int container_disk_lock(struct lxc_container *c)\n{\n\tint ret;\n\n\tif ((ret = lxclock(c->privlock, 0)))\n\t\treturn ret;\n\tif ((ret = lxclock(c->slock, 0))) {\n\t\tlxcunlock(c->privlock);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1246,
        "func": "Track::Info::~Info()\n{\n    Clear();\n}\n",
        "target": 1
    },
    {
        "id": 1247,
        "func": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 1248,
        "func": "void gdImageAlphaBlending (gdImagePtr im, int alphaBlendingArg)\n{\n\tim->alphaBlendingFlag = alphaBlendingArg;\n}\n",
        "target": 0
    },
    {
        "id": 1249,
        "func": "void ContainerNode::setHovered(bool over)\n{\n    if (over == hovered())\n        return;\n\n    Node::setHovered(over);\n\n    if (!layoutObject()) {\n        if (over)\n            return;\n        if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByHover() && styleChangeType() < SubtreeStyleChange)\n            document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoHover, *toElement(this));\n        else\n            setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Hover));\n        return;\n    }\n\n    if (styleChangeType() < SubtreeStyleChange) {\n        if (computedStyle()->affectedByHover() && computedStyle()->hasPseudoStyle(FIRST_LETTER))\n            setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Hover));\n        else if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByHover())\n            document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoHover, *toElement(this));\n        else if (computedStyle()->affectedByHover())\n            setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Hover));\n    }\n\n    LayoutTheme::theme().controlStateChanged(*layoutObject(), HoverControlState);\n}\n",
        "target": 0
    },
    {
        "id": 1250,
        "func": "void DownloadItemImplDelegate::AssertStateConsistent(\n    DownloadItemImpl* download) const {}\n",
        "target": 0
    },
    {
        "id": 1251,
        "func": "PromptBrowserLoginFunction::PromptBrowserLoginFunction()\n    : waiting_for_token_(false) {}\n",
        "target": 0
    },
    {
        "id": 1252,
        "func": "static ssize_t show_tabletMouseRight(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\tmap_val_to_str(mouse_button_map,\n\t\t\t\t\taiptek->curSetting.mouseButtonRight));\n}",
        "target": 0
    },
    {
        "id": 1253,
        "func": "void VP9Decoder::SetStream(const uint8_t* ptr, size_t size) {\n  DCHECK(ptr);\n  DCHECK(size);\n\n  DVLOG(4) << \"New input stream at: \" << (void*)ptr << \" size: \" << size;\n  parser_.SetStream(ptr, size);\n}\n",
        "target": 0
    },
    {
        "id": 1254,
        "func": "bool ChromeContentBrowserClient::NeedURLRequestContext() {\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 1255,
        "func": "int ppp_channel_index(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\n\tif (pch)\n\t\treturn pch->file.index;\n\treturn -1;\n}",
        "target": 0
    },
    {
        "id": 1256,
        "func": "static int f2fs_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tgroup_obj = pa;\n\t\t\tbreak;\n\n\t\tcase ACL_OTHER:\n\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n\t\t\tbreak;\n\n\t\tcase ACL_MASK:\n\t\t\tmask_obj = pa;\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
        "target": 0
    },
    {
        "id": 1257,
        "func": "static void decode_register_operand(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    struct operand *op)\n{\n\tunsigned reg = ctxt->modrm_reg;\n\n\tif (!(ctxt->d & ModRM))\n\t\treg = (ctxt->b & 7) | ((ctxt->rex_prefix & 1) << 3);\n\n\tif (ctxt->d & Sse) {\n\t\top->type = OP_XMM;\n\t\top->bytes = 16;\n\t\top->addr.xmm = reg;\n\t\tread_sse_reg(ctxt, &op->vec_val, reg);\n\t\treturn;\n\t}\n\tif (ctxt->d & Mmx) {\n\t\treg &= 7;\n\t\top->type = OP_MM;\n\t\top->bytes = 8;\n\t\top->addr.mm = reg;\n\t\treturn;\n\t}\n\n\top->type = OP_REG;\n\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\top->addr.reg = decode_register(ctxt, reg, ctxt->d & ByteOp);\n\n\tfetch_register_operand(op);\n\top->orig_val = op->val;\n}",
        "target": 0
    },
    {
        "id": 1258,
        "func": "int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t      gpa_t gpa)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tint offset = offset_in_page(gpa);\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\n\tghc->gpa = gpa;\n\tghc->generation = slots->generation;\n\tghc->memslot = __gfn_to_memslot(slots, gfn);\n\tghc->hva = gfn_to_hva_many(ghc->memslot, gfn, NULL);\n\tif (!kvm_is_error_hva(ghc->hva))\n\t\tghc->hva += offset;\n\telse\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 1259,
        "func": "void WebProcessProxy::didReceiveMessage(CoreIPC::Connection* connection, CoreIPC::MessageID messageID, CoreIPC::MessageDecoder& decoder)\n{\n    if (m_messageReceiverMap.dispatchMessage(connection, messageID, decoder))\n        return;\n\n    if (m_context->dispatchMessage(connection, messageID, decoder))\n        return;\n\n    if (decoder.messageReceiverName() == Messages::WebProcessProxy::messageReceiverName()) {\n        didReceiveWebProcessProxyMessage(connection, messageID, decoder);\n        return;\n    }\n\n#if ENABLE(CUSTOM_PROTOCOLS)\n    if (decoder.messageReceiverName() == Messages::CustomProtocolManagerProxy::messageReceiverName()) {\n#if ENABLE(NETWORK_PROCESS)\n        ASSERT(!context()->usesNetworkProcess());\n#endif\n        m_customProtocolManagerProxy.didReceiveMessage(connection, messageID, decoder);\n        return;\n    }\n#endif\n\n    uint64_t pageID = decoder.destinationID();\n    if (!pageID)\n        return;\n\n    WebPageProxy* pageProxy = webPage(pageID);\n    if (!pageProxy)\n        return;\n    \n    pageProxy->didReceiveMessage(connection, messageID, decoder);\n}\n",
        "target": 0
    },
    {
        "id": 1260,
        "func": "ScriptValue WebGL2RenderingContextBase::getActiveUniformBlockParameter(\n    ScriptState* script_state,\n    WebGLProgram* program,\n    GLuint uniform_block_index,\n    GLenum pname) {\n  if (isContextLost() ||\n      !ValidateWebGLObject(\"getActiveUniformBlockParameter\", program))\n    return ScriptValue::CreateNull(script_state);\n\n  if (!ValidateUniformBlockIndex(\"getActiveUniformBlockParameter\", program,\n                                 uniform_block_index))\n    return ScriptValue::CreateNull(script_state);\n\n  switch (pname) {\n    case GL_UNIFORM_BLOCK_BINDING:\n    case GL_UNIFORM_BLOCK_DATA_SIZE:\n    case GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS: {\n      GLint int_value = 0;\n      ContextGL()->GetActiveUniformBlockiv(\n          ObjectOrZero(program), uniform_block_index, pname, &int_value);\n      return WebGLAny(script_state, static_cast<unsigned>(int_value));\n    }\n    case GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: {\n      GLint uniform_count = 0;\n      ContextGL()->GetActiveUniformBlockiv(\n          ObjectOrZero(program), uniform_block_index,\n          GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS, &uniform_count);\n\n      Vector<GLint> indices(uniform_count);\n      ContextGL()->GetActiveUniformBlockiv(\n          ObjectOrZero(program), uniform_block_index, pname, indices.data());\n      return WebGLAny(\n          script_state,\n          DOMUint32Array::Create(reinterpret_cast<GLuint*>(indices.data()),\n                                 indices.size()));\n    }\n    case GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:\n    case GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: {\n      GLint bool_value = 0;\n      ContextGL()->GetActiveUniformBlockiv(\n          ObjectOrZero(program), uniform_block_index, pname, &bool_value);\n      return WebGLAny(script_state, static_cast<bool>(bool_value));\n    }\n    default:\n      SynthesizeGLError(GL_INVALID_ENUM, \"getActiveUniformBlockParameter\",\n                        \"invalid parameter name\");\n      return ScriptValue::CreateNull(script_state);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1261,
        "func": "unsigned HTMLInputElement::height() const {\n  return input_type_->Height();\n}\n",
        "target": 0
    },
    {
        "id": 1262,
        "func": "void QQuickWebViewExperimental::setUseDefaultContentItemSize(bool enable)\n{\n    Q_D(QQuickWebView);\n    d->m_useDefaultContentItemSize = enable;\n}\n",
        "target": 0
    },
    {
        "id": 1263,
        "func": "bool Extension::IsSandboxedPage(const std::string& relative_path) const {\n  return ResourceMatches(sandboxed_pages_, relative_path);\n}\n",
        "target": 0
    },
    {
        "id": 1264,
        "func": "void ChromeClientImpl::AjaxSucceeded(LocalFrame* frame) {\n  if (auto* fill_client = AutofillClientFromFrame(frame))\n    fill_client->AjaxSucceeded();\n}\n",
        "target": 0
    },
    {
        "id": 1265,
        "func": "SYSCALL_DEFINE6(osf_mmap, unsigned long, addr, unsigned long, len,\n\t\tunsigned long, prot, unsigned long, flags, unsigned long, fd,\n\t\tunsigned long, off)\n{\n\tunsigned long ret = -EINVAL;\n\n#if 0\n\tif (flags & (_MAP_HASSEMAPHORE | _MAP_INHERIT | _MAP_UNALIGNED))\n\t\tprintk(\"%s: unimplemented OSF mmap flags %04lx\\n\", \n\t\t\tcurrent->comm, flags);\n#endif\n\tif ((off + PAGE_ALIGN(len)) < off)\n\t\tgoto out;\n\tif (off & ~PAGE_MASK)\n\t\tgoto out;\n\tret = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n out:\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1266,
        "func": "get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)\n{\n    static gstrings_ret             ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gstrings_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(\"kadm5_get_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,\n                                     &ret.count);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
        "target": 1
    },
    {
        "id": 1267,
        "func": "void RenderViewImpl::willReleaseScriptContext(WebFrame* frame,\n                                              v8::Handle<v8::Context> context,\n                                              int world_id) {\n  content::GetContentClient()->renderer()->WillReleaseScriptContext(\n      frame, context, world_id);\n}\n",
        "target": 0
    },
    {
        "id": 1268,
        "func": "VaapiWrapper::~VaapiWrapper() {\n  DestroyPendingBuffers();\n  DestroyCodedBuffers();\n  DestroySurfaces();\n  DeinitializeVpp();\n  Deinitialize();\n}\n",
        "target": 0
    },
    {
        "id": 1269,
        "func": "static inline void update_load_set(struct load_weight *lw, unsigned long w)\n{\n\tlw->weight = w;\n\tlw->inv_weight = 0;\n}",
        "target": 0
    },
    {
        "id": 1270,
        "func": "bool AXNodeObject::isNativeTextControl() const {\n  Node* node = this->getNode();\n  if (!node)\n    return false;\n\n  if (isHTMLTextAreaElement(*node))\n    return true;\n\n  if (isHTMLInputElement(*node))\n    return toHTMLInputElement(node)->isTextField();\n\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 1271,
        "func": "WebRunnerBrowserContext::GetPushMessagingService() {\n  return nullptr;\n}\n",
        "target": 0
    },
    {
        "id": 1272,
        "func": "void SessionService::SetSelectedNavigationIndex(const SessionID& window_id,\n                                                const SessionID& tab_id,\n                                                int index) {\n  if (!ShouldTrackChangesToWindow(window_id))\n    return;\n\n  if (tab_to_available_range_.find(tab_id.id()) !=\n      tab_to_available_range_.end()) {\n    if (index < tab_to_available_range_[tab_id.id()].first ||\n        index > tab_to_available_range_[tab_id.id()].second) {\n      ResetFromCurrentBrowsers();\n      return;\n    }\n  }\n  ScheduleCommand(CreateSetSelectedNavigationIndexCommand(tab_id, index));\n}\n",
        "target": 0
    },
    {
        "id": 1273,
        "func": "   virtual std::string GetKeyboardOverlayId(const std::string& input_method_id) {\n     if (!initialized_successfully_)\n       return \"\";\n \n    return input_method::GetKeyboardOverlayId(input_method_id);\n   }\n",
        "target": 0
    },
    {
        "id": 1274,
        "func": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain == 0) {\n\t\t\t/* 2.0.34: EOF is incorrect. We use 0 for\n\t\t\t * errors and EOF, just like fileGetbuf,\n\t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. */\n\t\t\treturn 0; /* NOT EOF */\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}",
        "target": 1
    },
    {
        "id": 1275,
        "func": "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\n\tint i;\n\tif (huff->loc[ch] == NULL) { \n\t\t/* node_t hasn't been transmitted, send a NYT, then the symbol */\n\t\tHuff_transmit(huff, NYT, fout);\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tadd_bit((char)((ch >> i) & 0x1), fout);\n\t\t}\n\t} else {\n\t\tsend(huff->loc[ch], NULL, fout);\n\t}\n}",
        "target": 1
    },
    {
        "id": 1276,
        "func": "void NTPResourceCache::CreateNewTabIncognitoCSS() {\n  ui::ThemeProvider* tp = ThemeServiceFactory::GetForProfile(profile_);\n  DCHECK(tp);\n\n  SkColor color_background =\n      tp->GetColor(ThemeService::COLOR_NTP_BACKGROUND);\n\n  std::vector<std::string> subst;\n\n  subst.push_back(\n      profile_->GetPrefs()->GetString(prefs::kCurrentThemeID));  // $1\n\n  subst.push_back(SkColorToRGBAString(color_background));  // $2\n  subst.push_back(GetNewTabBackgroundCSS(tp, false));  // $3\n  subst.push_back(GetNewTabBackgroundCSS(tp, true));  // $4\n  subst.push_back(GetNewTabBackgroundTilingCSS(tp));  // $5\n\n  static const base::StringPiece new_tab_theme_css(\n      ResourceBundle::GetSharedInstance().GetRawDataResource(\n      IDR_NEW_INCOGNITO_TAB_THEME_CSS));\n\n  std::string full_css = ReplaceStringPlaceholders(\n      new_tab_theme_css, subst, NULL);\n\n  new_tab_incognito_css_ = base::RefCountedString::TakeString(&full_css);\n}\n",
        "target": 0
    },
    {
        "id": 1277,
        "func": "static int cms_kari_set1_pkey(CMS_ContentInfo *cms, CMS_RecipientInfo *ri,\n\t\t\t\t\t\tEVP_PKEY *pk, X509 *cert)\n\t{\n\tint i;\n\tSTACK_OF(CMS_RecipientEncryptedKey) *reks;\n\tCMS_RecipientEncryptedKey *rek;\n\treks = CMS_RecipientInfo_kari_get0_reks(ri);\n\tif (!cert)\n\t\treturn 0;\n\tfor (i = 0; i < sk_CMS_RecipientEncryptedKey_num(reks); i++)\n\t\t{\n\t\tint rv;\n\t\trek = sk_CMS_RecipientEncryptedKey_value(reks, i);\n\t\tif (CMS_RecipientEncryptedKey_cert_cmp(rek, cert))\n\t\t\tcontinue;\n\t\tCMS_RecipientInfo_kari_set0_pkey(ri, pk);\n\t\trv = CMS_RecipientInfo_kari_decrypt(cms, ri, rek);\n\t\tCMS_RecipientInfo_kari_set0_pkey(ri, NULL);\n\t\tif (rv > 0)\n\t\t\treturn 1;\n\t\treturn -1;\n\t\t}\n\treturn 0;\n\t}\n",
        "target": 0
    },
    {
        "id": 1278,
        "func": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}",
        "target": 1
    },
    {
        "id": 1279,
        "func": "selCreate(l_int32      height,\n          l_int32      width,\n          const char  *name)\n{\nSEL  *sel;\n\n    PROCNAME(\"selCreate\");\n\n    if ((sel = (SEL *)LEPT_CALLOC(1, sizeof(SEL))) == NULL)\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    if (name)\n        sel->name = stringNew(name);\n    sel->sy = height;\n    sel->sx = width;\n    if ((sel->data = create2dIntArray(height, width)) == NULL) {\n        LEPT_FREE(sel->name);\n        LEPT_FREE(sel);\n        return (SEL *)ERROR_PTR(\"data not allocated\", procName, NULL);\n    }\n\n    return sel;\n}",
        "target": 0
    },
    {
        "id": 1280,
        "func": "iperf_on_new_stream(struct iperf_stream *sp)\n{\n    connect_msg(sp);\n}",
        "target": 0
    },
    {
        "id": 1281,
        "func": "static void file_change_d(const char *p, struct branch *b)\n{\n\tstatic struct strbuf uq = STRBUF_INIT;\n\tconst char *endp;\n\n\tstrbuf_reset(&uq);\n\tif (!unquote_c_style(&uq, p, &endp)) {\n\t\tif (*endp)\n\t\t\tdie(\"Garbage after path in: %s\", command_buf.buf);\n\t\tp = uq.buf;\n\t}\n\ttree_content_remove(&b->branch_tree, p, NULL, 1);\n}",
        "target": 0
    },
    {
        "id": 1282,
        "func": "remove_leading_slash(const char *p)\n{\n\tconst char *rp;\n\n\t/* Remove leading \"//./\" or \"//?/\" or \"//?/UNC/\"\n\t * (absolute path prefixes used by Windows API) */\n\tif ((p[0] == '/' || p[0] == '\\\\') &&\n\t    (p[1] == '/' || p[1] == '\\\\') &&\n\t    (p[2] == '.' || p[2] == '?') &&\n\t    (p[3] == '/' || p[3] == '\\\\'))\n\t{\n\t\tif (p[2] == '?' &&\n\t\t    (p[4] == 'U' || p[4] == 'u') &&\n\t\t    (p[5] == 'N' || p[5] == 'n') &&\n\t\t    (p[6] == 'C' || p[6] == 'c') &&\n\t\t    (p[7] == '/' || p[7] == '\\\\'))\n\t\t\tp += 8;\n\t\telse\n\t\t\tp += 4;\n\t}\n\tdo {\n\t\trp = p;\n\t\t/* Remove leading drive letter from archives created\n\t\t * on Windows. */\n\t\tif (((p[0] >= 'a' && p[0] <= 'z') ||\n\t\t     (p[0] >= 'A' && p[0] <= 'Z')) &&\n\t\t\t p[1] == ':') {\n\t\t\tp += 2;\n\t\t}\n\t\t/* Remove leading \"/../\", \"//\", etc. */\n\t\twhile (p[0] == '/' || p[0] == '\\\\') {\n\t\t\tif (p[1] == '.' && p[2] == '.' &&\n\t\t\t\t(p[3] == '/' || p[3] == '\\\\')) {\n\t\t\t\tp += 3; /* Remove \"/..\", leave \"/\"\n\t\t\t\t\t * for next pass. */\n\t\t\t} else\n\t\t\t\tp += 1; /* Remove \"/\". */\n\t\t}\n\t} while (rp != p);\n\treturn (p);\n}",
        "target": 0
    },
    {
        "id": 1283,
        "func": "pkinit_server_plugin_init_realm(krb5_context context, const char *realmname,\n                                pkinit_kdc_context *pplgctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_kdc_context plgctx = NULL;\n\n    *pplgctx = NULL;\n\n    plgctx = calloc(1, sizeof(*plgctx));\n    if (plgctx == NULL)\n        goto errout;\n\n    pkiDebug(\"%s: initializing context at %p for realm '%s'\\n\",\n             __FUNCTION__, plgctx, realmname);\n    memset(plgctx, 0, sizeof(*plgctx));\n    plgctx->magic = PKINIT_CTX_MAGIC;\n\n    plgctx->realmname = strdup(realmname);\n    if (plgctx->realmname == NULL)\n        goto errout;\n    plgctx->realmname_len = strlen(plgctx->realmname);\n\n    retval = pkinit_init_plg_crypto(&plgctx->cryptoctx);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_plg_opts(&plgctx->opts);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_identity_crypto(&plgctx->idctx);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_identity_opts(&plgctx->idopts);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_init_kdc_profile(context, plgctx);\n    if (retval)\n        goto errout;\n\n    retval = pkinit_identity_initialize(context, plgctx->cryptoctx, NULL,\n                                        plgctx->idopts, plgctx->idctx,\n                                        NULL, NULL, NULL);\n    if (retval)\n        goto errout;\n    retval = pkinit_identity_prompt(context, plgctx->cryptoctx, NULL,\n                                    plgctx->idopts, plgctx->idctx,\n                                    NULL, NULL, 0, NULL);\n    if (retval)\n        goto errout;\n\n    pkiDebug(\"%s: returning context at %p for realm '%s'\\n\",\n             __FUNCTION__, plgctx, realmname);\n    *pplgctx = plgctx;\n    retval = 0;\n\nerrout:\n    if (retval)\n        pkinit_server_plugin_fini_realm(context, plgctx);\n\n    return retval;\n}",
        "target": 0
    },
    {
        "id": 1284,
        "func": "bool HeapAllocator::backingExpand(void* address, size_t newSize) {\n  if (!address)\n    return false;\n\n  ThreadState* state = ThreadState::current();\n  if (state->sweepForbidden())\n    return false;\n  ASSERT(!state->isInGC());\n  ASSERT(state->isAllocationAllowed());\n  DCHECK_EQ(&state->heap(), &ThreadState::fromObject(address)->heap());\n\n  BasePage* page = pageFromObject(address);\n  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)\n     return false;\n \n   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);\n  ASSERT(header->checkHeader());\n   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();\n   bool succeed = arena->expandObject(header, newSize);\n   if (succeed)\n    state->allocationPointAdjusted(arena->arenaIndex());\n  return succeed;\n}\n",
        "target": 1
    },
    {
        "id": 1285,
        "func": "void StreamTcpSetOSPolicy(TcpStream *stream, Packet *p)\n{\n    int ret = 0;\n\n    if (PKT_IS_IPV4(p)) {\n        /* Get the OS policy based on destination IP address, as destination\n           OS will decide how to react on the anomalies of newly received\n           packets */\n        ret = SCHInfoGetIPv4HostOSFlavour((uint8_t *)GET_IPV4_DST_ADDR_PTR(p));\n        if (ret > 0)\n            stream->os_policy = ret;\n        else\n            stream->os_policy = OS_POLICY_DEFAULT;\n\n    } else if (PKT_IS_IPV6(p)) {\n        /* Get the OS policy based on destination IP address, as destination\n           OS will decide how to react on the anomalies of newly received\n           packets */\n        ret = SCHInfoGetIPv6HostOSFlavour((uint8_t *)GET_IPV6_DST_ADDR(p));\n        if (ret > 0)\n            stream->os_policy = ret;\n        else\n            stream->os_policy = OS_POLICY_DEFAULT;\n    }\n\n    if (stream->os_policy == OS_POLICY_BSD_RIGHT)\n        stream->os_policy = OS_POLICY_BSD;\n    else if (stream->os_policy == OS_POLICY_OLD_SOLARIS)\n        stream->os_policy = OS_POLICY_SOLARIS;\n\n    SCLogDebug(\"Policy is %\"PRIu8\"\", stream->os_policy);\n\n}\n",
        "target": 0
    },
    {
        "id": 1286,
        "func": "void RenderWidgetHostViewAura::OnBoundsChanged(const gfx::Rect& old_bounds,\n                                               const gfx::Rect& new_bounds) {\n  if (is_fullscreen_)\n    SetSize(new_bounds.size());\n}\n",
        "target": 0
    },
    {
        "id": 1287,
        "func": "static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod2(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n\n    size_t argsCount = exec->argumentCount();\n    if (argsCount <= 1) {\n        impl->overloadedMethod(objArg);\n        return JSValue::encode(jsUndefined());\n    }\n\n    int intArg(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toInt32(exec));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    impl->overloadedMethod(objArg, intArg);\n    return JSValue::encode(jsUndefined());\n}\n",
        "target": 1
    },
    {
        "id": 1288,
        "func": "static inline void put_dct(MpegEncContext *s,\n                           int16_t *block, int i, uint8_t *dest, int line_size, int qscale)\n{\n    s->dct_unquantize_intra(s, block, i, qscale);\n    s->idsp.idct_put(dest, line_size, block);\n}",
        "target": 0
    },
    {
        "id": 1289,
        "func": "void RenderFrameHostImpl::BindWakeLockRequest(\n    device::mojom::WakeLockRequest request) {\n  device::mojom::WakeLock* renderer_wake_lock =\n      delegate_ ? delegate_->GetRendererWakeLock() : nullptr;\n  if (renderer_wake_lock)\n    renderer_wake_lock->AddClient(std::move(request));\n}\n",
        "target": 0
    },
    {
        "id": 1290,
        "func": "base::string16 TabStrip::GetAccessibleTabName(const Tab* tab) const {\n  const int model_index = GetModelIndexOfTab(tab);\n  return IsValidModelIndex(model_index) ? controller_->GetAccessibleTabName(tab)\n                                        : base::string16();\n}\n",
        "target": 0
    },
    {
        "id": 1291,
        "func": " void MediaStreamDispatcherHost::OpenDevice(int32_t page_request_id,\n                                           const std::string& device_id,\n                                           MediaStreamType type,\n                                           OpenDeviceCallback callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  base::PostTaskAndReplyWithResult(\n      base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::UI}).get(),\n      FROM_HERE,\n      base::BindOnce(salt_and_origin_callback_, render_process_id_,\n                     render_frame_id_),\n      base::BindOnce(&MediaStreamDispatcherHost::DoOpenDevice,\n                     weak_factory_.GetWeakPtr(), page_request_id, device_id,\n                     type, std::move(callback)));\n}\n",
        "target": 0
    },
    {
        "id": 1292,
        "func": "static int find_shared_ctxt(struct file *fp,\n\t\t\t    const struct qib_user_info *uinfo)\n{\n\tint devmax, ndev, i;\n\tint ret = 0;\n\n\tdevmax = qib_count_units(NULL, NULL);\n\n\tfor (ndev = 0; ndev < devmax; ndev++) {\n\t\tstruct qib_devdata *dd = qib_lookup(ndev);\n\n\t\t/* device portion of usable() */\n\t\tif (!(dd && (dd->flags & QIB_PRESENT) && dd->kregbase))\n\t\t\tcontinue;\n\t\tfor (i = dd->first_user_ctxt; i < dd->cfgctxts; i++) {\n\t\t\tstruct qib_ctxtdata *rcd = dd->rcd[i];\n\n\t\t\t/* Skip ctxts which are not yet open */\n\t\t\tif (!rcd || !rcd->cnt)\n\t\t\t\tcontinue;\n\t\t\t/* Skip ctxt if it doesn't match the requested one */\n\t\t\tif (rcd->subctxt_id != uinfo->spu_subctxt_id)\n\t\t\t\tcontinue;\n\t\t\t/* Verify the sharing process matches the master */\n\t\t\tif (rcd->subctxt_cnt != uinfo->spu_subctxt_cnt ||\n\t\t\t    rcd->userversion != uinfo->spu_userversion ||\n\t\t\t    rcd->cnt >= rcd->subctxt_cnt) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tctxt_fp(fp) = rcd;\n\t\t\tsubctxt_fp(fp) = rcd->cnt++;\n\t\t\trcd->subpid[subctxt_fp(fp)] = current->pid;\n\t\t\ttidcursor_fp(fp) = 0;\n\t\t\trcd->active_slaves |= 1 << subctxt_fp(fp);\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1293,
        "func": "static void h2_session_ev_proto_error(h2_session *session, int arg, const char *msg)\n{\n    if (!session->local.shutdown) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c, APLOGNO(03402)\n                      \"h2_session(%ld): proto error -> shutdown\", session->id);\n        h2_session_shutdown(session, arg, msg, 0);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1294,
        "func": "apprentice_unmap(struct magic_map *map)\n{\n\tif (map == NULL)\n\t\treturn;\n\tif (map->p != php_magic_database) {\n\t\tif (map->p == NULL) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\t\tif (map->magic[j]) {\n\t\t\t\t\tefree(map->magic[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tefree(map->p);\n\t\t}\n\t}\n\tefree(map);\n}\n",
        "target": 0
    },
    {
        "id": 1295,
        "func": "RenderFrameHostImpl* FindOpenerRFH(const WebContents::CreateParams& params) {\n  RenderFrameHostImpl* opener_rfh = nullptr;\n  if (params.opener_render_frame_id != MSG_ROUTING_NONE) {\n    opener_rfh = RenderFrameHostImpl::FromID(params.opener_render_process_id,\n                                             params.opener_render_frame_id);\n  }\n  return opener_rfh;\n}\n",
        "target": 0
    },
    {
        "id": 1296,
        "func": "void PageInfo::GetSafeBrowsingStatusByMaliciousContentStatus(\nvoid PageInfo::GetSiteIdentityByMaliciousContentStatus(\n     security_state::MaliciousContentStatus malicious_content_status,\n    PageInfo::SiteIdentityStatus* status,\n     base::string16* details) {\n   switch (malicious_content_status) {\n     case security_state::MALICIOUS_CONTENT_STATUS_NONE:\n       NOTREACHED();\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_MALWARE:\n      *status = PageInfo::SITE_IDENTITY_STATUS_MALWARE;\n       *details = l10n_util::GetStringUTF16(IDS_PAGE_INFO_MALWARE_DETAILS);\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_SOCIAL_ENGINEERING:\n      *status = PageInfo::SITE_IDENTITY_STATUS_SOCIAL_ENGINEERING;\n       *details =\n           l10n_util::GetStringUTF16(IDS_PAGE_INFO_SOCIAL_ENGINEERING_DETAILS);\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_UNWANTED_SOFTWARE:\n      *status = PageInfo::SITE_IDENTITY_STATUS_UNWANTED_SOFTWARE;\n       *details =\n           l10n_util::GetStringUTF16(IDS_PAGE_INFO_UNWANTED_SOFTWARE_DETAILS);\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_SIGN_IN_PASSWORD_REUSE:\n #if defined(FULL_SAFE_BROWSING)\n      *status = PageInfo::SITE_IDENTITY_STATUS_SIGN_IN_PASSWORD_REUSE;\n       *details = password_protection_service_\n                      ? password_protection_service_->GetWarningDetailText(\n                           PasswordReuseEvent::SIGN_IN_PASSWORD)\n                     : base::string16();\n#endif\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_ENTERPRISE_PASSWORD_REUSE:\n #if defined(FULL_SAFE_BROWSING)\n      *status = PageInfo::SITE_IDENTITY_STATUS_ENTERPRISE_PASSWORD_REUSE;\n       *details = password_protection_service_\n                      ? password_protection_service_->GetWarningDetailText(\n                           PasswordReuseEvent::ENTERPRISE_PASSWORD)\n                     : base::string16();\n #endif\n       break;\n     case security_state::MALICIOUS_CONTENT_STATUS_BILLING:\n      *status = PageInfo::SITE_IDENTITY_STATUS_BILLING;\n       *details = l10n_util::GetStringUTF16(IDS_PAGE_INFO_BILLING_DETAILS);\n       break;\n   }\n}\n",
        "target": 0
    },
    {
        "id": 1297,
        "func": "void TabStrip::Init() {\n  SetID(VIEW_ID_TAB_STRIP);\n  set_notify_enter_exit_on_child(true);\n\n  new_tab_button_ = new NewTabButton(this, this);\n  new_tab_button_->SetTooltipText(\n      l10n_util::GetStringUTF16(IDS_TOOLTIP_NEW_TAB));\n  new_tab_button_->SetAccessibleName(\n      l10n_util::GetStringUTF16(IDS_ACCNAME_NEWTAB));\n  new_tab_button_->SetImageVerticalAlignment(views::ImageButton::ALIGN_BOTTOM);\n  new_tab_button_->SetEventTargeter(\n      std::make_unique<views::ViewTargeter>(new_tab_button_));\n  AddChildView(new_tab_button_);\n\n  UpdateNewTabButtonBorder();\n  new_tab_button_bounds_.set_size(new_tab_button_->GetPreferredSize());\n\n  if (g_drop_indicator_width == 0) {\n    gfx::ImageSkia* drop_image = GetDropArrowImage(true);\n    g_drop_indicator_width = drop_image->width();\n    g_drop_indicator_height = drop_image->height();\n  }\n\n  UpdateContrastRatioValues();\n\n  if (!gfx::Animation::ShouldRenderRichAnimation())\n    bounds_animator_.SetAnimationDuration(0);\n}\n",
        "target": 0
    },
    {
        "id": 1298,
        "func": "void lock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 > inode2)\n\t\tswap(inode1, inode2);\n\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tmutex_lock(&inode1->i_mutex);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tmutex_lock_nested(&inode2->i_mutex, I_MUTEX_NONDIR2);\n}",
        "target": 0
    },
    {
        "id": 1299,
        "func": "ContentEncoding::GetEncryptionByIndex(unsigned long idx) const {\n   const ptrdiff_t count = encryption_entries_end_ - encryption_entries_;\n   assert(count >= 0);\n \n if (idx >= static_cast<unsigned long>(count))\n return NULL;\n\n return encryption_entries_[idx];\n}\n",
        "target": 1
    },
    {
        "id": 1300,
        "func": "clean_cell_pool(void)\n{\n  tor_assert(cell_pool);\n  mp_pool_clean(cell_pool, 0, 1);\n}",
        "target": 0
    },
    {
        "id": 1301,
        "func": "void fht16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n   vp9_fht16x16_c(in, out, stride, tx_type);\n }\n",
        "target": 1
    },
    {
        "id": 1302,
        "func": "bool PrintWebViewHelper::GetPrintSettingsFromUser(WebKit::WebFrame* frame,\n                                                  const WebKit::WebNode& node,\n                                                  int expected_pages_count,\n                                                  bool use_browser_overlays) {\n  PrintHostMsg_ScriptedPrint_Params params;\n  PrintMsg_PrintPages_Params print_settings;\n\n  params.host_window_id = render_view()->GetHostWindow();\n  params.cookie = print_pages_params_->params.document_cookie;\n  params.has_selection = frame->hasSelection();\n  params.expected_pages_count = expected_pages_count;\n  printing::MarginType margin_type = printing::DEFAULT_MARGINS;\n  if (PrintingNodeOrPdfFrame(frame, node))\n    margin_type = GetMarginsForPdf(frame, node);\n  params.margin_type = margin_type;\n \n   Send(new PrintHostMsg_DidShowPrintDialog(routing_id()));\n \n   print_pages_params_.reset();\n   IPC::SyncMessage* msg =\n       new PrintHostMsg_ScriptedPrint(routing_id(), params, &print_settings);\n   msg->EnableMessagePumping();\n   Send(msg);\n   print_pages_params_.reset(new PrintMsg_PrintPages_Params(print_settings));\n   return (print_settings.params.dpi && print_settings.params.document_cookie);\n }\n",
        "target": 1
    },
    {
        "id": 1303,
        "func": "static void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_shared_msrs *locals\n\t\t= container_of(urn, struct kvm_shared_msrs, urn);\n\tstruct kvm_shared_msr_values *values;\n\n\tfor (slot = 0; slot < shared_msrs_global.nr; ++slot) {\n\t\tvalues = &locals->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(shared_msrs_global.msrs[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n\tlocals->registered = false;\n\tuser_return_notifier_unregister(urn);\n}\n",
        "target": 0
    },
    {
        "id": 1304,
        "func": "bool TabsHighlightFunction::HighlightTab(TabStripModel* tabstrip,\n                                         ui::ListSelectionModel* selection,\n                                         int* active_index,\n                                         int index,\n                                         std::string* error) {\n  if (!tabstrip->ContainsIndex(index)) {\n    *error = ErrorUtils::FormatErrorMessage(keys::kTabIndexNotFoundError,\n                                            base::IntToString(index));\n    return false;\n  }\n\n  if (*active_index == -1)\n    *active_index = index;\n\n  selection->AddIndexToSelection(index);\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1305,
        "func": "bool HTMLMediaElement::seeking() const {\n  return seeking_;\n}\n",
        "target": 0
    },
    {
        "id": 1306,
        "func": "static jobject android_net_wifi_get_tdls_capabilities(JNIEnv *env, jclass cls, jint iface) {\n\n JNIHelper helper(env);\n    wifi_tdls_capabilities tdls_capabilities;\n    wifi_interface_handle handle = getIfaceHandle(helper, cls, iface);\n    wifi_error ret = hal_fn.wifi_get_tdls_capabilities(handle, &tdls_capabilities);\n\n if (WIFI_SUCCESS == ret) {\n JNIObject<jobject> capabilities = helper.createObject(\n \"com/android/server/wifi/WifiNative$TdlsCapabilities\");\n         helper.setIntField(capabilities, \"maxConcurrentTdlsSessionNumber\",\n                 tdls_capabilities.max_concurrent_tdls_session_num);\n         helper.setBooleanField(capabilities, \"isGlobalTdlsSupported\",\n                 tdls_capabilities.is_global_tdls_supported == 1);\n         helper.setBooleanField(capabilities, \"isPerMacTdlsSupported\",\n                 tdls_capabilities.is_per_mac_tdls_supported == 1);\n         helper.setBooleanField(capabilities, \"isOffChannelTdlsSupported\",\n                 tdls_capabilities.is_off_channel_tdls_supported);\n\n         ALOGD(\"TDLS Max Concurrent Tdls Session Number is: %d\",\n                 tdls_capabilities.max_concurrent_tdls_session_num);\n         ALOGD(\"Global Tdls is: %s\", tdls_capabilities.is_global_tdls_supported == 1 ? \"support\" :\n \"not support\");\n         ALOGD(\"Per Mac Tdls is: %s\", tdls_capabilities.is_per_mac_tdls_supported == 1 ? \"support\" :\n \"not support\");\n         ALOGD(\"Off Channel Tdls is: %s\", tdls_capabilities.is_off_channel_tdls_supported == 1 ?\n \"support\" : \"not support\");\n\n return capabilities.detach();\n } else {\n return NULL;\n }\n}\n",
        "target": 0
    },
    {
        "id": 1307,
        "func": "static int read_rom(struct edgeport_serial *serial,\n\t\t\t\tint start_address, int length, __u8 *buffer)\n{\n\tint status;\n\n\tif (serial->product_info.TiMode == TI_MODE_DOWNLOAD) {\n\t\tstatus = read_download_mem(serial->serial->dev,\n\t\t\t\t\t       start_address,\n\t\t\t\t\t       length,\n\t\t\t\t\t       serial->TI_I2C_Type,\n\t\t\t\t\t       buffer);\n\t} else {\n\t\tstatus = read_boot_mem(serial, start_address, length,\n\t\t\t\t\t\t\t\tbuffer);\n\t}\n\treturn status;\n}",
        "target": 0
    },
    {
        "id": 1308,
        "func": "static bool create_nic(char *nic, char *br, int pid, char **cnic)\n{\n\tchar *veth1buf, *veth2buf;\n\tveth1buf = alloca(IFNAMSIZ);\n\tveth2buf = alloca(IFNAMSIZ);\n\tint ret, mtu;\n\n\tret = snprintf(veth1buf, IFNAMSIZ, \"%s\", nic);\n\tif (ret < 0 || ret >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"host nic name too long\\n\");\n\t\treturn false;\n\t}\n\n\t/* create the nics */\n\tif (instantiate_veth(veth1buf, &veth2buf) < 0) {\n\t\tfprintf(stderr, \"Error creating veth tunnel\\n\");\n\t\treturn false;\n\t}\n\n\tif (strcmp(br, \"none\") != 0) {\n\t\t/* copy the bridge's mtu to both ends */\n\t\tmtu = get_mtu(br);\n\t\tif (mtu != -1) {\n\t\t\tif (lxc_netdev_set_mtu(veth1buf, mtu) < 0 ||\n\t\t\t\t\tlxc_netdev_set_mtu(veth2buf, mtu) < 0) {\n\t\t\t\tfprintf(stderr, \"Failed setting mtu\\n\");\n\t\t\t\tgoto out_del;\n\t\t\t}\n\t\t}\n\n\t\t/* attach veth1 to bridge */\n\t\tif (lxc_bridge_attach(lxcpath, lxcname, br, veth1buf) < 0) {\n\t\t\tfprintf(stderr, \"Error attaching %s to %s\\n\", veth1buf, br);\n\t\t\tgoto out_del;\n\t\t}\n\t}\n\n\t/* pass veth2 to target netns */\n\tret = lxc_netdev_move_by_name(veth2buf, pid, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Error moving %s to netns %d\\n\", veth2buf, pid);\n\t\tgoto out_del;\n\t}\n\t*cnic = strdup(veth2buf);\n\treturn true;\n\nout_del:\n\tlxc_netdev_delete_by_name(veth1buf);\n\treturn false;\n}",
        "target": 0
    },
    {
        "id": 1309,
        "func": "ProcUnmapWindow(ClientPtr client)\n{\n    WindowPtr pWin;\n\n    REQUEST(xResourceReq);\n    int rc;\n\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupWindow(&pWin, stuff->id, client, DixHideAccess);\n    if (rc != Success)\n        return rc;\n    UnmapWindow(pWin, FALSE);\n    /* update cache to say it is mapped */\n    return Success;\n}\n",
        "target": 0
    },
    {
        "id": 1310,
        "func": "swapReplace(int start, int end, const TranslationTableHeader *table,\n\t\tconst InString *input, OutString *output, int *posMapping,\n\t\tconst widechar *passInstructions, int passIC) {\n\tTranslationTableOffset swapRuleOffset;\n\tTranslationTableRule *swapRule;\n\twidechar *replacements;\n\tint p;\n\tswapRuleOffset = (passInstructions[passIC + 1] << 16) | passInstructions[passIC + 2];\n\tswapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];\n\treplacements = &swapRule->charsdots[swapRule->charslen];\n\tfor (p = start; p < end; p++) {\n\t\tint rep;\n\t\tint test;\n\t\tint k;\n\t\tif (swapRule->opcode == CTO_SwapDd) {\n\t\t\t// A sequence of dot patterns is encoded as the length of the first dot\n\t\t\t// pattern (single widechar) followed by the contents of the first dot pattern\n\t\t\t// (one widechar per cell) followed by the length of the second dot pattern,\n\t\t\t// etc. See the function `compileSwapDots'. Because the third operand of a\n\t\t\t// swapdd rule can only contain single-cell dot patterns, the elements at\n\t\t\t// index 0, 2, ... are \"1\" and the elements at index 1, 3, ... are the dot\n\t\t\t// patterns.\n\t\t\tfor (test = 0; test * 2 + 1 < swapRule->charslen; test++)\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test * 2 + 1]) break;\n\t\t\tif (test * 2 == swapRule->charslen) continue;\n\t\t} else {\n\t\t\tfor (test = 0; test < swapRule->charslen; test++)\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\tif (test == swapRule->charslen) continue;\n\t\t}\n\t\tk = 0;\n\t\tfor (rep = 0; rep < test; rep++)\n\t\t\tif (swapRule->opcode == CTO_SwapCc)\n\t\t\t\tk++;\n\t\t\telse\n\t\t\t\tk += replacements[k];\n\t\tif (swapRule->opcode == CTO_SwapCc) {\n\t\t\tif ((output->length + 1) > output->maxlength) return 0;\n\t\t\tposMapping[output->length] = p;\n\t\t\toutput->chars[output->length++] = replacements[k];\n\t\t} else {\n\t\t\tint l = replacements[k] - 1;\n\t\t\tint d = output->length + l;\n\t\t\tif (d > output->maxlength) return 0;\n\t\t\twhile (--d >= output->length) posMapping[d] = p;\n\t\t\tmemcpy(&output->chars[output->length], &replacements[k + 1],\n\t\t\t\t\tl * sizeof(*output->chars));\n\t\t\toutput->length += l;\n\t\t}\n\t}\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 1311,
        "func": "Vp9Parser::FrameInfo::FrameInfo(const uint8_t* ptr, off_t size)\n    : ptr(ptr), size(size) {}\n",
        "target": 1
    },
    {
        "id": 1312,
        "func": "PHP_METHOD(Phar, getSupportedCompression)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tarray_init(return_value);\n\tphar_request_initialize();\n\n\tif (PHAR_G(has_zlib)) {\n\t\tadd_next_index_stringl(return_value, \"GZ\", 2);\n\t}\n\n\tif (PHAR_G(has_bz2)) {\n\t\tadd_next_index_stringl(return_value, \"BZIP2\", 5);\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 1313,
        "func": " std::string SyncerProtoUtil::SyncEntityDebugString(\n     const sync_pb::SyncEntity& entry) {\n  const std::string& mtime_str =\n      GetTimeDebugString(ProtoTimeToTime(entry.mtime()));\n  const std::string& ctime_str =\n      GetTimeDebugString(ProtoTimeToTime(entry.ctime()));\n   return base::StringPrintf(\n       \"id: %s, parent_id: %s, \"\n       \"version: %\"PRId64\"d, \"\n      \"mtime: %\" PRId64\"d (%s), \"\n      \"ctime: %\" PRId64\"d (%s), \"\n       \"name: %s, sync_timestamp: %\" PRId64\"d, \"\n       \"%s \",\n       entry.id_string().c_str(),\n       entry.parent_id_string().c_str(),\n       entry.version(),\n      entry.mtime(), mtime_str.c_str(),\n      entry.ctime(), ctime_str.c_str(),\n       entry.name().c_str(), entry.sync_timestamp(),\n       entry.deleted() ? \"deleted, \":\"\");\n }\n",
        "target": 1
    },
    {
        "id": 1314,
        "func": "void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\t/* update jump label if enable bit changes */\n\tif ((vcpu->arch.apic_base ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif (!kvm_vcpu_is_bsp(apic->vcpu))\n\t\tvalue &= ~MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tu32 id = kvm_apic_id(apic);\n\t\t\tu32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));\n\t\t\tkvm_apic_set_ldr(apic, ldr);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}",
        "target": 0
    },
    {
        "id": 1315,
        "func": "void HttpStreamParser::GetSSLInfo(SSLInfo* ssl_info) {\n  if (request_->url.SchemeIs(\"https\") && connection_->socket()) {\n    SSLClientSocket* ssl_socket =\n        static_cast<SSLClientSocket*>(connection_->socket());\n    ssl_socket->GetSSLInfo(ssl_info);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1316,
        "func": "int cJSON_HasObjectItem(cJSON *object,const char *string)\t\t{return cJSON_GetObjectItem(object,string)?1:0;}",
        "target": 0
    },
    {
        "id": 1317,
        "func": "static int __init alsa_timer_init(void)\n{\n\tint err;\n\n\tsnd_device_initialize(&timer_dev, NULL);\n\tdev_set_name(&timer_dev, \"timer\");\n\n#ifdef SNDRV_OSS_INFO_DEV_TIMERS\n\tsnd_oss_info_register(SNDRV_OSS_INFO_DEV_TIMERS, SNDRV_CARDS - 1,\n\t\t\t      \"system timer\");\n#endif\n\n\terr = snd_timer_register_system();\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register system timer (%i)\\n\", err);\n\t\tput_device(&timer_dev);\n\t\treturn err;\n\t}\n\n\terr = snd_register_device(SNDRV_DEVICE_TYPE_TIMER, NULL, 0,\n\t\t\t\t  &snd_timer_f_ops, NULL, &timer_dev);\n\tif (err < 0) {\n\t\tpr_err(\"ALSA: unable to register timer device (%i)\\n\", err);\n\t\tsnd_timer_free_all();\n\t\tput_device(&timer_dev);\n\t\treturn err;\n\t}\n\n\tsnd_timer_proc_init();\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1318,
        "func": "static void show_symbol(struct seq_file *m, unsigned long address)\n{\n#ifdef CONFIG_KALLSYMS\n\tunsigned long offset, size;\n\tchar modname[MODULE_NAME_LEN], name[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_attrs(address, &size, &offset, modname, name) == 0) {\n\t\tseq_printf(m, \"%s+%#lx/%#lx\", name, offset, size);\n\t\tif (modname[0])\n\t\t\tseq_printf(m, \" [%s]\", modname);\n\t\treturn;\n\t}\n#endif\n\tseq_printf(m, \"%p\", (void *)address);\n}",
        "target": 0
    },
    {
        "id": 1319,
        "func": "status_t MediaPlayerService::AudioOutput::getPosition(uint32_t *position) const\n{\n Mutex::Autolock lock(mLock);\n if (mTrack == 0) return NO_INIT;\n return mTrack->getPosition(position);\n}\n",
        "target": 0
    },
    {
        "id": 1320,
        "func": "static int netlink_broadcast_deliver(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf &&\n\t    !test_bit(NETLINK_S_CONGESTED, &nlk->state)) {\n\t\tnetlink_skb_set_owner_r(skb, sk);\n\t\t__netlink_sendskb(sk, skb);\n\t\treturn atomic_read(&sk->sk_rmem_alloc) > (sk->sk_rcvbuf >> 1);\n\t}\n\treturn -1;\n}",
        "target": 0
    },
    {
        "id": 1321,
        "func": "void BrowserTabStripController::TabDetachedAt(TabContents* contents,\n                                               int model_index) {\n   hover_tab_selector_.CancelTabTransition();\n\n  tabstrip_->RemoveTabAt(model_index);\n}\n",
        "target": 1
    },
    {
        "id": 1322,
        "func": "float WebLocalFrameImpl::DistanceToNearestFindMatch(\n    const WebFloatPoint& point) {\n  float nearest_distance;\n  EnsureTextFinder().NearestFindMatch(point, &nearest_distance);\n  return nearest_distance;\n}\n",
        "target": 0
    },
    {
        "id": 1323,
        "func": "static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint offs, int count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * What the fuck is going on here?  We leave junk in the beginning\n\t * of ins and then check the field pretty close to that beginning?\n\t */\n\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n\t\treturn -EFAULT;\n\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\n\treturn store_instr(ins.channel, &ins);\n}",
        "target": 1
    },
    {
        "id": 1324,
        "func": "void QQuickWebViewExperimental::setAuthenticationDialog(QDeclarativeComponent* authenticationDialog)\n{\n    Q_D(QQuickWebView);\n    if (d->authenticationDialog == authenticationDialog)\n        return;\n    d->authenticationDialog = authenticationDialog;\n    emit authenticationDialogChanged();\n}\n",
        "target": 0
    },
    {
        "id": 1325,
        "func": "bool Document::childTypeAllowed(NodeType type) const\n{\n    switch (type) {\n    case ATTRIBUTE_NODE:\n    case CDATA_SECTION_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n    case DOCUMENT_NODE:\n    case ENTITY_NODE:\n    case NOTATION_NODE:\n    case TEXT_NODE:\n    case XPATH_NAMESPACE_NODE:\n        return false;\n    case COMMENT_NODE:\n    case PROCESSING_INSTRUCTION_NODE:\n        return true;\n    case DOCUMENT_TYPE_NODE:\n    case ELEMENT_NODE:\n        for (Node* c = firstChild(); c; c = c->nextSibling())\n            if (c->nodeType() == type)\n                return false;\n        return true;\n    }\n    return false;\n}\n",
        "target": 0
    },
    {
        "id": 1326,
        "func": "status_t MediaRecorder::setParameters(const String8& params) {\n    ALOGV(\"setParameters(%s)\", params.string());\n if (mMediaRecorder == NULL) {\n        ALOGE(\"media recorder is not initialized yet\");\n return INVALID_OPERATION;\n }\n\n bool isInvalidState = (mCurrentState &\n (MEDIA_RECORDER_PREPARED |\n                            MEDIA_RECORDER_RECORDING |\n                            MEDIA_RECORDER_ERROR));\n if (isInvalidState) {\n        ALOGE(\"setParameters is called in an invalid state: %d\", mCurrentState);\n return INVALID_OPERATION;\n }\n\n status_t ret = mMediaRecorder->setParameters(params);\n if (OK != ret) {\n        ALOGE(\"setParameters(%s) failed: %d\", params.string(), ret);\n }\n\n return ret;\n}\n",
        "target": 0
    },
    {
        "id": 1327,
        "func": "static inline void r_write_ble(void *dst, ut64 val, bool big_endian, int size) {\n\tswitch (size) {\n\tcase 8:\n\t\t((ut8*)dst)[0] = (ut8) val;\n\t\tbreak;\n\tcase 16:\n\t\tr_write_ble16 (dst, (ut16) val, big_endian);\n\t\tbreak;\n\tcase 24:\n\t\tr_write_ble24 (dst, (ut32) val, big_endian);\n\t\tbreak;\n\tcase 32:\n\t\tr_write_ble32 (dst, (ut32) val, big_endian);\n\t\tbreak;\n\tcase 64:\n\t\tr_write_ble64 (dst, val, big_endian);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
        "target": 0
    },
    {
        "id": 1328,
        "func": " SPL_METHOD(SplFileObject, fgets)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} /* }}} */\n\n/* {{{ proto string SplFileObject::current()\n",
        "target": 1
    },
    {
        "id": 1329,
        "func": "confirm_empty_trash (CommonJob *job)\n{\n    char *prompt;\n    int response;\n\n    /* Just Say Yes if the preference says not to confirm. */\n    if (!should_confirm_trash ())\n    {\n        return TRUE;\n    }\n\n    prompt = f (_(\"Empty all items from Trash?\"));\n\n    response = run_warning (job,\n                            prompt,\n                            f (_(\"All items in the Trash will be permanently deleted.\")),\n                            NULL,\n                            FALSE,\n                            CANCEL, _(\"Empty _Trash\"),\n                            NULL);\n\n    return (response == 1);\n}",
        "target": 0
    },
    {
        "id": 1330,
        "func": "void TabStripModel::SetTabBlocked(int index, bool blocked) {\n  DCHECK(ContainsIndex(index));\n  if (contents_data_[index]->blocked == blocked)\n    return;\n  contents_data_[index]->blocked = blocked;\n  FOR_EACH_OBSERVER(TabStripModelObserver, observers_,\n      TabBlockedStateChanged(contents_data_[index]->contents,\n      index));\n}\n",
        "target": 0
    },
    {
        "id": 1331,
        "func": "static void hns_xgmac_get_strings(u32 stringset, u8 *data)\n{\n\tchar *buff = (char *)data;\n\tu32 i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_xgmac_stats_string); i++) {\n\t\tsnprintf(buff, ETH_GSTRING_LEN, g_xgmac_stats_string[i].desc);\n\t\tbuff = buff + ETH_GSTRING_LEN;\n\t}\n}",
        "target": 0
    },
    {
        "id": 1332,
        "func": "static unsigned long mem_cgroup_reclaim(struct mem_cgroup *memcg,\n\t\t\t\t\tgfp_t gfp_mask,\n\t\t\t\t\tunsigned long flags)\n{\n\tunsigned long total = 0;\n\tbool noswap = false;\n\tint loop;\n\n\tif (flags & MEM_CGROUP_RECLAIM_NOSWAP)\n\t\tnoswap = true;\n\tif (!(flags & MEM_CGROUP_RECLAIM_SHRINK) && memcg->memsw_is_minimum)\n\t\tnoswap = true;\n\n\tfor (loop = 0; loop < MEM_CGROUP_MAX_RECLAIM_LOOPS; loop++) {\n\t\tif (loop)\n\t\t\tdrain_all_stock_async(memcg);\n\t\ttotal += try_to_free_mem_cgroup_pages(memcg, gfp_mask, noswap);\n\t\t/*\n\t\t * Allow limit shrinkers, which are triggered directly\n\t\t * by userspace, to catch signals and stop reclaim\n\t\t * after minimal progress, regardless of the margin.\n\t\t */\n\t\tif (total && (flags & MEM_CGROUP_RECLAIM_SHRINK))\n\t\t\tbreak;\n\t\tif (mem_cgroup_margin(memcg))\n\t\t\tbreak;\n\t\t/*\n\t\t * If nothing was reclaimed after two attempts, there\n\t\t * may be no reclaimable pages in this hierarchy.\n\t\t */\n\t\tif (loop && !total)\n\t\t\tbreak;\n\t}\n\treturn total;\n}",
        "target": 0
    },
    {
        "id": 1333,
        "func": "static int check_dr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint dr = ctxt->modrm_reg;\n\n\tif ((dr == 6 || dr == 7) && (new_val & 0xffffffff00000000ULL))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn check_dr_read(ctxt);\n}",
        "target": 0
    },
    {
        "id": 1334,
        "func": "static GF_StreamContext *gf_sm_get_stream(GF_SceneManager *ctx, u16 ESID)\n{\n\tu32 i, count;\n\tcount = gf_list_count(ctx->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_StreamContext *sc = gf_list_get(ctx->streams, i);\n\t\tif (sc->ESID==ESID) return sc;\n\t}\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 1335,
        "func": "struct sk_buff *__pskb_copy(struct sk_buff *skb, int headroom, gfp_t gfp_mask)\n{\n\tunsigned int size = skb_headlen(skb) + headroom;\n\tstruct sk_buff *n = __alloc_skb(size, gfp_mask,\n\t\t\t\t\tskb_alloc_rx_flag(skb), NUMA_NO_NODE);\n\n\tif (!n)\n\t\tgoto out;\n\n\t/* Set the data pointer */\n\tskb_reserve(n, headroom);\n\t/* Set the tail pointer and length */\n\tskb_put(n, skb_headlen(skb));\n\t/* Copy the bytes */\n\tskb_copy_from_linear_data(skb, n->data, n->len);\n\n\tn->truesize += skb->data_len;\n\tn->data_len  = skb->data_len;\n\tn->len\t     = skb->len;\n\n\tif (skb_shinfo(skb)->nr_frags) {\n\t\tint i;\n\n\t\tif (skb_orphan_frags(skb, gfp_mask)) {\n\t\t\tkfree_skb(n);\n\t\t\tn = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\t\tskb_shinfo(n)->frags[i] = skb_shinfo(skb)->frags[i];\n\t\t\tskb_frag_ref(skb, i);\n\t\t}\n\t\tskb_shinfo(n)->nr_frags = i;\n\t}\n\n\tif (skb_has_frag_list(skb)) {\n\t\tskb_shinfo(n)->frag_list = skb_shinfo(skb)->frag_list;\n\t\tskb_clone_fraglist(n);\n\t}\n\n\tcopy_skb_header(n, skb);\nout:\n\treturn n;\n}",
        "target": 0
    },
    {
        "id": 1336,
        "func": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}",
        "target": 1
    },
    {
        "id": 1337,
        "func": "void Document::updateBaseURL()\n{\n    KURL oldBaseURL = m_baseURL;\n    if (!m_baseElementURL.isEmpty())\n        m_baseURL = m_baseElementURL;\n    else if (!m_baseURLOverride.isEmpty())\n        m_baseURL = m_baseURLOverride;\n    else\n        m_baseURL = m_url;\n\n    selectorQueryCache().invalidate();\n\n    if (!m_baseURL.isValid())\n        m_baseURL = KURL();\n\n    if (m_elemSheet) {\n        ASSERT(!m_elemSheet->contents()->ruleCount());\n        bool usesRemUnits = m_elemSheet->contents()->usesRemUnits();\n        m_elemSheet = CSSStyleSheet::createInline(this, m_baseURL);\n        m_elemSheet->contents()->parserSetUsesRemUnits(usesRemUnits);\n    }\n\n    if (!equalIgnoringFragmentIdentifier(oldBaseURL, m_baseURL)) {\n        for (HTMLAnchorElement& anchor : Traversal<HTMLAnchorElement>::startsAfter(*this))\n            anchor.invalidateCachedVisitedLinkHash();\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1338,
        "func": "Guint JBIG2HuffmanDecoder::readBit() {\n  if (bufLen == 0) {\n    buf = str->getChar();\n    bufLen = 8;\n  }\n  --bufLen;\n  return (buf >> bufLen) & 1;\n}\n",
        "target": 0
    },
    {
        "id": 1339,
        "func": "box_diagonal(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box = PG_GETARG_BOX_P(0);\n\tLSEG\t   *result = (LSEG *) palloc(sizeof(LSEG));\n\n\tstatlseg_construct(result, &box->high, &box->low);\n\n\tPG_RETURN_LSEG_P(result);\n}",
        "target": 0
    },
    {
        "id": 1340,
        "func": "static inline int vmcs_field_type(unsigned long field)\n{\n\tif (0x1 & field)\t/* the *_HIGH fields are all 32 bit */\n\t\treturn VMCS_FIELD_TYPE_U32;\n\treturn (field >> 13) & 0x3 ;\n}",
        "target": 0
    },
    {
        "id": 1341,
        "func": "static ssize_t snd_compr_write(struct file *f, const char __user *buf,\n\t\tsize_t count, loff_t *offset)\n{\n\tstruct snd_compr_file *data = f->private_data;\n\tstruct snd_compr_stream *stream;\n\tsize_t avail;\n\tint retval;\n\n\tif (snd_BUG_ON(!data))\n\t\treturn -EFAULT;\n\n\tstream = &data->stream;\n\tmutex_lock(&stream->device->lock);\n\t/* write is allowed when stream is running or has been steup */\n\tif (stream->runtime->state != SNDRV_PCM_STATE_SETUP &&\n\t\t\tstream->runtime->state != SNDRV_PCM_STATE_RUNNING) {\n\t\tmutex_unlock(&stream->device->lock);\n\t\treturn -EBADFD;\n\t}\n\n\tavail = snd_compr_get_avail(stream);\n\tpr_debug(\"avail returned %ld\\n\", (unsigned long)avail);\n\t/* calculate how much we can write to buffer */\n\tif (avail > count)\n\t\tavail = count;\n\n\tif (stream->ops->copy) {\n\t\tchar __user* cbuf = (char __user*)buf;\n\t\tretval = stream->ops->copy(stream, cbuf, avail);\n\t} else {\n\t\tretval = snd_compr_write_data(stream, buf, avail);\n\t}\n\tif (retval > 0)\n\t\tstream->runtime->total_bytes_available += retval;\n\n\t/* while initiating the stream, write should be called before START\n\t * call, so in setup move state */\n\tif (stream->runtime->state == SNDRV_PCM_STATE_SETUP) {\n\t\tstream->runtime->state = SNDRV_PCM_STATE_PREPARED;\n\t\tpr_debug(\"stream prepared, Houston we are good to go\\n\");\n\t}\n\n\tmutex_unlock(&stream->device->lock);\n\treturn retval;\n}",
        "target": 0
    },
    {
        "id": 1342,
        "func": "void CuePoint::TrackPosition::Parse(\n    IMkvReader* pReader,\n    long long start_,\n    long long size_)\n{\n    const long long stop = start_ + size_;\n    long long pos = start_;\n \n    m_track = -1;\n    m_pos = -1;\n    m_block = 1;  //default\n \n    while (pos < stop)\n    {\n        long len;\n \n        const long long id = ReadUInt(pReader, pos, len);\n        assert(id >= 0);  //TODO\n        assert((pos + len) <= stop);\n \n        pos += len;  //consume ID\n \n        const long long size = ReadUInt(pReader, pos, len);\n        assert(size >= 0);\n        assert((pos + len) <= stop);\n \n        pos += len;  //consume Size field\n        assert((pos + size) <= stop);\n \n        if (id == 0x77)  //CueTrack ID\n            m_track = UnserializeUInt(pReader, pos, size);\n \n        else if (id == 0x71)  //CueClusterPos ID\n            m_pos = UnserializeUInt(pReader, pos, size);\n \n        else if (id == 0x1378)  //CueBlockNumber\n            m_block = UnserializeUInt(pReader, pos, size);\n        pos += size;  //consume payload\n        assert(pos <= stop);\n    }\n    assert(m_pos >= 0);\n    assert(m_track > 0);\n }\n",
        "target": 1
    },
    {
        "id": 1343,
        "func": "static int nfs4_xdr_dec_lookup(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_lookup_res *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\t\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tif ((status = decode_compound_hdr(&xdr, &hdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_putfh(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_lookup(&xdr)) != 0)\n\t\tgoto out;\n\tif ((status = decode_getfh(&xdr, res->fh)) != 0)\n\t\tgoto out;\n\tstatus = decode_getfattr(&xdr, res->fattr, res->server);\nout:\n\treturn status;\n}",
        "target": 0
    },
    {
        "id": 1344,
        "func": "void bt_sock_link(struct bt_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock(&l->lock);\n}",
        "target": 0
    },
    {
        "id": 1345,
        "func": "static inline bool vbe_enabled(VGACommonState *s)\n{\n    return s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED;\n}\n",
        "target": 0
    },
    {
        "id": 1346,
        "func": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\n\t/*\n\t * We take the read lock around doing both checks to close a\n\t * possible race where someone else was tracing our child and\n\t * detached between these two checks.  After this locked check,\n\t * we are sure that this is our traced child and that can only\n\t * be changed by us so it's not changing right after this.\n\t */\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\t/*\n\t\t * child->sighand can't be NULL, release_task()\n\t\t * does ptrace_unlink() before __exit_signal().\n\t\t */\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\n\t/* All systems go.. */\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 1347,
        "func": "static void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tunsigned int i;\n\tjp2_cmapent_t *ent;\n\tfprintf(out, \"numchans = %d\\n\", (int) cmap->numchans);\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tfprintf(out, \"cmptno=%d; map=%d; pcol=%d\\n\",\n\t\t  (int) ent->cmptno, (int) ent->map, (int) ent->pcol);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1348,
        "func": "void DataReductionProxyConfig::InitializeOnIOThread(\n    scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,\n    WarmupURLFetcher::CreateCustomProxyConfigCallback\n        create_custom_proxy_config_callback,\n    NetworkPropertiesManager* manager) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  network_properties_manager_ = manager;\n  network_properties_manager_->ResetWarmupURLFetchMetrics();\n\n  secure_proxy_checker_.reset(new SecureProxyChecker(url_loader_factory));\n  warmup_url_fetcher_.reset(new WarmupURLFetcher(\n      url_loader_factory, create_custom_proxy_config_callback,\n      base::BindRepeating(\n          &DataReductionProxyConfig::HandleWarmupFetcherResponse,\n          base::Unretained(this)),\n      base::BindRepeating(&DataReductionProxyConfig::GetHttpRttEstimate,\n                           base::Unretained(this)),\n       ui_task_runner_));\n \n  if (ShouldAddDefaultProxyBypassRules())\n    AddDefaultProxyBypassRules();\n \n   network_connection_tracker_->AddNetworkConnectionObserver(this);\n   network_connection_tracker_->GetConnectionType(\n      &connection_type_,\n      base::BindOnce(&DataReductionProxyConfig::OnConnectionChanged,\n                      weak_factory_.GetWeakPtr()));\n }\n",
        "target": 1
    },
    {
        "id": 1349,
        "func": "BluetoothSocketSendFunction::BluetoothSocketSendFunction()\n    : io_buffer_size_(0) {}\n",
        "target": 0
    },
    {
        "id": 1350,
        "func": "get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n\tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n\tint i;\n\n\twhile (leftover) {\n\t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n\n\t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\n\t\tleftover -= mc_size;\n\n\t\t/*\n\t\t * Since APs with same family and model as the BSP may boot in\n\t\t * the platform, we need to find and save microcode patches\n\t\t * with the same family and model as the BSP.\n\t\t */\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\n\t\tucode_ptr += mc_size;\n\t}\n\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}",
        "target": 1
    },
    {
        "id": 1351,
        "func": "int ext4_ext_truncate(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t last_block;\n\tint err = 0;\n\n\t/*\n\t * TODO: optimization is possible here.\n\t * Probably we need not scan at all,\n\t * because page truncation is enough.\n\t */\n\n\t/* we have to know where to truncate from in crash case */\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err)\n\t\treturn err;\n\n\tlast_block = (inode->i_size + sb->s_blocksize - 1)\n\t\t\t>> EXT4_BLOCK_SIZE_BITS(sb);\nretry:\n\terr = ext4_es_remove_extent(inode, last_block,\n\t\t\t\t    EXT_MAX_BLOCKS - last_block);\n\tif (err == -ENOMEM) {\n\t\tcond_resched();\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\tgoto retry;\n\t}\n\tif (err)\n\t\treturn err;\n\treturn ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCKS - 1);\n}",
        "target": 0
    },
    {
        "id": 1352,
        "func": "check_type_tree(Node* node, int type_mask, int bag_mask, int anchor_mask)\n{\n  NodeType type;\n  int r = 0;\n\n  type = NODE_TYPE(node);\n  if ((NODE_TYPE2BIT(type) & type_mask) == 0)\n    return 1;\n\n  switch (type) {\n  case NODE_LIST:\n  case NODE_ALT:\n    do {\n      r = check_type_tree(NODE_CAR(node), type_mask, bag_mask, anchor_mask);\n    } while (r == 0 && IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_QUANT:\n    r = check_type_tree(NODE_BODY(node), type_mask, bag_mask, anchor_mask);\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      if (((1<<en->type) & bag_mask) == 0)\n        return 1;\n\n      r = check_type_tree(NODE_BODY(node), type_mask, bag_mask, anchor_mask);\n      if (r == 0 && en->type == BAG_IF_ELSE) {\n        if (IS_NOT_NULL(en->te.Then)) {\n          r = check_type_tree(en->te.Then, type_mask, bag_mask, anchor_mask);\n          if (r != 0) break;\n        }\n        if (IS_NOT_NULL(en->te.Else)) {\n          r = check_type_tree(en->te.Else, type_mask, bag_mask, anchor_mask);\n        }\n      }\n    }\n    break;\n\n  case NODE_ANCHOR:\n    type = ANCHOR_(node)->type;\n    if ((type & anchor_mask) == 0)\n      return 1;\n\n    if (IS_NOT_NULL(NODE_BODY(node)))\n      r = check_type_tree(NODE_BODY(node), type_mask, bag_mask, anchor_mask);\n    break;\n\n  case NODE_GIMMICK:\n  default:\n    break;\n  }\n  return r;\n}",
        "target": 0
    },
    {
        "id": 1353,
        "func": "GF_Err gnrv_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 1354,
        "func": "static FORCEINLINE void GetThreadCache(nedpool **p, threadcache **tc, int *mymspace, size_t *size) THROWSPEC\n{\n\tint mycache;\n\tif(size && *size<sizeof(threadcacheblk)) *size=sizeof(threadcacheblk);\n\tif(!*p)\n\t{\n\t\t*p=&syspool;\n\t\tif(!syspool.threads) InitPool(&syspool, 0, -1);\n\t}\n\tmycache=(int)(size_t) TLSGET((*p)->mycache);\n\tif(mycache>0)\n\t{\n\t\t*tc=(*p)->caches[mycache-1];\n\t\t*mymspace=(*tc)->mymspace;\n\t}\n\telse if(!mycache)\n\t{\n\t\t*tc=AllocCache(*p);\n\t\tif(!*tc)\n\t\t{\t/* Disable */\n\t\t\tif(TLSSET((*p)->mycache, (void *)-1)) abort();\n\t\t\t*mymspace=0;\n\t\t}\n\t\telse\n\t\t\t*mymspace=(*tc)->mymspace;\n\t}\n\telse\n\t{\n\t\t*tc=0;\n\t\t*mymspace=-mycache-1;\n\t}\n\tassert(*mymspace>=0);\n\tassert((long)(size_t)CURRENT_THREAD==(*tc)->threadid);\n#ifdef FULLSANITYCHECKS\n\tif(*tc)\n\t{\n\t\tif(*(unsigned int *)\"NEDMALC1\"!=(*tc)->magic1 || *(unsigned int *)\"NEDMALC2\"!=(*tc)->magic2)\n\t\t{\n\t\t\tabort();\n\t\t}\n\t}\n#endif\n}",
        "target": 0
    },
    {
        "id": 1355,
        "func": "destroy_one_secret (gpointer data)\n{\n \tchar *secret = (char *) data;\n \n \t/* Don't leave the secret lying around in memory */\ng_message (\"%s: destroying %s\", __func__, secret);\n \tmemset (secret, 0, strlen (secret));\n \tg_free (secret);\n }\n",
        "target": 1
    },
    {
        "id": 1356,
        "func": "GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.\n{\n\tif (ms)\n\t{\n\t\tuint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}\n\treturn GPMF_ERROR_BAD_STRUCTURE;\n}",
        "target": 0
    },
    {
        "id": 1357,
        "func": "static int mov_read_smdm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    const int chroma_den = 50000;\n    const int luma_den = 10000;\n    int i, j, version;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Mastering Display Metadata box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported Mastering Display Metadata box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    sc->mastering = av_mastering_display_metadata_alloc();\n    if (!sc->mastering)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 2; j++)\n            sc->mastering->display_primaries[i][j] =\n                av_make_q(lrint(((double)avio_rb16(pb) / (1 << 16)) * chroma_den), chroma_den);\n    for (i = 0; i < 2; i++)\n        sc->mastering->white_point[i] =\n            av_make_q(lrint(((double)avio_rb16(pb) / (1 << 16)) * chroma_den), chroma_den);\n    sc->mastering->max_luminance =\n        av_make_q(lrint(((double)avio_rb32(pb) / (1 <<  8)) * luma_den), luma_den);\n    sc->mastering->min_luminance =\n        av_make_q(lrint(((double)avio_rb32(pb) / (1 << 14)) * luma_den), luma_den);\n\n    sc->mastering->has_primaries = 1;\n    sc->mastering->has_luminance = 1;\n\n    return 0;\n}",
        "target": 0
    },
    {
        "id": 1358,
        "func": "xmlXPathNextNamespace(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (ctxt->context->node->type != XML_ELEMENT_NODE) return(NULL);\n    if (ctxt->context->tmpNsList == NULL && cur != (xmlNodePtr) xmlXPathXMLNamespace) {\n        if (ctxt->context->tmpNsList != NULL)\n\t    xmlFree(ctxt->context->tmpNsList);\n\tctxt->context->tmpNsList =\n\t    xmlGetNsList(ctxt->context->doc, ctxt->context->node);\n\tctxt->context->tmpNsNr = 0;\n\tif (ctxt->context->tmpNsList != NULL) {\n\t    while (ctxt->context->tmpNsList[ctxt->context->tmpNsNr] != NULL) {\n\t\tctxt->context->tmpNsNr++;\n\t    }\n\t}\n\treturn((xmlNodePtr) xmlXPathXMLNamespace);\n    }\n    if (ctxt->context->tmpNsNr > 0) {\n\treturn (xmlNodePtr)ctxt->context->tmpNsList[--ctxt->context->tmpNsNr];\n    } else {\n\tif (ctxt->context->tmpNsList != NULL)\n\t    xmlFree(ctxt->context->tmpNsList);\n\tctxt->context->tmpNsList = NULL;\n\treturn(NULL);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1359,
        "func": "void LayerTreeHost::QueueSwapPromise(\n    std::unique_ptr<SwapPromise> swap_promise) {\n  swap_promise_manager_.QueueSwapPromise(std::move(swap_promise));\n}\n",
        "target": 0
    },
    {
        "id": 1360,
        "func": "void Player::cancelAnimationOnCompositor()\n{\n    if (hasActiveAnimationsOnCompositor())\n        toAnimation(m_content.get())->cancelAnimationOnCompositor();\n}\n",
        "target": 0
    },
    {
        "id": 1361,
        "func": "void Automation::GoBack(int tab_id, Error** error) {\n  int windex = 0, tab_index = 0;\n  *error = GetIndicesForTab(tab_id, &windex, &tab_index);\n  if (*error)\n    return;\n\n  std::string error_msg;\n  if (!SendGoBackJSONRequest(automation(), windex, tab_index, &error_msg))\n    *error = new Error(kUnknownError, error_msg);\n}\n",
        "target": 0
    },
    {
        "id": 1362,
        "func": "bool HTMLInputElement::MatchesDefaultPseudoClass() const {\n  return input_type_->MatchesDefaultPseudoClass();\n}\n",
        "target": 0
    },
    {
        "id": 1363,
        "func": "int shash_ahash_digest(struct ahash_request *req, struct shash_desc *desc)\n{\n\tstruct scatterlist *sg = req->src;\n\tunsigned int offset = sg->offset;\n\tunsigned int nbytes = req->nbytes;\n\tint err;\n\n\tif (nbytes < min(sg->length, ((unsigned int)(PAGE_SIZE)) - offset)) {\n\t\tvoid *data;\n\n\t\tdata = kmap_atomic(sg_page(sg));\n\t\terr = crypto_shash_digest(desc, data + offset, nbytes,\n\t\t\t\t\t  req->result);\n\t\tkunmap_atomic(data);\n\t\tcrypto_yield(desc->flags);\n\t} else\n\t\terr = crypto_shash_init(desc) ?:\n\t\t      shash_ahash_finup(req, desc);\n\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 1364,
        "func": "static void virtio_net_save(QEMUFile *f, void *opaque)\n{\n    int i;\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    /* At this point, backend must be stopped, otherwise\n     * it might keep writing to memory. */\n    assert(!n->vhost_started);\n    virtio_save(vdev, f);\n\n    qemu_put_buffer(f, n->mac, ETH_ALEN);\n    qemu_put_be32(f, n->vqs[0].tx_waiting);\n    qemu_put_be32(f, n->mergeable_rx_bufs);\n    qemu_put_be16(f, n->status);\n    qemu_put_byte(f, n->promisc);\n    qemu_put_byte(f, n->allmulti);\n    qemu_put_be32(f, n->mac_table.in_use);\n    qemu_put_buffer(f, n->mac_table.macs, n->mac_table.in_use * ETH_ALEN);\n    qemu_put_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);\n    qemu_put_be32(f, n->has_vnet_hdr);\n    qemu_put_byte(f, n->mac_table.multi_overflow);\n    qemu_put_byte(f, n->mac_table.uni_overflow);\n    qemu_put_byte(f, n->alluni);\n    qemu_put_byte(f, n->nomulti);\n    qemu_put_byte(f, n->nouni);\n    qemu_put_byte(f, n->nobcast);\n    qemu_put_byte(f, n->has_ufo);\n    if (n->max_queues > 1) {\n        qemu_put_be16(f, n->max_queues);\n        qemu_put_be16(f, n->curr_queues);\n        for (i = 1; i < n->curr_queues; i++) {\n            qemu_put_be32(f, n->vqs[i].tx_waiting);\n        }\n    }\n\n    if ((1 << VIRTIO_NET_F_CTRL_GUEST_OFFLOADS) & vdev->guest_features) {\n        qemu_put_be64(f, n->curr_guest_offloads);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1365,
        "func": "void RenderMessageFilter::OnCreateWindow(\n    const ViewHostMsg_CreateWindow_Params& params,\n    int* route_id,\n    int* surface_id,\n    int64* cloned_session_storage_namespace_id) {\n   bool no_javascript_access;\n   bool can_create_window =\n       GetContentClient()->browser()->CanCreateWindow(\n          params.opener_url,\n          params.opener_security_origin,\n           params.window_container_type,\n           resource_context_,\n           render_process_id_,\n          &no_javascript_access);\n\n  if (!can_create_window) {\n    *route_id = MSG_ROUTING_NONE;\n    *surface_id = 0;\n    return;\n  }\n\n  scoped_refptr<SessionStorageNamespaceImpl> cloned_namespace =\n      new SessionStorageNamespaceImpl(dom_storage_context_,\n                                      params.session_storage_namespace_id);\n  *cloned_session_storage_namespace_id = cloned_namespace->id();\n\n  render_widget_helper_->CreateNewWindow(params,\n                                         no_javascript_access,\n                                         peer_handle(),\n                                         route_id,\n                                         surface_id,\n                                         cloned_namespace);\n}\n",
        "target": 0
    },
    {
        "id": 1366,
        "func": "static int cxusb_dualdig4_rev2_tuner_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dib0700_adapter_state *st = adap->priv;\n\tstruct i2c_adapter *tun_i2c;\n\n\t/*\n\t * No need to call dvb7000p_attach here, as it was called\n\t * already, as frontend_attach method is called first, and\n\t * tuner_attach is only called on sucess.\n\t */\n\ttun_i2c = st->dib7000p_ops.get_i2c_master(adap->fe_adap[0].fe,\n\t\t\t\t\tDIBX000_I2C_INTERFACE_TUNER, 1);\n\n\tif (dvb_attach(dib0070_attach, adap->fe_adap[0].fe, tun_i2c,\n\t    &dib7070p_dib0070_config) == NULL)\n\t\treturn -ENODEV;\n\n\tst->set_param_save = adap->fe_adap[0].fe->ops.tuner_ops.set_params;\n\tadap->fe_adap[0].fe->ops.tuner_ops.set_params = dib7070_set_param_override;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1367,
        "func": "void PromoResourceService::ScheduleNotification(double promo_start,\n                                                double promo_end) {\n  if (promo_start > 0 && promo_end > 0) {\n    const int64 ms_until_start =\n        static_cast<int64>((base::Time::FromDoubleT(\n            promo_start) - base::Time::Now()).InMilliseconds());\n    const int64 ms_until_end =\n        static_cast<int64>((base::Time::FromDoubleT(\n            promo_end) - base::Time::Now()).InMilliseconds());\n    if (ms_until_start > 0) {\n       PostNotification(ms_until_start);\n     } else if (ms_until_end > 0) {\n       if (ms_until_start <= 0) {\n         PostNotification(0);\n       }\n       PostNotification(ms_until_end);\n     }\n   }\n }\n",
        "target": 1
    },
    {
        "id": 1368,
        "func": "static int kvm_is_user_mode(void)\n{\n\tint user_mode = 3;\n\n\tif (__this_cpu_read(current_vcpu))\n\t\tuser_mode = kvm_x86_ops->get_cpl(__this_cpu_read(current_vcpu));\n\n\treturn user_mode != 0;\n}",
        "target": 0
    },
    {
        "id": 1369,
        "func": "void String8::toLower(size_t start, size_t length)\n{\n const size_t len = size();\n if (start >= len) {\n return;\n }\n if (start+length > len) {\n        length = len-start;\n }\n char* buf = lockBuffer(len);\n    buf += start;\n while (length > 0) {\n *buf = tolower(*buf);\n        buf++;\n        length--;\n }\n    unlockBuffer(len);\n}\n",
        "target": 0
    },
    {
        "id": 1370,
        "func": "bool Job::GetDnsFromLocalCache(const std::string& host,\n                               ResolveDnsOperation op,\n                               std::string* output,\n                               bool* return_value) {\n  CheckIsOnWorkerThread();\n\n  DnsCache::const_iterator it = dns_cache_.find(MakeDnsCacheKey(host, op));\n  if (it == dns_cache_.end())\n    return false;\n\n  *output = it->second;\n  *return_value = !it->second.empty();\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1371,
        "func": " bool CreateIpcChannel(\n     const std::string& channel_name,\n     const std::string& pipe_security_descriptor,\n    scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,\n    IPC::Listener* delegate,\n    scoped_ptr<IPC::ChannelProxy>* channel_out) {\n   SECURITY_ATTRIBUTES security_attributes;\n   security_attributes.nLength = sizeof(security_attributes);\n  security_attributes.bInheritHandle = FALSE;\n\n  ULONG security_descriptor_length = 0;\n  if (!ConvertStringSecurityDescriptorToSecurityDescriptor(\n          UTF8ToUTF16(pipe_security_descriptor).c_str(),\n          SDDL_REVISION_1,\n          reinterpret_cast<PSECURITY_DESCRIPTOR*>(\n              &security_attributes.lpSecurityDescriptor),\n          &security_descriptor_length)) {\n    LOG_GETLASTERROR(ERROR) <<\n        \"Failed to create a security descriptor for the Chromoting IPC channel\";\n    return false;\n  }\n\n  std::string pipe_name(kChromePipeNamePrefix);\n  pipe_name.append(channel_name);\n\n  base::win::ScopedHandle pipe;\n  pipe.Set(CreateNamedPipe(\n      UTF8ToUTF16(pipe_name).c_str(),\n      PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,\n      PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,\n      1,\n      IPC::Channel::kReadBufferSize,\n      IPC::Channel::kReadBufferSize,\n      5000,\n      &security_attributes));\n  if (!pipe.IsValid()) {\n    LOG_GETLASTERROR(ERROR) <<\n        \"Failed to create the server end of the Chromoting IPC channel\";\n    LocalFree(security_attributes.lpSecurityDescriptor);\n    return false;\n  }\n \n   LocalFree(security_attributes.lpSecurityDescriptor);\n \n  channel_out->reset(new IPC::ChannelProxy(\n      IPC::ChannelHandle(pipe),\n      IPC::Channel::MODE_SERVER,\n      delegate,\n      io_task_runner));\n   return true;\n }\n",
        "target": 1
    },
    {
        "id": 1372,
        "func": "parse_mime(struct magic_set *ms, struct magic_entry *me, const char *line)\n{\n\tstruct magic *m = &me->mp[0];\n\n\treturn parse_extra(ms, me, line, offsetof(struct magic, mimetype),\n\t    sizeof(m->mimetype), \"MIME\", 1);\n}",
        "target": 0
    },
    {
        "id": 1373,
        "func": " void BluetoothDeviceChooserController::PostErrorCallback(\n    WebBluetoothResult error) {\n   if (!base::ThreadTaskRunnerHandle::Get()->PostTask(\n           FROM_HERE, base::BindOnce(error_callback_, error))) {\n     LOG(WARNING) << \"No TaskRunner.\";\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1374,
        "func": "static int vol_effect_process(effect_handle_t self,\n audio_buffer_t *in_buffer,\n audio_buffer_t *out_buffer)\n{\n int status = 0;\n    ALOGV(\"%s Called \", __func__);\n\n vol_listener_context_t *context = (vol_listener_context_t *)self;\n    pthread_mutex_lock(&vol_listner_init_lock);\n\n if (context->state != VOL_LISTENER_STATE_ACTIVE) {\n        ALOGE(\"%s: state is not active .. return error\", __func__);\n        status = -EINVAL;\n goto exit;\n }\n\n if (in_buffer->raw != out_buffer->raw) {\n        memcpy(out_buffer->raw, in_buffer->raw, out_buffer->frameCount * 2 * sizeof(int16_t));\n } else {\n        ALOGW(\"%s: something wrong, didn't handle in_buffer and out_buffer same address case\",\n              __func__);\n }\n\nexit:\n    pthread_mutex_unlock(&vol_listner_init_lock);\n return status;\n}\n",
        "target": 0
    },
    {
        "id": 1375,
        "func": "SProcPseudoramiXGetState(ClientPtr client)\n{\n    REQUEST(xPanoramiXGetStateReq);\n\n    TRACE;\n\n    swaps(&stuff->length);\n    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);\n    return ProcPseudoramiXGetState(client);\n}\n",
        "target": 0
    },
    {
        "id": 1376,
        "func": "bool RenderFrameHostImpl::CanAccessFilesOfPageState(const PageState& state) {\n  return ChildProcessSecurityPolicyImpl::GetInstance()->CanReadAllFiles(\n      GetProcess()->GetID(), state.GetReferencedFiles());\n}\n",
        "target": 0
    },
    {
        "id": 1377,
        "func": "static int pcrypt_init_padata(struct padata_pcrypt *pcrypt,\n\t\t\t      const char *name)\n{\n\tint ret = -ENOMEM;\n\tstruct pcrypt_cpumask *mask;\n\n\tget_online_cpus();\n\n\tpcrypt->wq = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM | WQ_CPU_INTENSIVE,\n\t\t\t\t     1, name);\n\tif (!pcrypt->wq)\n\t\tgoto err;\n\n\tpcrypt->pinst = padata_alloc_possible(pcrypt->wq);\n\tif (!pcrypt->pinst)\n\t\tgoto err_destroy_workqueue;\n\n\tmask = kmalloc(sizeof(*mask), GFP_KERNEL);\n\tif (!mask)\n\t\tgoto err_free_padata;\n\tif (!alloc_cpumask_var(&mask->mask, GFP_KERNEL)) {\n\t\tkfree(mask);\n\t\tgoto err_free_padata;\n\t}\n\n\tcpumask_and(mask->mask, cpu_possible_mask, cpu_online_mask);\n\trcu_assign_pointer(pcrypt->cb_cpumask, mask);\n\n\tpcrypt->nblock.notifier_call = pcrypt_cpumask_change_notify;\n\tret = padata_register_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);\n\tif (ret)\n\t\tgoto err_free_cpumask;\n\n\tret = pcrypt_sysfs_add(pcrypt->pinst, name);\n\tif (ret)\n\t\tgoto err_unregister_notifier;\n\n\tput_online_cpus();\n\n\treturn ret;\n\nerr_unregister_notifier:\n\tpadata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);\nerr_free_cpumask:\n\tfree_cpumask_var(mask->mask);\n\tkfree(mask);\nerr_free_padata:\n\tpadata_free(pcrypt->pinst);\nerr_destroy_workqueue:\n\tdestroy_workqueue(pcrypt->wq);\nerr:\n\tput_online_cpus();\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1378,
        "func": "bool UpdateValue(T* dest, const T& src) {\n  if (*dest == src)\n    return false;\n  *dest = src;\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1379,
        "func": "    int readOutBytes(char* outputBuffer, unsigned askedToRead) {\n        unsigned bytesLeft = m_buffer.size() - m_currentOffset;\n        unsigned lenToCopy = min(askedToRead, bytesLeft);\n        if (lenToCopy) {\n            memcpy(outputBuffer, m_buffer.data() + m_currentOffset, lenToCopy);\n            m_currentOffset += lenToCopy;\n        }\n        return lenToCopy;\n    }\n",
        "target": 0
    },
    {
        "id": 1380,
        "func": "static int find_unused_picture(H264Context *h)\n{\n    int i;\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (pic_is_unused(h, &h->DPB[i]))\n            break;\n    }\n    if (i == MAX_PICTURE_COUNT)\n        return AVERROR_INVALIDDATA;\n\n    if (h->DPB[i].needs_realloc) {\n        h->DPB[i].needs_realloc = 0;\n        unref_picture(h, &h->DPB[i]);\n    }\n\n    return i;\n}",
        "target": 0
    },
    {
        "id": 1381,
        "func": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n\n        /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n\n        g_return_val_if_fail (client != NULL, TRUE);\n\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}",
        "target": 1
    },
    {
        "id": 1382,
        "func": "static bool shouldAutofocusOnAttach(const HTMLFormControlElement* element)\n{\n    if (!element->isAutofocusable())\n        return false;\n    if (element->document().isSandboxed(SandboxAutomaticFeatures)) {\n        element->document().addConsoleMessage(ConsoleMessage::create(SecurityMessageSource, ErrorMessageLevel, \"Blocked autofocusing on a form control because the form's frame is sandboxed and the 'allow-scripts' permission is not set.\"));\n        return false;\n    }\n\n    return true;\n}\n",
        "target": 0
    },
    {
        "id": 1383,
        "func": "void GpuProcessHost::OnProcessCrashed(int exit_code) {\n   int process_crash_exit_code = exit_code;\n   base::debug::Alias(&process_crash_exit_code);\n \n  // Record crash before doing anything that could start a new GPU process.\n  RecordProcessCrash();\n\n  if (activity_flags_.IsFlagSet(\n          gpu::ActivityFlagsBase::FLAG_LOADING_PROGRAM_BINARY)) {\n    for (auto cache_key : client_id_to_shader_cache_) {\n      GetShaderCacheFactorySingleton()->ClearByClientId(\n          cache_key.first, base::Time(), base::Time::Max(), base::Bind([] {}));\n     }\n   }\n   SendOutstandingReplies(EstablishChannelStatus::GPU_HOST_INVALID);\n \n   ChildProcessTerminationInfo info =\n       process_->GetTerminationInfo(true /* known_dead */);\n  GpuDataManagerImpl::GetInstance()->ProcessCrashed(info.status);\n}\n",
        "target": 0
    },
    {
        "id": 1384,
        "func": "void TabStripModel::UpdateTabContentsStateAt(int index,\n    TabStripModelObserver::TabChangeType change_type) {\n  DCHECK(ContainsIndex(index));\n\n  FOR_EACH_OBSERVER(TabStripModelObserver, observers_,\n      TabChangedAt(GetTabContentsAtImpl(index), index, change_type));\n}\n",
        "target": 0
    },
    {
        "id": 1385,
        "func": "    void writeFile(const File& file)\n    {\n        append(FileTag);\n        doWriteFile(file);\n    }\n",
        "target": 0
    },
    {
        "id": 1386,
        "func": " const Block* SimpleBlock::GetBlock() const { return &m_block; }\n",
        "target": 0
    },
    {
        "id": 1387,
        "func": "static void __attribute__((no_instrument_function)) trace_save_gd(void)\n{\n}\n",
        "target": 0
    },
    {
        "id": 1388,
        "func": "static struct page *last_fsync_dnode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tstruct page *last_page = NULL;\n\n\tpagevec_init(&pvec, 0);\n\tindex = 0;\n\tend = ULONG_MAX;\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\t\tf2fs_put_page(last_page, 0);\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\treturn ERR_PTR(-EIO);\n\t\t\t}\n\n\t\t\tif (!IS_DNODE(page) || !is_cold_node(page))\n\t\t\t\tcontinue;\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tcontinue;\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ino_of_node(page) != ino)\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (last_page)\n\t\t\t\tf2fs_put_page(last_page, 0);\n\n\t\t\tget_page(page);\n\t\t\tlast_page = page;\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\treturn last_page;\n}",
        "target": 0
    },
    {
        "id": 1389,
        "func": "u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)\n{\n\tunsigned long flags;\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct buffer_page *bpage;\n\tu64 ret = 0;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn 0;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\t/*\n\t * if the tail is on reader_page, oldest time stamp is on the reader\n\t * page\n\t */\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\tbpage = cpu_buffer->reader_page;\n\telse\n\t\tbpage = rb_set_head_page(cpu_buffer);\n\tif (bpage)\n\t\tret = bpage->page->time_stamp;\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1390,
        "func": "force_unmount (Device *device,\n               ForceRemovalCompleteFunc callback,\n               gpointer user_data)\n{\n  int n;\n  char *argv[16];\n  const gchar *mount_path;\n\n  mount_path = ((gchar **) device->priv->device_mount_paths->pdata)[0];\n\n  n = 0;\n  argv[n++] = \"umount\";\n  /* on Linux, we only have lazy unmount for now */\n  argv[n++] = \"-l\";\n  argv[n++] = (gchar *) mount_path;\n  argv[n++] = NULL;\n\n  if (!job_new (NULL,\n                \"ForceUnmount\",\n                FALSE,\n                device,\n                argv,\n                NULL,\n                force_unmount_completed_cb,\n                FALSE,\n                force_unmount_data_new (mount_path, callback, user_data),\n                (GDestroyNotify) force_unmount_data_unref))\n    {\n      g_warning (\"Couldn't spawn unmount for force unmounting %s\", mount_path);\n      if (callback != NULL)\n        callback (device, FALSE, user_data);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1391,
        "func": "long Track::GetNext(\n    const BlockEntry* pCurrEntry,\n    const BlockEntry*& pNextEntry) const\n{\n    assert(pCurrEntry);\n    assert(!pCurrEntry->EOS());  //?\n \n    const Block* const pCurrBlock = pCurrEntry->GetBlock();\n    assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);\n    if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)\n        return -1;\n \n    const Cluster* pCluster = pCurrEntry->GetCluster();\n    assert(pCluster);\n    assert(!pCluster->EOS());\n \n    long status = pCluster->GetNext(pCurrEntry, pNextEntry);\n \n    if (status < 0)  //error\n         return status;\n \n    for (int i = 0; ; )\n    {\n        while (pNextEntry)\n        {\n            const Block* const pNextBlock = pNextEntry->GetBlock();\n            assert(pNextBlock);\n \n            if (pNextBlock->GetTrackNumber() == m_info.number)\n                return 0;\n \n            pCurrEntry = pNextEntry;\n \n            status = pCluster->GetNext(pCurrEntry, pNextEntry);\n \n            if (status < 0) //error\n                return status;\n        }\n \n        pCluster = m_pSegment->GetNext(pCluster);\n \n        if (pCluster == NULL)\n        {\n            pNextEntry = GetEOS();\n            return 1;\n        }\n \n        if (pCluster->EOS())\n        {\n #if 0\n             if (m_pSegment->Unparsed() <= 0)   //all clusters have been loaded\n             {\n                pNextEntry = GetEOS();\n\n                 return 1;\n             }\n #else\n            if (m_pSegment->DoneParsing())\n            {\n                pNextEntry = GetEOS();\n                return 1;\n            }\n #endif\n \n \n            pNextEntry = NULL;\n            return E_BUFFER_NOT_FULL;\n        }\n        status = pCluster->GetFirst(pNextEntry);\n        if (status < 0)  //error\n            return status;\n        if (pNextEntry == NULL)  //empty cluster\n            continue;\n        ++i;\n        if (i >= 100)\n            break;\n     }\n \n \n    pNextEntry = GetEOS();  //so we can return a non-NULL value\n    return 1;\n }\n",
        "target": 1
    },
    {
        "id": 1392,
        "func": "  base::string16 LocaleWindowCaptionFromPageTitle(\n      const base::string16& expected_title) {\n    base::string16 page_title = WindowCaptionFromPageTitle(expected_title);\n#if defined(OS_WIN)\n    std::string locale = g_browser_process->GetApplicationLocale();\n    if (base::i18n::GetTextDirectionForLocale(locale.c_str()) ==\n        base::i18n::RIGHT_TO_LEFT) {\n      base::i18n::WrapStringWithLTRFormatting(&page_title);\n    }\n\n    return page_title;\n#else\n    return page_title;\n#endif\n  }\n",
        "target": 0
    },
    {
        "id": 1393,
        "func": "\nstatic int avi_probe(AVProbeData *p)\n{\n    int i;\n\n    /* check file header */\n    for (i = 0; avi_headers[i][0]; i++)\n        if (AV_RL32(p->buf    ) == AV_RL32(avi_headers[i]    ) &&\n            AV_RL32(p->buf + 8) == AV_RL32(avi_headers[i] + 4))\n            return AVPROBE_SCORE_MAX;\n\n    return 0;",
        "target": 0
    },
    {
        "id": 1394,
        "func": "int UDPSocketWin::InternalConnect(const IPEndPoint& address) {\n  DCHECK(!is_connected());\n  DCHECK(!remote_address_.get());\n  int addr_family = address.GetSockAddrFamily();\n  int rv = CreateSocket(addr_family);\n  if (rv < 0)\n    return rv;\n\n  if (bind_type_ == DatagramSocket::RANDOM_BIND) {\n    size_t addr_size =\n        addr_family == AF_INET ? kIPv4AddressSize : kIPv6AddressSize;\n    IPAddressNumber addr_any(addr_size);\n    rv = RandomBind(addr_any);\n  }\n \n   if (rv < 0) {\n    UMA_HISTOGRAM_SPARSE_SLOWLY(\"Net.UdpSocketRandomBindErrorCode\", rv);\n     Close();\n     return rv;\n   }\n\n  SockaddrStorage storage;\n  if (!address.ToSockAddr(storage.addr, &storage.addr_len))\n    return ERR_ADDRESS_INVALID;\n\n  rv = connect(socket_, storage.addr, storage.addr_len);\n  if (rv < 0) {\n    int result = MapSystemError(WSAGetLastError());\n    Close();\n    return result;\n  }\n\n  remote_address_.reset(new IPEndPoint(address));\n  return rv;\n}\n",
        "target": 1
    },
    {
        "id": 1395,
        "func": "bool Resource::CanReuseRedirectChain() const {\n  for (auto& redirect : redirect_chain_) {\n    if (!CanUseResponse(redirect.redirect_response_, response_timestamp_))\n      return false;\n    if (redirect.request_.CacheControlContainsNoCache() ||\n        redirect.request_.CacheControlContainsNoStore())\n      return false;\n  }\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1396,
        "func": "void RenderView::textFieldDidEndEditing(\n    const WebKit::WebInputElement& element) {\n#if defined(WEBKIT_BUG_41283_IS_FIXED)\n  password_autocomplete_manager_.TextFieldDidEndEditing(element);\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 1397,
        "func": "void enable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 1;\n}",
        "target": 0
    },
    {
        "id": 1398,
        "func": "brcmf_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t struct cfg80211_pmksa *pmksa)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pmksa *pmk = &cfg->pmk_list.pmk[0];\n\ts32 err;\n\tu32 npmk, i;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tbrcmf_dbg(CONN, \"del_pmksa - PMK bssid = %pM\\n\", pmksa->bssid);\n\n\tnpmk = le32_to_cpu(cfg->pmk_list.npmk);\n\tfor (i = 0; i < npmk; i++)\n\t\tif (!memcmp(pmksa->bssid, pmk[i].bssid, ETH_ALEN))\n\t\t\tbreak;\n\n\tif ((npmk > 0) && (i < npmk)) {\n\t\tfor (; i < (npmk - 1); i++) {\n\t\t\tmemcpy(&pmk[i].bssid, &pmk[i + 1].bssid, ETH_ALEN);\n\t\t\tmemcpy(&pmk[i].pmkid, &pmk[i + 1].pmkid,\n\t\t\t       WLAN_PMKID_LEN);\n\t\t}\n\t\tmemset(&pmk[i], 0, sizeof(*pmk));\n\t\tcfg->pmk_list.npmk = cpu_to_le32(npmk - 1);\n\t} else {\n\t\tbrcmf_err(\"Cache entry not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = brcmf_update_pmklist(cfg, ifp);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n\n}",
        "target": 0
    },
    {
        "id": 1399,
        "func": "void IndexedDBDatabase::SendObservations(\n    std::map<int32_t, blink::mojom::IDBObserverChangesPtr> changes_map) {\n  for (auto* conn : connections_) {\n    auto it = changes_map.find(conn->id());\n    if (it != changes_map.end())\n      conn->callbacks()->OnDatabaseChange(std::move(it->second));\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1400,
        "func": "static int airo_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct airo_info *ai = dev->ml_priv;\n\tCmd cmd;\n\tResp rsp;\n\n\tif (!ai->APList)\n\t\tai->APList = kmalloc(sizeof(APListRid), GFP_KERNEL);\n\tif (!ai->APList)\n\t\treturn -ENOMEM;\n\tif (!ai->SSID)\n\t\tai->SSID = kmalloc(sizeof(SsidRid), GFP_KERNEL);\n\tif (!ai->SSID)\n\t\treturn -ENOMEM;\n\treadAPListRid(ai, ai->APList);\n\treadSsidRid(ai, ai->SSID);\n\tmemset(&cmd, 0, sizeof(cmd));\n\t/* the lock will be released at the end of the resume callback */\n\tif (down_interruptible(&ai->sem))\n\t\treturn -EAGAIN;\n\tdisable_MAC(ai, 0);\n\tnetif_device_detach(dev);\n\tai->power = state;\n\tcmd.cmd = HOSTSLEEP;\n\tissuecommand(ai, &cmd, &rsp);\n\n\tpci_enable_wake(pdev, pci_choose_state(pdev, state), 1);\n\tpci_save_state(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1401,
        "func": "void RenderBlock::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)\n{\n    RenderBox::styleDidChange(diff, oldStyle);\n\n    RenderStyle* newStyle = style();\n\n    if (!isAnonymousBlock()) {\n        for (RenderBlock* currCont = blockElementContinuation(); currCont; currCont = currCont->blockElementContinuation()) {\n            RenderBoxModelObject* nextCont = currCont->continuation();\n            currCont->setContinuation(0);\n            currCont->setStyle(newStyle);\n            currCont->setContinuation(nextCont);\n        }\n    }\n\n    if (FastTextAutosizer* textAutosizer = document().fastTextAutosizer())\n        textAutosizer->record(this);\n\n    propagateStyleToAnonymousChildren(true);\n    invalidateLineHeight();\n \n    m_hasBorderOrPaddingLogicalWidthChanged = oldStyle && diff == StyleDifferenceLayout && needsLayout() && borderOrPaddingLogicalWidthChanged(oldStyle, newStyle);\n \n    Vector<ImageResource*> images;\n    appendImagesFromStyle(images, *newStyle);\n    if (images.isEmpty())\n        ResourceLoadPriorityOptimizer::resourceLoadPriorityOptimizer()->removeRenderObject(this);\n    else\n        ResourceLoadPriorityOptimizer::resourceLoadPriorityOptimizer()->addRenderObject(this);\n}\n",
        "target": 1
    },
    {
        "id": 1402,
        "func": "static const char *check_secret(int module, const char *user, const char *group,\n\t\t\t\tconst char *challenge, const char *pass)\n{\n\tchar line[1024];\n        char pass2[MAX_DIGEST_LEN*2];\n        const char *fname = lp_secrets_file(module);\n        STRUCT_STAT st;\n       int fd, ok = 1;\n        int user_len = strlen(user);\n        int group_len = group ? strlen(group) : 0;\n        char *err;\n \n       if (!fname || !*fname || (fd = open(fname, O_RDONLY)) < 0)\n                return \"no secrets file\";\n \n       if (do_fstat(fd, &st) == -1) {\n                rsyserr(FLOG, errno, \"fstat(%s)\", fname);\n                ok = 0;\n        } else if (lp_strict_modes(module)) {\n\t\t\trprintf(FLOG, \"secrets file must not be other-accessible (see strict modes option)\\n\");\n\t\t\tok = 0;\n\t\t} else if (MY_UID() == 0 && st.st_uid != 0) {\n\t\t\trprintf(FLOG, \"secrets file must be owned by root when running as root (see strict modes)\\n\");\n\t\t\tok = 0;\n\t\t}\n                }\n",
        "target": 1
    },
    {
        "id": 1403,
        "func": "static bool isValidNameNonASCII(const UChar* characters, unsigned length)\n{\n    unsigned i = 0;\n\n    UChar32 c;\n    U16_NEXT(characters, i, length, c)\n    if (!isValidNameStart(c))\n        return false;\n\n    while (i < length) {\n        U16_NEXT(characters, i, length, c)\n        if (!isValidNamePart(c))\n            return false;\n    }\n\n    return true;\n}\n",
        "target": 0
    },
    {
        "id": 1404,
        "func": "aspath_private_as_check (struct aspath *aspath)\n{\n  struct assegment *seg;\n  \n  if ( !(aspath && aspath->segments) )\n    return 0;\n    \n  seg = aspath->segments;\n\n  while (seg)\n    {\n      int i;\n      \n      for (i = 0; i < seg->length; i++)\n\t{\n\t  if (!BGP_AS_IS_PRIVATE(seg->as[i]))\n\t    return 0;\n\t}\n      seg = seg->next;\n    }\n  return 1;\n}\n",
        "target": 0
    },
    {
        "id": 1405,
        "func": "bool FileBrowserPrivateGetShareUrlFunction::RunAsync() {\n  using extensions::api::file_browser_private::GetShareUrl::Params;\n  const scoped_ptr<Params> params(Params::Create(*args_));\n  EXTENSION_FUNCTION_VALIDATE(params);\n\n  const base::FilePath path = file_manager::util::GetLocalPathFromURL(\n      render_view_host(), GetProfile(), GURL(params->url));\n  DCHECK(drive::util::IsUnderDriveMountPoint(path));\n\n  const base::FilePath drive_path = drive::util::ExtractDrivePath(path);\n\n  drive::FileSystemInterface* const file_system =\n      drive::util::GetFileSystemByProfile(GetProfile());\n  if (!file_system) {\n    return false;\n  }\n \n   file_system->GetShareUrl(\n       drive_path,\n      GURL(\"chrome-extension://\" + extension_id()),  // embed origin\n       base::Bind(&FileBrowserPrivateGetShareUrlFunction::OnGetShareUrl, this));\n   return true;\n }\n",
        "target": 0
    },
    {
        "id": 1406,
        "func": "void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)\n {\n     if (origin && BlobURL::getOrigin(url) == \"null\")\n         originMap()->add(url.string(), origin);\n \n    if (isMainThread())\n        blobRegistry().registerBlobURL(url, srcURL);\n    else {\n         OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, srcURL));\n         callOnMainThread(&registerBlobURLFromTask, context.leakPtr());\n     }\n}\n",
        "target": 1
    },
    {
        "id": 1407,
        "func": "static int nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_lookup_root(server, fhandle, info);\n\t\tswitch (err) {\n\t\tcase 0:\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(server, err, &exception);\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 1408,
        "func": "void AutomationProvider::AddLoginHandler(NavigationController* tab,\n                                         LoginHandler* handler) {\n  login_handler_map_[tab] = handler;\n}\n",
        "target": 0
    },
    {
        "id": 1409,
        "func": "AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n    IgnoredReasons* ignoredReasons) const {\n\n  if (!m_layoutObject) {\n    if (ignoredReasons)\n      ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n    return IgnoreObject;\n  }\n\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n    if (equalIgnoringCase(getAttribute(aria_hiddenAttr), \"false\"))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n      ignoredReasons->push_back(IgnoredReason(AXNotVisible));\n    return IgnoreObject;\n  }\n\n  return AXObject::defaultObjectInclusion(ignoredReasons);\n}\n",
        "target": 1
    },
    {
        "id": 1410,
        "func": " DevToolsUI::DevToolsUI(content::WebUI* web_ui)\n    : WebUIController(web_ui) {\n   web_ui->SetBindings(0);\n   Profile* profile = Profile::FromWebUI(web_ui);\n   content::URLDataSource::Add(\n       profile,\n       new DevToolsDataSource(profile->GetRequestContext()));\n \n  GURL url = web_ui->GetWebContents()->GetVisibleURL();\n  if (url.spec() != SanitizeFrontendURL(url).spec())\n     return;\n  if (profile->IsOffTheRecord()) {\n    GURL site = content::SiteInstance::GetSiteForURL(profile, url);\n    content::BrowserContext::GetStoragePartitionForSite(profile, site)->\n        GetFileSystemContext()->EnableTemporaryFileSystemInIncognito();\n  }\n  bindings_.reset(new DevToolsUIBindings(web_ui->GetWebContents()));\n }\n",
        "target": 1
    },
    {
        "id": 1411,
        "func": "  void PerformClick(int x, int y) {\n    content::WebContents* contents =\n        browser()->tab_strip_model()->GetActiveWebContents();\n    blink::WebMouseEvent click_event(\n        blink::WebInputEvent::kMouseDown, blink::WebInputEvent::kNoModifiers,\n        blink::WebInputEvent::GetStaticTimeStampForTests());\n    click_event.button = blink::WebMouseEvent::Button::kLeft;\n    click_event.click_count = 1;\n    click_event.SetPositionInWidget(x, y);\n    contents->GetRenderViewHost()->GetWidget()->ForwardMouseEvent(click_event);\n    click_event.SetType(blink::WebInputEvent::kMouseUp);\n    contents->GetRenderViewHost()->GetWidget()->ForwardMouseEvent(click_event);\n  }\n",
        "target": 0
    },
    {
        "id": 1412,
        "func": "Eina_Bool ewk_frame_reload(Evas_Object* ewkFrame)\n{\n    EWK_FRAME_SD_GET_OR_RETURN(ewkFrame, smartData, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->frame, false);\n    smartData->frame->loader()->reload();\n    return true;\n}\n",
        "target": 0
    },
    {
        "id": 1413,
        "func": "static void virtio_gpu_reset(VirtIODevice *vdev)\n{\n    VirtIOGPU *g = VIRTIO_GPU(vdev);\n    struct virtio_gpu_simple_resource *res, *tmp;\n    int i;\n\n    g->enable = 0;\n\n    QTAILQ_FOREACH_SAFE(res, &g->reslist, next, tmp) {\n        virtio_gpu_resource_destroy(g, res);\n    }\n    for (i = 0; i < g->conf.max_outputs; i++) {\n#if 0\n        g->req_state[i].x = 0;\n        g->req_state[i].y = 0;\n        if (i == 0) {\n            g->req_state[0].width = 1024;\n            g->req_state[0].height = 768;\n        } else {\n            g->req_state[i].width = 0;\n            g->req_state[i].height = 0;\n        }\n#endif\n        g->scanout[i].resource_id = 0;\n        g->scanout[i].width = 0;\n        g->scanout[i].height = 0;\n        g->scanout[i].x = 0;\n        g->scanout[i].y = 0;\n        g->scanout[i].ds = NULL;\n    }\n    g->enabled_output_bitmask = 1;\n\n#ifdef CONFIG_VIRGL\n    if (g->use_virgl_renderer) {\n        virtio_gpu_virgl_reset(g);\n        g->use_virgl_renderer = 0;\n    }\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 1414,
        "func": "TabContentsWrapper* Browser::GetConstrainingContentsWrapper(\n  TabContentsWrapper* source) {\n  return source;\n}\n",
        "target": 0
    },
    {
        "id": 1415,
        "func": "static void longLongAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    ExceptionState exceptionState(ExceptionState::SetterContext, \"longLongAttr\", \"TestObject\", info.Holder(), info.GetIsolate());\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(long long, cppValue, toInt64(jsValue, exceptionState), exceptionState);\n    imp->setLongLongAttr(cppValue);\n}\n",
        "target": 0
    },
    {
        "id": 1416,
        "func": "static int queue_get(struct priv_net *pn, void *buf, int len)\n{\n\tstruct queue *head = &pn->pn_queue;\n\tstruct queue *q = head->q_next;\n\n\tif (q == head)\n\t\treturn 0;\n\n\tassert(q->q_len <= len);\n\tmemcpy(buf, q->q_buf, q->q_len);\n\n\tqueue_del(q);\n\tqueue_add(&pn->pn_queue_free, q);\n\n\treturn q->q_len;\n}",
        "target": 0
    },
    {
        "id": 1417,
        "func": "ofputil_protocol_to_ofp_version(enum ofputil_protocol protocol)\n{\n    switch (protocol) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        return OFP10_VERSION;\n    case OFPUTIL_P_OF11_STD:\n        return OFP11_VERSION;\n    case OFPUTIL_P_OF12_OXM:\n        return OFP12_VERSION;\n    case OFPUTIL_P_OF13_OXM:\n        return OFP13_VERSION;\n    case OFPUTIL_P_OF14_OXM:\n        return OFP14_VERSION;\n    case OFPUTIL_P_OF15_OXM:\n        return OFP15_VERSION;\n    case OFPUTIL_P_OF16_OXM:\n        return OFP16_VERSION;\n    }\n\n    OVS_NOT_REACHED();\n}\n",
        "target": 0
    },
    {
        "id": 1418,
        "func": " static void on_read(h2o_socket_t *sock, int status)\n{\n    h2o_http2_conn_t *conn = sock->data;\n\n    if (status != 0) {\n        h2o_socket_read_stop(conn->sock);\n        close_connection(conn);\n        return;\n     }\n \n     update_idle_timeout(conn);\n    parse_input(conn);\n \n     /* write immediately, if there is no write in flight and if pending write exists */\n     if (h2o_timeout_is_linked(&conn->_write.timeout_entry)) {\n        h2o_timeout_unlink(&conn->_write.timeout_entry);\n        do_emit_writereq(conn);\n    }\n}\n",
        "target": 1
    },
    {
        "id": 1419,
        "func": "bool MatchesQueryArg(QueryArg arg, bool value) {\n  if (arg == NOT_SET)\n    return true;\n\n  return (arg == MATCH_TRUE && value) || (arg == MATCH_FALSE && !value);\n}\n",
        "target": 0
    },
    {
        "id": 1420,
        "func": "Response DOMHandler::SetFileInputFiles(\n    std::unique_ptr<protocol::Array<std::string>> files,\n     Maybe<DOM::NodeId> node_id,\n     Maybe<DOM::BackendNodeId> backend_node_id,\n     Maybe<String> in_object_id) {\n   if (host_) {\n     for (size_t i = 0; i < files->length(); i++) {\n #if defined(OS_WIN)\n      ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadFile(\n          host_->GetProcess()->GetID(),\n          base::FilePath(base::UTF8ToUTF16(files->get(i))));\n#else\n      ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadFile(\n          host_->GetProcess()->GetID(),\n          base::FilePath(files->get(i)));\n#endif  // OS_WIN\n    }\n  }\n  return Response::FallThrough();\n}\n",
        "target": 1
    },
    {
        "id": 1421,
        "func": "static void prb_close_block(struct tpacket_kbdq_core *pkc1,\n\t\tstruct tpacket_block_desc *pbd1,\n\t\tstruct packet_sock *po, unsigned int stat)\n{\n\t__u32 status = TP_STATUS_USER | stat;\n\n\tstruct tpacket3_hdr *last_pkt;\n\tstruct tpacket_hdr_v1 *h1 = &pbd1->hdr.bh1;\n\tstruct sock *sk = &po->sk;\n\n\tif (po->stats.stats3.tp_drops)\n\t\tstatus |= TP_STATUS_LOSING;\n\n\tlast_pkt = (struct tpacket3_hdr *)pkc1->prev;\n\tlast_pkt->tp_next_offset = 0;\n\n\t/* Get the ts of the last pkt */\n\tif (BLOCK_NUM_PKTS(pbd1)) {\n\t\th1->ts_last_pkt.ts_sec = last_pkt->tp_sec;\n\t\th1->ts_last_pkt.ts_nsec\t= last_pkt->tp_nsec;\n\t} else {\n\t\t/* Ok, we tmo'd - so get the current time.\n\t\t *\n\t\t * It shouldn't really happen as we don't close empty\n\t\t * blocks. See prb_retire_rx_blk_timer_expired().\n\t\t */\n\t\tstruct timespec ts;\n\t\tgetnstimeofday(&ts);\n\t\th1->ts_last_pkt.ts_sec = ts.tv_sec;\n\t\th1->ts_last_pkt.ts_nsec\t= ts.tv_nsec;\n\t}\n\n\tsmp_wmb();\n\n\t/* Flush the block */\n\tprb_flush_block(pkc1, pbd1, status);\n\n\tsk->sk_data_ready(sk);\n\n\tpkc1->kactive_blk_num = GET_NEXT_PRB_BLK_NUM(pkc1);\n}",
        "target": 0
    },
    {
        "id": 1422,
        "func": " RenderWidgetHostView* RenderFrameHostManager::GetRenderWidgetHostView() const {\n  if (delegate_->GetInterstitialForRenderManager())\n    return delegate_->GetInterstitialForRenderManager()->GetView();\n   if (render_frame_host_)\n     return render_frame_host_->GetView();\n   return nullptr;\n}\n",
        "target": 0
    },
    {
        "id": 1423,
        "func": "PaintArtifactCompositor::PaintArtifactCompositor(\n    base::RepeatingCallback<void(const gfx::ScrollOffset&,\n                                 const cc::ElementId&)> scroll_callback)\n    : scroll_callback_(std::move(scroll_callback)),\n      tracks_raster_invalidations_(false) {\n  if (!RuntimeEnabledFeatures::SlimmingPaintV2Enabled() &&\n      !RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled())\n    return;\n  root_layer_ = cc::Layer::Create();\n}\n",
        "target": 0
    },
    {
        "id": 1424,
        "func": "static int dtls1_add_cert_to_buf(BUF_MEM *buf, unsigned long *l, X509 *x)\n\t{\n\tint n;\n\tunsigned char *p;\n\n\tn=i2d_X509(x,NULL);\n\tif (!BUF_MEM_grow_clean(buf,(int)(n+(*l)+3)))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_ADD_CERT_TO_BUF,ERR_R_BUF_LIB);\n\t\treturn 0;\n\t\t}\n\tp=(unsigned char *)&(buf->data[*l]);\n\tl2n3(n,p);\n\ti2d_X509(x,&p);\n\t*l+=n+3;\n\n\treturn 1;\n\t}\n",
        "target": 0
    },
    {
        "id": 1425,
        "func": "static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n\t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 1426,
        "func": "void lodepng_info_init(LodePNGInfo* info)\n{\n  lodepng_color_mode_init(&info->color);\n  info->interlace_method = 0;\n  info->compression_method = 0;\n  info->filter_method = 0;\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  info->background_defined = 0;\n  info->background_r = info->background_g = info->background_b = 0;\n\n  LodePNGText_init(info);\n  LodePNGIText_init(info);\n\n  info->time_defined = 0;\n  info->phys_defined = 0;\n\n  LodePNGUnknownChunks_init(info);\n#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/\n}\n",
        "target": 0
    },
    {
        "id": 1427,
        "func": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tfs->kill_sb(s);\n\n\t\t/* caches are now gone, we can safely kill the shrinker now */\n\t\tunregister_shrinker(&s->s_shrink);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1428,
        "func": "BOOLEAN btif_hl_find_mcl_idx_using_mdl_id( UINT8 mdl_id,UINT8 mcl_handle,\n                                           UINT8 *p_app_idx, UINT8 *p_mcl_idx){\n btif_hl_app_cb_t *p_acb;\n btif_hl_mcl_cb_t *p_mcb;\n    BOOLEAN         found=FALSE;\n    UINT8 i,j,x;\n\n for (i=0; i<BTA_HL_NUM_APPS; i++)\n {\n        p_acb =BTIF_HL_GET_APP_CB_PTR(i);\n for (j=0; j < BTA_HL_NUM_MCLS ; j++)\n {\n if (p_acb->mcb[j].in_use &&\n (p_acb->mcb[j].mcl_handle == mcl_handle))\n {\n                    p_mcb = &p_acb->mcb[j];\n                    BTIF_TRACE_DEBUG(\"btif_hl_find_mcl_idx_using_mdl_id: mcl handle found j =%d\",j);\n for (x=0; x < BTA_HL_NUM_MDLS_PER_MCL ; x ++)\n {\n if (p_mcb->mdl[x].in_use && p_mcb->mdl[x].mdl_id == mdl_id)\n {\n                            BTIF_TRACE_DEBUG(\"btif_hl_find_mcl_idx_using_mdl_id:found x =%d\",x);\n                            found = TRUE;\n *p_app_idx = i;\n *p_mcl_idx = j;\n break;\n }\n }\n }\n }\n }\n    BTIF_TRACE_DEBUG(\"%s found=%d app_idx=%d mcl_idx=%d\",__FUNCTION__,\n                      found, i, j);\n return found;\n}\n",
        "target": 0
    },
    {
        "id": 1429,
        "func": "static int setcalrgbspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CIESubst)\n{\n    ref rgbdict;\n    int code = 0;\n    float                   gamma[3], white[3], black[3], matrix[9];\n    static const float      dflt_gamma[3] = { 1.0, 1.0, 1.0 };\n    static const float      dflt_black[3] = {0,0,0}, dflt_white[3] = {0,0,0};\n    static const float      dflt_matrix[9] = {1,0,0,0,1,0,0,0,1};\n    int i;\n    gs_client_color cc;\n\n    *cont = 0;\n    code = array_get(imemory, r, 1, &rgbdict);\n    if (code < 0)\n        return code;\n/* Get all the parts */\n    code = dict_floats_param( imemory,\n                              &rgbdict,\n                              \"Gamma\",\n                              3,\n                              gamma,\n                              dflt_gamma );\n    if (code < 0)\n        return code;\n    if (gamma[0] <= 0 || gamma[1] <= 0 || gamma[2] <= 0)\n        return_error(gs_error_rangecheck);\n    code = dict_floats_param( imemory,\n                              &rgbdict,\n                              \"BlackPoint\",\n                              3,\n                              black,\n                              dflt_black );\n    if (code < 0)\n        return code;\n    code = dict_floats_param( imemory,\n                              &rgbdict,\n                              \"WhitePoint\",\n                              3,\n                              white,\n                              dflt_white );\n    if (code < 0)\n        return code;\n    if (white[0] <= 0 || white[1] != 1.0 || white[2] <= 0)\n        return_error(gs_error_rangecheck);\n    code = dict_floats_param( imemory,\n                              &rgbdict,\n                              \"Matrix\",\n                              9,\n                              matrix,\n                              dflt_matrix );\n    if (code < 0)\n        return code;\n    code = seticc_cal(i_ctx_p, white, black, gamma, matrix, 3, rgbdict.value.saveid);\n    if ( code < 0)\n        return gs_rethrow(code, \"setting CalRGB  color space\");\n    cc.pattern = 0x00;\n    for (i=0;i<3;i++)\n        cc.paint.values[i] = 0;\n    code = gs_setcolor(igs, &cc);\n    return code;\n}\n",
        "target": 0
    },
    {
        "id": 1430,
        "func": "int CommandBufferProxyImpl::GetRouteID() const {\n  return route_id_;\n}\n",
        "target": 0
    },
    {
        "id": 1431,
        "func": "void rb_free(struct ring_buffer *rb)\n{\n\tint i;\n\n\tperf_mmap_free_page((unsigned long)rb->user_page);\n\tfor (i = 0; i < rb->nr_pages; i++)\n\t\tperf_mmap_free_page((unsigned long)rb->data_pages[i]);\n\tkfree(rb);\n}",
        "target": 0
    },
    {
        "id": 1432,
        "func": "void MockDownloadController::SetApproveFileAccessRequestForTesting(\n    bool approve) {\n  approve_file_access_request_ = approve;\n}\n",
        "target": 0
    },
    {
        "id": 1433,
        "func": "process_buffered_input_packets(void)\n{\n\tdispatch_run(DISPATCH_NONBLOCK, NULL, active_state);\n}",
        "target": 0
    },
    {
        "id": 1434,
        "func": " void HeapObjectHeader::Finalize(Address object, size_t object_size) {\n   HeapAllocHooks::FreeHookIfEnabled(object);\n  const GCInfo* gc_info = ThreadHeap::GcInfo(GcInfoIndex());\n   if (gc_info->HasFinalizer())\n     gc_info->finalize_(object);\n \n  ASAN_RETIRE_CONTAINER_ANNOTATION(object, object_size);\n}\n",
        "target": 1
    },
    {
        "id": 1435,
        "func": "error::Error GLES2DecoderImpl::HandleGetProgramInfoCHROMIUM(\n    uint32 immediate_data_size, const cmds::GetProgramInfoCHROMIUM& c) {\n  GLuint program_id = static_cast<GLuint>(c.program);\n  uint32 bucket_id = c.bucket_id;\n  Bucket* bucket = CreateBucket(bucket_id);\n  bucket->SetSize(sizeof(ProgramInfoHeader));  // in case we fail.\n  Program* program = NULL;\n  program = GetProgram(program_id);\n  if (!program || !program->IsValid()) {\n    return error::kNoError;\n  }\n  program->GetProgramInfo(program_manager(), bucket);\n  return error::kNoError;\n}\n",
        "target": 0
    },
    {
        "id": 1436,
        "func": "void PrintWebViewHelper::OnPrintForPrintPreview(\n    const DictionaryValue& job_settings) {\n  DCHECK(is_preview_enabled_);\n  if (print_web_view_)\n    return;\n\n  if (!render_view()->GetWebView())\n    return;\n  WebFrame* main_frame = render_view()->GetWebView()->mainFrame();\n  if (!main_frame)\n    return;\n\n  WebDocument document = main_frame->document();\n  WebElement pdf_element = document.getElementById(\"pdf-viewer\");\n  if (pdf_element.isNull()) {\n    NOTREACHED();\n    return;\n  }\n\n  AutoReset<bool> set_printing_flag(&print_for_preview_, true);\n\n  WebFrame* pdf_frame = pdf_element.document().frame();\n  if (!UpdatePrintSettings(pdf_frame, pdf_element, job_settings)) {\n    LOG(ERROR) << \"UpdatePrintSettings failed\";\n    DidFinishPrinting(FAIL_PRINT);\n    return;\n  }\n\n  if (!RenderPagesForPrint(pdf_frame, pdf_element)) {\n    LOG(ERROR) << \"RenderPagesForPrint failed\";\n    DidFinishPrinting(FAIL_PRINT);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1437,
        "func": "static int ras_puthdr(jas_stream_t *out, ras_hdr_t *hdr)\n{\n\tif (ras_putint(out, RAS_MAGIC) || ras_putint(out, hdr->width) ||\n\t  ras_putint(out, hdr->height) || ras_putint(out, hdr->depth) ||\n\t  ras_putint(out, hdr->length) || ras_putint(out, hdr->type) ||\n\t  ras_putint(out, hdr->maptype) || ras_putint(out, hdr->maplength)) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1438,
        "func": "static void *__alloc_from_contiguous(struct device *dev, size_t size,\n\t\t\t\t     pgprot_t prot, struct page **ret_page,\n\t\t\t\t     const void *caller)\n{\n\tunsigned long order = get_order(size);\n\tsize_t count = size >> PAGE_SHIFT;\n\tstruct page *page;\n\tvoid *ptr;\n\n\tpage = dma_alloc_from_contiguous(dev, count, order);\n\tif (!page)\n\t\treturn NULL;\n\n\t__dma_clear_buffer(page, size);\n\n\tif (PageHighMem(page)) {\n\t\tptr = __dma_alloc_remap(page, size, GFP_KERNEL, prot, caller);\n\t\tif (!ptr) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t__dma_remap(page, size, prot);\n\t\tptr = page_address(page);\n\t}\n\t*ret_page = page;\n\treturn ptr;\n}",
        "target": 0
    },
    {
        "id": 1439,
        "func": "bool UDPSocketLibevent::SetSendBufferSize(int32 size) {\n  DCHECK(CalledOnValidThread());\n  int rv = setsockopt(socket_, SOL_SOCKET, SO_SNDBUF,\n                      reinterpret_cast<const char*>(&size), sizeof(size));\n  DCHECK(!rv) << \"Could not set socket send buffer size: \" << errno;\n  return rv == 0;\n}\n",
        "target": 0
    },
    {
        "id": 1440,
        "func": "static struct net_device *packet_cached_dev_get(struct packet_sock *po)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tdev = rcu_dereference(po->cached_dev);\n\tif (likely(dev))\n\t\tdev_hold(dev);\n\trcu_read_unlock();\n\n\treturn dev;\n}",
        "target": 0
    },
    {
        "id": 1441,
        "func": "bool IDNSpoofChecker::SimilarToTopDomains(base::StringPiece16 hostname) {\n  size_t hostname_length = hostname.length() - (hostname.back() == '.' ? 1 : 0);\n  icu::UnicodeString ustr_host(FALSE, hostname.data(), hostname_length);\n   if (lgc_letters_n_ascii_.span(ustr_host, 0, USET_SPAN_CONTAINED) ==\n       ustr_host.length())\n    diacritic_remover_.get()->transliterate(ustr_host);\n  extra_confusable_mapper_.get()->transliterate(ustr_host);\n \n   UErrorCode status = U_ZERO_ERROR;\n   icu::UnicodeString ustr_skeleton;\n  uspoof_getSkeletonUnicodeString(checker_, 0, ustr_host, ustr_skeleton,\n                                  &status);\n   if (U_FAILURE(status))\n     return false;\n   std::string skeleton;\n  return LookupMatchInTopDomains(ustr_skeleton.toUTF8String(skeleton));\n }\n",
        "target": 0
    },
    {
        "id": 1442,
        "func": "PassRefPtr<RTCSessionDescription> RTCPeerConnection::localDescription(ExceptionCode& ec)\n{\n    if (m_readyState == ReadyStateClosing || m_readyState == ReadyStateClosed) {\n        ec = INVALID_STATE_ERR;\n        return 0;\n    }\n    RefPtr<RTCSessionDescriptionDescriptor> descriptor = m_peerHandler->localDescription();\n    if (!descriptor)\n        return 0;\n    RefPtr<RTCSessionDescription> desc = RTCSessionDescription::create(descriptor.release());\n    return desc.release();\n}\n",
        "target": 1
    },
    {
        "id": 1443,
        "func": "  ft_add_renderer( FT_Module  module )\n  {\n    FT_Library   library = module->library;\n    FT_Memory    memory  = library->memory;\n    FT_Error     error;\n    FT_ListNode  node;\n\n\n    if ( FT_NEW( node ) )\n      goto Exit;\n\n    {\n      FT_Renderer         render = FT_RENDERER( module );\n      FT_Renderer_Class*  clazz  = (FT_Renderer_Class*)module->clazz;\n\n\n      render->clazz        = clazz;\n      render->glyph_format = clazz->glyph_format;\n\n      /* allocate raster object if needed */\n      if ( clazz->glyph_format == FT_GLYPH_FORMAT_OUTLINE &&\n           clazz->raster_class->raster_new )\n      {\n        error = clazz->raster_class->raster_new( memory, &render->raster );\n        if ( error )\n          goto Fail;\n\n        render->raster_render = clazz->raster_class->raster_render;\n        render->render        = clazz->render_glyph;\n      }\n\n      /* add to list */\n      node->data = module;\n      FT_List_Add( &library->renderers, node );\n\n      ft_set_current_renderer( library );\n    }\n\n  Fail:\n    if ( error )\n      FT_FREE( node );\n\n  Exit:\n    return error;\n  }\n",
        "target": 0
    },
    {
        "id": 1444,
        "func": "void WebContentsImpl::CreateNewWidget(int32_t render_process_id,\n                                      int32_t route_id,\n                                      bool is_fullscreen,\n                                      mojom::WidgetPtr widget) {\n  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);\n  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {\n    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);\n    return;\n  }\n\n  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(\n      this, process, route_id, std::move(widget), IsHidden());\n\n  RenderWidgetHostViewBase* widget_view =\n      static_cast<RenderWidgetHostViewBase*>(\n          view_->CreateViewForChildWidget(widget_host));\n  if (!widget_view)\n    return;\n  if (!is_fullscreen)\n    widget_view->SetWidgetType(WidgetType::kPopup);\n  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =\n      widget_view;\n}\n",
        "target": 0
    },
    {
        "id": 1445,
        "func": "void OffscreenCanvasSurfaceImpl::SetBeginFrameSource(\n    cc::BeginFrameSource* begin_frame_source) {}\n",
        "target": 1
    },
    {
        "id": 1446,
        "func": "display_init(struct display *dp)\n /* Call this only once right at the start to initialize the control\n    * structure, the (struct buffer) lists are maintained across calls - the\n    * memory is not freed.\n    */\n{\n   memset(dp, 0, sizeof *dp);\n   dp->options = WARNINGS; /* default to !verbose, !quiet */\n   dp->filename = NULL;\n   dp->operation = NULL;\n   dp->original_pp = NULL;\n   dp->original_ip = NULL;\n   dp->original_rows = NULL;\n   dp->read_pp = NULL;\n   dp->read_ip = NULL;\n   buffer_init(&dp->original_file);\n\n#  ifdef PNG_WRITE_SUPPORTED\n      dp->write_pp = NULL;\n      buffer_init(&dp->written_file);\n#  endif\n}\n",
        "target": 0
    },
    {
        "id": 1447,
        "func": "void ACodec::FlushingState::stateEntered() {\n    ALOGV(\"[%s] Now Flushing\", mCodec->mComponentName.c_str());\n\n    mFlushComplete[kPortIndexInput] = mFlushComplete[kPortIndexOutput] = false;\n}\n",
        "target": 0
    },
    {
        "id": 1448,
        "func": "bool RenderWidgetHostViewGuest::SupportsSpeech() const {\n  NOTIMPLEMENTED();\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 1449,
        "func": "static void auth_exit_ev(const void *event_data, void *user_data) {\n  pr_auth_cache_clear();\n\n  /* Close the scoreboard descriptor that we opened. */\n  (void) pr_close_scoreboard(FALSE);\n}\n",
        "target": 0
    },
    {
        "id": 1450,
        "func": "void JBIG2Bitmap::duplicateRow(int yDest, int ySrc) {\n  memcpy(data + yDest * line, data + ySrc * line, line);\n}\n",
        "target": 0
    },
    {
        "id": 1451,
        "func": "MagickPrivate MagickBooleanType AnnotateComponentGenesis(void)\n{\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    annotate_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}",
        "target": 0
    },
    {
        "id": 1452,
        "func": "ScriptValue Document::registerElement(ScriptState* script_state,\n                                      const AtomicString& name,\n                                      const ElementRegistrationOptions* options,\n                                      ExceptionState& exception_state) {\n  if (!RegistrationContext()) {\n    exception_state.ThrowDOMException(\n        DOMExceptionCode::kNotSupportedError,\n        \"No element registration context is available.\");\n    return ScriptValue();\n  }\n\n  if (name == \"dom-module\")\n    UseCounter::Count(*this, WebFeature::kPolymerV1Detected);\n\n  V0CustomElementConstructorBuilder constructor_builder(script_state, options);\n  RegistrationContext()->RegisterElement(this, &constructor_builder, name,\n                                         exception_state);\n  return constructor_builder.BindingsReturnValue();\n}\n",
        "target": 0
    },
    {
        "id": 1453,
        "func": "    virtual void drawLayersOnCCThread(CCLayerTreeHostImpl* impl)\n    {\n        m_numDraws++;\n        if (!impl->sourceFrameNumber())\n            endTest();\n    }\n",
        "target": 0
    },
    {
        "id": 1454,
        "func": "HB_Error  HB_GPOS_Select_Script( HB_GPOSHeader*  gpos,\n\t\t\t\t HB_UInt         script_tag,\n\t\t\t\t HB_UShort*       script_index )\n{\n  HB_UShort          n;\n\n  HB_ScriptList*    sl;\n  HB_ScriptRecord*  sr;\n\n\n  if ( !gpos || !script_index )\n    return ERR(HB_Err_Invalid_Argument);\n\n  sl = &gpos->ScriptList;\n  sr = sl->ScriptRecord;\n\n  for ( n = 0; n < sl->ScriptCount; n++ )\n    if ( script_tag == sr[n].ScriptTag )\n    {\n      *script_index = n;\n\n      return HB_Err_Ok;\n    }\n\n  return HB_Err_Not_Covered;\n}\n",
        "target": 0
    },
    {
        "id": 1455,
        "func": "error::Error GLES2DecoderImpl::HandleGetShaderSource(\n    uint32 immediate_data_size, const gles2::GetShaderSource& c) {\n  GLuint shader = c.shader;\n  uint32 bucket_id = static_cast<uint32>(c.bucket_id);\n  Bucket* bucket = CreateBucket(bucket_id);\n  ShaderManager::ShaderInfo* info = GetShaderInfoNotProgram(\n      shader, \"glGetShaderSource\");\n  if (!info || !info->source()) {\n    bucket->SetSize(0);\n    return error::kNoError;\n  }\n  bucket->SetFromString(info->source()->c_str());\n  return error::kNoError;\n}\n",
        "target": 0
    },
    {
        "id": 1456,
        "func": "static void process_bin_flush(conn *c) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = binary_get_request(c);\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    set_current_time();\n\n    if (exptime > 0) {\n        settings.oldest_live = realtime(exptime) - 1;\n    } else {\n        settings.oldest_live = current_time - 1;\n    }\n    item_flush_expired();\n\n    pthread_mutex_lock(&c->thread->stats.mutex);\n    c->thread->stats.flush_cmds++;\n    pthread_mutex_unlock(&c->thread->stats.mutex);\n\n    write_bin_response(c, NULL, 0, 0, 0);\n}",
        "target": 0
    },
    {
        "id": 1457,
        "func": "void Document::nodeWillBeRemoved(Node* n)\n{\n    HashSet<NodeIterator*>::const_iterator nodeIteratorsEnd = m_nodeIterators.end();\n    for (HashSet<NodeIterator*>::const_iterator it = m_nodeIterators.begin(); it != nodeIteratorsEnd; ++it)\n        (*it)->nodeWillBeRemoved(n);\n\n    if (!m_ranges.isEmpty()) {\n        HashSet<Range*>::const_iterator rangesEnd = m_ranges.end();\n        for (HashSet<Range*>::const_iterator it = m_ranges.begin(); it != rangesEnd; ++it)\n            (*it)->nodeWillBeRemoved(n);\n    }\n\n    if (Frame* frame = this->frame()) {\n        frame->eventHandler()->nodeWillBeRemoved(n);\n        frame->selection().nodeWillBeRemoved(n);\n        frame->page()->dragCaretController().nodeWillBeRemoved(n);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1458,
        "func": "static inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}",
        "target": 0
    },
    {
        "id": 1459,
        "func": "ScriptPromise ImageBitmapFactories::createImageBitmap(EventTarget& eventTarget, HTMLCanvasElement* canvas, int sx, int sy, int sw, int sh, ExceptionState& exceptionState)\n{\n    ASSERT(eventTarget.toDOMWindow());\n\n    if (!canvas) {\n        exceptionState.throwTypeError(\"The canvas element provided is invalid.\");\n        return ScriptPromise();\n    }\n    if (!canvas->originClean()) {\n        exceptionState.throwSecurityError(\"The canvas element provided is tainted with cross-origin data.\");\n        return ScriptPromise();\n    }\n    if (!sw || !sh) {\n         exceptionState.throwDOMException(IndexSizeError, String::format(\"The source %s provided is 0.\", sw ? \"height\" : \"width\"));\n         return ScriptPromise();\n     }\n    return fulfillImageBitmap(eventTarget.executionContext(), ImageBitmap::create(canvas, IntRect(sx, sy, sw, sh)));\n }\n",
        "target": 1
    },
    {
        "id": 1460,
        "func": "bool NaClProcessHost::Launch(\n    ChromeRenderMessageFilter* chrome_render_message_filter,\n    int socket_count,\n    IPC::Message* reply_msg) {\n#ifdef DISABLE_NACL\n  NOTIMPLEMENTED() << \"Native Client disabled at build time\";\n  return false;\n#else\n  if (socket_count > 8) {\n    return false;\n  }\n\n\n  for (int i = 0; i < socket_count; i++) {\n    nacl::Handle pair[2];\n    if (nacl::SocketPair(pair) == -1)\n      return false;\n    internal_->sockets_for_renderer.push_back(pair[0]);\n    internal_->sockets_for_sel_ldr.push_back(pair[1]);\n    SetCloseOnExec(pair[0]);\n    SetCloseOnExec(pair[1]);\n  }\n\n  if (!LaunchSelLdr()) {\n    return false;\n  }\n  chrome_render_message_filter_ = chrome_render_message_filter;\n  reply_msg_ = reply_msg;\n\n  return true;\n#endif  // DISABLE_NACL\n}\n",
        "target": 0
    },
    {
        "id": 1461,
        "func": "static void hash_cleanup(Hash* hash)\n{\n  free(hash->head);\n  free(hash->val);\n  free(hash->chain);\n\n  free(hash->zeros);\n  free(hash->headz);\n  free(hash->chainz);\n}\n",
        "target": 0
    },
    {
        "id": 1462,
        "func": "void DevToolsWindow::RequestFileSystems() {\n  CHECK(web_contents_->GetURL().SchemeIs(chrome::kChromeDevToolsScheme));\n  file_helper_->RequestFileSystems(base::Bind(\n      &DevToolsWindow::FileSystemsLoaded, weak_factory_.GetWeakPtr()));\n}\n",
        "target": 0
    },
    {
        "id": 1463,
        "func": "static inline void shrink_free_pagepool(struct xen_blkif *blkif, int num)\n{\n\t/* Remove requested pages in batches of NUM_BATCH_FREE_PAGES */\n\tstruct page *page[NUM_BATCH_FREE_PAGES];\n\tunsigned int num_pages = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&blkif->free_pages_lock, flags);\n\twhile (blkif->free_pages_num > num) {\n\t\tBUG_ON(list_empty(&blkif->free_pages));\n\t\tpage[num_pages] = list_first_entry(&blkif->free_pages,\n\t\t                                   struct page, lru);\n\t\tlist_del(&page[num_pages]->lru);\n\t\tblkif->free_pages_num--;\n\t\tif (++num_pages == NUM_BATCH_FREE_PAGES) {\n\t\t\tspin_unlock_irqrestore(&blkif->free_pages_lock, flags);\n\t\t\tfree_xenballooned_pages(num_pages, page);\n\t\t\tspin_lock_irqsave(&blkif->free_pages_lock, flags);\n\t\t\tnum_pages = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&blkif->free_pages_lock, flags);\n\tif (num_pages != 0)\n\t\tfree_xenballooned_pages(num_pages, page);\n}",
        "target": 0
    },
    {
        "id": 1464,
        "func": " bool WebPageProxy::gestureWillBegin(const IntPoint& point)\n {\n    bool canBeginPanning;\n     process()->sendSync(Messages::WebPage::GestureWillBegin(point), Messages::WebPage::GestureWillBegin::Reply(canBeginPanning), m_pageID);\n     return canBeginPanning;\n }\n",
        "target": 1
    },
    {
        "id": 1465,
        "func": "static ssize_t mem_read(struct file * file, char __user * buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = -ESRCH;\n\tstruct mm_struct *mm;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tmm = check_mem_permission(task);\n\tret = PTR_ERR(mm);\n\tif (IS_ERR(mm))\n\t\tgoto out_free;\n\n\tret = -EIO;\n \n\tif (file->private_data != (void*)((long)current->self_exec_id))\n\t\tgoto out_put;\n\n\tret = 0;\n \n\twhile (count > 0) {\n\t\tint this_len, retval;\n\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tretval = access_remote_vm(mm, src, page, this_len, 0);\n\t\tif (!retval) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n \n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\nout_put:\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1466,
        "func": "  void Zoom(double factor, bool text_only) {\n    if (ppp_zoom_ != NULL) {\n      ppp_zoom_->Zoom(plugin_->pp_instance(),\n                      factor,\n                      PP_FromBool(text_only));\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 1467,
        "func": "void RenderViewImpl::OnDragSourceSystemDragEnded() {\n  webview()->dragSourceSystemDragEnded();\n}\n",
        "target": 0
    },
    {
        "id": 1468,
        "func": "void IndexedDBDatabase::Put(IndexedDBTransaction* transaction,\n                            int64_t object_store_id,\n                            IndexedDBValue* value,\n                            std::unique_ptr<IndexedDBKey> key,\n                            blink::mojom::IDBPutMode put_mode,\n                            scoped_refptr<IndexedDBCallbacks> callbacks,\n                            const std::vector<IndexedDBIndexKeys>& index_keys) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::Put\", \"txn.id\", transaction->id());\n  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);\n\n  if (!ValidateObjectStoreId(object_store_id))\n    return;\n\n  DCHECK(key);\n  DCHECK(value);\n  std::unique_ptr<PutOperationParams> params(\n      std::make_unique<PutOperationParams>());\n  params->object_store_id = object_store_id;\n  params->value.swap(*value);\n  params->key = std::move(key);\n  params->put_mode = put_mode;\n  params->callbacks = callbacks;\n  params->index_keys = index_keys;\n  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::PutOperation,\n                                           this, std::move(params)));\n}\n",
        "target": 0
    },
    {
        "id": 1469,
        "func": "invoke_NPN_NewStream(PluginInstance *plugin, NPMIMEType type, const char *target, NPStream **pstream)\n{\n  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),\n\t\t\t\t\t\t NPERR_GENERIC_ERROR);\n\n  int error = rpc_method_invoke(g_rpc_connection,\n\t\t\t\t\t\t\t\tRPC_METHOD_NPN_NEW_STREAM,\n\t\t\t\t\t\t\t\tRPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,\n\t\t\t\t\t\t\t\tRPC_TYPE_STRING, type,\n\t\t\t\t\t\t\t\tRPC_TYPE_STRING, target,\n\t\t\t\t\t\t\t\tRPC_TYPE_INVALID);\n\n  if (error != RPC_ERROR_NO_ERROR) {\n\tnpw_perror(\"NPN_NewStream() invoke\", error);\n\treturn NPERR_OUT_OF_MEMORY_ERROR;\n  }\n\n  int32_t ret;\n  uint32_t stream_id;\n  char *url;\n  uint32_t end;\n  uint32_t lastmodified;\n  void *notifyData;\n  char *headers;\n  error = rpc_method_wait_for_reply(g_rpc_connection,\n\t\t\t\t\t\t\t\t\tRPC_TYPE_INT32, &ret,\n\t\t\t\t\t\t\t\t\tRPC_TYPE_UINT32, &stream_id,\n\t\t\t\t\t\t\t\t\tRPC_TYPE_STRING, &url,\n\t\t\t\t\t\t\t\t\tRPC_TYPE_UINT32, &end,\n\t\t\t\t\t\t\t\t\tRPC_TYPE_UINT32, &lastmodified,\n\t\t\t\t\t\t\t\t\tRPC_TYPE_NP_NOTIFY_DATA, &notifyData,\n\t\t\t\t\t\t\t\t\tRPC_TYPE_STRING, &headers,\n\t\t\t\t\t\t\t\t\tRPC_TYPE_INVALID);\n\n  if (error != RPC_ERROR_NO_ERROR) {\n\tnpw_perror(\"NPN_NewStream() wait for reply\", error);\n\treturn NPERR_GENERIC_ERROR;\n  }\n\n  NPStream *stream = NULL;\n  if (ret == NPERR_NO_ERROR) {\n\tif ((stream = malloc(sizeof(*stream))) == NULL)\n\t  return NPERR_OUT_OF_MEMORY_ERROR;\n\tmemset(stream, 0, sizeof(*stream));\n\n\tStreamInstance *stream_ndata;\n\tif ((stream_ndata = malloc(sizeof(*stream_ndata))) == NULL) {\n\t  free(stream);\n\t  return NPERR_OUT_OF_MEMORY_ERROR;\n\t}\n\tstream->ndata = stream_ndata;\n\tstream->url = url;\n\tstream->end = end;\n\tstream->lastmodified = lastmodified;\n\tstream->notifyData = notifyData;\n\tstream->headers = headers;\n\tmemset(stream_ndata, 0, sizeof(*stream_ndata));\n\tstream_ndata->stream_id = stream_id;\n\tid_link(stream_id, stream_ndata);\n\tstream_ndata->stream = stream;\n\tstream_ndata->is_plugin_stream = 1;\n  }\n  else {\n\tif (url)\n\t  free(url);\n\tif (headers)\n\t  free(headers);\n  }\n  *pstream = stream;\n\n  return ret;\n}",
        "target": 0
    },
    {
        "id": 1470,
        "func": "void omx_video::free_ion_memory(struct venc_ion *buf_ion_info)\n{\n if (!buf_ion_info) {\n        DEBUG_PRINT_ERROR(\"Invalid input to free_ion_memory\");\n return;\n }\n if (ioctl(buf_ion_info->ion_device_fd,ION_IOC_FREE,\n &buf_ion_info->ion_alloc_data.handle)) {\n        DEBUG_PRINT_ERROR(\"ION free failed \");\n return;\n }\n    close(buf_ion_info->ion_device_fd);\n    buf_ion_info->ion_alloc_data.handle = 0;\n    buf_ion_info->ion_device_fd = -1;\n    buf_ion_info->fd_ion_data.fd = -1;\n}\n",
        "target": 0
    },
    {
        "id": 1471,
        "func": "void WebBluetoothServiceImpl::OnCharacteristicWriteValueFailed(\n    RemoteCharacteristicWriteValueCallback callback,\n    device::BluetoothRemoteGattService::GattErrorCode error_code) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  std::move(callback).Run(TranslateGATTErrorAndRecord(\n      error_code, UMAGATTOperation::CHARACTERISTIC_WRITE));\n}\n",
        "target": 0
    },
    {
        "id": 1472,
        "func": "int perf_swevent_get_recursion_context(void)\n{\n\tstruct swevent_htable *swhash = &__get_cpu_var(swevent_htable);\n\n\treturn get_recursion_context(swhash->recursion);\n}",
        "target": 0
    },
    {
        "id": 1473,
        "func": "static int oz_hcd_buffer_data(struct oz_endpoint *ep, const u8 *data,\n\t\t\t      int data_len)\n{\n\tint space;\n\tint copy_len;\n\n\tif (!ep->buffer)\n\t\treturn -1;\n\tspace = ep->out_ix-ep->in_ix-1;\n\tif (space < 0)\n\t\tspace += ep->buffer_size;\n\tif (space < (data_len+1)) {\n\t\toz_dbg(ON, \"Buffer full\\n\");\n\t\treturn -1;\n\t}\n\tep->buffer[ep->in_ix] = (u8)data_len;\n\tif (++ep->in_ix == ep->buffer_size)\n\t\tep->in_ix = 0;\n\tcopy_len = ep->buffer_size - ep->in_ix;\n\tif (copy_len > data_len)\n\t\tcopy_len = data_len;\n\tmemcpy(&ep->buffer[ep->in_ix], data, copy_len);\n\n\tif (copy_len < data_len) {\n\t\tmemcpy(ep->buffer, data+copy_len, data_len-copy_len);\n\t\tep->in_ix = data_len-copy_len;\n\t} else {\n\t\tep->in_ix += copy_len;\n\t}\n\tif (ep->in_ix == ep->buffer_size)\n\t\tep->in_ix = 0;\n\tep->buffered_units++;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1474,
        "func": "spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}",
        "target": 1
    },
    {
        "id": 1475,
        "func": "static ssize_t aac_show_max_id(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t  class_to_shost(device)->max_id);\n}",
        "target": 0
    },
    {
        "id": 1476,
        "func": "dissect_spoolss_string_parm_data(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t    proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 buffer_len, len;\n\tgchar *s;\n\tproto_item *item = NULL;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\t/* Dissect size and data */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\thf_string_parm_size, &buffer_len);\n\n\ts = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &len, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\n\tif (tree && buffer_len) {\n\t\ttvb_ensure_bytes_exist(tvb, offset, buffer_len);\n\n\t\titem = proto_tree_add_string(\n\t\t\ttree, hf_string_parm_data, tvb, offset, len, s);\n\t}\n\toffset += buffer_len;\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", s);\n\n\t/* Append string to upper level item */\n\tif (tree && item) {\n\t\titem = item->parent != NULL ? item->parent : item;\n\t\tproto_item_append_text(item, \": %s\", s);\n\t}\n\n\treturn offset;\n}",
        "target": 0
    },
    {
        "id": 1477,
        "func": "GahpServer::getPollInterval()\n{\n\treturn m_pollInterval;\n}\n",
        "target": 0
    },
    {
        "id": 1478,
        "func": "GDataRootDirectory::GDataRootDirectory()\n    : ALLOW_THIS_IN_INITIALIZER_LIST(GDataDirectory(NULL, this)),\n      fake_search_directory_(new GDataDirectory(NULL, NULL)),\n       largest_changestamp_(0), serialized_size_(0) {\n   title_ = kGDataRootDirectory;\n   SetFileNameFromTitle();\n  resource_id_ = kGDataRootDirectoryResourceId;\n  // Add self to the map so the root directory can be looked up by the\n  // resource ID.\n  AddEntryToResourceMap(this);\n }\n",
        "target": 0
    },
    {
        "id": 1479,
        "func": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\terr = notify_change(upperdentry, attr, NULL);\n\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t} else {\n\t\terr = ovl_copy_up_last(dentry, attr, false);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 1480,
        "func": "ofputil_append_ofp15_group_desc_reply(const struct ofputil_group_desc *gds,\n                                      const struct ovs_list *buckets,\n                                      struct ovs_list *replies,\n                                      enum ofp_version version)\n{\n    struct ofpbuf *reply = ofpbuf_from_list(ovs_list_back(replies));\n    struct ofp15_group_desc_stats *ogds;\n    struct ofputil_bucket *bucket;\n    size_t start_ogds, start_buckets;\n\n    start_ogds = reply->size;\n    ofpbuf_put_zeros(reply, sizeof *ogds);\n    start_buckets = reply->size;\n    LIST_FOR_EACH (bucket, list_node, buckets) {\n        ofputil_put_ofp15_bucket(bucket, bucket->bucket_id,\n                                 gds->type, reply, version);\n    }\n    ogds = ofpbuf_at_assert(reply, start_ogds, sizeof *ogds);\n    ogds->type = gds->type;\n    ogds->group_id = htonl(gds->group_id);\n    ogds->bucket_list_len =  htons(reply->size - start_buckets);\n\n    /* Add group properties */\n    if (gds->props.selection_method[0]) {\n        ofputil_put_group_prop_ntr_selection_method(version, &gds->props,\n                                                    reply);\n    }\n    ogds = ofpbuf_at_assert(reply, start_ogds, sizeof *ogds);\n    ogds->length = htons(reply->size - start_ogds);\n\n    ofpmp_postappend(replies, start_ogds);\n}\n",
        "target": 0
    },
    {
        "id": 1481,
        "func": "  int RequestNavigation(FrameTreeNode* node, const GURL& url) {\n    return RequestNavigationWithParameters(node, url, Referrer(),\n                                           ui::PAGE_TRANSITION_LINK);\n  }\n",
        "target": 0
    },
    {
        "id": 1482,
        "func": "void ContainerNode::cloneChildNodes(ContainerNode *clone)\n{\n    HTMLElement* deleteButtonContainerElement = 0;\n    if (Frame* frame = document()->frame())\n        deleteButtonContainerElement = frame->editor()->deleteButtonController()->containerElement();\n\n    ExceptionCode ec = 0;\n    for (Node* n = firstChild(); n && !ec; n = n->nextSibling()) {\n        if (n == deleteButtonContainerElement)\n            continue;\n        clone->appendChild(n->cloneNode(true), ec);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1483,
        "func": "void FindMatchesByUsername(const PasswordFormFillData& fill_data,\n                           const base::string16& current_username,\n                           bool exact_username_match,\n                           RendererSavePasswordProgressLogger* logger,\n                           base::string16* username,\n                           base::string16* password) {\n  if (DoUsernamesMatch(fill_data.username_field.value, current_username,\n                       exact_username_match)) {\n    *username = fill_data.username_field.value;\n    *password = fill_data.password_field.value;\n    if (logger)\n      logger->LogMessage(Logger::STRING_USERNAMES_MATCH);\n  } else {\n    for (const auto& it : fill_data.additional_logins) {\n      if (!it.second.realm.empty()) {\n        continue;\n      }\n      if (DoUsernamesMatch(it.first, current_username, exact_username_match)) {\n        *username = it.first;\n        *password = it.second.password;\n        break;\n      }\n    }\n    if (logger) {\n      logger->LogBoolean(Logger::STRING_MATCH_IN_ADDITIONAL,\n                         !(username->empty() && password->empty()));\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1484,
        "func": "omx_vdec::~omx_vdec()\n{\n    m_pmem_info = NULL;\n struct v4l2_decoder_cmd dec;\n    DEBUG_PRINT_HIGH(\"In OMX vdec Destructor\");\n if (m_pipe_in) close(m_pipe_in);\n if (m_pipe_out) close(m_pipe_out);\n    m_pipe_in = -1;\n    m_pipe_out = -1;\n    DEBUG_PRINT_HIGH(\"Waiting on OMX Msg Thread exit\");\n if (msg_thread_created)\n        pthread_join(msg_thread_id,NULL);\n    DEBUG_PRINT_HIGH(\"Waiting on OMX Async Thread exit\");\n    dec.cmd = V4L2_DEC_CMD_STOP;\n if (drv_ctx.video_driver_fd >=0 ) {\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_DECODER_CMD, &dec))\n            DEBUG_PRINT_ERROR(\"STOP Command failed\");\n }\n if (async_thread_created)\n        pthread_join(async_thread_id,NULL);\n    unsubscribe_to_events(drv_ctx.video_driver_fd);\n\n     close(drv_ctx.video_driver_fd);\n     pthread_mutex_destroy(&m_lock);\n     pthread_mutex_destroy(&c_lock);\n     sem_destroy(&m_cmd_lock);\n     if (perf_flag) {\n         DEBUG_PRINT_HIGH(\"--> TOTAL PROCESSING TIME\");\n        dec_time.end();\n }\n    DEBUG_PRINT_INFO(\"Exit OMX vdec Destructor: fd=%d\",drv_ctx.video_driver_fd);\n}\n",
        "target": 1
    },
    {
        "id": 1485,
        "func": "int __init tcp4_proc_init(void)\n{\n\treturn register_pernet_subsys(&tcp4_net_ops);\n}",
        "target": 0
    },
    {
        "id": 1486,
        "func": "JSValue jsTestObjConditionalAttr2(ExecState* exec, JSValue slotBase, const Identifier&)\n{\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(slotBase));\n    UNUSED_PARAM(exec);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    JSValue result = jsNumber(impl->conditionalAttr2());\n    return result;\n}\n",
        "target": 0
    },
    {
        "id": 1487,
        "func": "InputType* PasswordInputType::Create(HTMLInputElement& element) {\n  return new PasswordInputType(element);\n}\n",
        "target": 0
    },
    {
        "id": 1488,
        "func": "AutoFillCCInfoBarDelegate::AutoFillCCInfoBarDelegate(TabContents* tab_contents,\n                                                      AutoFillManager* host)\n     : ConfirmInfoBarDelegate(tab_contents),\n       host_(host) {\n  if (tab_contents)\n    tab_contents->AddInfoBar(this);\n }\n",
        "target": 1
    },
    {
        "id": 1489,
        "func": "void tty_write_message(struct tty_struct *tty, char *msg)\n{\n\tif (tty) {\n\t\tmutex_lock(&tty->atomic_write_lock);\n\t\ttty_lock(tty);\n\t\tif (tty->ops->write && tty->count > 0)\n\t\t\ttty->ops->write(tty, msg, strlen(msg));\n\t\ttty_unlock(tty);\n\t\ttty_write_unlock(tty);\n\t}\n\treturn;\n}",
        "target": 0
    },
    {
        "id": 1490,
        "func": "  static void  Ins_IP( INS_ARG )\n  {\n    TT_F26Dot6  org_a, org_b, org_x,\n                cur_a, cur_b, cur_x,\n                distance;\n    Int         point;\n    (void)args;\n\n    if ( CUR.top < CUR.GS.loop ||\n         BOUNDS(CUR.GS.rp1, CUR.zp0.n_points) ||\n         BOUNDS(CUR.GS.rp2, CUR.zp1.n_points))\n    {\n      CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    org_a = CUR_Func_dualproj( CUR.zp0.org_x[CUR.GS.rp1],\n                               CUR.zp0.org_y[CUR.GS.rp1] );\n\n    org_b = CUR_Func_dualproj( CUR.zp1.org_x[CUR.GS.rp2],\n                               CUR.zp1.org_y[CUR.GS.rp2] );\n\n    cur_a = CUR_Func_project( CUR.zp0.cur_x[CUR.GS.rp1],\n                              CUR.zp0.cur_y[CUR.GS.rp1] );\n\n    cur_b = CUR_Func_project( CUR.zp1.cur_x[CUR.GS.rp2],\n                              CUR.zp1.cur_y[CUR.GS.rp2] );\n\n    while ( CUR.GS.loop > 0 )\n    {\n      CUR.args--;\n\n      point = (Int)CUR.stack[CUR.args];\n      if ( BOUNDS( point, CUR.zp2.n_points ) )\n      {\n        CUR.error = TT_Err_Invalid_Reference;\n        return;\n      }\n\n      org_x = CUR_Func_dualproj( CUR.zp2.org_x[point],\n                                 CUR.zp2.org_y[point] );\n\n      cur_x = CUR_Func_project( CUR.zp2.cur_x[point],\n                                CUR.zp2.cur_y[point] );\n\n      if ( ( org_a <= org_b && org_x <= org_a ) ||\n           ( org_a >  org_b && org_x >= org_a ) )\n\n        distance = ( cur_a - org_a ) + ( org_x - cur_x );\n\n      else if ( ( org_a <= org_b  &&  org_x >= org_b ) ||\n                ( org_a >  org_b  &&  org_x <  org_b ) )\n\n        distance = ( cur_b - org_b ) + ( org_x - cur_x );\n\n      else\n         /* note: it seems that rounding this value isn't a good */\n         /*       idea (cf. width of capital 'S' in Times)       */\n\n         distance = MulDiv_Round( cur_b - cur_a,\n                                  org_x - org_a,\n                                  org_b - org_a ) + ( cur_a - cur_x );\n\n      CUR_Func_move( &CUR.zp2, point, distance );\n\n      CUR.GS.loop--;\n    }\n\n    CUR.GS.loop = 1;\n    CUR.new_top = CUR.args;\n  }\n",
        "target": 0
    },
    {
        "id": 1491,
        "func": "static inline void __flow_hash_consistentify(struct flow_keys *keys)\n{\n\tint addr_diff, i;\n\n\tswitch (keys->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\taddr_diff = (__force u32)keys->addrs.v4addrs.dst -\n\t\t\t    (__force u32)keys->addrs.v4addrs.src;\n\t\tif ((addr_diff < 0) ||\n\t\t    (addr_diff == 0 &&\n\t\t     ((__force u16)keys->ports.dst <\n\t\t      (__force u16)keys->ports.src))) {\n\t\t\tswap(keys->addrs.v4addrs.src, keys->addrs.v4addrs.dst);\n\t\t\tswap(keys->ports.src, keys->ports.dst);\n\t\t}\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\taddr_diff = memcmp(&keys->addrs.v6addrs.dst,\n\t\t\t\t   &keys->addrs.v6addrs.src,\n\t\t\t\t   sizeof(keys->addrs.v6addrs.dst));\n\t\tif ((addr_diff < 0) ||\n\t\t    (addr_diff == 0 &&\n\t\t     ((__force u16)keys->ports.dst <\n\t\t      (__force u16)keys->ports.src))) {\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tswap(keys->addrs.v6addrs.src.s6_addr32[i],\n\t\t\t\t     keys->addrs.v6addrs.dst.s6_addr32[i]);\n\t\t\tswap(keys->ports.src, keys->ports.dst);\n\t\t}\n\t\tbreak;\n\t}\n}",
        "target": 0
    },
    {
        "id": 1492,
        "func": "static void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\n\tmight_sleep();\n\n\tpage = gfn_to_page(svm->vcpu.kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\n\t*_page = page;\n\n\treturn kmap(page);\n\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 1493,
        "func": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}",
        "target": 1
    },
    {
        "id": 1494,
        "func": "netlink_kernel_create(struct net *net, int unit,\n\t\t      struct module *module,\n\t\t      struct netlink_kernel_cfg *cfg)\n{\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tstruct netlink_sock *nlk;\n\tstruct listeners *listeners = NULL;\n\tstruct mutex *cb_mutex = cfg ? cfg->cb_mutex : NULL;\n\tunsigned int groups;\n\n\tBUG_ON(!nl_table);\n\n\tif (unit < 0 || unit >= MAX_LINKS)\n\t\treturn NULL;\n\n\tif (sock_create_lite(PF_NETLINK, SOCK_DGRAM, unit, &sock))\n\t\treturn NULL;\n\n\t/*\n\t * We have to just have a reference on the net from sk, but don't\n\t * get_net it. Besides, we cannot get and then put the net here.\n\t * So we create one inside init_net and the move it to net.\n\t */\n\n\tif (__netlink_create(&init_net, sock, cb_mutex, unit) < 0)\n\t\tgoto out_sock_release_nosk;\n\n\tsk = sock->sk;\n\tsk_change_net(sk, net);\n\n\tif (!cfg || cfg->groups < 32)\n\t\tgroups = 32;\n\telse\n\t\tgroups = cfg->groups;\n\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tgoto out_sock_release;\n\n\tsk->sk_data_ready = netlink_data_ready;\n\tif (cfg && cfg->input)\n\t\tnlk_sk(sk)->netlink_rcv = cfg->input;\n\n\tif (netlink_insert(sk, net, 0))\n\t\tgoto out_sock_release;\n\n\tnlk = nlk_sk(sk);\n\tnlk->flags |= NETLINK_KERNEL_SOCKET;\n\n\tnetlink_table_grab();\n\tif (!nl_table[unit].registered) {\n\t\tnl_table[unit].groups = groups;\n\t\trcu_assign_pointer(nl_table[unit].listeners, listeners);\n\t\tnl_table[unit].cb_mutex = cb_mutex;\n\t\tnl_table[unit].module = module;\n\t\tnl_table[unit].bind = cfg ? cfg->bind : NULL;\n\t\tnl_table[unit].registered = 1;\n\t} else {\n\t\tkfree(listeners);\n\t\tnl_table[unit].registered++;\n\t}\n\tnetlink_table_ungrab();\n\treturn sk;\n\nout_sock_release:\n\tkfree(listeners);\n\tnetlink_kernel_release(sk);\n\treturn NULL;\n\nout_sock_release_nosk:\n\tsock_release(sock);\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 1495,
        "func": "SYSCALL_DEFINE0(restart_syscall)\n{\n\tstruct restart_block *restart = &current_thread_info()->restart_block;\n\treturn restart->fn(restart);\n}",
        "target": 0
    },
    {
        "id": 1496,
        "func": "void InputWindowInfo::addTouchableRegion(const Rect& region) {\n    touchableRegion.orSelf(region);\n}\n",
        "target": 0
    },
    {
        "id": 1497,
        "func": "static int _hid_get_config_descriptor(struct hid_device_priv* dev, void *data, size_t *size)\n",
        "target": 0
    },
    {
        "id": 1498,
        "func": "static inline void put_numa_group(struct numa_group *grp)\n{\n\tif (atomic_dec_and_test(&grp->refcount))\n\t\tkfree_rcu(grp, rcu);\n}",
        "target": 0
    },
    {
        "id": 1499,
        "func": "static void vmx_flush_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 *pml_buf;\n\tu16 pml_idx;\n\n\tpml_idx = vmcs_read16(GUEST_PML_INDEX);\n\n\t/* Do nothing if PML buffer is empty */\n\tif (pml_idx == (PML_ENTITY_NUM - 1))\n\t\treturn;\n\n\t/* PML index always points to next available PML buffer entity */\n\tif (pml_idx >= PML_ENTITY_NUM)\n\t\tpml_idx = 0;\n\telse\n\t\tpml_idx++;\n\n\tpml_buf = page_address(vmx->pml_pg);\n\tfor (; pml_idx < PML_ENTITY_NUM; pml_idx++) {\n\t\tu64 gpa;\n\n\t\tgpa = pml_buf[pml_idx];\n\t\tWARN_ON(gpa & (PAGE_SIZE - 1));\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\t}\n\n\t/* reset PML index */\n\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n}",
        "target": 0
    },
    {
        "id": 1500,
        "func": "lock_file_new (const char *path)\n{\n  LockFile *lock = xcalloc (sizeof (LockFile));\n\n  lock->path = path;\n  if (last_lock_file != NULL)\n    last_lock_file->next = lock;\n  else\n    lock_files = lock;\n\n  last_lock_file = lock;\n  return lock;\n}",
        "target": 0
    },
    {
        "id": 1501,
        "func": "void RenderView::ForEach(RenderViewVisitor* visitor) {\n  ViewMap* views = g_view_map.Pointer();\n  for (ViewMap::iterator it = views->begin(); it != views->end(); ++it) {\n    if (!visitor->Visit(it->second))\n      return;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1502,
        "func": "AffineTransform& AffineTransform::rotateFromVector(double x, double y)\n{\n    return rotateRadians(atan2(y, x));\n}\n",
        "target": 0
    },
    {
        "id": 1503,
        "func": "bool GLSurfaceOzoneSurfacelessSurfaceImpl::CreatePixmaps() {\n  if (!fbo_)\n    return true;\n  for (size_t i = 0; i < arraysize(textures_); i++) {\n    scoped_refptr<ui::NativePixmap> pixmap =\n        ui::OzonePlatform::GetInstance()\n            ->GetSurfaceFactoryOzone()\n            ->CreateNativePixmap(widget_, GetSize(),\n                                 gfx::BufferFormat::BGRA_8888,\n                                 gfx::BufferUsage::SCANOUT);\n    if (!pixmap)\n      return false;\n    scoped_refptr<GLImageOzoneNativePixmap> image =\n        new GLImageOzoneNativePixmap(GetSize(), GL_BGRA_EXT);\n    if (!image->Initialize(pixmap.get(), gfx::BufferFormat::BGRA_8888))\n      return false;\n    if (images_[i])\n      images_[i]->Destroy(true);\n    images_[i] = image;\n    ScopedTextureBinder binder(GL_TEXTURE_2D, textures_[i]);\n    if (!images_[i]->BindTexImage(GL_TEXTURE_2D))\n      return false;\n  }\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1504,
        "func": " bool Smb4KMountJob::fillArgs(Smb4KShare *share, QMap<QString, QVariant>& map)\n {\n  QString mount;\n  QStringList paths;\n  paths << \"/bin\";\n  paths << \"/sbin\";\n  paths << \"/usr/bin\";\n  paths << \"/usr/sbin\";\n  paths << \"/usr/local/bin\";\n  paths << \"/usr/local/sbin\";\n  for (int i = 0; i < paths.size(); ++i)\n  {\n    mount = KGlobal::dirs()->findExe(\"mount.cifs\", paths.at(i));\n    if (!mount.isEmpty())\n    {\n      map.insert(\"mh_command\", mount);\n      break;\n    }\n    else\n    {\n      continue;\n    }\n  }\n \n   if (mount.isEmpty())\n   {\n  paths << \"/sbin\";\n  paths << \"/usr/bin\";\n  paths << \"/usr/sbin\";\n  paths << \"/usr/local/bin\";\n  paths << \"/usr/local/sbin\";\n   }\n   \n   QMap<QString, QString> global_options = globalSambaOptions();\n   Smb4KCustomOptions *options  = Smb4KCustomOptionsManager::self()->findOptions(share);\n      break;\n    }\n",
        "target": 1
    },
    {
        "id": 1505,
        "func": "static void free_sched_domain(struct rcu_head *rcu)\n{\n\tstruct sched_domain *sd = container_of(rcu, struct sched_domain, rcu);\n\n\t/*\n\t * If its an overlapping domain it has private groups, iterate and\n\t * nuke them all.\n\t */\n\tif (sd->flags & SD_OVERLAP) {\n\t\tfree_sched_groups(sd->groups, 1);\n\t} else if (atomic_dec_and_test(&sd->groups->ref)) {\n\t\tkfree(sd->groups->sgc);\n\t\tkfree(sd->groups);\n\t}\n\tkfree(sd);\n}\n",
        "target": 0
    },
    {
        "id": 1506,
        "func": "MagickExport void SetImageInfoFile(ImageInfo *image_info,FILE *file)\n{\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image_info->file=file;\n}\n",
        "target": 0
    },
    {
        "id": 1507,
        "func": "bool ExtensionPrefs::RemoveIdleInstallInfo(const std::string& extension_id) {\n  if (!GetExtensionPref(extension_id))\n    return false;\n  ScopedExtensionPrefUpdate update(prefs_, extension_id);\n  bool result = update->Remove(kIdleInstallInfo, NULL);\n  return result;\n}\n",
        "target": 0
    },
    {
        "id": 1508,
        "func": "  void EndTraceAndFlushAsync(WaitableEvent* flush_complete_event) {\n    TraceLog::GetInstance()->SetDisabled();\n    TraceLog::GetInstance()->Flush(\n        base::Bind(&TraceEventTestFixture::OnTraceDataCollected,\n                   base::Unretained(static_cast<TraceEventTestFixture*>(this)),\n                   base::Unretained(flush_complete_event)));\n  }\n",
        "target": 0
    },
    {
        "id": 1509,
        "func": "std::vector<FilePath> GDataCache::GetCachePaths(\n    const FilePath& cache_root_path) {\n  std::vector<FilePath> cache_paths;\n  cache_paths.push_back(cache_root_path.Append(kGDataCacheMetaDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCachePinnedDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCacheOutgoingDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCachePersistentDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDownloadsDir));\n  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDocumentsDir));\n  return cache_paths;\n}\n",
        "target": 1
    },
    {
        "id": 1510,
        "func": "AXObjectInclusion AXLayoutObject::defaultObjectInclusion(\n    IgnoredReasons* ignoredReasons) const {\n\n  if (!m_layoutObject) {\n    if (ignoredReasons)\n      ignoredReasons->push_back(IgnoredReason(AXNotRendered));\n    return IgnoreObject;\n  }\n\n   if (m_layoutObject->style()->visibility() != EVisibility::kVisible) {\n    if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), \"false\"))\n       return DefaultBehavior;\n \n     if (ignoredReasons)\n      ignoredReasons->push_back(IgnoredReason(AXNotVisible));\n    return IgnoreObject;\n  }\n\n  return AXObject::defaultObjectInclusion(ignoredReasons);\n}\n",
        "target": 0
    },
    {
        "id": 1511,
        "func": "static unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}",
        "target": 0
    },
    {
        "id": 1512,
        "func": "void SoundPool::autoPause()\n{\n    ALOGV(\"autoPause()\");\n Mutex::Autolock lock(&mLock);\n for (int i = 0; i < mMaxChannels; ++i) {\n SoundChannel* channel = &mChannelPool[i];\n        channel->autoPause();\n }\n}\n",
        "target": 0
    },
    {
        "id": 1513,
        "func": " static Handle<Object> GetInternalImpl(Handle<JSObject> holder,\n uint32_t entry) {\n return GetImpl(holder, entry);\n }\n",
        "target": 0
    },
    {
        "id": 1514,
        "func": "static int http_read_stream(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int err, new_location, read_ret;\n    int64_t seek_ret;\n\n    if (!s->hd)\n        return AVERROR_EOF;\n\n    if (s->end_chunked_post && !s->end_header) {\n        err = http_read_header(h, &new_location);\n        if (err < 0)\n            return err;\n    }\n\n    if (s->chunksize >= 0) {\n        if (!s->chunksize) {\n            char line[32];\n\n                do {\n                    if ((err = http_get_line(s, line, sizeof(line))) < 0)\n                        return err;\n                } while (!*line);    /* skip CR LF from last chunk */\n\n                s->chunksize = strtoll(line, NULL, 16);\n\n                av_log(NULL, AV_LOG_TRACE, \"Chunked encoding data size: %\"PRId64\"'\\n\",\n                        s->chunksize);\n\n                if (!s->chunksize)\n                    return 0;\n        }\n        size = FFMIN(size, s->chunksize);\n    }\n#if CONFIG_ZLIB\n    if (s->compressed)\n        return http_buf_read_compressed(h, buf, size);\n#endif /* CONFIG_ZLIB */\n    read_ret = http_buf_read(h, buf, size);\n    if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)\n        || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {\n        int64_t target = h->is_streamed ? 0 : s->off;\n\n        if (s->reconnect_delay > s->reconnect_delay_max)\n            return AVERROR(EIO);\n\n        av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRId64\" error=%s.\\n\", s->off, av_err2str(read_ret));\n        av_usleep(1000U*1000*s->reconnect_delay);\n        s->reconnect_delay = 1 + 2*s->reconnect_delay;\n        seek_ret = http_seek_internal(h, target, SEEK_SET, 1);\n        if (seek_ret != target) {\n            av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRId64\".\\n\", target);\n            return read_ret;\n        }\n\n        read_ret = http_buf_read(h, buf, size);\n    } else\n        s->reconnect_delay = 0;\n\n    return read_ret;\n}",
        "target": 1
    },
    {
        "id": 1515,
        "func": "static const char *set_recursion_limit(cmd_parms *cmd, void *dummy,\n                                       const char *arg1, const char *arg2)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    int limit = atoi(arg1);\n\n    if (limit <= 0) {\n        return \"The recursion limit must be greater than zero.\";\n    }\n    if (limit < 4) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00119)\n                     \"Limiting internal redirects to very low numbers may \"\n                     \"cause normal requests to fail.\");\n    }\n\n    conf->redirect_limit = limit;\n\n    if (arg2) {\n        limit = atoi(arg2);\n\n        if (limit <= 0) {\n            return \"The recursion limit must be greater than zero.\";\n        }\n        if (limit < 4) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00120)\n                         \"Limiting the subrequest depth to a very low level may\"\n                         \" cause normal requests to fail.\");\n        }\n    }\n\n    conf->subreq_limit = limit;\n\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 1516,
        "func": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tcomplete(&task->slow_task->completion);\n}",
        "target": 1
    },
    {
        "id": 1517,
        "func": "static MagickBooleanType OpenPixelCacheOnDisk(CacheInfo *cache_info,\n  const MapMode mode)\n{\n  int\n    file;\n\n  /*\n    Open pixel cache on disk.\n  */\n  if ((cache_info->file != -1) && (cache_info->mode == mode))\n    return(MagickTrue);  /* cache already open and in the proper mode */\n  if (*cache_info->cache_filename == '\\0')\n    file=AcquireUniqueFileResource(cache_info->cache_filename);\n  else\n    switch (mode)\n    {\n      case ReadMode:\n      {\n        file=open_utf8(cache_info->cache_filename,O_RDONLY | O_BINARY,0);\n        break;\n      }\n      case WriteMode:\n      {\n        file=open_utf8(cache_info->cache_filename,O_WRONLY | O_CREAT |\n          O_BINARY | O_EXCL,S_MODE);\n        if (file == -1)\n          file=open_utf8(cache_info->cache_filename,O_WRONLY | O_BINARY,S_MODE);\n        break;\n      }\n      case IOMode:\n      default:\n      {\n        file=open_utf8(cache_info->cache_filename,O_RDWR | O_CREAT | O_BINARY |\n          O_EXCL,S_MODE);\n        if (file == -1)\n          file=open_utf8(cache_info->cache_filename,O_RDWR | O_BINARY,S_MODE);\n        break;\n      }\n    }\n  if (file == -1)\n    return(MagickFalse);\n  (void) AcquireMagickResource(FileResource,1);\n  if (cache_info->file != -1)\n    (void) ClosePixelCacheOnDisk(cache_info);\n  cache_info->file=file;\n  cache_info->mode=mode;\n  return(MagickTrue);\n}",
        "target": 0
    },
    {
        "id": 1518,
        "func": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_request_sock *req_inet;\n\n\t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\n\treq_inet = inet_rsk(req);\n\topt = xchg(&req_inet->opt, opt);\n\tkfree(opt);\n\n\treturn 0;\n\nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}",
        "target": 1
    },
    {
        "id": 1519,
        "func": "void V8TestObject::NamedPropertyEnumeratorCallback(\n    const v8::PropertyCallbackInfo<v8::Array>& info) {\n  test_object_v8_internal::NamedPropertyEnumerator(info);\n}\n",
        "target": 0
    },
    {
        "id": 1520,
        "func": "Browser::DownloadClosePreventionType Browser::OkToCloseWithInProgressDownloads(\n    int* num_downloads_blocking) const {\n  DCHECK(num_downloads_blocking);\n  *num_downloads_blocking = 0;\n\n  if (!g_browser_process->profile_manager())\n    return DOWNLOAD_CLOSE_OK;\n\n  int total_download_count =\n      DownloadService::NonMaliciousDownloadCountAllProfiles();\n  if (total_download_count == 0)\n    return DOWNLOAD_CLOSE_OK;   // No downloads; can definitely close.\n\n  int profile_window_count = 0;\n  int total_window_count = 0;\n  for (auto* browser : *BrowserList::GetInstance()) {\n    if (browser == this || browser->IsAttemptingToCloseBrowser())\n      continue;\n\n    if (browser->profile() == profile())\n      profile_window_count++;\n    total_window_count++;\n  }\n\n  if (total_window_count == 0) {\n    *num_downloads_blocking = total_download_count;\n    return DOWNLOAD_CLOSE_BROWSER_SHUTDOWN;\n  }\n\n  DownloadService* download_service =\n      DownloadServiceFactory::GetForBrowserContext(profile());\n  if ((profile_window_count == 0) &&\n      (download_service->NonMaliciousDownloadCount() > 0) &&\n      profile()->IsOffTheRecord()) {\n    *num_downloads_blocking = download_service->NonMaliciousDownloadCount();\n    return DOWNLOAD_CLOSE_LAST_WINDOW_IN_INCOGNITO_PROFILE;\n  }\n\n  return DOWNLOAD_CLOSE_OK;\n}\n",
        "target": 0
    },
    {
        "id": 1521,
        "func": "selFindMaxTranslations(SEL      *sel,\n                       l_int32  *pxp,\n                       l_int32  *pyp,\n                       l_int32  *pxn,\n                       l_int32  *pyn)\n{\nl_int32  sx, sy, cx, cy, i, j;\nl_int32  maxxp, maxyp, maxxn, maxyn;\n\n    PROCNAME(\"selaFindMaxTranslations\");\n\n    if (!pxp || !pyp || !pxn || !pyn)\n        return ERROR_INT(\"&xp (etc) defined\", procName, 1);\n    *pxp = *pyp = *pxn = *pyn = 0;\n    if (!sel)\n        return ERROR_INT(\"sel not defined\", procName, 1);\n    selGetParameters(sel, &sy, &sx, &cy, &cx);\n\n    maxxp = maxyp = maxxn = maxyn = 0;\n    for (i = 0; i < sy; i++) {\n        for (j = 0; j < sx; j++) {\n            if (sel->data[i][j] == 1) {\n                maxxp = L_MAX(maxxp, cx - j);\n                maxyp = L_MAX(maxyp, cy - i);\n                maxxn = L_MAX(maxxn, j - cx);\n                maxyn = L_MAX(maxyn, i - cy);\n            }\n        }\n    }\n\n    *pxp = maxxp;\n    *pyp = maxyp;\n    *pxn = maxxn;\n    *pyn = maxyn;\n\n    return 0;\n}",
        "target": 0
    },
    {
        "id": 1522,
        "func": "cdf_tole4(uint32_t sv)\n{\n\treturn CDF_TOLE4(sv);\n}",
        "target": 0
    },
    {
        "id": 1523,
        "func": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info->si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info->si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}",
        "target": 0
    },
    {
        "id": 1524,
        "func": "PHP_PGSQL_API int php_pgsql_result2array(PGresult *pg_result, zval *ret_array) \n{\n\tzval row;\n\tchar *field_name;\n\tsize_t num_fields;\n\tint pg_numrows, pg_row;\n\tuint i;\n\tassert(Z_TYPE_P(ret_array) == IS_ARRAY);\n\n\tif ((pg_numrows = PQntuples(pg_result)) <= 0) {\n\t\treturn FAILURE;\n\t}\n\tfor (pg_row = 0; pg_row < pg_numrows; pg_row++) {\n\t\tarray_init(&row);\n\t\tfor (i = 0, num_fields = PQnfields(pg_result); i < num_fields; i++) {\n\t\t\tif (PQgetisnull(pg_result, pg_row, i)) {\n\t\t\t\tfield_name = PQfname(pg_result, i);\n\t\t\t\tadd_assoc_null(&row, field_name);\n\t\t\t} else {\n\t\t\t\tchar *element = PQgetvalue(pg_result, pg_row, i);\n\t\t\t\tif (element) {\n\t\t\t\t\tconst size_t element_len = strlen(element);\n\n\t\t\t\t\tfield_name = PQfname(pg_result, i);\n\t\t\t\t\tadd_assoc_stringl(&row, field_name, element, element_len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tadd_index_zval(ret_array, pg_row, &row);\n\t}\n\treturn SUCCESS;\n}\n",
        "target": 0
    },
    {
        "id": 1525,
        "func": "void WebContentsAndroid::BeginExitTransition(JNIEnv* env,\n                                             jobject jobj,\n                                             jstring css_selector,\n                                             jboolean exit_to_native_app) {\n  web_contents_->GetMainFrame()->Send(new FrameMsg_BeginExitTransition(\n      web_contents_->GetMainFrame()->GetRoutingID(),\n      ConvertJavaStringToUTF8(env, css_selector),\n      exit_to_native_app));\n}\n",
        "target": 0
    },
    {
        "id": 1526,
        "func": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}",
        "target": 1
    },
    {
        "id": 1527,
        "func": "static int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(vcpu->arch.apic &&\n\t\t      !kvm_iodevice_write(&vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu->kvm, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n",
        "target": 0
    },
    {
        "id": 1528,
        "func": "isVDSetTerminator(struct iso9660 *iso9660, const unsigned char *h)\n{\n\t(void)iso9660; /* UNUSED */\n\n\t/* Type of the Volume Descriptor Set Terminator must be 255. */\n\tif (h[0] != 255)\n\t\treturn (0);\n\n\t/* Volume Descriptor Version must be 1. */\n\tif (h[6] != 1)\n\t\treturn (0);\n\n\t/* Reserved field must be 0. */\n\tif (!isNull(iso9660, h, 7, 2048-7))\n\t\treturn (0);\n\n\treturn (1);\n}",
        "target": 0
    },
    {
        "id": 1529,
        "func": "void TabStripModel::ToggleSelectionAt(int index) {\n  DCHECK(ContainsIndex(index));\n  TabStripSelectionModel new_model;\n  new_model.Copy(selection_model());\n  if (selection_model_.IsSelected(index)) {\n    if (selection_model_.size() == 1) {\n      return;\n    }\n    new_model.RemoveIndexFromSelection(index);\n    new_model.set_anchor(index);\n    if (new_model.active() == index ||\n        new_model.active() == TabStripSelectionModel::kUnselectedIndex)\n      new_model.set_active(new_model.selected_indices()[0]);\n  } else {\n    new_model.AddIndexToSelection(index);\n    new_model.set_anchor(index);\n    new_model.set_active(index);\n  }\n  SetSelection(new_model, NOTIFY_DEFAULT);\n}\n",
        "target": 0
    },
    {
        "id": 1530,
        "func": "int GroupNameTransactionHelper(const std::string& url,\n                               HttpNetworkSession* session) {\n  HttpRequestInfo request;\n  request.method = \"GET\";\n  request.url = GURL(url);\n  request.traffic_annotation =\n      net::MutableNetworkTrafficAnnotationTag(TRAFFIC_ANNOTATION_FOR_TESTS);\n\n  HttpNetworkTransaction trans(DEFAULT_PRIORITY, session);\n\n  TestCompletionCallback callback;\n\n  return trans.Start(&request, callback.callback(), NetLogWithSource());\n}\n",
        "target": 0
    },
    {
        "id": 1531,
        "func": "bool AreWeShowingSignin(GURL url, SyncPromoUI::Source source,\n                        std::string email) {\n  GURL::Replacements replacements;\n  replacements.ClearQuery();\n  GURL clean_login_url =\n      GURL(GaiaUrls::GetInstance()->service_login_url()).ReplaceComponents(\n          replacements);\n\n  return (url.ReplaceComponents(replacements) == clean_login_url &&\n          source != SyncPromoUI::SOURCE_UNKNOWN) ||\n      (IsValidGaiaSigninRedirectOrResponseURL(url) &&\n       url.spec().find(\"ChromeLoginPrompt\") != std::string::npos &&\n       !email.empty());\n}\n",
        "target": 0
    },
    {
        "id": 1532,
        "func": "FrameTreeNode* RenderFrameHostManager::GetOuterDelegateNode() {\n  int outer_contents_frame_tree_node_id =\n      delegate_->GetOuterDelegateFrameTreeNodeId();\n  return FrameTreeNode::GloballyFindByID(outer_contents_frame_tree_node_id);\n}\n",
        "target": 0
    },
    {
        "id": 1533,
        "func": "  std::string RequestString(const std::string& url,\n                            const std::string& mode,\n                            const std::string& credentials) const {\n    return base::StringPrintf(\"url:%s, mode:%s, credentials:%s\\n\", url.c_str(),\n                              mode.c_str(), credentials.c_str());\n  }\n",
        "target": 0
    },
    {
        "id": 1534,
        "func": "void CLASS dcraw_message(int code, const char *format, ...) {\n  if (verbose || code!=DCRAW_VERBOSE) {\n    va_list ap;\n    va_start(ap, format);\n    vfprintf(stderr, format, ap);\n    va_end(ap);\n  }\n}",
        "target": 0
    },
    {
        "id": 1535,
        "func": "SCTP_STATIC int __sctp_setsockopt_connectx(struct sock* sk,\n\t\t\t\t      struct sockaddr __user *addrs,\n\t\t\t\t      int addrs_size,\n\t\t\t\t      sctp_assoc_t *assoc_id)\n{\n\tint err = 0;\n\tstruct sockaddr *kaddrs;\n\n\tSCTP_DEBUG_PRINTK(\"%s - sk %p addrs %p addrs_size %d\\n\",\n\t\t\t  __func__, sk, addrs, addrs_size);\n\n\tif (unlikely(addrs_size <= 0))\n\t\treturn -EINVAL;\n\n\t/* Check the user passed a healthy pointer.  */\n\tif (unlikely(!access_ok(VERIFY_READ, addrs, addrs_size)))\n\t\treturn -EFAULT;\n\n\t/* Alloc space for the address array in kernel memory.  */\n\tkaddrs = kmalloc(addrs_size, GFP_KERNEL);\n\tif (unlikely(!kaddrs))\n\t\treturn -ENOMEM;\n\n\tif (__copy_from_user(kaddrs, addrs, addrs_size)) {\n\t\terr = -EFAULT;\n\t} else {\n\t\terr = __sctp_connect(sk, kaddrs, addrs_size, assoc_id);\n\t}\n\n\tkfree(kaddrs);\n\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 1536,
        "func": "void BaseArena::removeAllPages() {\n  clearFreeLists();\n\n  ASSERT(!m_firstUnsweptPage);\n  while (m_firstPage) {\n    BasePage* page = m_firstPage;\n    page->unlink(&m_firstPage);\n    page->removeFromHeap();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1537,
        "func": "static int nfs4_xdr_dec_open_downgrade(struct rpc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       struct nfs_closeres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_open_downgrade(xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server,\n\t\t\t!RPC_IS_ASYNC(rqstp->rq_task));\nout:\n\treturn status;\n}",
        "target": 0
    },
    {
        "id": 1538,
        "func": "png_set_compression_mem_level(png_structp png_ptr, int mem_level)\n{\n   png_debug(1, \"in png_set_compression_mem_level\");\n\n   if (png_ptr == NULL)\n      return;\n   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL;\n   png_ptr->zlib_mem_level = mem_level;\n}\n",
        "target": 0
    },
    {
        "id": 1539,
        "func": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
        "target": 0
    },
    {
        "id": 1540,
        "func": "midi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int offs, int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\n\tleave_sysex(dev);\n\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\n\tif (format != SYSEX_PATCH)\n\t{\n/*\t\t  printk(\"MIDI Error: Invalid patch format (key) 0x%x\\n\", format);*/\n\t\t  return -EINVAL;\n\t}\n\tif (count < hdr_size)\n\t{\n/*\t\tprintk(\"MIDI Error: Patch header too short\\n\");*/\n\t\treturn -EINVAL;\n\t}\n\tcount -= hdr_size;\n\n\t/*\n\t * Copy the header from user space but ignore the first bytes which have\n\t * been transferred already.\n\t */\n\n\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n\t\treturn -EFAULT;\n \n \tif (count < sysex.len)\n\t{\n/*\t\tprintk(KERN_WARNING \"MIDI Warning: Sysex record too short (%d<%d)\\n\", count, (int) sysex.len);*/\n\t\tsysex.len = count;\n\t}\n  \tleft = sysex.len;\n  \tsrc_offs = 0;\n\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\n\t\teox_seen = (i > 0 && data & 0x80);\t/* End of sysex */\n\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 1541,
        "func": "void RenderViewHostManager::OnCrossSiteResponse(int new_render_process_host_id,\n                                                int new_request_id) {\n  if (!cross_navigation_pending_)\n    return;\n  DCHECK(pending_render_view_host_);\n\n  render_view_host_->SwapOut(new_render_process_host_id, new_request_id);\n\n  pending_render_view_host_->SetHasPendingCrossSiteRequest(false,\n                                                           new_request_id);\n}\n",
        "target": 0
    },
    {
        "id": 1542,
        "func": "file_pstring_length_size(const struct magic *m)\n{\n\tswitch (m->str_flags & PSTRING_LEN) {\n\tcase PSTRING_1_LE:\n\t\treturn 1;\n\tcase PSTRING_2_LE:\n\tcase PSTRING_2_BE:\n\t\treturn 2;\n\tcase PSTRING_4_LE:\n\tcase PSTRING_4_BE:\n\t\treturn 4;\n\tdefault:\n\t\tabort();\t/* Impossible */\n\t\treturn 1;\n\t}\n}",
        "target": 0
    },
    {
        "id": 1543,
        "func": "static int DefragMfIpv6Test(void)\n{\n    int retval = 0;\n    int ip_id = 9;\n    Packet *p = NULL;\n\n    DefragInit();\n\n    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n    if (p1 == NULL || p2 == NULL || p3 == NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p1, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p2, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    /* This should return a packet as MF=0. */\n    p = Defrag(NULL, NULL, p3, NULL);\n    if (p == NULL) {\n        goto end;\n    }\n\n    /* For IPv6 the expected length is just the length of the payload\n     * of 2 fragments, so 16. */\n    if (IPV6_GET_PLEN(p) != 16) {\n        goto end;\n    }\n\n    retval = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    if (p2 != NULL) {\n        SCFree(p2);\n    }\n    if (p3 != NULL) {\n        SCFree(p3);\n    }\n    if (p != NULL) {\n        SCFree(p);\n    }\n    DefragDestroy();\n    return retval;\n}",
        "target": 1
    },
    {
        "id": 1544,
        "func": " TestNativeHandler::TestNativeHandler(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n      \"GetWakeEventPage\",\n       base::Bind(&TestNativeHandler::GetWakeEventPage, base::Unretained(this)));\n }\n",
        "target": 1
    },
    {
        "id": 1545,
        "func": "static ulong *reg_write(struct x86_emulate_ctxt *ctxt, unsigned nr)\n{\n\tctxt->regs_valid |= 1 << nr;\n\tctxt->regs_dirty |= 1 << nr;\n\treturn &ctxt->_regs[nr];\n}",
        "target": 0
    },
    {
        "id": 1546,
        "func": "spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}",
        "target": 1
    },
    {
        "id": 1547,
        "func": "static void tsc210x_reset(TSC210xState *s)\n{\n    s->state = 0;\n    s->pin_func = 2;\n    s->enabled = 0;\n    s->busy = 0;\n    s->nextfunction = 0;\n    s->ref = 0;\n    s->timing = 0;\n    s->irq = 0;\n    s->dav = 0;\n\n    s->audio_ctrl1 = 0x0000;\n    s->audio_ctrl2 = 0x4410;\n    s->audio_ctrl3 = 0x0000;\n    s->pll[0] = 0x1004;\n    s->pll[1] = 0x0000;\n    s->pll[2] = 0x1fff;\n    s->volume = 0xffff;\n    s->dac_power = 0x8540;\n    s->softstep = 1;\n    s->volume_change = 0;\n    s->powerdown = 0;\n    s->filter_data[0x00] = 0x6be3;\n    s->filter_data[0x01] = 0x9666;\n    s->filter_data[0x02] = 0x675d;\n    s->filter_data[0x03] = 0x6be3;\n    s->filter_data[0x04] = 0x9666;\n    s->filter_data[0x05] = 0x675d;\n    s->filter_data[0x06] = 0x7d83;\n    s->filter_data[0x07] = 0x84ee;\n    s->filter_data[0x08] = 0x7d83;\n    s->filter_data[0x09] = 0x84ee;\n    s->filter_data[0x0a] = 0x6be3;\n    s->filter_data[0x0b] = 0x9666;\n    s->filter_data[0x0c] = 0x675d;\n    s->filter_data[0x0d] = 0x6be3;\n    s->filter_data[0x0e] = 0x9666;\n    s->filter_data[0x0f] = 0x675d;\n    s->filter_data[0x10] = 0x7d83;\n    s->filter_data[0x11] = 0x84ee;\n    s->filter_data[0x12] = 0x7d83;\n    s->filter_data[0x13] = 0x84ee;\n\n    s->i2s_tx_rate = 0;\n    s->i2s_rx_rate = 0;\n\n    s->kb.scan = 1;\n    s->kb.debounce = 0;\n    s->kb.mask = 0x0000;\n    s->kb.mode = 3;\n    s->kb.intr = 0;\n\n    qemu_set_irq(s->pint, !s->irq);\n    qemu_set_irq(s->davint, !s->dav);\n    qemu_irq_raise(s->kbint);\n}\n",
        "target": 0
    },
    {
        "id": 1548,
        "func": "static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool compat)\n{\n\tstruct file *file = kiocb->ki_filp;\n\tssize_t ret = 0;\n\n\tswitch (kiocb->ki_opcode) {\n\tcase IOCB_CMD_PREAD:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(READ, file, kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITE:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(WRITE, file, kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PREADV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(READ, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITEV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(WRITE, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_FDSYNC:\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_fsync)\n\t\t\tkiocb->ki_retry = aio_fdsync;\n\t\tbreak;\n\tcase IOCB_CMD_FSYNC:\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_fsync)\n\t\t\tkiocb->ki_retry = aio_fsync;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"EINVAL: io_submit: no operation provided\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!kiocb->ki_retry)\n\t\treturn ret;\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1549,
        "func": "static inline unsigned d_count(const struct dentry *dentry)\n{\n\treturn dentry->d_lockref.count;\n}",
        "target": 0
    },
    {
        "id": 1550,
        "func": "DECLAREwriteFunc(writeBufferToSeparateTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\ttsize_t tilew  = TIFFTileRowSize(out);\n\tuint32 iimagew = TIFFRasterScanlineSize(out);\n\tint iskew = iimagew - tilew*spp;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\tuint16 bps, bytes_per_sample;\n\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n\tassert( bps % 8 == 0 );\n\tbytes_per_sample = bps/8;\n\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\ttsample_t s;\n\t\t\tfor (s = 0; s < spp; s++) {\n\t\t\t\t/*\n\t\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t\t * visible portion and skewing factors.\n\t\t\t\t */\n\t\t\t\tif (colb + tilew > imagew) {\n\t\t\t\t\tuint32 width = (imagew - colb);\n\t\t\t\t\tint oskew = tilew - width;\n\n\t\t\t\t\tcpContigBufToSeparateBuf(obuf,\n\t\t\t\t\t    bufp + (colb*spp) + s,\n\t\t\t\t\t    nrow, width/bytes_per_sample,\n\t\t\t\t\t    oskew, (oskew*spp)+iskew, spp,\n\t\t\t\t\t    bytes_per_sample);\n\t\t\t\t} else\n\t\t\t\t\tcpContigBufToSeparateBuf(obuf,\n\t\t\t\t\t    bufp + (colb*spp) + s,\n\t\t\t\t\t    nrow, tilewidth,\n\t\t\t\t\t    0, iskew, spp,\n\t\t\t\t\t    bytes_per_sample);\n\t\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) {\n\t\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t\t    \"Error, can't write tile at %lu %lu \"\n\t\t\t\t\t    \"sample %lu\",\n\t\t\t\t\t    (unsigned long) col,\n\t\t\t\t\t    (unsigned long) row,\n\t\t\t\t\t    (unsigned long) s);\n\t\t\t\t\t_TIFFfree(obuf);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * iimagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}\n",
        "target": 0
    },
    {
        "id": 1551,
        "func": "xsltComputeAllKeys(xsltTransformContextPtr ctxt, xmlNodePtr contextNode)\n{\n    if ((ctxt == NULL) || (contextNode == NULL)) {\n\txsltTransformError(ctxt, NULL, ctxt->inst,\n\t    \"Internal error in xsltComputeAllKeys(): \"\n\t    \"Bad arguments.\\n\");\n\treturn(-1);\n    }\n\n    if (ctxt->document == NULL) {\n\t/*\n\t* The document info will only be NULL if we have a RTF.\n\t*/\n\tif (contextNode->doc->_private != NULL)\n\t    goto doc_info_mismatch;\n\t/*\n\t* On-demand creation of the document info (needed for keys).\n\t*/\n\tctxt->document = xsltNewDocument(ctxt, contextNode->doc);\n\tif (ctxt->document == NULL)\n\t    return(-1);\n    }\n    return xsltInitAllDocKeys(ctxt);\n\ndoc_info_mismatch:\n    xsltTransformError(ctxt, NULL, ctxt->inst,\n\t\"Internal error in xsltComputeAllKeys(): \"\n\t\"The context's document info doesn't match the \"\n\t\"document info of the current result tree.\\n\");\n    ctxt->state = XSLT_STATE_STOPPED;\n    return(-1);\n}\n",
        "target": 0
    },
    {
        "id": 1552,
        "func": "void RenderViewHostImpl::OnRenderViewGone(int status, int exit_code) {\n  render_view_termination_status_ =\n      static_cast<base::TerminationStatus>(status);\n\n  ClearPowerSaveBlockers();\n\n  RendererExited(render_view_termination_status_, exit_code);\n\n  delegate_->RenderViewGone(this,\n                            static_cast<base::TerminationStatus>(status),\n                            exit_code);\n}\n",
        "target": 0
    },
    {
        "id": 1553,
        "func": "static void VoidMethodDefaultIntegerArgsMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"voidMethodDefaultIntegerArgs\");\n\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  int32_t default_long_arg;\n  int64_t default_long_long_arg;\n  uint32_t default_unsigned_arg;\n  if (!info[0]->IsUndefined()) {\n    default_long_arg = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), info[0], exception_state);\n    if (exception_state.HadException())\n      return;\n  } else {\n    default_long_arg = 10;\n  }\n  if (!info[1]->IsUndefined()) {\n    default_long_long_arg = NativeValueTraits<IDLLongLong>::NativeValue(info.GetIsolate(), info[1], exception_state);\n    if (exception_state.HadException())\n      return;\n  } else {\n    default_long_long_arg = -10;\n  }\n  if (!info[2]->IsUndefined()) {\n    default_unsigned_arg = NativeValueTraits<IDLUnsignedLong>::NativeValue(info.GetIsolate(), info[2], exception_state);\n    if (exception_state.HadException())\n      return;\n  } else {\n    default_unsigned_arg = 4294967295u;\n  }\n\n  impl->voidMethodDefaultIntegerArgs(default_long_arg, default_long_long_arg, default_unsigned_arg);\n}\n",
        "target": 0
    },
    {
        "id": 1554,
        "func": "HttpUtil::NameValuePairsIterator::~NameValuePairsIterator() {}\n",
        "target": 0
    },
    {
        "id": 1555,
        "func": "int blk_pre_runtime_suspend(struct request_queue *q)\n{\n\tint ret = 0;\n\n\tif (!q->dev)\n\t\treturn ret;\n\n\tspin_lock_irq(q->queue_lock);\n\tif (q->nr_pending) {\n\t\tret = -EBUSY;\n\t\tpm_runtime_mark_last_busy(q->dev);\n\t} else {\n\t\tq->rpm_status = RPM_SUSPENDING;\n\t}\n\tspin_unlock_irq(q->queue_lock);\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1556,
        "func": "static __init int svm_hardware_setup(void)\n{\n\tint cpu;\n\tstruct page *iopm_pages;\n\tvoid *iopm_va;\n\tint r;\n\n\tiopm_pages = alloc_pages(GFP_KERNEL, IOPM_ALLOC_ORDER);\n\n\tif (!iopm_pages)\n\t\treturn -ENOMEM;\n\n\tiopm_va = page_address(iopm_pages);\n\tmemset(iopm_va, 0xff, PAGE_SIZE * (1 << IOPM_ALLOC_ORDER));\n\tiopm_base = page_to_pfn(iopm_pages) << PAGE_SHIFT;\n\n\tinit_msrpm_offsets();\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_FXSR_OPT))\n\t\tkvm_enable_efer_bits(EFER_FFXSR);\n\n\tif (boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = TSC_RATIO_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 32;\n\t}\n\n\tif (nested) {\n\t\tprintk(KERN_INFO \"kvm: Nested Virtualization enabled\\n\");\n\t\tkvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tr = svm_cpu_init(cpu);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_NPT))\n\t\tnpt_enabled = false;\n\n\tif (npt_enabled && !npt) {\n\t\tprintk(KERN_INFO \"kvm: Nested Paging disabled\\n\");\n\t\tnpt_enabled = false;\n\t}\n\n\tif (npt_enabled) {\n\t\tprintk(KERN_INFO \"kvm: Nested Paging enabled\\n\");\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\treturn 0;\n\nerr:\n\t__free_pages(iopm_pages, IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n\treturn r;\n}",
        "target": 0
    },
    {
        "id": 1557,
        "func": "jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_matrix_create(x->numrows_, x->numcols_);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}",
        "target": 1
    },
    {
        "id": 1558,
        "func": "static void fix_all_wrapped_labels(GtkWidget *widget)\n{\n    wrap_fixer(widget, NULL);\n}",
        "target": 0
    },
    {
        "id": 1559,
        "func": "static void __update_inv_weight(struct load_weight *lw)\n{\n\tunsigned long w;\n\n\tif (likely(lw->inv_weight))\n\t\treturn;\n\n\tw = scale_load_down(lw->weight);\n\n\tif (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))\n\t\tlw->inv_weight = 1;\n\telse if (unlikely(!w))\n\t\tlw->inv_weight = WMULT_CONST;\n\telse\n\t\tlw->inv_weight = WMULT_CONST / w;\n}",
        "target": 0
    },
    {
        "id": 1560,
        "func": "static int oz_urb_process(struct oz_hcd *ozhcd, struct urb *urb)\n{\n\tint rc = 0;\n\tstruct oz_port *port = urb->hcpriv;\n\tu8 ep_addr;\n\n\t/* When we are paranoid we keep a list of urbs which we check against\n\t * before handing one back. This is just for debugging during\n\t * development and should be turned off in the released driver.\n\t */\n\toz_remember_urb(urb);\n\t/* Check buffer is valid.\n\t */\n\tif (!urb->transfer_buffer && urb->transfer_buffer_length)\n\t\treturn -EINVAL;\n\t/* Check if there is a device at the port - refuse if not.\n\t */\n\tif ((port->flags & OZ_PORT_F_PRESENT) == 0)\n\t\treturn -EPIPE;\n\tep_addr = usb_pipeendpoint(urb->pipe);\n\tif (ep_addr) {\n\t\t/* If the request is not for EP0 then queue it.\n\t\t */\n\t\tif (oz_enqueue_ep_urb(port, ep_addr, usb_pipein(urb->pipe),\n\t\t\turb, 0))\n\t\t\trc = -EPIPE;\n\t} else {\n\t\toz_process_ep0_urb(ozhcd, urb, GFP_ATOMIC);\n\t}\n\treturn rc;\n}",
        "target": 0
    },
    {
        "id": 1561,
        "func": "int FLTIsLineFilter(FilterEncodingNode *psFilterNode)\n{\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 0;\n\n  if (psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n      psFilterNode->psRightNode &&\n      psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_GEOMETRY_LINE)\n    return 1;\n\n  return 0;\n}",
        "target": 0
    },
    {
        "id": 1562,
        "func": "void BrowserViewRenderer::ReturnUnusedResource(\n    scoped_ptr<ChildFrame> child_frame) {\n  if (!child_frame.get() || !child_frame->frame.get())\n    return;\n\n  cc::CompositorFrameAck frame_ack;\n  cc::TransferableResource::ReturnResources(\n      child_frame->frame->delegated_frame_data->resource_list,\n      &frame_ack.resources);\n  if (compositor_ && !frame_ack.resources.empty())\n    compositor_->ReturnResources(frame_ack);\n}\n",
        "target": 0
    },
    {
        "id": 1563,
        "func": "std::string GetActiveExperimentFlags() {\n  return std::string();\n}\n",
        "target": 0
    },
    {
        "id": 1564,
        "func": "void ProxyResolverV8TracingImpl::CancelRequest(\n    ProxyResolver::RequestHandle request) {\n  Job* job = reinterpret_cast<Job*>(request);\n  job->Cancel();\n}\n",
        "target": 0
    },
    {
        "id": 1565,
        "func": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n     ASN1_TIME atm;\n     long offset;\n     char buff1[24], buff2[24], *p;\n    int i, j;\n \n     p = buff1;\n    i = ctm->length;\n     str = (char *)ctm->data;\n     if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n             return 0;\n         memcpy(p, str, 10);\n         p += 10;\n         str += 10;\n     } else {\n        if (i < 13)\n             return 0;\n         memcpy(p, str, 12);\n         p += 12;\n         str += 12;\n     }\n \n     if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n         *(p++) = '0';\n         *(p++) = '0';\n     } else {\n         *(p++) = *(str++);\n         *(p++) = *(str++);\n        /* Skip any fractional seconds... */\n        if (*str == '.') {\n             str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n         }\n \n     }\n     *(p++) = 'Z';\n     *(p++) = '\\0';\n \n    if (*str == 'Z')\n         offset = 0;\n    else {\n         if ((*str != '+') && (*str != '-'))\n             return 0;\n         offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n         offset += (str[3] - '0') * 10 + (str[4] - '0');\n         if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           /* cf. RFC 2459 */\n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 /* wait a second then return younger :-) */\n        return -1;\n    else\n        return i;\n}\n",
        "target": 1
    },
    {
        "id": 1566,
        "func": "OperationID FileSystemOperationRunner::BeginOperation(\n     std::unique_ptr<FileSystemOperation> operation) {\n   OperationID id = next_operation_id_++;\n \n  operations_.emplace(id, std::move(operation));\n   return id;\n }\n",
        "target": 1
    },
    {
        "id": 1567,
        "func": "void CameraService::BasicClient::disconnect() {\n    ALOGV(\"BasicClient::disconnect\");\n    mCameraService->removeClientByRemote(mRemoteBinder);\n\n     mClientPid = 0;\n }\n",
        "target": 0
    },
    {
        "id": 1568,
        "func": "  virtual bool has_cellular_networks() const {\n    return cellular_networks_.begin() != cellular_networks_.end();\n  }\n",
        "target": 0
    },
    {
        "id": 1569,
        "func": "void PDFiumEngine::Highlight(void* buffer,\n                             int stride,\n                             const pp::Rect& rect,\n                             std::vector<pp::Rect>* highlighted_rects) {\n  if (!buffer)\n    return;\n\n  pp::Rect new_rect = rect;\n  for (const auto& highlighted : *highlighted_rects)\n    new_rect = new_rect.Subtract(highlighted);\n\n  highlighted_rects->push_back(new_rect);\n  int l = new_rect.x();\n  int t = new_rect.y();\n  int w = new_rect.width();\n  int h = new_rect.height();\n\n  for (int y = t; y < t + h; ++y) {\n    for (int x = l; x < l + w; ++x) {\n      uint8_t* pixel = static_cast<uint8_t*>(buffer) + y * stride + x * 4;\n      pixel[0] = static_cast<uint8_t>(pixel[0] * (kHighlightColorB / 255.0));\n      pixel[1] = static_cast<uint8_t>(pixel[1] * (kHighlightColorG / 255.0));\n      pixel[2] = static_cast<uint8_t>(pixel[2] * (kHighlightColorR / 255.0));\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1570,
        "func": "my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)\n{\n  *len = 0;\n  g_hash_table_foreach (table, hash_foreach, len);\n  return TRUE;\n}\n",
        "target": 1
    },
    {
        "id": 1571,
        "func": "GLvoid StubGLAttachShader(GLuint program, GLuint shader) {\n  glAttachShader(program, shader);\n}\n",
        "target": 0
    },
    {
        "id": 1572,
        "func": "void svc_rdma_xdr_encode_array_chunk(struct rpcrdma_write_array *ary,\n\t\t\t\t     int chunk_no,\n\t\t\t\t     __be32 rs_handle,\n\t\t\t\t     __be64 rs_offset,\n\t\t\t\t     u32 write_len)\n{\n\tstruct rpcrdma_segment *seg = &ary->wc_array[chunk_no].wc_target;\n\tseg->rs_handle = rs_handle;\n\tseg->rs_offset = rs_offset;\n\tseg->rs_length = cpu_to_be32(write_len);\n}\n",
        "target": 1
    },
    {
        "id": 1573,
        "func": "void FileSystemManagerImpl::DidGetMetadataForStreaming(\n    CreateSnapshotFileCallback callback,\n    base::File::Error result,\n    const base::File::Info& info) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  std::move(callback).Run(info, base::FilePath(), result, nullptr);\n}\n",
        "target": 0
    },
    {
        "id": 1574,
        "func": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\n\tif (numrows < 0 || numcols < 0) {\n\t\treturn 0;\n\t}\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\treturn 0;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = numrows * numcols;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n}",
        "target": 1
    },
    {
        "id": 1575,
        "func": "static int xt_match_seq_show(struct seq_file *seq, void *v)\n{\n\tconst struct nf_mttg_trav *trav = seq->private;\n\tconst struct xt_match *match;\n\n\tswitch (trav->class) {\n\tcase MTTG_TRAV_NFP_UNSPEC:\n\tcase MTTG_TRAV_NFP_SPEC:\n\t\tif (trav->curr == trav->head)\n\t\t\treturn 0;\n\t\tmatch = list_entry(trav->curr, struct xt_match, list);\n\t\tif (*match->name)\n\t\t\tseq_printf(seq, \"%s\\n\", match->name);\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1576,
        "func": "static bool valid_rep(cs_struct *h, unsigned int opcode)\n{\n\tunsigned int id;\n\tint i = insn_find(insns, ARR_SIZE(insns), opcode, &h->insn_cache);\n\tif (i != 0) {\n\t\tid = insns[i].mapid;\n\t\tswitch(id) {\n\t\t\tdefault:\n\t\t\t\treturn false;\n\n\t\t\tcase X86_INS_MOVSB:\n\t\t\tcase X86_INS_MOVSW:\n\t\t\tcase X86_INS_MOVSQ:\n\n\t\t\tcase X86_INS_LODSB:\n\t\t\tcase X86_INS_LODSW:\n\t\t\tcase X86_INS_LODSQ:\n\n\t\t\tcase X86_INS_STOSB:\n\t\t\tcase X86_INS_STOSW:\n\t\t\tcase X86_INS_STOSQ:\n\n\t\t\tcase X86_INS_INSB:\n\t\t\tcase X86_INS_INSW:\n\t\t\tcase X86_INS_INSD:\n\n\t\t\tcase X86_INS_OUTSB:\n\t\t\tcase X86_INS_OUTSW:\n\t\t\tcase X86_INS_OUTSD:\n\t\t\t\treturn true;\n\n\t\t\t// following are some confused instructions, which have the same\n\t\t\t// mnemonics in 128bit media instructions. Intel is horribly crazy!\n\t\t\tcase X86_INS_MOVSD:\n\t\t\t\tif (opcode == X86_MOVSL) // REP MOVSD\n\t\t\t\t\treturn true;\n\t\t\t\treturn false;\n\n\t\t\tcase X86_INS_LODSD:\n\t\t\t\tif (opcode == X86_LODSL) // REP LODSD\n\t\t\t\t\treturn true;\n\t\t\t\treturn false;\n\n\t\t\tcase X86_INS_STOSD:\n\t\t\t\tif (opcode == X86_STOSL) // REP STOSD\n\t\t\t\t\treturn true;\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t// not found\n\treturn false;\n}",
        "target": 0
    },
    {
        "id": 1577,
        "func": "static void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n\twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n\tkfree(ubufs);\n}",
        "target": 1
    },
    {
        "id": 1578,
        "func": "void GLES2DecoderImpl::DoBindRenderbuffer(GLenum target, GLuint client_id) {\n  RenderbufferManager::RenderbufferInfo* info = NULL;\n  GLuint service_id = 0;\n  if (client_id != 0) {\n    info = GetRenderbufferInfo(client_id);\n    if (!info) {\n      if (!group_->bind_generates_resource()) {\n        SetGLError(\n            GL_INVALID_VALUE,\n            \"glBindRenderbuffer: id not generated by glGenRenderbuffers\");\n        return;\n      }\n\n      glGenRenderbuffersEXT(1, &service_id);\n      CreateRenderbufferInfo(client_id, service_id);\n      info = GetRenderbufferInfo(client_id);\n      IdAllocatorInterface* id_allocator =\n          group_->GetIdAllocator(id_namespaces::kRenderbuffers);\n      id_allocator->MarkAsUsed(client_id);\n    } else {\n      service_id = info->service_id();\n    }\n    info->MarkAsValid();\n  }\n  bound_renderbuffer_ = info;\n  glBindRenderbufferEXT(target, service_id);\n}\n",
        "target": 0
    },
    {
        "id": 1579,
        "func": "_SSL_set_verify (SSL_CTX *ctx, void *verify_callback, char *cacert)\n{\n\tif (!SSL_CTX_set_default_verify_paths (ctx))\n\t{\n\t\t__SSL_fill_err_buf (\"SSL_CTX_set_default_verify_paths\");\n\t\treturn (err_buf);\n\t}\n/*\n\tif (cacert)\n\t{\n\t\tif (!SSL_CTX_load_verify_locations (ctx, cacert, NULL))\n\t\t{\n\t\t\t__SSL_fill_err_buf (\"SSL_CTX_load_verify_locations\");\n\t\t\treturn (err_buf);\n\t\t}\n\t}\n*/\n\tSSL_CTX_set_verify (ctx, SSL_VERIFY_PEER, verify_callback);\n\n\treturn (NULL);\n}",
        "target": 0
    },
    {
        "id": 1580,
        "func": "  gray_split_cubic( FT_Vector*  base )\n  {\n    TPos  a, b, c, d;\n\n\n    base[6].x = base[3].x;\n    c = base[1].x;\n    d = base[2].x;\n    base[1].x = a = ( base[0].x + c ) / 2;\n    base[5].x = b = ( base[3].x + d ) / 2;\n    c = ( c + d ) / 2;\n    base[2].x = a = ( a + c ) / 2;\n    base[4].x = b = ( b + c ) / 2;\n    base[3].x = ( a + b ) / 2;\n\n    base[6].y = base[3].y;\n    c = base[1].y;\n    d = base[2].y;\n    base[1].y = a = ( base[0].y + c ) / 2;\n    base[5].y = b = ( base[3].y + d ) / 2;\n    c = ( c + d ) / 2;\n    base[2].y = a = ( a + c ) / 2;\n    base[4].y = b = ( b + c ) / 2;\n    base[3].y = ( a + b ) / 2;\n  }\n",
        "target": 0
    },
    {
        "id": 1581,
        "func": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n\n    /* http://issues.apache.org/bugzilla/show_bug.cgi?id=31875\n     * http://issues.apache.org/bugzilla/show_bug.cgi?id=28450\n     *\n     * This is not in fact a URI, it's a path.  That matters in the\n     * case of a leading double-slash.  We need to resolve the issue\n     * by normalising that out before treating it as a URI.\n     */\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n\n    if (status == APR_SUCCESS) {\n        /* if it has a scheme we may need to do absoluteURI vhost stuff */\n        if (r->parsed_uri.scheme\n            && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n\n#if defined(OS2) || defined(WIN32)\n        /* Handle path translations for OS/2 and plug security hole.\n         * This will prevent \"http://www.wherever.com/..\\..\\/\" from\n         * returning a directory for the root drive.\n         */\n        {\n            char *x;\n\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif /* OS2 || WIN32 */\n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             /* set error status */\n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1582,
        "func": "WebViewPlugin* WebViewPlugin::Create(WebViewPlugin::Delegate* delegate,\n                                     const WebPreferences& preferences,\n                                     const std::string& html_data,\n                                     const GURL& url) {\n  WebViewPlugin* plugin = new WebViewPlugin(delegate);\n  WebView* web_view = plugin->web_view();\n  preferences.Apply(web_view);\n  web_view->mainFrame()->loadHTMLString(html_data, url);\n  return plugin;\n}\n",
        "target": 0
    },
    {
        "id": 1583,
        "func": "void Document::ScheduleUseShadowTreeUpdate(SVGUseElement& element) {\n  use_elements_needing_update_.insert(&element);\n  ScheduleLayoutTreeUpdateIfNeeded();\n}\n",
        "target": 0
    },
    {
        "id": 1584,
        "func": " static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n {\n \tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n \t*data = &iterator->current;\n }\n",
        "target": 1
    },
    {
        "id": 1585,
        "func": "static void clamp_output_samples(struct iw_context *ctx, iw_tmpsample *out_pix, int num_out_pix)\n{\n\tint i;\n\n\tfor(i=0;i<num_out_pix;i++) {\n\t\tif(out_pix[i]<0.0) out_pix[i]=0.0;\n\t\telse if(out_pix[i]>1.0) out_pix[i]=1.0;\n\t}\n}",
        "target": 0
    },
    {
        "id": 1586,
        "func": "asmlinkage void user_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n{\n\tenum direction dir;\n\n\tif(!(current->thread.flags & SPARC_FLAG_UNALIGNED) ||\n\t   (((insn >> 30) & 3) != 3))\n\t\tgoto kill_user;\n\tdir = decode_direction(insn);\n\tif(!ok_for_user(regs, insn, dir)) {\n\t\tgoto kill_user;\n\t} else {\n\t\tint err, size = decode_access_size(insn);\n\t\tunsigned long addr;\n\n\t\tif(floating_point_load_or_store_p(insn)) {\n\t\t\tprintk(\"User FPU load/store unaligned unsupported.\\n\");\n\t\t\tgoto kill_user;\n\t\t}\n\n\t\taddr = compute_effective_address(regs, insn);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch(dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,\n\t\t\t\t\t   (unsigned long *) addr, regs);\n\t\t\tbreak;\n\n\t\tcase both:\n\t\t\t/*\n\t\t\t * This was supported in 2.4. However, we question\n\t\t\t * the value of SWAP instruction across word boundaries.\n\t\t\t */\n\t\t\tprintk(\"Unaligned SWAP unsupported.\\n\");\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tunaligned_panic(\"Impossible user unaligned trap.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (err)\n\t\t\tgoto kill_user;\n\t\telse\n\t\t\tadvance(regs);\n\t\tgoto out;\n\t}\n\nkill_user:\n\tuser_mna_trap_fault(regs, insn);\nout:\n\t;\n}",
        "target": 1
    },
    {
        "id": 1587,
        "func": "static long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\n\t/*\n\t * IOCTL_VMMDEV_REQUEST needs the buffer to be below 4G to avoid\n\t * the need for a bounce-buffer and another copy later on.\n\t */\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(buf, (void *)arg, hdr.size_in)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\n\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 1588,
        "func": "void Con_CheckResize (void)\n{\n\tint\t\ti, j, width, oldwidth, oldtotallines, numlines, numchars;\n\tshort\ttbuf[CON_TEXTSIZE];\n\n\twidth = (SCREEN_WIDTH / SMALLCHAR_WIDTH) - 2;\n\n\tif (width == con.linewidth)\n\t\treturn;\n\n\tif (width < 1)\t\t\t// video hasn't been initialized yet\n\t{\n\t\twidth = DEFAULT_CONSOLE_WIDTH;\n\t\tcon.linewidth = width;\n\t\tcon.totallines = CON_TEXTSIZE / con.linewidth;\n\t\tfor(i=0; i<CON_TEXTSIZE; i++)\n\n\t\t\tcon.text[i] = (ColorIndex(COLOR_WHITE)<<8) | ' ';\n\t}\n\telse\n\t{\n\t\toldwidth = con.linewidth;\n\t\tcon.linewidth = width;\n\t\toldtotallines = con.totallines;\n\t\tcon.totallines = CON_TEXTSIZE / con.linewidth;\n\t\tnumlines = oldtotallines;\n\n\t\tif (con.totallines < numlines)\n\t\t\tnumlines = con.totallines;\n\n\t\tnumchars = oldwidth;\n\t\n\t\tif (con.linewidth < numchars)\n\t\t\tnumchars = con.linewidth;\n\n\t\tCom_Memcpy (tbuf, con.text, CON_TEXTSIZE * sizeof(short));\n\t\tfor(i=0; i<CON_TEXTSIZE; i++)\n\n\t\t\tcon.text[i] = (ColorIndex(COLOR_WHITE)<<8) | ' ';\n\n\n\t\tfor (i=0 ; i<numlines ; i++)\n\t\t{\n\t\t\tfor (j=0 ; j<numchars ; j++)\n\t\t\t{\n\t\t\t\tcon.text[(con.totallines - 1 - i) * con.linewidth + j] =\n\t\t\t\t\t\ttbuf[((con.current - i + oldtotallines) %\n\t\t\t\t\t\t\t  oldtotallines) * oldwidth + j];\n\t\t\t}\n\t\t}\n\n\t\tCon_ClearNotify ();\n\t}\n\n\tcon.current = con.totallines - 1;\n\tcon.display = con.current;\n}\n",
        "target": 0
    },
    {
        "id": 1589,
        "func": "static void tg3_disable_nvram_access(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, 5750_PLUS) && !tg3_flag(tp, PROTECTED_NVRAM)) {\n\t\tu32 nvaccess = tr32(NVRAM_ACCESS);\n\n\t\ttw32(NVRAM_ACCESS, nvaccess & ~ACCESS_ENABLE);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1590,
        "func": "void PaintController::EndSubsequence(const DisplayItemClient& client,\n                                     size_t start) {\n  size_t end = new_display_item_list_.size();\n\n  if (RuntimeEnabledFeatures::PaintUnderInvalidationCheckingEnabled() &&\n      IsCheckingUnderInvalidation()) {\n    SubsequenceMarkers* markers = GetSubsequenceMarkers(client);\n    if (!markers && start != end) {\n      ShowSequenceUnderInvalidationError(\n          \"under-invalidation : unexpected subsequence\", client, start, end);\n      CHECK(false);\n    }\n    if (markers && markers->end - markers->start != end - start) {\n      ShowSequenceUnderInvalidationError(\n          \"under-invalidation: new subsequence wrong length\", client, start,\n          end);\n      CHECK(false);\n    }\n  }\n\n  if (start == end) {\n    return;\n  }\n\n  new_paint_chunks_.ForceNewChunk();\n\n  DCHECK(!new_cached_subsequences_.Contains(&client))\n      << \"Multiple subsequences for client: \" << client.DebugName();\n\n  new_cached_subsequences_.insert(&client, SubsequenceMarkers(start, end));\n  last_cached_subsequence_end_ = end;\n}\n",
        "target": 0
    },
    {
        "id": 1591,
        "func": "static int wanxl_open(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tu8 __iomem *dbr = port->card->plx + PLX_DOORBELL_TO_CARD;\n\tunsigned long timeout;\n\tint i;\n\n\tif (get_status(port)->open) {\n\t\tnetdev_err(dev, \"port already open\\n\");\n\t\treturn -EIO;\n\t}\n\tif ((i = hdlc_open(dev)) != 0)\n\t\treturn i;\n\n\tport->tx_in = port->tx_out = 0;\n\tfor (i = 0; i < TX_BUFFERS; i++)\n\t\tget_status(port)->tx_descs[i].stat = PACKET_EMPTY;\n\t/* signal the card */\n\twritel(1 << (DOORBELL_TO_CARD_OPEN_0 + port->node), dbr);\n\n\ttimeout = jiffies + HZ;\n\tdo {\n\t\tif (get_status(port)->open) {\n\t\t\tnetif_start_queue(dev);\n\t\t\treturn 0;\n\t\t}\n\t} while (time_after(timeout, jiffies));\n\n\tnetdev_err(dev, \"unable to open port\\n\");\n\t/* ask the card to close the port, should it be still alive */\n\twritel(1 << (DOORBELL_TO_CARD_CLOSE_0 + port->node), dbr);\n\treturn -EFAULT;\n}",
        "target": 0
    },
    {
        "id": 1592,
        "func": "void RenderProcessHostImpl::OnChannelConnected(int32_t peer_pid) {\n  channel_connected_ = true;\n  if (IsReady()) {\n    DCHECK(!sent_render_process_ready_);\n    sent_render_process_ready_ = true;\n    for (auto& observer : observers_)\n      observer.RenderProcessReady(this);\n  }\n\n#if defined(IPC_MESSAGE_LOG_ENABLED)\n  Send(new ChildProcessMsg_SetIPCLoggingEnabled(\n      IPC::Logging::GetInstance()->Enabled()));\n#endif\n\n  tracked_objects::ThreadData::Status status =\n      tracked_objects::ThreadData::status();\n  Send(new ChildProcessMsg_SetProfilerStatus(status));\n\n  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                          base::Bind(&AudioInputRendererHost::set_renderer_pid,\n                                     audio_input_renderer_host_, peer_pid));\n}\n",
        "target": 0
    },
    {
        "id": 1593,
        "func": "static void do_write_page(struct f2fs_summary *sum, struct f2fs_io_info *fio)\n{\n\tint type = __get_segment_type(fio);\n\tint err;\n\nreallocate:\n\tallocate_data_block(fio->sbi, fio->page, fio->old_blkaddr,\n\t\t\t&fio->new_blkaddr, sum, type, fio, true);\n\n\t/* writeout dirty page into bdev */\n\terr = f2fs_submit_page_write(fio);\n\tif (err == -EAGAIN) {\n\t\tfio->old_blkaddr = fio->new_blkaddr;\n\t\tgoto reallocate;\n\t}\n}",
        "target": 0
    },
    {
        "id": 1594,
        "func": "static void null_endofword(char *word)\n{\n\twhile (*word && *word != ' ' && *word != '\\t')\n\t\tword++;\n\t*word = '\\0';\n}",
        "target": 0
    },
    {
        "id": 1595,
        "func": "static void ohci_sof(OHCIState *ohci)\n{\n    ohci_eof_timer(ohci);\n    ohci_set_interrupt(ohci, OHCI_INTR_SF);\n}\n",
        "target": 0
    },
    {
        "id": 1596,
        "func": "ZEND_API int zend_get_object_classname(const zval *object, const char **class_name, zend_uint *class_name_len TSRMLS_DC) /* {{{ */\n{\n\tif (Z_OBJ_HT_P(object)->get_class_name == NULL ||\n\t\tZ_OBJ_HT_P(object)->get_class_name(object, class_name, class_name_len, 0 TSRMLS_CC) != SUCCESS) {\n\t\tzend_class_entry *ce = Z_OBJCE_P(object);\n\n\t\t*class_name = ce->name;\n\t\t*class_name_len = ce->name_length;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 1597,
        "func": " SendTabToSelfInfoBarDelegate::SendTabToSelfInfoBarDelegate(\n     const SendTabToSelfEntry* entry) {\n   entry_ = entry;\n }\n",
        "target": 1
    },
    {
        "id": 1598,
        "func": "_gnutls_handshake_hash_add_sent (gnutls_session_t session,\n\t\t\t\t gnutls_handshake_description_t type,\n\t\t\t\t opaque * dataptr, uint32_t datalen)\n{\n  int ret;\n\n  if ((ret = _gnutls_handshake_hash_pending (session)) < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n\n  if (type != GNUTLS_HANDSHAKE_HELLO_REQUEST)\n    {\n      _gnutls_hash (&session->internals.handshake_mac_handle_sha, dataptr,\n\t\t    datalen);\n      _gnutls_hash (&session->internals.handshake_mac_handle_md5, dataptr,\n\t\t    datalen);\n    }\n\n  return 0;\n}\n",
        "target": 0
    },
    {
        "id": 1599,
        "func": "pdf_dict_find(fz_context *ctx, pdf_obj *obj, pdf_obj *key)\n{\n\tint len = DICT(obj)->len;\n\tif ((obj->flags & PDF_FLAGS_SORTED) && len > 0)\n\t{\n\t\tint l = 0;\n\t\tint r = len - 1;\n\t\tpdf_obj *k = DICT(obj)->items[r].k;\n\n\t\tif (k == key || (k >= PDF_OBJ__LIMIT && strcmp(NAME(k)->n, PDF_NAMES[(intptr_t)key]) < 0))\n\t\t{\n\t\t\treturn -1 - (r+1);\n\t\t}\n\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint m = (l + r) >> 1;\n\t\t\tint c;\n\n\t\t\tk = DICT(obj)->items[m].k;\n\t\t\tc = (k < PDF_OBJ__LIMIT ? (char *)key-(char *)k : -strcmp(NAME(k)->n, PDF_NAMES[(intptr_t)key]));\n\t\t\tif (c < 0)\n\t\t\t\tr = m - 1;\n\t\t\telse if (c > 0)\n\t\t\t\tl = m + 1;\n\t\t\telse\n\t\t\t\treturn m;\n\t\t}\n\t\treturn -1 - l;\n\t}\n\telse\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tpdf_obj *k = DICT(obj)->items[i].k;\n\t\t\tif (k < PDF_OBJ__LIMIT)\n\t\t\t{\n\t\t\t\tif (k == key)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!strcmp(PDF_NAMES[(intptr_t)key], NAME(k)->n))\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1 - len;\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 1600,
        "func": "void RenderFrameHostManager::DidNavigateFrame(\n    RenderFrameHostImpl* render_frame_host,\n    bool was_caused_by_user_gesture,\n    bool is_same_document_navigation) {\n  CommitPendingIfNecessary(render_frame_host, was_caused_by_user_gesture,\n                           is_same_document_navigation);\n\n  if (!is_same_document_navigation)\n    CommitPendingFramePolicy();\n}\n",
        "target": 0
    },
    {
        "id": 1601,
        "func": "QTNSort(QTNode *in)\n{\n\tint\t\t\ti;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type != QI_OPR)\n\t\treturn;\n\n\tfor (i = 0; i < in->nchild; i++)\n\t\tQTNSort(in->child[i]);\n\tif (in->nchild > 1)\n\t\tqsort((void *) in->child, in->nchild, sizeof(QTNode *), cmpQTN);\n}",
        "target": 0
    },
    {
        "id": 1602,
        "func": "int rds_get_mr(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_args args;\n\n\tif (optlen != sizeof(struct rds_get_mr_args))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, (struct rds_get_mr_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_args)))\n\t\treturn -EFAULT;\n\n\treturn __rds_rdma_map(rs, &args, NULL, NULL);\n}",
        "target": 0
    },
    {
        "id": 1603,
        "func": "static int decode_attr_nlink(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *nlink)\n{\n\t__be32 *p;\n\n\t*nlink = 1;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_NUMLINKS - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_NUMLINKS)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(*nlink);\n\t\tbitmap[1] &= ~FATTR4_WORD1_NUMLINKS;\n\t}\n\tdprintk(\"%s: nlink=%u\\n\", __func__, (unsigned int)*nlink);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1604,
        "func": "ofputil_encode_table_features_request(enum ofp_version ofp_version)\n{\n    struct ofpbuf *request = NULL;\n\n    switch (ofp_version) {\n    case OFP10_VERSION:\n    case OFP11_VERSION:\n    case OFP12_VERSION:\n        ovs_fatal(0, \"dump-table-features needs OpenFlow 1.3 or later \"\n                     \"(\\'-O OpenFlow13\\')\");\n    case OFP13_VERSION:\n    case OFP14_VERSION:\n    case OFP15_VERSION:\n    case OFP16_VERSION:\n        request = ofpraw_alloc(OFPRAW_OFPST13_TABLE_FEATURES_REQUEST,\n                               ofp_version, 0);\n        break;\n    default:\n        OVS_NOT_REACHED();\n    }\n\n    return request;\n}\n",
        "target": 0
    },
    {
        "id": 1605,
        "func": "INT_PTR CALLBACK SelectionDynCallback(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tint r = -1;\n\tswitch (message) {\n\tcase WM_INITDIALOG:\n\t\treturn (INT_PTR)TRUE;\n\n\tcase WM_COMMAND:\n\t\tswitch (LOWORD(wParam)) {\n\t\tcase IDOK:\n\t\t\tr = 0;\n\t\tcase IDCANCEL:\n\t\t\tEndDialog(hwndDlg, r);\n\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}",
        "target": 0
    },
    {
        "id": 1606,
        "func": "bool vnc_has_job(VncState *vs)\n{\n    bool ret;\n\n    vnc_lock_queue(queue);\n    ret = vnc_has_job_locked(vs);\n    vnc_unlock_queue(queue);\n    return ret;\n}\n",
        "target": 0
    },
    {
        "id": 1607,
        "func": "void SynchronizeVisualPropertiesMessageFilter::OnUpdatedSurfaceIdOnUI(\n    viz::LocalSurfaceId surface_id) {\n  last_surface_id_ = surface_id;\n  if (surface_id_run_loop_) {\n    surface_id_run_loop_->QuitWhenIdle();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1608,
        "func": "static void __usb_queue_reset_device(struct work_struct *ws)\n{\n\tint rc;\n\tstruct usb_interface *iface =\n\t\tcontainer_of(ws, struct usb_interface, reset_ws);\n\tstruct usb_device *udev = interface_to_usbdev(iface);\n\n\trc = usb_lock_device_for_reset(udev, iface);\n\tif (rc >= 0) {\n\t\tusb_reset_device(udev);\n\t\tusb_unlock_device(udev);\n\t}\n\tusb_put_intf(iface);\t/* Undo _get_ in usb_queue_reset_device() */\n}",
        "target": 0
    },
    {
        "id": 1609,
        "func": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}",
        "target": 1
    },
    {
        "id": 1610,
        "func": "static M_fs_error_t M_fs_move_file(const char *path_old, const char *path_new)\n{\n\tM_fs_error_t  res;\n\n\t/* Try to move the file. This will (should) fail if the file is cross volume. */\n#ifdef _WIN32\n\tif (MoveFileEx(path_old, path_new, MOVEFILE_REPLACE_EXISTING))\n#else\n\tif (rename(path_old, path_new) == 0)\n#endif\n\t{\n\t\tres = M_FS_ERROR_SUCCESS;\n\t} else {\n#ifdef _WIN32\n\t\tres = M_fs_error_from_syserr(GetLastError());\n#else\n\t\tres = M_fs_error_from_syserr(errno);\n#endif\n\t}\n\n\treturn res;\n}",
        "target": 0
    },
    {
        "id": 1611,
        "func": "ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n}",
        "target": 1
    },
    {
        "id": 1612,
        "func": "static inline int x86_pmu_initialized(void)\n{\n\treturn x86_pmu.handle_irq != NULL;\n}",
        "target": 0
    },
    {
        "id": 1613,
        "func": "ChromeInvalidationClient::~ChromeInvalidationClient() {\n  DCHECK(CalledOnValidThread());\n  push_client_->RemoveObserver(this);\n  Stop();\n  DCHECK(!listener_);\n }\n",
        "target": 0
    },
    {
        "id": 1614,
        "func": "void GraphicsContext::clearRect(const FloatRect&) \n{ \n    notImplemented(); \n}\n",
        "target": 0
    },
    {
        "id": 1615,
        "func": "error::Error GLES2DecoderImpl::HandleTexSubImage2D(\n    uint32 immediate_data_size, const cmds::TexSubImage2D& c) {\n  TRACE_EVENT2(\"gpu\", \"GLES2DecoderImpl::HandleTexSubImage2D\",\n      \"width\", c.width, \"height\", c.height);\n  GLboolean internal = static_cast<GLboolean>(c.internal);\n  if (internal == GL_TRUE && texture_state_.tex_image_2d_failed)\n    return error::kNoError;\n\n  GLenum target = static_cast<GLenum>(c.target);\n  GLint level = static_cast<GLint>(c.level);\n  GLint xoffset = static_cast<GLint>(c.xoffset);\n  GLint yoffset = static_cast<GLint>(c.yoffset);\n  GLsizei width = static_cast<GLsizei>(c.width);\n  GLsizei height = static_cast<GLsizei>(c.height);\n  GLenum format = static_cast<GLenum>(c.format);\n  GLenum type = static_cast<GLenum>(c.type);\n  uint32 data_size;\n  if (!GLES2Util::ComputeImageDataSizes(\n      width, height, format, type, state_.unpack_alignment, &data_size,\n      NULL, NULL)) {\n    return error::kOutOfBounds;\n  }\n  const void* pixels = GetSharedMemoryAs<const void*>(\n      c.pixels_shm_id, c.pixels_shm_offset, data_size);\n  return DoTexSubImage2D(\n      target, level, xoffset, yoffset, width, height, format, type, pixels);\n}\n",
        "target": 0
    },
    {
        "id": 1616,
        "func": "fep_client_send_text (FepClient *client, const char *text)\n{\n  FepControlMessage message;\n\n  message.command = FEP_CONTROL_SEND_TEXT;\n  _fep_control_message_alloc_args (&message, 1);\n  _fep_control_message_write_string_arg (&message, 0, text, strlen (text) + 1);\n\n  if (client->filter_running)\n    client->messages = _fep_append_control_message (client->messages, &message);\n  else\n    _fep_write_control_message (client->control, &message);\n  _fep_control_message_free_args (&message);\n}\n",
        "target": 0
    },
    {
        "id": 1617,
        "func": "is_anychar_infinite_greedy(QuantNode* qn)\n{\n  if (qn->greedy && IS_REPEAT_INFINITE(qn->upper) &&\n      NODE_IS_ANYCHAR(NODE_QUANT_BODY(qn)))\n    return 1;\n  else\n    return 0;\n}",
        "target": 0
    },
    {
        "id": 1618,
        "func": "static void command_timed_out(UNUSED_ATTR void *context) {\n  pthread_mutex_lock(&commands_pending_response_lock);\n\n if (list_is_empty(commands_pending_response)) {\n    LOG_ERROR(\"%s with no commands pending response\", __func__);\n } else {\n waiting_command_t *wait_entry = list_front(commands_pending_response);\n    pthread_mutex_unlock(&commands_pending_response_lock);\n\n    LOG_ERROR(\"%s hci layer timeout waiting for response to a command. opcode: 0x%x\", __func__, wait_entry->opcode);\n\n   }\n \n   LOG_ERROR(\"%s restarting the bluetooth process.\", __func__);\n  usleep(10000);\n   kill(getpid(), SIGKILL);\n }\n",
        "target": 1
    },
    {
        "id": 1619,
        "func": "gs_get_colorname_string(const gs_memory_t *mem, gs_separation_name colorname_index,\n                        unsigned char **ppstr, unsigned int *pname_size)\n{\n    ref nref;\n\n    name_index_ref(mem, colorname_index, &nref);\n    name_string_ref(mem, &nref, &nref);\n    return obj_string_data(mem, &nref, (const unsigned char**) ppstr, pname_size);\n}\n",
        "target": 0
    },
    {
        "id": 1620,
        "func": "bool SessionStore::AreValidSpecifics(const SessionSpecifics& specifics) {\n  if (specifics.session_tag().empty()) {\n    return false;\n  }\n  if (specifics.has_tab()) {\n    return specifics.tab_node_id() >= 0 && specifics.tab().tab_id() > 0;\n  }\n  if (specifics.has_header()) {\n    std::set<int> session_tab_ids;\n    for (const sync_pb::SessionWindow& window : specifics.header().window()) {\n      for (int tab_id : window.tab()) {\n        bool success = session_tab_ids.insert(tab_id).second;\n        if (!success) {\n          return false;\n        }\n      }\n    }\n    return !specifics.has_tab() &&\n           specifics.tab_node_id() == TabNodePool::kInvalidTabNodeID;\n  }\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 1621,
        "func": "static int sco_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tbdaddr_t *src = &bt_sk(sk)->src;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&sco_sk_list.lock);\n\n\tif (__sco_get_sock_listen_by_addr(src)) {\n\t\terr = -EADDRINUSE;\n\t\tgoto unlock;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\tsk->sk_state = BT_LISTEN;\n\nunlock:\n\twrite_unlock(&sco_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 1622,
        "func": "void FileAPIMessageFilter::DidFinish(int request_id,\n                                     base::PlatformFileError result) {\n  if (result == base::PLATFORM_FILE_OK)\n    Send(new FileSystemMsg_DidSucceed(request_id));\n  else\n    Send(new FileSystemMsg_DidFail(request_id, result));\n  UnregisterOperation(request_id);\n}\n",
        "target": 0
    },
    {
        "id": 1623,
        "func": "float GetTouchAngle(const base::NativeEvent& native_event) {\n  NOTIMPLEMENTED();\n  return 0.0;\n}\n",
        "target": 0
    },
    {
        "id": 1624,
        "func": "static unsigned short ReadDCMShort(DCMStreamInfo *stream_info,Image *image)\n{\n  int\n    shift;\n\n  unsigned short\n    value;\n\n  if (image->compression != RLECompression)\n    return(ReadBlobLSBShort(image));\n  shift=image->depth < 16 ? 4 : 8;\n  value=ReadDCMByte(stream_info,image) | (unsigned short)\n    (ReadDCMByte(stream_info,image) << shift);\n  return(value);\n}",
        "target": 0
    },
    {
        "id": 1625,
        "func": "void vm_info_final(struct user_ta_ctx *utc)\n{\n\tif (!utc->vm_info)\n\t\treturn;\n\n\t/* clear MMU entries to avoid clash when asid is reused */\n\ttlbi_asid(utc->vm_info->asid);\n\n\tasid_free(utc->vm_info->asid);\n\twhile (!TAILQ_EMPTY(&utc->vm_info->regions))\n\t\tumap_remove_region(utc->vm_info,\n\t\t\t\t   TAILQ_FIRST(&utc->vm_info->regions));\n\tfree(utc->vm_info);\n\tutc->vm_info = NULL;\n}",
        "target": 0
    },
    {
        "id": 1626,
        "func": "rpc_setup_pipedir(struct rpc_clnt *clnt, char *dir_name)\n{\n\tstatic uint32_t clntid;\n\tstruct nameidata nd;\n\tstruct path path;\n\tchar name[15];\n\tstruct qstr q = {\n\t\t.name = name,\n\t};\n\tint error;\n\n\tclnt->cl_path.mnt = ERR_PTR(-ENOENT);\n\tclnt->cl_path.dentry = ERR_PTR(-ENOENT);\n\tif (dir_name == NULL)\n\t\treturn 0;\n\n\tpath.mnt = rpc_get_mount();\n\tif (IS_ERR(path.mnt))\n\t\treturn PTR_ERR(path.mnt);\n\terror = vfs_path_lookup(path.mnt->mnt_root, path.mnt, dir_name, 0, &nd);\n\tif (error)\n\t\tgoto err;\n\n\tfor (;;) {\n\t\tq.len = snprintf(name, sizeof(name), \"clnt%x\", (unsigned int)clntid++);\n\t\tname[sizeof(name) - 1] = '\\0';\n\t\tq.hash = full_name_hash(q.name, q.len);\n\t\tpath.dentry = rpc_create_client_dir(nd.path.dentry, &q, clnt);\n\t\tif (!IS_ERR(path.dentry))\n\t\t\tbreak;\n\t\terror = PTR_ERR(path.dentry);\n\t\tif (error != -EEXIST) {\n\t\t\tprintk(KERN_INFO \"RPC: Couldn't create pipefs entry\"\n\t\t\t\t\t\" %s/%s, error %d\\n\",\n\t\t\t\t\tdir_name, name, error);\n\t\t\tgoto err_path_put;\n\t\t}\n\t}\n\tpath_put(&nd.path);\n\tclnt->cl_path = path;\n\treturn 0;\nerr_path_put:\n\tpath_put(&nd.path);\nerr:\n\trpc_put_mount();\n\treturn error;\n}",
        "target": 0
    },
    {
        "id": 1627,
        "func": "PHP_METHOD(PharFileInfo, getPharFlags)\n{\n\tPHAR_ENTRY_OBJECT();\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(entry_obj->ent.entry->flags & ~(PHAR_ENT_PERM_MASK|PHAR_ENT_COMPRESSION_MASK));\n}\n",
        "target": 0
    },
    {
        "id": 1628,
        "func": "static int out_get_render_position(const struct audio_stream_out *stream,\n uint32_t *dsp_frames)\n{\n (void)stream;\n *dsp_frames = 0;\n return -EINVAL;\n}\n",
        "target": 0
    },
    {
        "id": 1629,
        "func": "static bool ExecuteInsertText(LocalFrame& frame,\n                              Event*,\n                              EditorCommandSource,\n                              const String& value) {\n  DCHECK(frame.GetDocument());\n  TypingCommand::InsertText(*frame.GetDocument(), value, 0);\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1630,
        "func": " pvscsi_convert_sglist(PVSCSIRequest *r)\n {\n    int chunk_size;\n     uint64_t data_length = r->req.dataLen;\n     PVSCSISGState sg = r->sg;\n    while (data_length) {\n        while (!sg.resid) {\n             pvscsi_get_next_sg_elem(&sg);\n             trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                         r->sg.resid);\n         }\n        assert(data_length > 0);\n        chunk_size = MIN((unsigned) data_length, sg.resid);\n         if (chunk_size) {\n             qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n         }\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}\n",
        "target": 1
    },
    {
        "id": 1631,
        "func": "void AudioSource::releaseQueuedFrames_l() {\n    ALOGV(\"releaseQueuedFrames_l\");\n List<MediaBuffer *>::iterator it;\n while (!mBuffersReceived.empty()) {\n        it = mBuffersReceived.begin();\n (*it)->release();\n        mBuffersReceived.erase(it);\n }\n}\n",
        "target": 0
    },
    {
        "id": 1632,
        "func": "static inline int qeth_create_skb_frag(struct qeth_qdio_buffer *qethbuffer,\n\t\tstruct qdio_buffer_element *element,\n\t\tstruct sk_buff **pskb, int offset, int *pfrag, int data_len)\n{\n\tstruct page *page = virt_to_page(element->addr);\n\tif (*pskb == NULL) {\n\t\tif (qethbuffer->rx_skb) {\n\t\t\t/* only if qeth_card.options.cq == QETH_CQ_ENABLED */\n\t\t\t*pskb = qethbuffer->rx_skb;\n\t\t\tqethbuffer->rx_skb = NULL;\n\t\t} else {\n\t\t\t*pskb = dev_alloc_skb(QETH_RX_PULL_LEN + ETH_HLEN);\n\t\t\tif (!(*pskb))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_reserve(*pskb, ETH_HLEN);\n\t\tif (data_len <= QETH_RX_PULL_LEN) {\n\t\t\tmemcpy(skb_put(*pskb, data_len), element->addr + offset,\n\t\t\t\tdata_len);\n\t\t} else {\n\t\t\tget_page(page);\n\t\t\tmemcpy(skb_put(*pskb, QETH_RX_PULL_LEN),\n\t\t\t       element->addr + offset, QETH_RX_PULL_LEN);\n\t\t\tskb_fill_page_desc(*pskb, *pfrag, page,\n\t\t\t\toffset + QETH_RX_PULL_LEN,\n\t\t\t\tdata_len - QETH_RX_PULL_LEN);\n\t\t\t(*pskb)->data_len += data_len - QETH_RX_PULL_LEN;\n\t\t\t(*pskb)->len      += data_len - QETH_RX_PULL_LEN;\n\t\t\t(*pskb)->truesize += data_len - QETH_RX_PULL_LEN;\n\t\t\t(*pfrag)++;\n\t\t}\n\t} else {\n\t\tget_page(page);\n\t\tskb_fill_page_desc(*pskb, *pfrag, page, offset, data_len);\n\t\t(*pskb)->data_len += data_len;\n\t\t(*pskb)->len      += data_len;\n\t\t(*pskb)->truesize += data_len;\n\t\t(*pfrag)++;\n\t}\n\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1633,
        "func": "int BackendImpl::DoomEntriesSince(const base::Time initial_time,\n                                  const CompletionCallback& callback) {\n  DCHECK(!callback.is_null());\n  background_queue_.DoomEntriesSince(initial_time, callback);\n  return net::ERR_IO_PENDING;\n}\n",
        "target": 0
    },
    {
        "id": 1634,
        "func": "static void free_kmem_cache_cpus(struct kmem_cache *s)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct kmem_cache_cpu *c = get_cpu_slab(s, cpu);\n\n\t\tif (c) {\n\t\t\ts->cpu_slab[cpu] = NULL;\n\t\t\tfree_kmem_cache_cpu(c, cpu);\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 1635,
        "func": "bool GLES2DecoderImpl::PrepForSetUniformByLocation(\n    GLint fake_location,\n    const char* function_name,\n    Program::UniformApiType api_type,\n    GLint* real_location,\n    GLenum* type,\n    GLsizei* count) {\n  DCHECK(type);\n  DCHECK(count);\n  DCHECK(real_location);\n\n  if (!CheckCurrentProgramForUniform(fake_location, function_name)) {\n    return false;\n  }\n  GLint array_index = -1;\n  const Program::UniformInfo* info =\n      state_.current_program->GetUniformInfoByFakeLocation(\n          fake_location, real_location, &array_index);\n  if (!info) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"unknown location\");\n    return false;\n  }\n  if (!CheckUniformForApiType(info, function_name, api_type)) {\n    return false;\n  }\n  if (*count > 1 && !info->is_array) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"count > 1 for non-array\");\n    return false;\n  }\n  *count = std::min(info->size - array_index, *count);\n  if (*count <= 0) {\n    return false;\n  }\n  *type = info->type;\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1636,
        "func": "HRESULT DataObjectImpl::EnumFormatEtc(\n    DWORD direction, IEnumFORMATETC** enumerator) {\n  if (direction == DATADIR_GET) {\n    FormatEtcEnumerator* e =\n        new FormatEtcEnumerator(contents_.begin(), contents_.end());\n    e->AddRef();\n    *enumerator = e;\n    return S_OK;\n  }\n  return E_NOTIMPL;\n}\n",
        "target": 0
    },
    {
        "id": 1637,
        "func": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}",
        "target": 1
    },
    {
        "id": 1638,
        "func": "NaClProcessHost::~NaClProcessHost() {\n#ifndef DISABLE_NACL\n  for (size_t i = 0; i < internal_->sockets_for_renderer.size(); i++) {\n    if (nacl::Close(internal_->sockets_for_renderer[i]) != 0) {\n      LOG(ERROR) << \"nacl::Close() failed\";\n    }\n  }\n  for (size_t i = 0; i < internal_->sockets_for_sel_ldr.size(); i++) {\n    if (nacl::Close(internal_->sockets_for_sel_ldr[i]) != 0) {\n      LOG(ERROR) << \"nacl::Close() failed\";\n    }\n  }\n#endif\n\n  if (reply_msg_) {\n    reply_msg_->set_reply_error();\n    chrome_render_message_filter_->Send(reply_msg_);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1639,
        "func": "svcauth_gss_acquire_cred(void)\n{\n\tOM_uint32\tmaj_stat, min_stat;\n\n\tlog_debug(\"in svcauth_gss_acquire_cred()\");\n\n\tmaj_stat = gss_acquire_cred(&min_stat, svcauth_gss_name, 0,\n\t\t\t\t    GSS_C_NULL_OID_SET, GSS_C_ACCEPT,\n\t\t\t\t    &svcauth_gss_creds, NULL, NULL);\n\n\tif (maj_stat != GSS_S_COMPLETE) {\n\t\tlog_status(\"gss_acquire_cred\", maj_stat, min_stat);\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}",
        "target": 0
    },
    {
        "id": 1640,
        "func": "tell_controller_about_resolved_result(entry_connection_t *conn,\n                                      int answer_type,\n                                      size_t answer_len,\n                                      const char *answer,\n                                      int ttl,\n                                      time_t expires)\n{\n  expires = time(NULL) + ttl;\n  if (answer_type == RESOLVED_TYPE_IPV4 && answer_len >= 4) {\n    char *cp = tor_dup_ip(ntohl(get_uint32(answer)));\n    control_event_address_mapped(conn->socks_request->address,\n                                 cp, expires, NULL, 0);\n    tor_free(cp);\n  } else if (answer_type == RESOLVED_TYPE_HOSTNAME && answer_len < 256) {\n    char *cp = tor_strndup(answer, answer_len);\n    control_event_address_mapped(conn->socks_request->address,\n                                 cp, expires, NULL, 0);\n    tor_free(cp);\n  } else {\n    control_event_address_mapped(conn->socks_request->address,\n                                 \"<error>\", time(NULL)+ttl,\n                                 \"error=yes\", 0);\n  }\n}",
        "target": 0
    },
    {
        "id": 1641,
        "func": "bool CanHandleTouchHud() {\n  return RootWindowController::ForTargetRootWindow()->touch_hud_debug();\n}\n",
        "target": 0
    },
    {
        "id": 1642,
        "func": "static int rm_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n    AVStream *st = NULL; // init to silence compiler warning\n    int i, len, res, seq = 1;\n    int64_t timestamp, pos;\n    int flags;\n\n    for (;;) {\n        if (rm->audio_pkt_cnt) {\n            // If there are queued audio packet return them first\n            st = s->streams[rm->audio_stream_num];\n            res = ff_rm_retrieve_cache(s, s->pb, st, st->priv_data, pkt);\n            if(res < 0)\n                return res;\n            flags = 0;\n        } else {\n            if (rm->old_format) {\n                RMStream *ast;\n\n                st = s->streams[0];\n                ast = st->priv_data;\n                timestamp = AV_NOPTS_VALUE;\n                len = !ast->audio_framesize ? RAW_PACKET_SIZE :\n                    ast->coded_framesize * ast->sub_packet_h / 2;\n                flags = (seq++ == 1) ? 2 : 0;\n                pos = avio_tell(s->pb);\n            } else {\n                len = rm_sync(s, &timestamp, &flags, &i, &pos);\n                if (len > 0)\n                    st = s->streams[i];\n            }\n\n            if (avio_feof(s->pb))\n                return AVERROR_EOF;\n            if (len <= 0)\n                return AVERROR(EIO);\n\n            res = ff_rm_parse_packet (s, s->pb, st, st->priv_data, len, pkt,\n                                      &seq, flags, timestamp);\n            if (res < -1)\n                return res;\n            if((flags&2) && (seq&0x7F) == 1)\n                av_add_index_entry(st, pos, timestamp, 0, 0, AVINDEX_KEYFRAME);\n            if (res)\n                continue;\n        }\n\n        if(  (st->discard >= AVDISCARD_NONKEY && !(flags&2))\n           || st->discard >= AVDISCARD_ALL){\n            av_packet_unref(pkt);\n        } else\n            break;\n    }\n\n    return 0;\n}",
        "target": 0
    },
    {
        "id": 1643,
        "func": "zrestore(i_ctx_t *i_ctx_p)\n {\n     os_ptr op = osp;\n    alloc_save_t *asave;\n    bool last;\n    vm_save_t *vmsave;\n    int code = restore_check_operand(op, &asave, idmemory);\n \n     if (code < 0)\n         return code;\n     if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n               (ulong) alloc_save_client_data(asave),\n                (ulong) op->value.saveid);\n     if (I_VALIDATE_BEFORE_RESTORE)\n         ivalidate_clean_spaces(i_ctx_p);\n        ivalidate_clean_spaces(i_ctx_p);\n    /* Check the contents of the stacks. */\n     {\n         int code;\n \n        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0\n             ) {\n             osp++;\n             return code;\n         }\n     }\n     /* Reset l_new in all stack entries if the new save level is zero. */\n     /* Also do some special fixing on the e-stack. */\n     restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n    }\n",
        "target": 1
    },
    {
        "id": 1644,
        "func": "on_register_handler(TCMUService1HandlerManager1 *interface,\n\t\t    GDBusMethodInvocation *invocation,\n\t\t    gchar *subtype,\n\t\t    gchar *cfg_desc,\n\t\t    gpointer user_data)\n{\n\tstruct tcmur_handler *handler;\n\tstruct dbus_info *info;\n\tchar *bus_name;\n\n\tbus_name = g_strdup_printf(\"org.kernel.TCMUService1.HandlerManager1.%s\",\n\t\t\t\t   subtype);\n\n\thandler               = g_new0(struct tcmur_handler, 1);\n\thandler->subtype      = g_strdup(subtype);\n\thandler->cfg_desc     = g_strdup(cfg_desc);\n\thandler->open         = dbus_handler_open;\n\thandler->close        = dbus_handler_close;\n \thandler->handle_cmd   = dbus_handler_handle_cmd;\n \n \tinfo = g_new0(struct dbus_info, 1);\n \tinfo->register_invocation = invocation;\n \tinfo->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,\n \t\t\t\t\t    bus_name,\n\t\t\t\t\t    G_BUS_NAME_WATCHER_FLAGS_NONE,\n\t\t\t\t\t    on_handler_appeared,\n\t\t\t\t\t    on_handler_vanished,\n\t\t\t\t\t    handler,\n\t\t\t\t\t    NULL);\n\tg_free(bus_name);\n\thandler->opaque = info;\n\treturn TRUE;\n}\n",
        "target": 1
    },
    {
        "id": 1645,
        "func": "int ZEXPORT inflateUndermine(strm, subvert)\nz_streamp strm;\nint subvert;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n    state->sane = !subvert;\n    return Z_OK;\n#else\n    state->sane = 1;\n    return Z_DATA_ERROR;\n#endif\n}",
        "target": 0
    },
    {
        "id": 1646,
        "func": "void CLASS foveon_thumb()\n{\n  int bwide;\n  unsigned row, col, bitbuf=0, bit=1, c, i;\n  char *buf;\n  struct decode *dindex;\n  short pred[3];\n\n  bwide = get4();\n  fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  if (bwide > 0) {\n    if (bwide < thumb_width*3) return;\n    buf = (char *) malloc (bwide);\n    merror (buf, \"foveon_thumb()\");\n    for (row=0; row < thumb_height; row++) {\n      fread  (buf, 1, bwide, ifp);\n      fwrite (buf, 3, thumb_width, ofp);\n    }\n    free (buf);\n    return;\n  }\n  foveon_decoder (256, 0);\n\n  for (row=0; row < thumb_height; row++) {\n    memset (pred, 0, sizeof pred);\n    if (!bit) get4();\n    for (bit=col=0; col < thumb_width; col++)\n      FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += dindex->leaf;\n\tfputc (pred[c], ofp);\n      }\n  }\n}",
        "target": 0
    },
    {
        "id": 1647,
        "func": "KeyboardLibrary* CrosLibrary::GetKeyboardLibrary() {\n  return keyboard_lib_.GetDefaultImpl(use_stub_impl_);\n}\n",
        "target": 1
    },
    {
        "id": 1648,
        "func": "AP_DECLARE(apr_socket_t *) ap_get_conn_socket(conn_rec *c)\n{\n    return ap_get_core_module_config(c->conn_config);\n}\n",
        "target": 0
    },
    {
        "id": 1649,
        "func": "void GLES2DecoderImpl::DoPopulateSubscribedValuesCHROMIUM(GLenum target) {\n  if (!CheckCurrentValuebuffer(\"glPopulateSubscribedValuesCHROMIUM\")) {\n    return;\n  }\n  valuebuffer_manager()->UpdateValuebufferState(state_.bound_valuebuffer.get());\n}\n",
        "target": 0
    },
    {
        "id": 1650,
        "func": "error::Error GLES2DecoderImpl::HandleGetAttachedShaders(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  const volatile gles2::cmds::GetAttachedShaders& c =\n      *static_cast<const volatile gles2::cmds::GetAttachedShaders*>(cmd_data);\n  uint32_t result_size = c.result_size;\n  GLuint program_id = static_cast<GLuint>(c.program);\n  Program* program = GetProgramInfoNotShader(\n      program_id, \"glGetAttachedShaders\");\n  if (!program) {\n    return error::kNoError;\n  }\n  typedef cmds::GetAttachedShaders::Result Result;\n  uint32_t max_count = Result::ComputeMaxResults(result_size);\n  uint32_t checked_size = 0;\n  if (!Result::ComputeSize(max_count).AssignIfValid(&checked_size)) {\n    return error::kOutOfBounds;\n  }\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.result_shm_id, c.result_shm_offset, checked_size);\n  if (!result) {\n    return error::kOutOfBounds;\n  }\n  if (result->size != 0) {\n    return error::kInvalidArguments;\n  }\n  GLsizei count = 0;\n  api()->glGetAttachedShadersFn(program->service_id(), max_count, &count,\n                                result->GetData());\n  for (GLsizei ii = 0; ii < count; ++ii) {\n    if (!shader_manager()->GetClientId(result->GetData()[ii],\n                                       &result->GetData()[ii])) {\n      NOTREACHED();\n      return error::kGenericError;\n    }\n  }\n  result->SetNumResults(count);\n  return error::kNoError;\n}\n",
        "target": 0
    },
    {
        "id": 1651,
        "func": "  void StartServerWithExpiredCert() {\n    expired_https_server_.reset(\n        new net::EmbeddedTestServer(net::EmbeddedTestServer::TYPE_HTTPS));\n    expired_https_server_->SetSSLConfig(net::EmbeddedTestServer::CERT_EXPIRED);\n    expired_https_server_->AddDefaultHandlers(\n        base::FilePath(FILE_PATH_LITERAL(\"chrome/test/data\")));\n    ASSERT_TRUE(expired_https_server_->Start());\n  }\n",
        "target": 0
    },
    {
        "id": 1652,
        "func": "bool TestBrowserWindow::IsMaximized() const {\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 1653,
        "func": "static bool nested_cr3_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tunsigned long invalid_mask;\n\n\tinvalid_mask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\treturn (val & invalid_mask) == 0;\n}",
        "target": 0
    },
    {
        "id": 1654,
        "func": "void Document::DetachRange(Range* range) {\n  ranges_.erase(range);\n}\n",
        "target": 0
    },
    {
        "id": 1655,
        "func": "  explicit HeaderTestDispatcherHostDelegate(const GURL& watch_url)\n  explicit ThrottleContentBrowserClient(const GURL& watch_url)\n       : watch_url_(watch_url) {}\n",
        "target": 0
    },
    {
        "id": 1656,
        "func": "static struct sk_buff *nfc_llcp_allocate_snl(struct nfc_llcp_local *local,\n\t\t\t\t\t     size_t tlv_length)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 0;\n\n\tif (local == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tsize += tlv_length;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, LLCP_SAP_SDP, LLCP_SAP_SDP, LLCP_PDU_SNL);\n\n\treturn skb;\n}",
        "target": 0
    },
    {
        "id": 1657,
        "func": " void AXObjectCacheImpl::postPlatformNotification(AXObject* obj,\n                                                 AXNotification notification) {\n  if (!obj || !obj->getDocument() || !obj->documentFrameView() ||\n      !obj->documentFrameView()->frame().page())\n    return;\n\n  ChromeClient& client =\n      obj->getDocument()->axObjectCacheOwner().page()->chromeClient();\n  client.postAccessibilityNotification(obj, notification);\n}\n",
        "target": 0
    },
    {
        "id": 1658,
        "func": "static bool on_accept(private_stroke_socket_t *this, stream_t *stream)\n{\n\tstroke_msg_t *msg;\n\tuint16_t len;\n\tFILE *out;\n\n\t/* read length */\n\tif (!stream->read_all(stream, &len, sizeof(len)))\n\t{\n\t\tif (errno != EWOULDBLOCK)\n\t\t{\n\t\t\tDBG1(DBG_CFG, \"reading length of stroke message failed: %s\",\n\t\t\t\t strerror(errno));\n                }\n                return FALSE;\n        }\n \n        /* read message (we need an additional byte to terminate the buffer) */\n        msg = malloc(len + 1);\n\t\t\tDBG1(DBG_CFG, \"reading stroke message failed: %s\", strerror(errno));\n\t\t}\n",
        "target": 1
    },
    {
        "id": 1659,
        "func": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n\n\tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n\n\tbsg_set_block(bd, file);\n\n\tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\n\t*ppos = bytes_written;\n\n\t/*\n\t * return bytes written on non-fatal errors\n\t */\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}",
        "target": 1
    },
    {
        "id": 1660,
        "func": "void PepperDeviceEnumerationHostHelper::OnNotifyDeviceChange(\n    uint32_t callback_id,\n    int /* request_id */,\n    const std::vector<ppapi::DeviceRefData>& devices) {\n  resource_host_->host()->SendUnsolicitedReply(\n      resource_host_->pp_resource(),\n      PpapiPluginMsg_DeviceEnumeration_NotifyDeviceChange(callback_id,\n                                                          devices));\n}\n",
        "target": 0
    },
    {
        "id": 1661,
        "func": "int OmniboxViewWin::OnPerformDrop(const views::DropTargetEvent& event) {\n  return OnPerformDropImpl(event, false);\n}\n",
        "target": 0
    },
    {
        "id": 1662,
        "func": "static int read_fragment_table(long long *directory_table_end)\n{\n\tint res, i;\n\tint bytes = SQUASHFS_FRAGMENT_BYTES(sBlk.s.fragments);\n\tint  indexes = SQUASHFS_FRAGMENT_INDEXES(sBlk.s.fragments);\n\tlong long fragment_table_index[indexes];\n\n\tTRACE(\"read_fragment_table: %d fragments, reading %d fragment indexes \"\n\t\t\"from 0x%llx\\n\", sBlk.s.fragments, indexes,\n\t\tsBlk.s.fragment_table_start);\n\n\tif(sBlk.s.fragments == 0) {\n\t\t*directory_table_end = sBlk.s.fragment_table_start;\n\t\treturn TRUE;\n\t}\n\n\tfragment_table = malloc(bytes);\n\tif(fragment_table == NULL)\n\t\tEXIT_UNSQUASH(\"read_fragment_table: failed to allocate \"\n\t\t\t\"fragment table\\n\");\n\n\tres = read_fs_bytes(fd, sBlk.s.fragment_table_start,\n\t\tSQUASHFS_FRAGMENT_INDEX_BYTES(sBlk.s.fragments),\n\t\tfragment_table_index);\n\tif(res == FALSE) {\n\t\tERROR(\"read_fragment_table: failed to read fragment table \"\n\t\t\t\"index\\n\");\n\t\treturn FALSE;\n\t}\n\tSQUASHFS_INSWAP_FRAGMENT_INDEXES(fragment_table_index, indexes);\n\n\tfor(i = 0; i < indexes; i++) {\n\t\tint expected = (i + 1) != indexes ? SQUASHFS_METADATA_SIZE :\n\t\t\t\t\tbytes & (SQUASHFS_METADATA_SIZE - 1);\n\t\tint length = read_block(fd, fragment_table_index[i], NULL,\n\t\t\texpected, ((char *) fragment_table) + (i *\n\t\t\tSQUASHFS_METADATA_SIZE));\n\t\tTRACE(\"Read fragment table block %d, from 0x%llx, length %d\\n\",\n\t\t\ti, fragment_table_index[i], length);\n\t\tif(length == FALSE) {\n\t\t\tERROR(\"read_fragment_table: failed to read fragment \"\n\t\t\t\t\"table index\\n\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tfor(i = 0; i < sBlk.s.fragments; i++) \n\t\tSQUASHFS_INSWAP_FRAGMENT_ENTRY(&fragment_table[i]);\n\n\t*directory_table_end = fragment_table_index[0];\n\treturn TRUE;\n}",
        "target": 1
    },
    {
        "id": 1663,
        "func": "void test_truncate(const char *path)\n{\n\tif (truncate(path, 0) == 0) {\n\t\tfprintf(stderr, \"leak at truncate of %s\\n\", path);\n\t\texit(1);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1664,
        "func": "static int putreg32(struct task_struct *child, unsigned regno, u32 value)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\n\tswitch (regno) {\n\n\tSEG32(cs);\n\tSEG32(ds);\n\tSEG32(es);\n\tSEG32(fs);\n\tSEG32(gs);\n\tSEG32(ss);\n\n\tR32(ebx, bx);\n\tR32(ecx, cx);\n\tR32(edx, dx);\n\tR32(edi, di);\n\tR32(esi, si);\n\tR32(ebp, bp);\n\tR32(eax, ax);\n\tR32(eip, ip);\n\tR32(esp, sp);\n\n\tcase offsetof(struct user32, regs.orig_eax):\n\t\t/*\n\t\t * A 32-bit debugger setting orig_eax means to restore\n\t\t * the state of the task restarting a 32-bit syscall.\n\t\t * Make sure we interpret the -ERESTART* codes correctly\n\t\t * in case the task is not actually still sitting at the\n\t\t * exit from a 32-bit syscall with TS_COMPAT still set.\n\t\t */\n\t\tregs->orig_ax = value;\n\t\tif (syscall_get_nr(child, regs) >= 0)\n\t\t\ttask_thread_info(child)->status |= TS_COMPAT;\n\t\tbreak;\n\n\tcase offsetof(struct user32, regs.eflags):\n\t\treturn set_flags(child, value);\n\n\tcase offsetof(struct user32, u_debugreg[0]) ...\n\t\toffsetof(struct user32, u_debugreg[7]):\n\t\tregno -= offsetof(struct user32, u_debugreg[0]);\n\t\treturn ptrace_set_debugreg(child, regno / 4, value);\n\n\tdefault:\n\t\tif (regno > sizeof(struct user32) || (regno & 3))\n\t\t\treturn -EIO;\n\n\t\t/*\n\t\t * Other dummy fields in the virtual user structure\n\t\t * are ignored\n\t\t */\n\t\tbreak;\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1665,
        "func": "  PictureLayerImplTest()\n      : proxy_(base::MessageLoopProxy::current()),\n        host_impl_(LowResTilingsSettings(), &proxy_, &shared_bitmap_manager_),\n        root_id_(6),\n        id_(7),\n        pending_layer_(nullptr),\n        old_pending_layer_(nullptr),\n        active_layer_(nullptr) {\n    host_impl_.SetViewportSize(gfx::Size(10000, 10000));\n  }\n",
        "target": 0
    },
    {
        "id": 1666,
        "func": "int rxrpc_kernel_get_error_number(struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\n\treturn sp->error;\n}",
        "target": 0
    },
    {
        "id": 1667,
        "func": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); /* bypass_guest_pf = 0 */\n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}",
        "target": 1
    },
    {
        "id": 1668,
        "func": "void DownloadResourceHandler::OnRequestRedirected(\n    const net::RedirectInfo& redirect_info,\n    network::ResourceResponse* response,\n    std::unique_ptr<ResourceController> controller) {\n  url::Origin new_origin(url::Origin::Create(redirect_info.new_url));\n  if (!follow_cross_origin_redirects_ &&\n      !first_origin_.IsSameOriginWith(new_origin)) {\n    base::PostTaskWithTraits(\n        FROM_HERE, {BrowserThread::UI},\n        base::BindOnce(\n            &NavigateOnUIThread, redirect_info.new_url, request()->url_chain(),\n            Referrer(GURL(redirect_info.new_referrer),\n                      Referrer::NetReferrerPolicyToBlinkReferrerPolicy(\n                          redirect_info.new_referrer_policy)),\n             GetRequestInfo()->HasUserGesture(),\n            GetRequestInfo()->GetWebContentsGetterForRequest()));\n     controller->Cancel();\n     return;\n   }\n  if (core_.OnRequestRedirected()) {\n    controller->Resume();\n  } else {\n    controller->Cancel();\n  }\n}\n",
        "target": 1
    },
    {
        "id": 1669,
        "func": "rb_decrement_entry(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t   struct ring_buffer_event *event)\n{\n\tunsigned long addr = (unsigned long)event;\n\tstruct buffer_page *bpage = cpu_buffer->commit_page;\n\tstruct buffer_page *start;\n\n\taddr &= PAGE_MASK;\n\n\t/* Do the likely case first */\n\tif (likely(bpage->page == (void *)addr)) {\n\t\tlocal_dec(&bpage->entries);\n\t\treturn;\n\t}\n\n\t/*\n\t * Because the commit page may be on the reader page we\n\t * start with the next page and check the end loop there.\n\t */\n\trb_inc_page(cpu_buffer, &bpage);\n\tstart = bpage;\n\tdo {\n\t\tif (bpage->page == (void *)addr) {\n\t\t\tlocal_dec(&bpage->entries);\n\t\t\treturn;\n\t\t}\n\t\trb_inc_page(cpu_buffer, &bpage);\n\t} while (bpage != start);\n\n\t/* commit not part of this buffer?? */\n\tRB_WARN_ON(cpu_buffer, 1);\n}",
        "target": 0
    },
    {
        "id": 1670,
        "func": "static apr_array_header_t *parse_errorlog_string(apr_pool_t *p,\n                                                 const char *s,\n                                                 const char **err,\n                                                 int is_main_fmt)\n{\n    apr_array_header_t *a = apr_array_make(p, 30,\n                                           sizeof(ap_errorlog_format_item));\n    char *res;\n    int seen_msg_fmt = 0;\n\n    while (s && *s) {\n        ap_errorlog_format_item *item =\n            (ap_errorlog_format_item *)apr_array_push(a);\n        memset(item, 0, sizeof(*item));\n        res = parse_errorlog_item(p, item, &s);\n        if (res) {\n            *err = res;\n            return NULL;\n        }\n        if (item->flags & AP_ERRORLOG_FLAG_MESSAGE) {\n            if (!is_main_fmt) {\n                *err = \"%M cannot be used in once-per-request or \"\n                       \"once-per-connection formats\";\n                return NULL;\n            }\n            seen_msg_fmt = 1;\n        }\n        if (is_main_fmt && item->flags & AP_ERRORLOG_FLAG_REQUIRED) {\n            *err = \"The '+' flag cannot be used in the main error log format\";\n            return NULL;\n        }\n        if (!is_main_fmt && item->min_loglevel) {\n            *err = \"The loglevel cannot be used as a condition in \"\n                   \"once-per-request or once-per-connection formats\";\n            return NULL;\n        }\n        if (item->min_loglevel > APLOG_TRACE8) {\n            *err = \"The specified loglevel modifier is out of range\";\n            return NULL;\n        }\n    }\n\n    if (is_main_fmt && !seen_msg_fmt) {\n        *err = \"main ErrorLogFormat must contain message format string '%M'\";\n        return NULL;\n    }\n\n    return a;\n}\n",
        "target": 0
    },
    {
        "id": 1671,
        "func": "static int get_int_option(const char* options, const char* option_name,\n\t\tint base, int default_value)\n{\n\tconst char* p = get_option(options, option_name);\n\n\tif (p == NULL)\n\t\treturn default_value;\n\treturn strtol(p, NULL, base);\n}\n",
        "target": 0
    },
    {
        "id": 1672,
        "func": "void DeleteFont(FPDF_SYSFONTINFO*, void* font_id) {\n  long res_id = reinterpret_cast<long>(font_id);\n  pp::Module::Get()->core()->ReleaseResource(res_id);\n}\n",
        "target": 0
    },
    {
        "id": 1673,
        "func": "static toff_t TIFFSeekBlob(thandle_t image,toff_t offset,int whence)\n{\n  return((toff_t) SeekBlob((Image *) image,(MagickOffsetType) offset,whence));\n}\n",
        "target": 0
    },
    {
        "id": 1674,
        "func": "void ComponentUpdaterPolicyTest::EnabledPolicy_GroupPolicySupported() {\n  SetEnableComponentUpdates(true);\n  UpdateComponent(MakeCrxComponent(true));\n}\n",
        "target": 0
    },
    {
        "id": 1675,
        "func": "void GpuVideoDecodeAccelerator::DismissPictureBuffer(\n    int32 picture_buffer_id) {\n  if (!Send(new AcceleratedVideoDecoderHostMsg_DismissPictureBuffer(\n          host_route_id_, picture_buffer_id))) {\n    DLOG(ERROR) << \"Send(AcceleratedVideoDecoderHostMsg_DismissPictureBuffer) \"\n                << \"failed\";\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1676,
        "func": "raptor_rss_emit_connection(raptor_parser* rdf_parser,\n                           raptor_term *subject_identifier,\n                           raptor_uri* predicate_uri, int predicate_ordinal,\n                           raptor_term *object_identifier) \n{\n  raptor_rss_parser* rss_parser = (raptor_rss_parser*)rdf_parser->context;\n  raptor_uri *puri = NULL;\n  raptor_term *predicate_term = NULL;\n  \n  if(!subject_identifier) {\n    raptor_parser_error(rdf_parser, \"Connection subject has no identifier\");\n    return 1;\n  }\n\n  rss_parser->statement.subject = subject_identifier;\n\n  if(!predicate_uri) {\n    /* new URI object */\n    puri = raptor_new_uri_from_rdf_ordinal(rdf_parser->world, predicate_ordinal);\n    predicate_uri = puri;\n  }\n  predicate_term = raptor_new_term_from_uri(rdf_parser->world,\n                                            predicate_uri);\n  rss_parser->statement.predicate = predicate_term;\n  rss_parser->statement.object = object_identifier;\n  \n  /* Generate the statement */\n  (*rdf_parser->statement_handler)(rdf_parser->user_data,\n                                   &rss_parser->statement);\n\n  raptor_free_term(predicate_term);\n  \n  if(puri)\n    raptor_free_uri(puri);\n    \n  return 0;\n}",
        "target": 0
    },
    {
        "id": 1677,
        "func": "static int StreamTcpTest06 (void)\n{\n    Packet *p = SCMalloc(SIZE_OF_PACKET);\n    if (unlikely(p == NULL))\n        return 0;\n    Flow f;\n    TcpSession ssn;\n    ThreadVars tv;\n    StreamTcpThread stt;\n    TCPHdr tcph;\n    memset(p, 0, SIZE_OF_PACKET);\n    PacketQueue pq;\n    memset(&pq,0,sizeof(PacketQueue));\n    memset (&f, 0, sizeof(Flow));\n    memset(&ssn, 0, sizeof (TcpSession));\n    memset(&tv, 0, sizeof (ThreadVars));\n    memset(&stt, 0, sizeof (StreamTcpThread));\n    memset(&tcph, 0, sizeof (TCPHdr));\n    FLOW_INITIALIZE(&f);\n    p->flow = &f;\n    int ret = 0;\n\n    StreamTcpUTInit(&stt.ra_ctx);\n\n    tcph.th_flags = TH_FIN;\n    p->tcph = &tcph;\n\n    /* StreamTcpPacket returns -1 on unsolicited FIN */\n    if (StreamTcpPacket(&tv, p, &stt, &pq) != -1) {\n        printf(\"StreamTcpPacket failed: \");\n        goto end;\n    }\n\n    if (((TcpSession *)(p->flow->protoctx)) != NULL) {\n        printf(\"we have a ssn while we shouldn't: \");\n        goto end;\n    }\n\n    p->tcph->th_flags = TH_RST;\n    /* StreamTcpPacket returns -1 on unsolicited RST */\n    if (StreamTcpPacket(&tv, p, &stt, &pq) != -1) {\n        printf(\"StreamTcpPacket failed (2): \");\n        goto end;\n    }\n\n    if (((TcpSession *)(p->flow->protoctx)) != NULL) {\n        printf(\"we have a ssn while we shouldn't (2): \");\n        goto end;\n    }\n\n    ret = 1;\nend:\n    SCFree(p);\n    FLOW_DESTROY(&f);\n    StreamTcpUTDeinit(stt.ra_ctx);\n    return ret;\n}\n",
        "target": 0
    },
    {
        "id": 1678,
        "func": "OMX_ERRORTYPE omx_vdec::free_input_buffer(OMX_BUFFERHEADERTYPE *bufferHdr)\n{\n unsigned int index = 0;\n if (bufferHdr == NULL || m_inp_mem_ptr == NULL) {\n return OMX_ErrorBadParameter;\n }\n\n\n     index = bufferHdr - m_inp_mem_ptr;\n     DEBUG_PRINT_LOW(\"Free Input Buffer index = %d\",index);\n \n    auto_lock l(buf_lock);\n    bufferHdr->pInputPortPrivate = NULL;\n\n     if (index < drv_ctx.ip_buf.actualcount && drv_ctx.ptr_inputbuffer) {\n         DEBUG_PRINT_LOW(\"Free Input Buffer index = %d\",index);\n         if (drv_ctx.ptr_inputbuffer[index].pmem_fd > 0) {\n struct vdec_setbuffer_cmd setbuffers;\n            setbuffers.buffer_type = VDEC_BUFFER_TYPE_INPUT;\n            memcpy (&setbuffers.buffer,&drv_ctx.ptr_inputbuffer[index],\n sizeof (vdec_bufferpayload));\n if (!secure_mode) {\n                DEBUG_PRINT_LOW(\"unmap the input buffer fd=%d\",\n                        drv_ctx.ptr_inputbuffer[index].pmem_fd);\n                DEBUG_PRINT_LOW(\"unmap the input buffer size=%u  address = %p\",\n (unsigned int)drv_ctx.ptr_inputbuffer[index].mmaped_size,\n                        drv_ctx.ptr_inputbuffer[index].bufferaddr);\n                munmap (drv_ctx.ptr_inputbuffer[index].bufferaddr,\n                        drv_ctx.ptr_inputbuffer[index].mmaped_size);\n }\n            close (drv_ctx.ptr_inputbuffer[index].pmem_fd);\n            drv_ctx.ptr_inputbuffer[index].pmem_fd = -1;\n if (m_desc_buffer_ptr && m_desc_buffer_ptr[index].buf_addr) {\n                free(m_desc_buffer_ptr[index].buf_addr);\n                m_desc_buffer_ptr[index].buf_addr = NULL;\n                m_desc_buffer_ptr[index].desc_data_size = 0;\n }\n#ifdef USE_ION\n            free_ion_memory(&drv_ctx.ip_buf_ion_info[index]);\n#endif\n }\n }\n\n return OMX_ErrorNone;\n}\n",
        "target": 0
    },
    {
        "id": 1679,
        "func": "static void process_level0_extended_area(LHAFileHeader *header,\n                                         uint8_t *data, size_t data_len)\n{\n\t// PMarc archives can include comments that are stored in the\n\t// extended area. It is possible that this could conflict with\n\t// the logic below, so specifically exclude them.\n\n\tif (!strncmp(header->compress_method, \"-pm\", 3)) {\n\t\treturn;\n\t}\n\n\t// Different tools include different extended areas. Try to\n\t// identify which tool generated this one, based on the first\n\t// byte.\n\n\tswitch (data[0]) {\n\t\tcase LHA_OS_TYPE_UNIX:\n\t\tcase LHA_OS_TYPE_OS9_68K:\n\t\t\tprocess_level0_unix_area(header, data, data_len);\n\t\t\tbreak;\n\n\t\tcase LHA_OS_TYPE_OS9:\n\t\t\tprocess_level0_os9_area(header, data, data_len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}",
        "target": 0
    },
    {
        "id": 1680,
        "func": " void ProfileChooserView::SignOutAllWebAccounts() {\n   Hide();\n   ProfileOAuth2TokenServiceFactory::GetForProfile(browser_->profile())\n      ->RevokeAllCredentials();\n }\n",
        "target": 1
    },
    {
        "id": 1681,
        "func": "void PasswordInputType::DisableSecureTextInput() {\n  LocalFrame* frame = GetElement().GetDocument().GetFrame();\n  if (!frame)\n    return;\n  frame->Selection().SetUseSecureKeyboardEntryWhenActive(false);\n}\n",
        "target": 1
    },
    {
        "id": 1682,
        "func": "lrmd_remote_client_destroy(gpointer user_data)\n{\n    crm_client_t *client = user_data;\n\n    if (client == NULL) {\n        return;\n    }\n\n    ipc_proxy_remove_provider(client);\n\n    /* if this is the last remote connection, stop recurring\n     * operations */\n    if (crm_hash_table_size(client_connections) == 1) {\n        client_disconnect_cleanup(NULL);\n    }\n\n    crm_notice(\"LRMD client disconnecting remote client - name: %s id: %s\",\n               client->name ? client->name : \"<unknown>\", client->id);\n\n    if (client->remote->tls_session) {\n        void *sock_ptr;\n        int csock;\n\n        sock_ptr = gnutls_transport_get_ptr(*client->remote->tls_session);\n        csock = GPOINTER_TO_INT(sock_ptr);\n\n        gnutls_bye(*client->remote->tls_session, GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*client->remote->tls_session);\n        gnutls_free(client->remote->tls_session);\n        close(csock);\n    }\n\n    lrmd_client_destroy(client);\n    return;\n}",
        "target": 0
    },
    {
        "id": 1683,
        "func": "static void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_line = num;\n\tup_write(&tty->termios_rwsem);\n}",
        "target": 1
    },
    {
        "id": 1684,
        "func": "const config_section_node_t *config_section_begin(const config_t *config) {\n  assert(config != NULL);\n return (const config_section_node_t *)list_begin(config->sections);\n}\n",
        "target": 0
    },
    {
        "id": 1685,
        "func": "ZEND_API void zend_wrong_param_count(TSRMLS_D) /* {{{ */\n{\n\tconst char *space;\n\tconst char *class_name = get_active_class_name(&space TSRMLS_CC);\n\n\tzend_error(E_WARNING, \"Wrong parameter count for %s%s%s()\", class_name, space, get_active_function_name(TSRMLS_C));\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 1686,
        "func": "void SkiaOutputSurfaceImpl::BindToClient(OutputSurfaceClient* client) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  DCHECK(client);\n  DCHECK(!client_);\n  client_ = client;\n}\n",
        "target": 0
    },
    {
        "id": 1687,
        "func": "crm_ipc_destroy(crm_ipc_t * client)\n{\n    if (client) {\n        if (client->ipc && qb_ipcc_is_connected(client->ipc)) {\n            crm_notice(\"Destroying an active IPC connection to %s\", client->name);\n            /* The next line is basically unsafe\n             *\n             * If this connection was attached to mainloop and mainloop is active,\n             *   the 'disconnected' callback will end up back here and we'll end\n             *   up free'ing the memory twice - something that can still happen\n             *   even without this if we destroy a connection and it closes before\n             *   we call exit\n             */\n            /* crm_ipc_close(client); */\n        }\n        crm_trace(\"Destroying IPC connection to %s: %p\", client->name, client);\n        free(client->buffer);\n        free(client->name);\n        free(client);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1688,
        "func": "void DownloadRequestLimiter::TabDownloadState::DidFinishNavigation(\n    content::NavigationHandle* navigation_handle) {\n  if (!navigation_handle->IsInMainFrame())\n    return;\n\n   if (status_ == ALLOW_ONE_DOWNLOAD ||\n       (status_ == PROMPT_BEFORE_DOWNLOAD &&\n       !navigation_handle->IsRendererInitiated())) {\n    NotifyCallbacks(false);\n    host_->Remove(this, web_contents());\n  }\n}\n",
        "target": 1
    },
    {
        "id": 1689,
        "func": "static void __exit comedi_cleanup(void)\n{\n\tint i;\n\n\tcomedi_cleanup_legacy_minors();\n\tfor (i = 0; i < COMEDI_NUM_MINORS; ++i)\n\t\tBUG_ON(comedi_file_info_table[i]);\n\n\tclass_destroy(comedi_class);\n\tcdev_del(&comedi_cdev);\n\tunregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);\n\n\tcomedi_proc_cleanup();\n}",
        "target": 0
    },
    {
        "id": 1690,
        "func": "static void nf_ct_net_exit(struct net *net)\n{\n\tnf_ct_frags6_sysctl_unregister(net);\n\tinet_frags_exit_net(&net->nf_frag.frags, &nf_frags);\n}",
        "target": 0
    },
    {
        "id": 1691,
        "func": "GF_Err drep_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DREPBox *ptr = (GF_DREPBox *)s;\n\tptr->nbBytes = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 1692,
        "func": "enum act_return http_action_set_req_line(struct act_rule *rule, struct proxy *px,\n                                         struct session *sess, struct stream *s, int flags)\n{\n\tstruct chunk *replace;\n\tenum act_return ret = ACT_RET_ERR;\n\n\treplace = alloc_trash_chunk();\n\tif (!replace)\n\t\tgoto leave;\n\n\t/* If we have to create a query string, prepare a '?'. */\n\tif (rule->arg.http.action == 2)\n\t\treplace->str[replace->len++] = '?';\n\treplace->len += build_logline(s, replace->str + replace->len, replace->size - replace->len,\n\t                              &rule->arg.http.logfmt);\n\n\thttp_replace_req_line(rule->arg.http.action, replace->str, replace->len, px, s);\n\n\tret = ACT_RET_CONT;\n\nleave:\n\tfree_trash_chunk(replace);\n\treturn ret;\n}\n",
        "target": 0
    },
    {
        "id": 1693,
        "func": "static void pdf_run_EX(fz_context *ctx, pdf_processor *proc)\n{\n}\n",
        "target": 0
    },
    {
        "id": 1694,
        "func": "void Camera3Device::notify(const camera3_notify_msg *msg) {\n    ATRACE_CALL();\n NotificationListener *listener;\n {\n Mutex::Autolock l(mOutputLock);\n        listener = mListener;\n }\n\n if (msg == NULL) {\n        SET_ERR(\"HAL sent NULL notify message!\");\n return;\n }\n\n switch (msg->type) {\n case CAMERA3_MSG_ERROR: {\n            notifyError(msg->message.error, listener);\n break;\n }\n case CAMERA3_MSG_SHUTTER: {\n            notifyShutter(msg->message.shutter, listener);\n break;\n }\n default:\n            SET_ERR(\"Unknown notify message from HAL: %d\",\n                    msg->type);\n }\n}\n",
        "target": 0
    },
    {
        "id": 1695,
        "func": "  sfnt_done_face( TT_Face  face )\n  {\n    FT_Memory     memory;\n    SFNT_Service  sfnt;\n\n\n    if ( !face )\n      return;\n\n    memory = face->root.memory;\n    sfnt   = (SFNT_Service)face->sfnt;\n\n    if ( sfnt )\n    {\n      /* destroy the postscript names table if it is loaded */\n      if ( sfnt->free_psnames )\n        sfnt->free_psnames( face );\n\n      /* destroy the embedded bitmaps table if it is loaded */\n      if ( sfnt->free_eblc )\n        sfnt->free_eblc( face );\n    }\n\n#ifdef TT_CONFIG_OPTION_BDF\n    /* freeing the embedded BDF properties */\n    tt_face_free_bdf_props( face );\n#endif\n\n    /* freeing the kerning table */\n    tt_face_done_kern( face );\n\n    /* freeing the collection table */\n    FT_FREE( face->ttc_header.offsets );\n    face->ttc_header.count = 0;\n\n    /* freeing table directory */\n    FT_FREE( face->dir_tables );\n    face->num_tables = 0;\n\n    {\n      FT_Stream  stream = FT_FACE_STREAM( face );\n\n\n      /* simply release the 'cmap' table frame */\n      FT_FRAME_RELEASE( face->cmap_table );\n      face->cmap_size = 0;\n    }\n\n    face->horz_metrics_size = 0;\n    face->vert_metrics_size = 0;\n\n    /* freeing vertical metrics, if any */\n    if ( face->vertical_info )\n    {\n      FT_FREE( face->vertical.long_metrics  );\n      FT_FREE( face->vertical.short_metrics );\n      face->vertical_info = 0;\n    }\n\n    /* freeing the gasp table */\n    FT_FREE( face->gasp.gaspRanges );\n    face->gasp.numRanges = 0;\n\n    /* freeing the name table */\n    if ( sfnt )\n      sfnt->free_name( face );\n\n    /* freeing family and style name */\n    FT_FREE( face->root.family_name );\n    FT_FREE( face->root.style_name );\n\n    /* freeing sbit size table */\n    FT_FREE( face->root.available_sizes );\n    FT_FREE( face->sbit_strike_map );\n    face->root.num_fixed_sizes = 0;\n\n    FT_FREE( face->postscript_name );\n\n    face->sfnt = NULL;\n  }\n",
        "target": 0
    },
    {
        "id": 1696,
        "func": "static int labbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)\n{\n    os_ptr op;\n    int i, components=1;\n\n    components = 3;\n    pop(components);\n    op = osp;\n    components = 3;\n    push(components);\n    op -= components-1;\n    for (i=0;i<components;i++) {\n        make_real(op, (float)0);\n        op++;\n    }\n    *stage = 0;\n    *cont = 0;\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 1697,
        "func": " void ExtensionHelper::InlineWebstoreInstall(\n    int install_id, std::string webstore_item_id, GURL requestor_url) {\n   Send(new ExtensionHostMsg_InlineWebstoreInstall(\n       routing_id(), install_id, webstore_item_id, requestor_url));\n }\n",
        "target": 1
    },
    {
        "id": 1698,
        "func": "static struct blkcg_gq *blkg_alloc(struct blkcg *blkcg, struct request_queue *q,\n\t\t\t\t   gfp_t gfp_mask)\n{\n\tstruct blkcg_gq *blkg;\n\tint i;\n\n\t/* alloc and init base part */\n\tblkg = kzalloc_node(sizeof(*blkg), gfp_mask, q->node);\n\tif (!blkg)\n\t\treturn NULL;\n\n\tif (blkg_rwstat_init(&blkg->stat_bytes, gfp_mask) ||\n\t    blkg_rwstat_init(&blkg->stat_ios, gfp_mask))\n\t\tgoto err_free;\n\n\tblkg->q = q;\n\tINIT_LIST_HEAD(&blkg->q_node);\n\tblkg->blkcg = blkcg;\n\tatomic_set(&blkg->refcnt, 1);\n\n\t/* root blkg uses @q->root_rl, init rl only for !root blkgs */\n\tif (blkcg != &blkcg_root) {\n\t\tif (blk_init_rl(&blkg->rl, q, gfp_mask))\n\t\t\tgoto err_free;\n\t\tblkg->rl.blkg = blkg;\n\t}\n\n\tfor (i = 0; i < BLKCG_MAX_POLS; i++) {\n\t\tstruct blkcg_policy *pol = blkcg_policy[i];\n\t\tstruct blkg_policy_data *pd;\n\n\t\tif (!blkcg_policy_enabled(q, pol))\n\t\t\tcontinue;\n\n\t\t/* alloc per-policy data and attach it to blkg */\n\t\tpd = pol->pd_alloc_fn(gfp_mask, q->node);\n\t\tif (!pd)\n\t\t\tgoto err_free;\n\n\t\tblkg->pd[i] = pd;\n\t\tpd->blkg = blkg;\n\t\tpd->plid = i;\n\t}\n\n\treturn blkg;\n\nerr_free:\n\tblkg_free(blkg);\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 1699,
        "func": "insert_hIST(png_structp png_ptr, png_infop info_ptr, int nparams, png_charpp params)\n {\n    int i;\n    png_uint_16 freq[256];\n\n /* libpng takes the count from the PLTE count; we don't check it here but we\n    * do set the array to 0 for unspecified entries.\n    */\n   memset(freq, 0, sizeof freq);\n for (i=0; i<nparams; ++i)\n {\n char *endptr = NULL;\n unsigned long int l = strtoul(params[i], &endptr, 0/*base*/);\n\n if (params[i][0] && *endptr == 0 && l <= 65535)\n         freq[i] = (png_uint_16)l;\n\n else\n {\n         fprintf(stderr, \"hIST[%d]: %s: invalid frequency\\n\", i, params[i]);\n         exit(1);\n }\n }\n\n\n    png_set_hIST(png_ptr, info_ptr, freq);\n }\n",
        "target": 1
    },
    {
        "id": 1700,
        "func": "bool PrintWebViewHelper::InitPrintSettings(WebKit::WebFrame* frame,\n                                           WebKit::WebNode* node,\n                                           bool is_preview) {\n   DCHECK(frame);\n   PrintMsg_PrintPages_Params settings;\n \n  Send(new PrintHostMsg_GetDefaultPrintSettings(routing_id(),\n                                                &settings.params));\n   bool result = true;\n   if (PrintMsg_Print_Params_IsEmpty(settings.params)) {\n    if (!is_preview) {\n      render_view()->runModalAlertDialog(\n          frame,\n          l10n_util::GetStringUTF16(\n              IDS_PRINT_PREVIEW_INVALID_PRINTER_SETTINGS));\n    }\n     result = false;\n   }\n \n  if (result &&\n      (settings.params.dpi < kMinDpi || settings.params.document_cookie == 0)) {\n    NOTREACHED();\n    result = false;\n  }\n\n  settings.pages.clear();\n  print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));\n  return result;\n}\n",
        "target": 1
    },
    {
        "id": 1701,
        "func": "void InterstitialPage::FocusThroughTabTraversal(bool reverse) {\n  render_view_host_->SetInitialFocus(reverse);\n}\n",
        "target": 0
    },
    {
        "id": 1702,
        "func": "PHP_FUNCTION(mcrypt_enc_get_modes_name)\n{\n\tchar *name;\n\tMCRYPT_GET_TD_ARG\n\n\tname = mcrypt_enc_get_modes_name(pm->td);\n\tRETVAL_STRING(name, 1);\n\tmcrypt_free(name);\n}\n",
        "target": 0
    },
    {
        "id": 1703,
        "func": "ExtensionService* ExtensionSystemImpl::extension_service() {\n  return shared_->extension_service();\n}\n",
        "target": 0
    },
    {
        "id": 1704,
        "func": "static bt_status_t init(btrc_callbacks_t* callbacks )\n{\n    BTIF_TRACE_EVENT(\"## %s ##\", __FUNCTION__);\n bt_status_t result = BT_STATUS_SUCCESS;\n\n if (bt_rc_callbacks)\n return BT_STATUS_DONE;\n\n    bt_rc_callbacks = callbacks;\n    memset (&btif_rc_cb, 0, sizeof(btif_rc_cb));\n    btif_rc_cb.rc_vol_label=MAX_LABEL;\n    btif_rc_cb.rc_volume=MAX_VOLUME;\n    lbl_init();\n\n return result;\n}\n",
        "target": 0
    },
    {
        "id": 1705,
        "func": " AudioRendererHost::AudioRendererHost(int render_process_id,\n                                      media::AudioManager* audio_manager,\n                                      AudioMirroringManager* mirroring_manager,\n                                      MediaStreamManager* media_stream_manager,\n                                      const std::string& salt)\n    : BrowserMessageFilter(AudioMsgStart),\n      render_process_id_(render_process_id),\n      audio_manager_(audio_manager),\n      mirroring_manager_(mirroring_manager),\n       media_stream_manager_(media_stream_manager),\n       salt_(salt),\n       validate_render_frame_id_function_(&ValidateRenderFrameId),\n      authorization_handler_(audio_manager_,\n                              media_stream_manager,\n                              render_process_id_,\n                              salt) {\n  DCHECK(audio_manager_);\n}\n",
        "target": 1
    },
    {
        "id": 1706,
        "func": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\t/*\n\t\t * In autoclear mode, stop the loop thread\n\t\t * and remove configuration after last close.\n\t\t */\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\t/*\n\t\t * Otherwise keep thread (if running) and config,\n\t\t * but flush possible ongoing bios in thread.\n\t\t */\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}",
        "target": 1
    },
    {
        "id": 1707,
        "func": "static void nfs4_reclaim_complete_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\tstruct nfs4_sequence_res *res = &calldata->res.seq_res;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!nfs41_sequence_done(task, res))\n\t\treturn;\n\n\tif (nfs41_reclaim_complete_handle_errors(task, clp) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}",
        "target": 0
    },
    {
        "id": 1708,
        "func": "  void Observe(int type,\n      const NotificationSource& source,\n      const NotificationDetails& details) {\n    switch (type) {\n      case chrome::NOTIFICATION_FOREIGN_SESSION_UPDATED:\n        notified_of_update_ = true;\n        break;\n      default:\n        NOTREACHED();\n        break;\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 1709,
        "func": "void LayerTreeHost::SetNextCommitWaitsForActivation() {\n  proxy_->SetNextCommitWaitsForActivation();\n}\n",
        "target": 0
    },
    {
        "id": 1710,
        "func": "int netif_set_real_num_rx_queues(struct net_device *dev, unsigned int rxq)\n{\n\tint rc;\n\n\tif (rxq < 1 || rxq > dev->num_rx_queues)\n\t\treturn -EINVAL;\n\n\tif (dev->reg_state == NETREG_REGISTERED) {\n\t\tASSERT_RTNL();\n\n\t\trc = net_rx_queue_update_kobjects(dev, dev->real_num_rx_queues,\n\t\t\t\t\t\t  rxq);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tdev->real_num_rx_queues = rxq;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1711,
        "func": "PHP_FUNCTION(openssl_get_cert_locations)\n{\n\tarray_init(return_value);\n\n\tadd_assoc_string(return_value, \"default_cert_file\", (char *) X509_get_default_cert_file(), 1);\n\tadd_assoc_string(return_value, \"default_cert_file_env\", (char *) X509_get_default_cert_file_env(), 1);\n\tadd_assoc_string(return_value, \"default_cert_dir\", (char *) X509_get_default_cert_dir(), 1);\n\tadd_assoc_string(return_value, \"default_cert_dir_env\", (char *) X509_get_default_cert_dir_env(), 1);\n\tadd_assoc_string(return_value, \"default_private_dir\", (char *) X509_get_default_private_dir(), 1);\n\tadd_assoc_string(return_value, \"default_default_cert_area\", (char *) X509_get_default_cert_area(), 1);\n\tadd_assoc_string(return_value, \"ini_cafile\",\n\t\tzend_ini_string(\"openssl.cafile\", sizeof(\"openssl.cafile\"), 0), 1);\n\tadd_assoc_string(return_value, \"ini_capath\",\n\t\tzend_ini_string(\"openssl.capath\", sizeof(\"openssl.capath\"), 0), 1);\n}\n",
        "target": 0
    },
    {
        "id": 1712,
        "func": "png_set_write_status_fn(png_structp png_ptr, png_write_status_ptr write_row_fn)\n{\n   if (png_ptr == NULL)\n      return;\n   png_ptr->write_row_fn = write_row_fn;\n}\n",
        "target": 0
    },
    {
        "id": 1713,
        "func": "void preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);\n\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}",
        "target": 0
    },
    {
        "id": 1714,
        "func": "void V8TestObject::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute_Getter\");\n\n  test_object_v8_internal::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetterForMainWorld(info);\n}\n",
        "target": 0
    },
    {
        "id": 1715,
        "func": "void GLES2DecoderImpl::ForceCompileShaderIfPending(\n    ShaderManager::ShaderInfo* info) {\n  if (info->compilation_status() ==\n      ShaderManager::ShaderInfo::PENDING_DEFERRED_COMPILE) {\n\n    ShaderTranslator* translator = NULL;\n    if (use_shader_translator_) {\n      translator = info->shader_type() == GL_VERTEX_SHADER ?\n          vertex_translator_.get() : fragment_translator_.get();\n    }\n    program_manager()->ForceCompileShader(info->deferred_compilation_source(),\n                                          info,\n                                          translator,\n                                          feature_info_);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1716,
        "func": "int FS_Write( const void *buffer, int len, fileHandle_t h ) {\n\tint block, remaining;\n\tint written;\n\tbyte    *buf;\n\tint tries;\n\tFILE    *f;\n\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\" );\n\t}\n\n\tif ( !h ) {\n\t\treturn 0;\n\t}\n\n\tf = FS_FileForHandle( h );\n\tbuf = (byte *)buffer;\n\n\tremaining = len;\n\ttries = 0;\n\twhile ( remaining ) {\n\t\tblock = remaining;\n\t\twritten = fwrite( buf, 1, block, f );\n\t\tif ( written == 0 ) {\n\t\t\tif ( !tries ) {\n\t\t\t\ttries = 1;\n\t\t\t} else {\n\t\t\t\tCom_Printf( \"FS_Write: 0 bytes written\\n\" );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif ( written == -1 ) {\n\t\t\tCom_Printf( \"FS_Write: -1 bytes written\\n\" );\n\t\t\treturn 0;\n\t\t}\n\n\t\tremaining -= written;\n\t\tbuf += written;\n\t}\n\tif ( fsh[h].handleSync ) {\n\t\tfflush( f );\n\t}\n\treturn len;\n}\n",
        "target": 0
    },
    {
        "id": 1717,
        "func": "  InputMethodStatusConnection()\n      : current_input_method_changed_(NULL),\n        register_ime_properties_(NULL),\n        update_ime_property_(NULL),\n        connection_change_handler_(NULL),\n        language_library_(NULL),\n        ibus_(NULL),\n         ibus_config_(NULL) {\n   }\n",
        "target": 1
    },
    {
        "id": 1718,
        "func": " void ManifestChangeNotifier::DidChangeManifest() {\n   if (weak_factory_.HasWeakPtrs())\n     return;\n \n  if (!render_frame()->GetWebFrame()->IsLoading()) {\n    render_frame()\n        ->GetTaskRunner(blink::TaskType::kUnspecedLoading)\n        ->PostTask(FROM_HERE,\n                   base::BindOnce(&ManifestChangeNotifier::ReportManifestChange,\n                                  weak_factory_.GetWeakPtr()));\n    return;\n  }\n  ReportManifestChange();\n}\n",
        "target": 1
    },
    {
        "id": 1719,
        "func": " void HTMLMediaElement::ChangeNetworkStateFromLoadingToIdle() {\n   progress_event_timer_.Stop();\n \n  if (GetWebMediaPlayer() && GetWebMediaPlayer()->DidLoadingProgress())\n    ScheduleEvent(EventTypeNames::progress);\n  ScheduleEvent(EventTypeNames::suspend);\n  SetNetworkState(kNetworkIdle);\n }\n",
        "target": 1
    },
    {
        "id": 1720,
        "func": "AuthenticatorBleEnterPairingModeSheetModel::GetStepIllustration(\n    ImageColorScheme color_scheme) const {\n  return color_scheme == ImageColorScheme::kDark ? kWebauthnBleDarkIcon\n                                                 : kWebauthnBleIcon;\n}\n",
        "target": 0
    },
    {
        "id": 1721,
        "func": "static NPError g_NPP_New(NPMIMEType plugin_type, uint32_t instance_id,\n\t\t\t\t\t\t uint16_t mode, int16_t argc, char *argn[], char *argv[],\n\t\t\t\t\t\t NPSavedData *saved)\n{\n  PluginInstance *plugin = npw_plugin_instance_new(&PluginInstanceClass);\n  if (plugin == NULL)\n\treturn NPERR_OUT_OF_MEMORY_ERROR;\n  plugin->instance_id = instance_id;\n  id_link(instance_id, plugin);\n\n  NPP instance = malloc(sizeof(*instance));\n  if (instance == NULL)\n\treturn NPERR_OUT_OF_MEMORY_ERROR;\n  memset(instance, 0, sizeof(*instance));\n  instance->ndata = plugin;\n  plugin->instance = instance;\n\n  // check for size hints\n  for (int i = 0; i < argc; i++) {\n\tif (argn[i] == NULL)\n\t  continue;\n\tif (strcasecmp(argn[i], \"width\") == 0) {\n\t  if (i < argc && argv[i])\n\t\tplugin->width = atoi(argv[i]);\n\t}\n\telse if (strcasecmp(argn[i], \"height\") == 0) {\n\t  if (i < argc && argv[i])\n\t\tplugin->height = atoi(argv[i]);\n\t}\n  }\n\n  D(bugiI(\"NPP_New instance=%p\\n\", instance));\n  NPError ret = plugin_funcs.newp(plugin_type, instance, mode, argc, argn, argv, saved);\n  D(bugiD(\"NPP_New return: %d [%s]\\n\", ret, string_of_NPError(ret)));\n\n  // check if XEMBED is to be used\n  long supports_XEmbed = FALSE;\n  if (mozilla_funcs.getvalue) {\n\t// Even though NPAPI kindly provides an NPBool typedef,\n\t// NPNVSupportsXEmbedBool is documented to be a 4-byte PRBool. And\n\t// Flash treats it as such.\n\tNPError error = mozilla_funcs.getvalue(NULL, NPNVSupportsXEmbedBool, (void *)&supports_XEmbed);\n\tif (error == NPERR_NO_ERROR && plugin_funcs.getvalue) {\n\t  long needs_XEmbed = FALSE;\n\t  error = plugin_funcs.getvalue(instance, NPPVpluginNeedsXEmbed, (void *)&needs_XEmbed);\n\t  if (error == NPERR_NO_ERROR)\n\t\tplugin->use_xembed = supports_XEmbed && needs_XEmbed;\n\t}\n  }\n\n  // assume Gtk plugin (no Xt event loop) if XEMBED is used\n  if (!plugin->use_xembed) {\n\tif (xt_source_create() < 0)\n\t  return NPERR_GENERIC_ERROR;\n  }\n\n  return ret;\n}",
        "target": 0
    },
    {
        "id": 1722,
        "func": "static v8::Handle<v8::Value> methodWithSequenceArgCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodWithSequenceArg\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(sequence<ScriptProfile>*, sequenceArg, toNativeArray<ScriptProfile>(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     imp->methodWithSequenceArg(sequenceArg);\n    return v8::Handle<v8::Value>();\n}\n",
        "target": 1
    },
    {
        "id": 1723,
        "func": "static int handle_xsaves(struct kvm_vcpu *vcpu)\n{\n\tkvm_skip_emulated_instruction(vcpu);\n\tWARN(1, \"this should never happen\\n\");\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 1724,
        "func": "image_transform_png_set_strip_alpha_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n       that->colour_type = PNG_COLOR_TYPE_GRAY;\n else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)\n      that->colour_type = PNG_COLOR_TYPE_RGB;\n\n   that->have_tRNS = 0;\n   that->alphaf = 1;\n\n this->next->mod(this->next, that, pp, display);\n}\n",
        "target": 1
    },
    {
        "id": 1725,
        "func": "int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\t__ceph_setattr(inode, &newattrs);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tceph_set_cached_acl(inode, type, acl);\n\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 1726,
        "func": "void RenderBox::updateGridPositionAfterStyleChange(const RenderStyle* oldStyle)\n{\n    if (!oldStyle || !parent() || !parent()->isRenderGrid())\n        return;\n\n    if (oldStyle->gridColumnStart() == style()->gridColumnStart()\n        && oldStyle->gridColumnEnd() == style()->gridColumnEnd()\n        && oldStyle->gridRowStart() == style()->gridRowStart()\n        && oldStyle->gridRowEnd() == style()->gridRowEnd()\n        && oldStyle->order() == style()->order()\n        && oldStyle->hasOutOfFlowPosition() == style()->hasOutOfFlowPosition())\n        return;\n\n    toRenderGrid(parent())->dirtyGrid();\n}\n",
        "target": 0
    },
    {
        "id": 1727,
        "func": "FileSystemOperation::TaskParamsForDidGetQuota::~TaskParamsForDidGetQuota() {}\n",
        "target": 0
    },
    {
        "id": 1728,
        "func": "void RendererSchedulerImpl::UnregisterTimeDomain(TimeDomain* time_domain) {\n  helper_.UnregisterTimeDomain(time_domain);\n}\n",
        "target": 0
    },
    {
        "id": 1729,
        "func": "int ocfs2_update_inode_atime(struct inode *inode,\n\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) bh->b_data;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Don't use ocfs2_mark_inode_dirty() here as we don't always\n\t * have i_mutex to guard against concurrent changes to other\n\t * inode fields.\n\t */\n\tinode->i_atime = current_time(inode);\n\tdi->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tdi->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_journal_dirty(handle, bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1730,
        "func": "static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatPoint* points)\n{\n    path->incReserve(numPoints);\n    path->moveTo(WebCoreFloatToSkScalar(points[0].x()),\n                 WebCoreFloatToSkScalar(points[0].y()));\n    for (size_t i = 1; i < numPoints; ++i) {\n         path->lineTo(WebCoreFloatToSkScalar(points[i].x()),\n                      WebCoreFloatToSkScalar(points[i].y()));\n     }\n    path->setIsConvex(true);\n }\n",
        "target": 1
    },
    {
        "id": 1731,
        "func": "static void ptrace_siblings(pid_t pid, pid_t main_tid, std::set<pid_t>& tids) {\n  char task_path[64];\n//// Attach to a thread, and verify that it's still a member of the given process\n \n  snprintf(task_path, sizeof(task_path), \"/proc/%d/task\", pid);\n \n   std::unique_ptr<DIR, int (*)(DIR*)> d(opendir(task_path), closedir);\n \n if (!d) {\n    ALOGE(\"debuggerd: failed to open /proc/%d/task: %s\", pid, strerror(errno));\n return;\n }\n\n struct dirent* de;\n while ((de = readdir(d.get())) != NULL) {\n if (!strcmp(de->d_name, \".\") || !strcmp(de->d_name, \"..\")) {\n continue;\n }\n\n char* end;\n pid_t tid = strtoul(de->d_name, &end, 10);\n if (*end) {\n continue;\n }\n\n if (tid == main_tid) {\n\n       continue;\n     }\n \n    if (ptrace(PTRACE_ATTACH, tid, 0, 0) < 0) {\n       ALOGE(\"debuggerd: ptrace attach to %d failed: %s\", tid, strerror(errno));\n       continue;\n     }\n\n    tids.insert(tid);\n }\n}\n",
        "target": 1
    },
    {
        "id": 1732,
        "func": "static void reflectedCustomURLAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;\n    TestObjectV8Internal::reflectedCustomURLAttrAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 1733,
        "func": "static void init_reg_state(struct bpf_verifier_env *env,\n\t\t\t   struct bpf_func_state *state)\n{\n\tstruct bpf_reg_state *regs = state->regs;\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tmark_reg_not_init(env, regs, i);\n\t\tregs[i].live = REG_LIVE_NONE;\n\t\tregs[i].parent = NULL;\n\t}\n\n\t/* frame pointer */\n\tregs[BPF_REG_FP].type = PTR_TO_STACK;\n\tmark_reg_known_zero(env, regs, BPF_REG_FP);\n\tregs[BPF_REG_FP].frameno = state->frameno;\n\n\t/* 1st arg to a function */\n\tregs[BPF_REG_1].type = PTR_TO_CTX;\n\tmark_reg_known_zero(env, regs, BPF_REG_1);\n}",
        "target": 0
    },
    {
        "id": 1734,
        "func": "static void ssl_update_checksum_sha384( ssl_context *ssl, unsigned char *buf,\n                                        size_t len )\n{\n    sha4_update( &ssl->handshake->fin_sha4, buf, len );\n}",
        "target": 0
    },
    {
        "id": 1735,
        "func": "pch_name (enum nametype type)\n{\n  return type == NONE ? NULL : p_name[type];\n}\n",
        "target": 0
    },
    {
        "id": 1736,
        "func": "static int netlink_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t      char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tint len, val, err;\n\n\tif (level != SOL_NETLINK)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase NETLINK_PKTINFO:\n\t\tif (len < sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof(int);\n\t\tval = nlk->flags & NETLINK_F_RECV_PKTINFO ? 1 : 0;\n\t\tif (put_user(len, optlen) ||\n\t\t    put_user(val, optval))\n\t\t\treturn -EFAULT;\n\t\terr = 0;\n\t\tbreak;\n\tcase NETLINK_BROADCAST_ERROR:\n\t\tif (len < sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof(int);\n\t\tval = nlk->flags & NETLINK_F_BROADCAST_SEND_ERROR ? 1 : 0;\n\t\tif (put_user(len, optlen) ||\n\t\t    put_user(val, optval))\n\t\t\treturn -EFAULT;\n\t\terr = 0;\n\t\tbreak;\n\tcase NETLINK_NO_ENOBUFS:\n\t\tif (len < sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof(int);\n\t\tval = nlk->flags & NETLINK_F_RECV_NO_ENOBUFS ? 1 : 0;\n\t\tif (put_user(len, optlen) ||\n\t\t    put_user(val, optval))\n\t\t\treturn -EFAULT;\n\t\terr = 0;\n\t\tbreak;\n\tcase NETLINK_LIST_MEMBERSHIPS: {\n\t\tint pos, idx, shift;\n\n\t\terr = 0;\n\t\tnetlink_lock_table();\n\t\tfor (pos = 0; pos * 8 < nlk->ngroups; pos += sizeof(u32)) {\n\t\t\tif (len - pos < sizeof(u32))\n\t\t\t\tbreak;\n\n\t\t\tidx = pos / sizeof(unsigned long);\n\t\t\tshift = (pos % sizeof(unsigned long)) * 8;\n\t\t\tif (put_user((u32)(nlk->groups[idx] >> shift),\n\t\t\t\t     (u32 __user *)(optval + pos))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (put_user(ALIGN(nlk->ngroups / 8, sizeof(u32)), optlen))\n\t\t\terr = -EFAULT;\n\t\tnetlink_unlock_table();\n\t\tbreak;\n\t}\n\tcase NETLINK_CAP_ACK:\n\t\tif (len < sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tlen = sizeof(int);\n\t\tval = nlk->flags & NETLINK_F_CAP_ACK ? 1 : 0;\n\t\tif (put_user(len, optlen) ||\n\t\t    put_user(val, optval))\n\t\t\treturn -EFAULT;\n\t\terr = 0;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 1737,
        "func": "void CrosLibrary::TestApi::SetSystemLibrary(\n    SystemLibrary* library, bool own) {\n  library_->system_lib_.SetImpl(library, own);\n}\n",
        "target": 1
    },
    {
        "id": 1738,
        "func": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert1(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     a* (toa(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->convert1();\n    return JSValue::encode(jsUndefined());\n}\n",
        "target": 1
    },
    {
        "id": 1739,
        "func": "static int sctp_getsockopt_adaptation_layer(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sctp_setadaptation adaptation;\n\n\tif (len != sizeof(struct sctp_setadaptation))\n\t\treturn -EINVAL;\n\n\tadaptation.ssb_adaptation_ind = sctp_sk(sk)->adaptation_ind;\n\tif (copy_to_user(optval, &adaptation, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1740,
        "func": "static int wait_for_fpga_config(void)\n{\n\tint ret = 0, done;\n\t/* approx 5 s */\n\tu32 timeout = 500000;\n \n \tprintf(\"PCIe FPGA config:\");\n \tdo {\n\t\tdone = qrio_get_gpio(GPIO_A, FPGA_DONE);\n \t\tif (timeout-- == 0) {\n \t\t\tprintf(\" FPGA_DONE timeout\\n\");\n \t\t\tret = -EFAULT;\n\t\t\tgoto err_out;\n\t\t}\n\t\tudelay(10);\n\t} while (!done);\n\n\tprintf(\" done\\n\");\n \n err_out:\n \t/* deactive CONF_SEL and give the CPU conf EEPROM access */\n\tqrio_set_gpio(GPIO_A, CONF_SEL_L, 1);\n \ttoggle_fpga_eeprom_bus(true);\n \n \treturn ret;\n}\n",
        "target": 1
    },
    {
        "id": 1741,
        "func": "const uint8_t *smb1cli_conn_server_challenge(struct smbXcli_conn *conn)\n{\n\treturn conn->smb1.server.challenge;\n}\n",
        "target": 0
    },
    {
        "id": 1742,
        "func": "ssize_t NuMediaExtractor::fetchTrackSamples(\n int64_t seekTimeUs, MediaSource::ReadOptions::SeekMode mode) {\n TrackInfo *minInfo = NULL;\n ssize_t minIndex = -1;\n\n for (size_t i = 0; i < mSelectedTracks.size(); ++i) {\n TrackInfo *info = &mSelectedTracks.editItemAt(i);\n\n if (seekTimeUs >= 0ll) {\n            info->mFinalResult = OK;\n\n if (info->mSample != NULL) {\n                info->mSample->release();\n                info->mSample = NULL;\n                info->mSampleTimeUs = -1ll;\n }\n } else if (info->mFinalResult != OK) {\n continue;\n }\n\n if (info->mSample == NULL) {\n MediaSource::ReadOptions options;\n if (seekTimeUs >= 0ll) {\n                options.setSeekTo(seekTimeUs, mode);\n }\n status_t err = info->mSource->read(&info->mSample, &options);\n\n if (err != OK) {\n                CHECK(info->mSample == NULL);\n\n                info->mFinalResult = err;\n\n if (info->mFinalResult != ERROR_END_OF_STREAM) {\n                    ALOGW(\"read on track %zu failed with error %d\",\n                          info->mTrackIndex, err);\n }\n\n                info->mSampleTimeUs = -1ll;\n continue;\n } else {\n                CHECK(info->mSample != NULL);\n                CHECK(info->mSample->meta_data()->findInt64(\n                            kKeyTime, &info->mSampleTimeUs));\n }\n }\n\n if (minInfo == NULL  || info->mSampleTimeUs < minInfo->mSampleTimeUs) {\n            minInfo = info;\n            minIndex = i;\n }\n }\n\n return minIndex;\n}\n",
        "target": 0
    },
    {
        "id": 1743,
        "func": "handle_from_string(const u_char *handle, u_int hlen)\n{\n\tint val;\n\n\tif (hlen != sizeof(int32_t))\n\t\treturn -1;\n\tval = get_u32(handle);\n\tif (handle_is_ok(val, HANDLE_FILE) ||\n\t    handle_is_ok(val, HANDLE_DIR))\n\t\treturn val;\n\treturn -1;\n}",
        "target": 0
    },
    {
        "id": 1744,
        "func": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n \n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}\n",
        "target": 1
    },
    {
        "id": 1745,
        "func": "void AutomationProviderImportSettingsObserver::ImportStarted() {\n}\n",
        "target": 0
    },
    {
        "id": 1746,
        "func": "static int cxusb_probe(struct usb_interface *intf,\n\t\t       const struct usb_device_id *id)\n{\n\tif (0 == dvb_usb_device_init(intf, &cxusb_medion_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_lgh064f_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_dee1601_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_lgz201_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_dtt7579_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_dualdig4_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_bluebird_nano2_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf,\n\t\t\t\t&cxusb_bluebird_nano2_needsfirmware_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_aver_a868r_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf,\n\t\t\t\t     &cxusb_bluebird_dualdig4_rev2_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_d680_dmb_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_mygica_d689_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0 == dvb_usb_device_init(intf, &cxusb_mygica_t230_properties,\n\t\t\t\t     THIS_MODULE, NULL, adapter_nr) ||\n\t    0)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}",
        "target": 0
    },
    {
        "id": 1747,
        "func": "static long cap_prctl_drop(struct cred *new, unsigned long cap)\n{\n\tif (!capable(CAP_SETPCAP))\n\t\treturn -EPERM;\n\tif (!cap_valid(cap))\n\t\treturn -EINVAL;\n\n\tcap_lower(new->cap_bset, cap);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1748,
        "func": "static void iwbmp_set_default_bitfields(struct iwbmprcontext *rctx)\n{\n\tint k;\n\n\tif(rctx->bitfields_set) return;\n\n\tif(rctx->bitcount==16) {\n\t\t// Default is 5 bits for each channel.\n\t\trctx->bf_mask[0]=0x7c00; // 01111100 00000000 (red)\n\t\trctx->bf_mask[1]=0x03e0; // 00000011 11100000 (green)\n\t\trctx->bf_mask[2]=0x001f; // 00000000 00011111 (blue)\n\t}\n\telse if(rctx->bitcount==32) {\n\t\trctx->bf_mask[0]=0x00ff0000;\n\t\trctx->bf_mask[1]=0x0000ff00;\n\t\trctx->bf_mask[2]=0x000000ff;\n\t}\n\telse {\n\t\treturn;\n\t}\n\n\tfor(k=0;k<3;k++) {\n\t\tprocess_bf_mask(rctx,k);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1749,
        "func": "void do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tif (test_thread_flag(TIF_SYSCALL_TRACE)\n\t\t\t&& (current->ptrace & PT_PTRACED))\n\t\tdo_syscall_trace();\n\n#if 0\n\tif (unlikely(current->audit_context))\n\t\taudit_syscall_entry(current, AUDIT_ARCH_XTENSA..);\n#endif\n}",
        "target": 0
    },
    {
        "id": 1750,
        "func": "CaptivePortalDetector::~CaptivePortalDetector() {\n}\n",
        "target": 0
    },
    {
        "id": 1751,
        "func": "static netdev_tx_t atl2_xmit_frame(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *netdev)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct tx_pkt_header *txph;\n\tu32 offset, copy_len;\n\tint txs_unused;\n\tint txbuf_unused;\n\n\tif (test_bit(__ATL2_DOWN, &adapter->flags)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (unlikely(skb->len <= 0)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\ttxs_unused = TxsFreeUnit(adapter);\n\ttxbuf_unused = TxdFreeBytes(adapter);\n\n\tif (skb->len + sizeof(struct tx_pkt_header) + 4  > txbuf_unused ||\n\t\ttxs_unused < 1) {\n\t\t/* not enough resources */\n\t\tnetif_stop_queue(netdev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\toffset = adapter->txd_write_ptr;\n\n\ttxph = (struct tx_pkt_header *) (((u8 *)adapter->txd_ring) + offset);\n\n\t*(u32 *)txph = 0;\n\ttxph->pkt_size = skb->len;\n\n\toffset += 4;\n\tif (offset >= adapter->txd_ring_size)\n\t\toffset -= adapter->txd_ring_size;\n\tcopy_len = adapter->txd_ring_size - offset;\n\tif (copy_len >= skb->len) {\n\t\tmemcpy(((u8 *)adapter->txd_ring) + offset, skb->data, skb->len);\n\t\toffset += ((u32)(skb->len + 3) & ~3);\n\t} else {\n\t\tmemcpy(((u8 *)adapter->txd_ring)+offset, skb->data, copy_len);\n\t\tmemcpy((u8 *)adapter->txd_ring, skb->data+copy_len,\n\t\t\tskb->len-copy_len);\n\t\toffset = ((u32)(skb->len-copy_len + 3) & ~3);\n\t}\n#ifdef NETIF_F_HW_VLAN_CTAG_TX\n\tif (skb_vlan_tag_present(skb)) {\n\t\tu16 vlan_tag = skb_vlan_tag_get(skb);\n\t\tvlan_tag = (vlan_tag << 4) |\n\t\t\t(vlan_tag >> 13) |\n\t\t\t((vlan_tag >> 9) & 0x8);\n\t\ttxph->ins_vlan = 1;\n\t\ttxph->vlan = vlan_tag;\n\t}\n#endif\n\tif (offset >= adapter->txd_ring_size)\n\t\toffset -= adapter->txd_ring_size;\n\tadapter->txd_write_ptr = offset;\n\n\t/* clear txs before send */\n\tadapter->txs_ring[adapter->txs_next_clear].update = 0;\n\tif (++adapter->txs_next_clear == adapter->txs_ring_size)\n\t\tadapter->txs_next_clear = 0;\n\n\tATL2_WRITE_REGW(&adapter->hw, REG_MB_TXD_WR_IDX,\n\t\t(adapter->txd_write_ptr >> 2));\n\n\tmmiowb();\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}",
        "target": 0
    },
    {
        "id": 1752,
        "func": "static int kvm_assign_ioeventfd_idx(struct kvm *kvm,\n\t\t\t\tenum kvm_bus bus_idx,\n\t\t\t\tstruct kvm_ioeventfd *args)\n{\n\n\tstruct eventfd_ctx *eventfd;\n\tstruct _ioeventfd *p;\n\tint ret;\n\n\teventfd = eventfd_ctx_fdget(args->fd);\n\tif (IS_ERR(eventfd))\n\t\treturn PTR_ERR(eventfd);\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tINIT_LIST_HEAD(&p->list);\n\tp->addr    = args->addr;\n\tp->bus_idx = bus_idx;\n\tp->length  = args->len;\n\tp->eventfd = eventfd;\n\n\t/* The datamatch feature is optional, otherwise this is a wildcard */\n\tif (args->flags & KVM_IOEVENTFD_FLAG_DATAMATCH)\n\t\tp->datamatch = args->datamatch;\n\telse\n\t\tp->wildcard = true;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\t/* Verify that there isn't a match already */\n\tif (ioeventfd_check_collision(kvm, p)) {\n\t\tret = -EEXIST;\n\t\tgoto unlock_fail;\n\t}\n\n\tkvm_iodevice_init(&p->dev, &ioeventfd_ops);\n\n\tret = kvm_io_bus_register_dev(kvm, bus_idx, p->addr, p->length,\n\t\t\t\t      &p->dev);\n\tif (ret < 0)\n\t\tgoto unlock_fail;\n\n\tkvm_get_bus(kvm, bus_idx)->ioeventfd_count++;\n\tlist_add_tail(&p->list, &kvm->ioeventfds);\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn 0;\n\nunlock_fail:\n\tmutex_unlock(&kvm->slots_lock);\n\nfail:\n\tkfree(p);\n\teventfd_ctx_put(eventfd);\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1753,
        "func": "iperf_on_test_start(struct iperf_test *test)\n{\n    if (test->json_output) {\n\tcJSON_AddItemToObject(test->json_start, \"test_start\", iperf_json_printf(\"protocol: %s  num_streams: %d  blksize: %d  omit: %d  duration: %d  bytes: %d  blocks: %d  reverse: %d\", test->protocol->name, (int64_t) test->num_streams, (int64_t) test->settings->blksize, (int64_t) test->omit, (int64_t) test->duration, (int64_t) test->settings->bytes, (int64_t) test->settings->blocks, test->reverse?(int64_t)1:(int64_t)0));\n    } else {\n\tif (test->verbose) {\n\t    if (test->settings->bytes)\n\t\tiprintf(test, test_start_bytes, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->settings->bytes);\n\t    else if (test->settings->blocks)\n\t\tiprintf(test, test_start_blocks, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->settings->blocks);\n\t    else\n\t\tiprintf(test, test_start_time, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->duration);\n\t}\n    }\n}",
        "target": 0
    },
    {
        "id": 1754,
        "func": "static int tun_attach(struct tun_struct *tun, struct file *file, bool skip_filter)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev = tun->dev;\n\tint err;\n\n\terr = security_tun_dev_attach(tfile->socket.sk, tun->security);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (rtnl_dereference(tfile->tun) && !tfile->detached)\n\t\tgoto out;\n\n\terr = -EBUSY;\n\tif (!(tun->flags & IFF_MULTI_QUEUE) && tun->numqueues == 1)\n\t\tgoto out;\n\n\terr = -E2BIG;\n\tif (!tfile->detached &&\n\t    tun->numqueues + tun->numdisabled == MAX_TAP_QUEUES)\n\t\tgoto out;\n\n\terr = 0;\n\n\t/* Re-attach the filter to persist device */\n\tif (!skip_filter && (tun->filter_attached == true)) {\n\t\tlock_sock(tfile->socket.sk);\n\t\terr = sk_attach_filter(&tun->fprog, tfile->socket.sk);\n\t\trelease_sock(tfile->socket.sk);\n\t\tif (!err)\n\t\t\tgoto out;\n\t}\n\n\tif (!tfile->detached &&\n\t    skb_array_init(&tfile->tx_array, dev->tx_queue_len, GFP_KERNEL)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttfile->queue_index = tun->numqueues;\n\ttfile->socket.sk->sk_shutdown &= ~RCV_SHUTDOWN;\n\trcu_assign_pointer(tfile->tun, tun);\n\trcu_assign_pointer(tun->tfiles[tun->numqueues], tfile);\n\ttun->numqueues++;\n\n\tif (tfile->detached)\n\t\ttun_enable_queue(tfile);\n\telse\n\t\tsock_hold(&tfile->sk);\n\n\ttun_set_real_num_queues(tun);\n\n\t/* device is allowed to go away first, so no need to hold extra\n\t * refcnt.\n\t */\n\nout:\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 1755,
        "func": "bool parse_method(struct pool *pool, char *s)\n{\n\tjson_t *val = NULL, *method, *err_val, *params;\n\tjson_error_t err;\n\tbool ret = false;\n\tchar *buf;\n\n\tif (!s)\n\t\tgoto out;\n\n\tval = JSON_LOADS(s, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tgoto out;\n\t}\n\n\tmethod = json_object_get(val, \"method\");\n\tif (!method)\n\t\tgoto out_decref;\n\terr_val = json_object_get(val, \"error\");\n\tparams = json_object_get(val, \"params\");\n\n\tif (err_val && !json_is_null(err_val)) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC method decode failed: %s\", ss);\n\t\tfree(ss);\n\t\tgoto out_decref;\n\t}\n\n\tbuf = (char *)json_string_value(method);\n\tif (!buf)\n\t\tgoto out_decref;\n\n\tif (!strncasecmp(buf, \"mining.notify\", 13)) {\n\t\tif (parse_notify(pool, params))\n\t\t\tpool->stratum_notify = ret = true;\n\t\telse\n\t\t\tpool->stratum_notify = ret = false;\n\t\tgoto out_decref;\n\t}\n\n\tif (!strncasecmp(buf, \"mining.set_difficulty\", 21)) {\n\t\tret = parse_diff(pool, params);\n\t\tgoto out_decref;\n\t}\n\n\tif (!strncasecmp(buf, \"client.reconnect\", 16)) {\n\t\tret = parse_reconnect(pool, params);\n\t\tgoto out_decref;\n\t}\n\n\tif (!strncasecmp(buf, \"client.get_version\", 18)) {\n\t\tret =  send_version(pool, val);\n\t\tgoto out_decref;\n\t}\n\n\tif (!strncasecmp(buf, \"client.show_message\", 19)) {\n\t\tret = show_message(pool, params);\n\t\tgoto out_decref;\n\t}\nout_decref:\n\tjson_decref(val);\nout:\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 1756,
        "func": "v8::Handle<v8::Value> V8DataView::setUint8Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.DataView.setUint8\");\n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     DataView* imp = V8DataView::toNative(args.Holder());\n     ExceptionCode ec = 0;\n    EXCEPTION_BLOCK(unsigned, byteOffset, toUInt32(args[0]));\n    EXCEPTION_BLOCK(int, value, toInt32(args[1]));\n    imp->setUint8(byteOffset, static_cast<uint8_t>(value), ec);\n    if (UNLIKELY(ec))\n        V8Proxy::setDOMException(ec, args.GetIsolate());\n    return v8::Handle<v8::Value>();\n}\n",
        "target": 1
    },
    {
        "id": 1757,
        "func": "  virtual void DidFail(FileError::ErrorCode) {\n    callback_->sendFailure(Response::Error(\"Couldn't read BLOB\"));\n    Dispose();\n  }\n",
        "target": 0
    },
    {
        "id": 1758,
        "func": "static char *escape_pathname(const char *inp)\n{\n    const unsigned char *s;\n    char *escaped, *d;\n\n    if (!inp) {\n        return NULL;\n     }\n     escaped = malloc (4 * strlen(inp) + 1);\n     if (!escaped) {\n    \tperror(\"malloc\");\n\treturn NULL;\n     }\n     for (d = escaped, s = (const unsigned char *)inp; *s; s++) {\n         if (needs_escape (*s)) {\n            snprintf (d, 5, \"\\\\x%02x\", *s);\n            d += strlen (d);\n        } else {\n            *d++ = *s;\n        }\n    }\n    *d++ = '\\0';\n    return escaped;\n}\n",
        "target": 1
    },
    {
        "id": 1759,
        "func": "void RenderFrameHostManager::DidNavigateFrame(\n    RenderFrameHostImpl* render_frame_host,\n    bool was_caused_by_user_gesture) {\n  CommitPendingIfNecessary(render_frame_host, was_caused_by_user_gesture);\n\n  CommitPendingFramePolicy();\n}\n",
        "target": 0
    },
    {
        "id": 1760,
        "func": "static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}",
        "target": 0
    },
    {
        "id": 1761,
        "func": "static void __sctp_unhash_established(struct sctp_association *asoc)\n{\n\tstruct sctp_hashbucket *head;\n\tstruct sctp_ep_common *epb;\n\n\tepb = &asoc->base;\n\n\tepb->hashent = sctp_assoc_hashfn(epb->bind_addr.port,\n\t\t\t\t\t asoc->peer.port);\n\n\thead = &sctp_assoc_hashtable[epb->hashent];\n\n\tsctp_write_lock(&head->lock);\n\t__hlist_del(&epb->node);\n\tsctp_write_unlock(&head->lock);\n}",
        "target": 0
    },
    {
        "id": 1762,
        "func": "static void saa7164_bus_verify(struct saa7164_dev *dev)\n{\n\tstruct tmComResBusInfo *b = &dev->bus;\n\tint bug = 0;\n\n\tif (saa7164_readl(b->m_dwSetReadPos) > b->m_dwSizeSetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwSetWritePos) > b->m_dwSizeSetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwGetReadPos) > b->m_dwSizeGetRing)\n\t\tbug++;\n\n\tif (saa7164_readl(b->m_dwGetWritePos) > b->m_dwSizeGetRing)\n\t\tbug++;\n\n\tif (bug) {\n\t\tsaa_debug = 0xffff; /* Ensure we get the bus dump */\n\t\tsaa7164_bus_dump(dev);\n\t\tsaa_debug = 1024; /* Ensure we get the bus dump */\n\t\tBUG();\n\t}\n}",
        "target": 0
    },
    {
        "id": 1763,
        "func": "int vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn)\n{\n\tint ret;\n\tpgprot_t pgprot = vma->vm_page_prot;\n\t/*\n\t * Technically, architectures with pte_special can avoid all these\n\t * restrictions (same for remap_pfn_range).  However we would like\n\t * consistency in testing and feature parity among all, so we should\n\t * try to keep these invariants in place for everybody.\n\t */\n\tBUG_ON(!(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)));\n\tBUG_ON((vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) ==\n\t\t\t\t\t\t(VM_PFNMAP|VM_MIXEDMAP));\n\tBUG_ON((vma->vm_flags & VM_PFNMAP) && is_cow_mapping(vma->vm_flags));\n\tBUG_ON((vma->vm_flags & VM_MIXEDMAP) && pfn_valid(pfn));\n\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\tif (track_pfn_vma_new(vma, &pgprot, pfn, PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\tret = insert_pfn(vma, addr, pfn, pgprot);\n\n\tif (ret)\n\t\tuntrack_pfn_vma(vma, pfn, PAGE_SIZE);\n\n\treturn ret;\n}\n",
        "target": 0
    },
    {
        "id": 1764,
        "func": "GF_Err gf_hevc_get_sps_info_with_state(HEVCState *hevc, char *sps_data, u32 sps_size, u32 *sps_id, u32 *width, u32 *height, s32 *par_n, s32 *par_d)\n{\n\ts32 idx;\n\tidx = gf_media_hevc_read_sps(sps_data, sps_size, hevc);\n\tif (idx<0) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (sps_id) *sps_id = idx;\n\n\tif (width) *width = hevc->sps[idx].width;\n\tif (height) *height = hevc->sps[idx].height;\n\tif (par_n) *par_n = hevc->sps[idx].aspect_ratio_info_present_flag ? hevc->sps[idx].sar_width : (u32) -1;\n\tif (par_d) *par_d = hevc->sps[idx].aspect_ratio_info_present_flag ? hevc->sps[idx].sar_height : (u32) -1;\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 1765,
        "func": "void AutoFillManager::HandleSubmit() {\n  std::vector<FormStructure*> import;\n  import.push_back(upload_form_structure_.get());\n  if (!personal_data_->ImportFormData(import, this))\n    return;\n\n  AutoFillProfile* profile;\n  CreditCard* credit_card;\n  personal_data_->GetImportedFormData(&profile, &credit_card);\n\n  if (credit_card) {\n    cc_infobar_.reset(new AutoFillCCInfoBarDelegate(tab_contents_, this));\n  } else {\n    UploadFormData();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1766,
        "func": "int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (*s && len > 0) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n\t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n\t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n\t\t} else {\n\t\t\t*op++ = *s++;\n\t\t\tlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}",
        "target": 1
    },
    {
        "id": 1767,
        "func": "void ShelfLayoutManager::LayoutShelf() {\n  if (in_shutdown_)\n    return;\n\n  LayoutShelfAndUpdateBounds();\n}\n",
        "target": 0
    },
    {
        "id": 1768,
        "func": "static int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_req *req = data;\n\tvoid *ptr = req->data;\n\tint type, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc;\n\n\tBT_DBG(\"sk %p, rsp %p, len %d, req %p\", sk, rsp, len, data);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (val < L2CAP_DEFAULT_MIN_MTU) {\n\t\t\t\t*result = L2CAP_CONF_UNACCEPT;\n\t\t\t\tpi->omtu = L2CAP_DEFAULT_MIN_MTU;\n\t\t\t} else\n\t\t\t\tpi->omtu = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tpi->flush_to = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,\n\t\t\t\t\t\t\t2, pi->flush_to);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen == sizeof(rfc))\n\t\t\t\tmemcpy(&rfc, (void *)val, olen);\n\n\t\t\tif ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&\n\t\t\t\t\t\t\trfc.mode != pi->mode)\n\t\t\t\treturn -ECONNREFUSED;\n\n\t\t\tpi->mode = rfc.mode;\n\t\t\tpi->fcs = 0;\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*result == L2CAP_CONF_SUCCESS) {\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tpi->remote_tx_win   = rfc.txwin_size;\n\t\t\tpi->retrans_timeout = rfc.retrans_timeout;\n\t\t\tpi->monitor_timeout = rfc.monitor_timeout;\n\t\t\tpi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tbreak;\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tpi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treq->dcid   = cpu_to_le16(pi->dcid);\n\treq->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;\n}",
        "target": 0
    },
    {
        "id": 1769,
        "func": "void StyleResolver::matchHostRules(Element* element, ScopedStyleResolver* resolver, ElementRuleCollector& collector, bool includeEmptyRules)\n{\n    if (element != &resolver->scopingNode())\n        return;\n    resolver->matchHostRules(collector, includeEmptyRules);\n}\n",
        "target": 0
    },
    {
        "id": 1770,
        "func": "static const char *set_enable_mmap(cmd_parms *cmd, void *d_,\n                                   const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->enable_mmap = ENABLE_MMAP_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->enable_mmap = ENABLE_MMAP_OFF;\n    }\n    else {\n        return \"parameter must be 'on' or 'off'\";\n    }\n\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 1771,
        "func": "WebContentsView* ContentBrowserClient::OverrideCreateWebContentsView(\n    WebContents* web_contents,\n    RenderViewHostDelegateView** render_view_host_delegate_view) {\n  return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 1772,
        "func": "static inline struct crypto_shash *__crypto_shash_cast(struct crypto_tfm *tfm)\n{\n\treturn container_of(tfm, struct crypto_shash, base);\n}",
        "target": 0
    },
    {
        "id": 1773,
        "func": "static void free_states(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state_list *sl, *sln;\n\tint i;\n\n\tif (!env->explored_states)\n\t\treturn;\n\n\tfor (i = 0; i < env->prog->len; i++) {\n\t\tsl = env->explored_states[i];\n\n\t\tif (sl)\n\t\t\twhile (sl != STATE_LIST_MARK) {\n\t\t\t\tsln = sl->next;\n\t\t\t\tfree_verifier_state(&sl->state, false);\n\t\t\t\tkfree(sl);\n\t\t\t\tsl = sln;\n\t\t\t}\n\t}\n\n\tkfree(env->explored_states);\n}",
        "target": 0
    },
    {
        "id": 1774,
        "func": "int kvm_dev_ioctl_check_extension(long ext)\n{\n\tint r;\n\tswitch (ext) {\n\tcase KVM_CAP_IRQCHIP:\n\t\tr = vgic_present;\n\t\tbreak;\n\tcase KVM_CAP_USER_MEMORY:\n\tcase KVM_CAP_SYNC_MMU:\n\tcase KVM_CAP_DESTROY_MEMORY_REGION_WORKS:\n\tcase KVM_CAP_ONE_REG:\n\tcase KVM_CAP_ARM_PSCI:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_COALESCED_MMIO:\n\t\tr = KVM_COALESCED_MMIO_PAGE_OFFSET;\n\t\tbreak;\n\tcase KVM_CAP_ARM_SET_DEVICE_ADDR:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_NR_VCPUS:\n\t\tr = num_online_cpus();\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n\tdefault:\n\t\tr = kvm_arch_dev_ioctl_check_extension(ext);\n\t\tbreak;\n\t}\n\treturn r;\n}",
        "target": 0
    },
    {
        "id": 1775,
        "func": "void PageSerializer::addToResources(Resource* resource, PassRefPtr<SharedBuffer> data, const KURL& url)\n{\n    if (!data) {\n        LOG_ERROR(\"No data for resource %s\", url.string().utf8().data());\n        return;\n    }\n\n    String mimeType = resource->response().mimeType();\n    m_resources->append(SerializedResource(url, mimeType, data));\n    m_resourceURLs.add(url);\n}\n",
        "target": 0
    },
    {
        "id": 1776,
        "func": "void CheckURLIsBlockedInWebContents(content::WebContents* web_contents,\n                                    const GURL& url) {\n  EXPECT_EQ(url, web_contents->GetURL());\n\n  base::string16 blocked_page_title;\n  if (url.has_host()) {\n    blocked_page_title = base::UTF8ToUTF16(url.host());\n  } else {\n    blocked_page_title = base::UTF8ToUTF16(url.spec());\n  }\n  EXPECT_EQ(blocked_page_title, web_contents->GetTitle());\n\n  bool result = false;\n  EXPECT_TRUE(content::ExecuteScriptAndExtractBool(\n      web_contents,\n      \"var textContent = document.body.textContent;\"\n      \"var hasError = textContent.indexOf('ERR_BLOCKED_BY_ADMINISTRATOR') >= 0;\"\n      \"domAutomationController.send(hasError);\",\n      &result));\n  EXPECT_TRUE(result);\n}\n",
        "target": 0
    },
    {
        "id": 1777,
        "func": "long long powerLawRand(long long min, long long max, double alpha) {\n    double pl, r;\n\n    max += 1;\n    r = ((double)rand()) / RAND_MAX;\n    pl = pow(\n        ((pow(max,alpha+1) - pow(min,alpha+1))*r + pow(min,alpha+1)),\n        (1.0/(alpha+1)));\n    return (max-1-(long long)pl)+min;\n}\n",
        "target": 0
    },
    {
        "id": 1778,
        "func": "static int s390_regs_get(struct task_struct *target,\n\t\t\t const struct user_regset *regset,\n\t\t\t unsigned int pos, unsigned int count,\n\t\t\t void *kbuf, void __user *ubuf)\n{\n\tif (target == current)\n\t\tsave_access_regs(target->thread.acrs);\n\n\tif (kbuf) {\n\t\tunsigned long *k = kbuf;\n\t\twhile (count > 0) {\n\t\t\t*k++ = __peek_user(target, pos);\n\t\t\tcount -= sizeof(*k);\n\t\t\tpos += sizeof(*k);\n\t\t}\n\t} else {\n\t\tunsigned long __user *u = ubuf;\n\t\twhile (count > 0) {\n\t\t\tif (__put_user(__peek_user(target, pos), u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tcount -= sizeof(*u);\n\t\t\tpos += sizeof(*u);\n\t\t}\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1779,
        "func": "int TS_X509_ALGOR_print_bio(BIO *bio, const X509_ALGOR *alg)\n{\n    int i = OBJ_obj2nid(alg->algorithm);\n    return BIO_printf(bio, \"Hash Algorithm: %s\\n\",\n                      (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n}\n",
        "target": 0
    },
    {
        "id": 1780,
        "func": "static inline bool isObservable(JSTestActiveDOMObject* jsTestActiveDOMObject)\n{\n    if (jsTestActiveDOMObject->hasCustomProperties())\n        return true;\n    return false;\n}\n",
        "target": 0
    },
    {
        "id": 1781,
        "func": "FetchManager::FetchManager(ExecutionContext* execution_context)\n    : ContextLifecycleObserver(execution_context) {}\n",
        "target": 0
    },
    {
        "id": 1782,
        "func": "bool ProfilingProcessHost::OnMemoryDump(\n    const base::trace_event::MemoryDumpArgs& args,\n    base::trace_event::ProcessMemoryDump* pmd) {\n  profiling_service_->DumpProcessesForTracing(\n      base::BindOnce(&ProfilingProcessHost::OnDumpProcessesForTracingCallback,\n                     base::Unretained(this), args.dump_guid));\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1783,
        "func": "static aClient *decode_puid(char *puid)\n{\n\taClient *cptr;\n\tchar *it, *it2;\n\tint cookie = 0;\n\n\tif ((it = strrchr(puid, '!')) == NULL)\n\t\treturn NULL;\n\n\t*it++ = '\\0';\n\n\tif ((it2 = strrchr(it, '.')) != NULL)\n\t{\n\t\t*it2++ = '\\0';\n\t\tcookie = atoi(it2);\n\t}\n\n\tif (stricmp(me.name, puid))\n\t\treturn NULL;\n\n\tlist_for_each_entry(cptr, &unknown_list, lclient_node)\n\t\tif (cptr->local->sasl_cookie == cookie)\n\t\t\treturn cptr;\n\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 1784,
        "func": "CMS_RecipientInfo *CMS_add1_recipient_cert(CMS_ContentInfo *cms,\n                                           X509 *recip, unsigned int flags)\n{\n    CMS_RecipientInfo *ri = NULL;\n    CMS_EnvelopedData *env;\n    EVP_PKEY *pk = NULL;\n    env = cms_get0_enveloped(cms);\n    if (!env)\n        goto err;\n\n    /* Initialize recipient info */\n    ri = M_ASN1_new_of(CMS_RecipientInfo);\n    if (!ri)\n        goto merr;\n\n    pk = X509_get0_pubkey(recip);\n    if (!pk) {\n        CMSerr(CMS_F_CMS_ADD1_RECIPIENT_CERT, CMS_R_ERROR_GETTING_PUBLIC_KEY);\n        goto err;\n    }\n\n    switch (cms_pkey_get_ri_type(pk)) {\n\n    case CMS_RECIPINFO_TRANS:\n        if (!cms_RecipientInfo_ktri_init(ri, recip, pk, flags))\n            goto err;\n        break;\n\n    case CMS_RECIPINFO_AGREE:\n        if (!cms_RecipientInfo_kari_init(ri, recip, pk, flags))\n            goto err;\n        break;\n\n    default:\n        CMSerr(CMS_F_CMS_ADD1_RECIPIENT_CERT,\n               CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\n        goto err;\n\n    }\n\n    if (!sk_CMS_RecipientInfo_push(env->recipientInfos, ri))\n        goto merr;\n\n    return ri;\n\n merr:\n    CMSerr(CMS_F_CMS_ADD1_RECIPIENT_CERT, ERR_R_MALLOC_FAILURE);\n err:\n    M_ASN1_free_of(ri, CMS_RecipientInfo);\n    return NULL;\n\n}\n",
        "target": 0
    },
    {
        "id": 1785,
        "func": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\n\tif (reading_from_buf) {\n\t\t/* We had an existing partial packet, so add the new\n\t\t * packet to the buffer and parse the whole thing */\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\t/* Buffer the data when the inner packet is split\n\t\t\t * across multiple sideband packets */\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\n\t\t/* Advance in the buffer */\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\n\t\t/* When a valid packet with no content has been\n\t\t * read, git_pkt_parse_line does not report an\n\t\t * error, but the pkt pointer has not been set.\n\t\t * Handle this by skipping over empty packets.\n\t\t */\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\n\t\terror = add_push_report_pkt(push, pkt);\n\n\t\tgit_pkt_free(pkt);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\terror = 0;\n\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}",
        "target": 1
    },
    {
        "id": 1786,
        "func": "OPJ_BOOL opj_tcd_init( opj_tcd_t *p_tcd,\n                                           opj_image_t * p_image,\n                                           opj_cp_t * p_cp )\n{\n        p_tcd->image = p_image;\n        p_tcd->cp = p_cp;\n\n        p_tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_calloc(1,sizeof(opj_tcd_tile_t));\n        if (! p_tcd->tcd_image->tiles) {\n                return OPJ_FALSE;\n        }\n\n        p_tcd->tcd_image->tiles->comps = (opj_tcd_tilecomp_t *) opj_calloc(p_image->numcomps,sizeof(opj_tcd_tilecomp_t));\n        if (! p_tcd->tcd_image->tiles->comps ) {\n                return OPJ_FALSE;\n        }\n\n        p_tcd->tcd_image->tiles->numcomps = p_image->numcomps;\n        p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;\n\n        return OPJ_TRUE;\n}",
        "target": 0
    },
    {
        "id": 1787,
        "func": "void V8TestObject::ReadonlyWindowAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_readonlyWindowAttribute_Getter\");\n\n  test_object_v8_internal::ReadonlyWindowAttributeAttributeGetter(info);\n}\n",
        "target": 0
    },
    {
        "id": 1788,
        "func": "static struct tpm_chip *tpm_chip_find_get(int chip_num)\n{\n\tstruct tpm_chip *pos, *chip = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (chip_num != TPM_ANY_NUM && chip_num != pos->dev_num)\n\t\t\tcontinue;\n\n\t\tif (try_module_get(pos->dev->driver->owner)) {\n\t\t\tchip = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn chip;\n}",
        "target": 0
    },
    {
        "id": 1789,
        "func": "void ResourceLoader::DidFinishLoading(double finish_time,\n                                      int64_t encoded_data_length,\n                                      int64_t encoded_body_length,\n                                      int64_t decoded_body_length) {\n  resource_->SetEncodedDataLength(encoded_data_length);\n  resource_->SetEncodedBodyLength(encoded_body_length);\n  resource_->SetDecodedBodyLength(decoded_body_length);\n\n  Release(ResourceLoadScheduler::ReleaseOption::kReleaseAndSchedule);\n  loader_.reset();\n\n  network_instrumentation::EndResourceLoad(\n      resource_->Identifier(),\n      network_instrumentation::RequestOutcome::kSuccess);\n\n  fetcher_->HandleLoaderFinish(resource_.Get(), finish_time,\n                               ResourceFetcher::kDidFinishLoading);\n}\n",
        "target": 0
    },
    {
        "id": 1790,
        "func": "static void methodWithEnforceRangeInt32Method(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ExceptionState exceptionState(ExceptionState::ExecutionContext, \"methodWithEnforceRangeInt32\", \"TestObject\", info.Holder(), info.GetIsolate());\n    if (UNLIKELY(info.Length() < 1)) {\n        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, value, toInt32(info[0], EnforceRange, exceptionState), exceptionState);\n    imp->methodWithEnforceRangeInt32(value);\n}\n",
        "target": 0
    },
    {
        "id": 1791,
        "func": "static void jpc_crg_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tif (crg->comps) {\n\t\tjas_free(crg->comps);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1792,
        "func": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\treturn -ENOSYS;\n}",
        "target": 1
    },
    {
        "id": 1793,
        "func": "static void php_apache_request_dtor(request_rec *r TSRMLS_DC)\n{\n\tphp_request_shutdown(NULL);\n}\n",
        "target": 0
    },
    {
        "id": 1794,
        "func": "void HTMLLinkElement::LinkLoaded() {\n  DispatchEvent(*Event::Create(EventTypeNames::load));\n}\n",
        "target": 0
    },
    {
        "id": 1795,
        "func": "BackingStore* RenderWidgetHostViewAndroid::AllocBackingStore(\n    const gfx::Size& size) {\n  NOTIMPLEMENTED();\n  return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 1796,
        "func": "bool DataReductionProxyConfig::AreProxiesBypassed(\n    const net::ProxyRetryInfoMap& retry_map,\n    const net::ProxyConfig::ProxyRules& proxy_rules,\n    bool is_https,\n    base::TimeDelta* min_retry_delay) const {\n  if (proxy_rules.type != net::ProxyConfig::ProxyRules::Type::PROXY_LIST_PER_SCHEME)\n    return false;\n\n  if (is_https)\n    return false;\n\n  const net::ProxyList* proxies =\n      proxy_rules.MapUrlSchemeToProxyList(url::kHttpScheme);\n\n  if (!proxies)\n    return false;\n\n  base::TimeDelta min_delay = base::TimeDelta::Max();\n  bool bypassed = false;\n\n  for (const net::ProxyServer& proxy : proxies->GetAll()) {\n    if (!proxy.is_valid() || proxy.is_direct())\n      continue;\n\n    base::TimeDelta delay;\n    if (FindConfiguredDataReductionProxy(proxy)) {\n      if (!IsProxyBypassed(retry_map, proxy, &delay))\n        return false;\n      if (delay < min_delay)\n        min_delay = delay;\n      bypassed = true;\n    }\n  }\n\n  if (min_retry_delay && bypassed)\n    *min_retry_delay = min_delay;\n\n  return bypassed;\n}\n",
        "target": 0
    },
    {
        "id": 1797,
        "func": "WebView* RenderViewImpl::createView(\n    WebFrame* creator,\n    const WebURLRequest& request,\n    const WebWindowFeatures& features,\n    const WebString& frame_name,\n    WebNavigationPolicy policy) {\n  if (shared_popup_counter_->data > kMaximumNumberOfUnacknowledgedPopups)\n    return NULL;\n\n  ViewHostMsg_CreateWindow_Params params;\n  params.opener_id = routing_id_;\n  params.user_gesture = creator->isProcessingUserGesture();\n  params.window_container_type = WindowFeaturesToContainerType(features);\n  params.session_storage_namespace_id = session_storage_namespace_id_;\n   params.frame_name = frame_name;\n   params.opener_frame_id = creator->identifier();\n   params.opener_url = creator->document().url();\n  GURL security_url(creator->document().securityOrigin().toString().utf8());\n  if (!security_url.is_valid())\n    security_url = GURL();\n  params.opener_security_origin = security_url;\n   params.opener_suppressed = creator->willSuppressOpenerInNewFrame();\n   params.disposition = NavigationPolicyToDisposition(policy);\n   if (!request.isNull())\n    params.target_url = request.url();\n\n  int32 routing_id = MSG_ROUTING_NONE;\n  int32 surface_id = 0;\n  int64 cloned_session_storage_namespace_id;\n\n  RenderThread::Get()->Send(\n      new ViewHostMsg_CreateWindow(params,\n                                   &routing_id,\n                                   &surface_id,\n                                   &cloned_session_storage_namespace_id));\n  if (routing_id == MSG_ROUTING_NONE)\n    return NULL;\n\n  creator->consumeUserGesture();\n\n  RenderViewImpl* view = RenderViewImpl::Create(\n      routing_id_,\n      renderer_preferences_,\n      webkit_preferences_,\n      shared_popup_counter_,\n      routing_id,\n      surface_id,\n      cloned_session_storage_namespace_id,\n      frame_name,\n      true,\n      false,\n      1,\n      screen_info_,\n      accessibility_mode_);\n  view->opened_by_user_gesture_ = params.user_gesture;\n\n  view->opener_suppressed_ = params.opener_suppressed;\n\n  view->alternate_error_page_url_ = alternate_error_page_url_;\n\n  return view->webview();\n}\n",
        "target": 0
    },
    {
        "id": 1798,
        "func": "int trace_find_tgid(int pid)\n{\n\tif (unlikely(!tgid_map || !pid || pid > PID_MAX_DEFAULT))\n\t\treturn 0;\n\n\treturn tgid_map[pid];\n}",
        "target": 0
    },
    {
        "id": 1799,
        "func": "return_pkinit_kx(krb5_context context, krb5_kdc_req *request,\n                 krb5_kdc_rep *reply, krb5_keyblock *encrypting_key,\n                 krb5_pa_data **out_padata)\n{\n    krb5_error_code ret = 0;\n    krb5_keyblock *session = reply->ticket->enc_part2->session;\n    krb5_keyblock *new_session = NULL;\n    krb5_pa_data *pa = NULL;\n    krb5_enc_data enc;\n    krb5_data *scratch = NULL;\n\n    *out_padata = NULL;\n    enc.ciphertext.data = NULL;\n    if (!krb5_principal_compare(context, request->client,\n                                krb5_anonymous_principal()))\n        return 0;\n    /*\n     * The KDC contribution key needs to be a fresh key of an enctype supported\n     * by the client and server. The existing session key meets these\n     * requirements so we use it.\n     */\n    ret = krb5_c_fx_cf2_simple(context, session, \"PKINIT\",\n                               encrypting_key, \"KEYEXCHANGE\",\n                               &new_session);\n    if (ret)\n        goto cleanup;\n    ret = encode_krb5_encryption_key( session, &scratch);\n    if (ret)\n        goto cleanup;\n    ret = krb5_encrypt_helper(context, encrypting_key,\n                              KRB5_KEYUSAGE_PA_PKINIT_KX, scratch, &enc);\n    if (ret)\n        goto cleanup;\n    memset(scratch->data, 0, scratch->length);\n    krb5_free_data(context, scratch);\n    scratch = NULL;\n    ret = encode_krb5_enc_data(&enc, &scratch);\n    if (ret)\n        goto cleanup;\n    pa = malloc(sizeof(krb5_pa_data));\n    if (pa == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n    pa->pa_type = KRB5_PADATA_PKINIT_KX;\n    pa->length = scratch->length;\n    pa->contents = (krb5_octet *) scratch->data;\n    *out_padata = pa;\n    scratch->data = NULL;\n    memset(session->contents, 0, session->length);\n    krb5_free_keyblock_contents(context, session);\n    *session = *new_session;\n    new_session->contents = NULL;\ncleanup:\n    krb5_free_data_contents(context, &enc.ciphertext);\n    krb5_free_keyblock(context, new_session);\n    krb5_free_data(context, scratch);\n    return ret;\n}\n",
        "target": 0
    },
    {
        "id": 1800,
        "func": "void TabStripModelObserver::ActiveTabChanged(TabContents* old_contents,\n                                             TabContents* new_contents,\n                                             int index,\n                                             bool user_gesture) {\n}\n",
        "target": 0
    },
    {
        "id": 1801,
        "func": "WebKit::WebSpeechInputController* RenderViewImpl::speechInputController(\n    WebKit::WebSpeechInputListener* listener) {\n#if defined(ENABLE_INPUT_SPEECH)\n  if (!input_tag_speech_dispatcher_)\n    input_tag_speech_dispatcher_ =\n        new InputTagSpeechDispatcher(this, listener);\n#endif\n  return input_tag_speech_dispatcher_;\n}\n",
        "target": 0
    },
    {
        "id": 1802,
        "func": "void RenderViewImpl::DidHandleMouseEvent(const WebKit::WebMouseEvent& event) {\n  FOR_EACH_OBSERVER(RenderViewObserver, observers_, DidHandleMouseEvent(event));\n}\n",
        "target": 0
    },
    {
        "id": 1803,
        "func": "static void btpan_close_conn(btpan_conn_t* conn)\n{\n    BTIF_TRACE_API(\"btpan_close_conn: %p\",conn);\n\n if (conn && conn->state == PAN_STATE_OPEN)\n {\n        BTIF_TRACE_DEBUG(\"btpan_close_conn: PAN_STATE_OPEN\");\n\n        conn->state = PAN_STATE_CLOSE;\n        btpan_cb.open_count--;\n\n if (btpan_cb.open_count == 0)\n {\n            destroy_tap_read_thread();\n if (btpan_cb.tap_fd != INVALID_FD)\n {\n                btpan_tap_close(btpan_cb.tap_fd);\n                btpan_cb.tap_fd = INVALID_FD;\n }\n }\n }\n}\n",
        "target": 0
    },
    {
        "id": 1804,
        "func": "int bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (sk->sk_state != state) {\n\t\tif (!timeo) {\n\t\t\terr = -EINPROGRESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 1805,
        "func": "static int bin_main(RCore *r, int mode, int va) {\n\tRBinAddr *binmain = r_bin_get_sym (r->bin, R_BIN_SYM_MAIN);\n\tut64 addr;\n\tif (!binmain) {\n\t\treturn false;\n\t}\n\taddr = va ? r_bin_a2b (r->bin, binmain->vaddr) : binmain->paddr;\n\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"symbols\");\n\t\tr_flag_set (r->flags, \"main\", addr, r->blocksize);\n\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\tr_cons_printf (\"%\"PFMT64d, addr);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs symbols\\n\");\n\t\tr_cons_printf (\"f main @ 0x%08\"PFMT64x\"\\n\", addr);\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{\\\"vaddr\\\":%\" PFMT64d\n\t\t\t\",\\\"paddr\\\":%\" PFMT64d \"}\", addr, binmain->paddr);\n\t} else {\n\t\tr_cons_printf (\"[Main]\\n\");\n\t\tr_cons_printf (\"vaddr=0x%08\"PFMT64x\" paddr=0x%08\"PFMT64x\"\\n\",\n\t\t\taddr, binmain->paddr);\n\t}\n\treturn true;\n}",
        "target": 0
    },
    {
        "id": 1806,
        "func": "static int tcp_v4_send_synack(struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct request_values *rvp)\n{\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tint err = -1;\n\tstruct sk_buff * skb;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\treturn -1;\n\n\tskb = tcp_make_synack(sk, dst, req, rvp);\n\n\tif (skb) {\n\t\t__tcp_v4_send_check(skb, ireq->loc_addr, ireq->rmt_addr);\n\n\t\terr = ip_build_and_send_pkt(skb, sk, ireq->loc_addr,\n\t\t\t\t\t    ireq->rmt_addr,\n\t\t\t\t\t    ireq->opt);\n\t\terr = net_xmit_eval(err);\n\t}\n\n\tdst_release(dst);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 1807,
        "func": "static int decode_attr_space_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_AVAIL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_AVAIL;\n\t}\n\tdprintk(\"%s: space avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
        "target": 0
    },
    {
        "id": 1808,
        "func": "bool SSLClientSocketOpenSSL::DoTransportIO() {\n  bool network_moved = false;\n  int rv;\n  do {\n    rv = BufferSend();\n    if (rv != ERR_IO_PENDING && rv != 0)\n      network_moved = true;\n  } while (rv > 0);\n  if (!transport_recv_eof_ && BufferRecv() != ERR_IO_PENDING)\n    network_moved = true;\n  return network_moved;\n}\n",
        "target": 0
    },
    {
        "id": 1809,
        "func": "static int handle_pte_fault(struct mm_struct *mm,\n\t\t     struct vm_area_struct *vma, unsigned long address,\n\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)\n{\n\tpte_t entry;\n\tspinlock_t *ptl;\n\n\t/*\n\t * some architectures can have larger ptes than wordsize,\n\t * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and CONFIG_32BIT=y,\n\t * so READ_ONCE or ACCESS_ONCE cannot guarantee atomic accesses.\n\t * The code below just needs a consistent view for the ifs and\n\t * we later double check anyway with the ptl lock held. So here\n\t * a barrier will do.\n\t */\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n\t\t\t\t\t\t\tpmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\n\tif (pte_protnone(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*pte, entry)))\n\t\tgoto unlock;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, ptl, entry);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vma, address, pte);\n\t} else {\n\t\t/*\n\t\t * This is needed only for protection faults but the arch code\n\t\t * is not yet telling us if this is a protection fault or not.\n\t\t * This still avoids useless tlb flushes for .text page faults\n\t\t * with threads.\n\t\t */\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\nunlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 1810,
        "func": "void ChromeExtensionWebContentsObserver::RenderViewCreated(\n     content::RenderViewHost* render_view_host) {\n   ReloadIfTerminated(render_view_host);\n   ExtensionWebContentsObserver::RenderViewCreated(render_view_host);\n }\n",
        "target": 1
    },
    {
        "id": 1811,
        "func": "void WebFrameLoaderClient::download(ResourceHandle* handle,\n                                    const ResourceRequest& request,\n                                    const ResourceRequest& initialRequest,\n                                    const ResourceResponse& response) {\n  NOTREACHED();\n}\n",
        "target": 0
    },
    {
        "id": 1812,
        "func": "PP_Flash_Menu* ReadMenu(int depth,\n                        const IPC::Message* m,\n                        PickleIterator* iter) {\n  if (depth > kMaxMenuDepth)\n    return NULL;\n  ++depth;\n\n  PP_Flash_Menu* menu = new PP_Flash_Menu;\n  menu->items = NULL;\n\n  if (!m->ReadUInt32(iter, &menu->count)) {\n    FreeMenu(menu);\n    return NULL;\n  }\n\n   if (menu->count == 0)\n     return menu;\n \n   menu->items = new PP_Flash_MenuItem[menu->count];\n   memset(menu->items, 0, sizeof(PP_Flash_MenuItem) * menu->count);\n   for (uint32_t i = 0; i < menu->count; ++i) {\n    if (!ReadMenuItem(depth, m, iter, menu->items + i)) {\n      FreeMenu(menu);\n      return NULL;\n    }\n  }\n  return menu;\n}\n",
        "target": 1
    },
    {
        "id": 1813,
        "func": "void GLES2DecoderImpl::ClearScheduleCALayerState() {\n  ca_layer_shared_state_.reset();\n}\n",
        "target": 0
    },
    {
        "id": 1814,
        "func": "beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\n\tif (l_strnstart(\"MSG\", 4, (const char *)bp, length)) /* A REQuest */\n\t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(\"RPY \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(\"ERR \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(\"ANS \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(\"NUL \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(\"SEQ \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(\"END\", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP END\"));\n\telse\n\t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}",
        "target": 1
    },
    {
        "id": 1815,
        "func": "static void posix_acl_fix_xattr_userns(\n\tstruct user_namespace *to, struct user_namespace *from,\n\tvoid *value, size_t size)\n{\n\tstruct posix_acl_xattr_header *header = value;\n\tstruct posix_acl_xattr_entry *entry = (void *)(header + 1), *end;\n\tint count;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!value)\n\t\treturn;\n\tif (size < sizeof(struct posix_acl_xattr_header))\n\t\treturn;\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn;\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn;\n\tif (count == 0)\n\t\treturn;\n\n\tfor (end = entry + count; entry != end; entry++) {\n\t\tswitch(le16_to_cpu(entry->e_tag)) {\n\t\tcase ACL_USER:\n\t\t\tuid = make_kuid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kuid(to, uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tgid = make_kgid(from, le32_to_cpu(entry->e_id));\n\t\t\tentry->e_id = cpu_to_le32(from_kgid(to, gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 1816,
        "func": "  NetworkLibraryImpl()\n      : network_manager_monitor_(NULL),\n        data_plan_monitor_(NULL),\n        ethernet_(NULL),\n        wifi_(NULL),\n        cellular_(NULL),\n        available_devices_(0),\n        enabled_devices_(0),\n        connected_devices_(0),\n        offline_mode_(false) {\n    if (EnsureCrosLoaded()) {\n      Init();\n      network_manager_monitor_ =\n          MonitorNetworkManager(&NetworkManagerStatusChangedHandler,\n                                this);\n      data_plan_monitor_ = MonitorCellularDataPlan(&DataPlanUpdateHandler,\n                                                   this);\n    } else {\n      InitTestData();\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 1817,
        "func": "XmpIteratorPtr xmp_iterator_new(XmpPtr xmp, const char *schema,\n                                const char *propName, XmpIterOptions options)\n{\n    CHECK_PTR(xmp, NULL);\n    RESET_ERROR;\n\n    try {\n        auto xiter = std::unique_ptr<SXMPIterator>(\n            new SXMPIterator(*(SXMPMeta *)xmp, schema, propName, options));\n\n        return reinterpret_cast<XmpIteratorPtr>(xiter.release());\n    }\n    catch (const XMP_Error &e) {\n        set_error(e);\n    }\n\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 1818,
        "func": "header_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} /* header_put_be_3byte */",
        "target": 0
    },
    {
        "id": 1819,
        "func": "void GetCookiesCallback(std::string* cookies_out,\n                        base::RunLoop* run_loop,\n                        const std::vector<net::CanonicalCookie>& cookies) {\n  *cookies_out = net::CanonicalCookie::BuildCookieLine(cookies);\n  run_loop->Quit();\n}\n",
        "target": 0
    },
    {
        "id": 1820,
        "func": "void RootWindow::SetFocusedWindow(Window* focused_window,\n                                  const aura::Event* event) {\n  if (focused_window == focused_window_)\n    return;\n  if (focused_window && !focused_window->CanFocus())\n    return;\n  if (focused_window && client::GetActivationClient(this) &&\n      !client::GetActivationClient(this)->OnWillFocusWindow(focused_window,\n                                                            event)) {\n    return;\n  }\n\n  Window* old_focused_window = focused_window_;\n  focused_window_ = focused_window;\n  if (old_focused_window && old_focused_window->delegate())\n    old_focused_window->delegate()->OnBlur();\n  if (focused_window_ && focused_window_->delegate())\n    focused_window_->delegate()->OnFocus();\n  if (focused_window_) {\n    FOR_EACH_OBSERVER(RootWindowObserver, observers_,\n                      OnWindowFocused(focused_window_));\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1821,
        "func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ =\n      icu::UnicodeSet(icu::UnicodeString(\"[Ð°ÑÔÐµÒ»Ñ–Ñ˜ÓÐ¾Ñ€Ô›Ñ•ÔÑ…ÑƒÑŠÐ¬Ò½Ð¿Ð³ÑµÑ¡]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n \n   UParseError parse_error;\n  transliterator_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"DropAcc\"),\n       icu::UnicodeString(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                         \" Å‚ > l; Ã¸ > o; Ä‘ > d; Ó > l; [ÐºÄ¸Îº] > k; Ð¿ > n;\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n",
        "target": 1
    },
    {
        "id": 1822,
        "func": "static void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (kvm_x86_ops->get_nmi_mask(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
        "target": 0
    },
    {
        "id": 1823,
        "func": "void GpuProcessHost::RequestHDRStatus(RequestHDRStatusCallback request_cb) {\n  gpu_service_ptr_->RequestHDRStatus(std::move(request_cb));\n}\n",
        "target": 0
    },
    {
        "id": 1824,
        "func": "static bool ask_continue_before_steal(const char *base_dir, const char *dump_dir)\n{\n    char *msg = xasprintf(_(\"Need writable directory, but '%s' is not writable.\"\n                            \" Move it to '%s' and operate on the moved data?\"),\n                            dump_dir, base_dir);\n    const bool response = run_ask_yes_no_yesforever_dialog(\"ask_steal_dir\", msg, GTK_WINDOW(g_wnd_assistant));\n    free(msg);\n    return response;\n}",
        "target": 0
    },
    {
        "id": 1825,
        "func": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/\n}",
        "target": 1
    },
    {
        "id": 1826,
        "func": "void impeg2d_flush_ext_and_user_data(dec_state_t *ps_dec)\n{\n    UWORD32 u4_start_code;\n stream_t *ps_stream;\n\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n }\n}\n",
        "target": 0
    },
    {
        "id": 1827,
        "func": "void QQuickWebView::touchEvent(QTouchEvent* event)\n{\n    Q_D(QQuickWebView);\n    if (d->m_dialogActive) {\n        event->ignore();\n        return;\n    }\n\n    bool lockingDisabled = flickableDirection() != AutoFlickDirection\n                           || event->touchPoints().size() != 1\n                           || width() >= contentWidth()\n                           || height() >= contentHeight();\n\n    if (!lockingDisabled)\n        d->axisLocker.update(event);\n    else\n        d->axisLocker.reset();\n\n    forceActiveFocus();\n    d->pageView->eventHandler()->handleTouchEvent(event);\n}\n",
        "target": 0
    },
    {
        "id": 1828,
        "func": "  bool IsTappedNodeNull() const { return tapped_node_.IsNull(); }\n",
        "target": 0
    },
    {
        "id": 1829,
        "func": "static int nested_vmx_check_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (!(vmcs12->exception_bitmap & (1u << nr)))\n\t\treturn 0;\n\n\tnested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,\n\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 1830,
        "func": "static int harmonize_features(struct sk_buff *skb, __be16 protocol, int features)\n{\n\tif (!can_checksum_protocol(features, protocol)) {\n\t\tfeatures &= ~NETIF_F_ALL_CSUM;\n\t\tfeatures &= ~NETIF_F_SG;\n\t} else if (illegal_highdma(skb->dev, skb)) {\n\t\tfeatures &= ~NETIF_F_SG;\n\t}\n\n\treturn features;\n}",
        "target": 0
    },
    {
        "id": 1831,
        "func": "PHP_METHOD(SoapServer, fault)\n{\n\tchar *code, *string, *actor=NULL, *name=NULL;\n\tint code_len, string_len, actor_len = 0, name_len = 0;\n\tzval* details = NULL;\n\tsoapServicePtr service;\n\txmlCharEncodingHandlerPtr old_encoding;\n\n\tSOAP_SERVER_BEGIN_CODE();\n\tFETCH_THIS_SERVICE(service);\n\told_encoding = SOAP_GLOBAL(encoding);\n\tSOAP_GLOBAL(encoding) = service->encoding;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|szs\",\n\t    &code, &code_len, &string, &string_len, &actor, &actor_len, &details,\n\t    &name, &name_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tsoap_server_fault(code, string, actor, details, name TSRMLS_CC);\n\n\tSOAP_GLOBAL(encoding) = old_encoding;\n\tSOAP_SERVER_END_CODE();\n}\n",
        "target": 0
    },
    {
        "id": 1832,
        "func": " static int is_rndis(USBNetState *s)\n {\n    return s->dev.config ?\n            s->dev.config->bConfigurationValue == DEV_RNDIS_CONFIG_VALUE : 0;\n }\n",
        "target": 0
    },
    {
        "id": 1833,
        "func": "std::wstring StripWWW(const std::wstring& text) {\n  const std::wstring www(L\"www.\");\n  return (text.compare(0, www.length(), www) == 0) ?\n      text.substr(www.length()) : text;\n}\n",
        "target": 0
    },
    {
        "id": 1834,
        "func": "MojoResult Core::WrapPlatformSharedBufferHandle(\n    const MojoPlatformHandle* platform_handle,\n    size_t size,\n    const MojoSharedBufferGuid* guid,\n    MojoPlatformSharedBufferHandleFlags flags,\n    MojoHandle* mojo_handle) {\n  DCHECK(size);\n  ScopedPlatformHandle handle;\n  MojoResult result =\n      MojoPlatformHandleToScopedPlatformHandle(platform_handle, &handle);\n  if (result != MOJO_RESULT_OK)\n    return result;\n \n   base::UnguessableToken token =\n       base::UnguessableToken::Deserialize(guid->high, guid->low);\n  bool read_only = flags & MOJO_PLATFORM_SHARED_BUFFER_HANDLE_FLAG_READ_ONLY;\n   scoped_refptr<PlatformSharedBuffer> platform_buffer =\n       PlatformSharedBuffer::CreateFromPlatformHandle(size, read_only, token,\n                                                      std::move(handle));\n  if (!platform_buffer)\n    return MOJO_RESULT_UNKNOWN;\n\n  scoped_refptr<SharedBufferDispatcher> dispatcher;\n  result = SharedBufferDispatcher::CreateFromPlatformSharedBuffer(\n      platform_buffer, &dispatcher);\n  if (result != MOJO_RESULT_OK)\n    return result;\n\n  MojoHandle h = AddDispatcher(dispatcher);\n  if (h == MOJO_HANDLE_INVALID) {\n    dispatcher->Close();\n    return MOJO_RESULT_RESOURCE_EXHAUSTED;\n  }\n\n  *mojo_handle = h;\n  return MOJO_RESULT_OK;\n}\n",
        "target": 1
    },
    {
        "id": 1835,
        "func": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 1836,
        "func": "static int em_dr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tunsigned long val;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tval = ctxt->src.val & ~0ULL;\n\telse\n\t\tval = ctxt->src.val & ~0U;\n\n\t/* #UD condition is already handled. */\n\tif (ctxt->ops->set_dr(ctxt, ctxt->modrm_reg, val) < 0)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}",
        "target": 0
    },
    {
        "id": 1837,
        "func": "bool Browser::RemoveFromSet(UnloadListenerSet* set, TabContents* tab) {\n  DCHECK(is_attempting_to_close_browser_);\n\n  UnloadListenerSet::iterator iter = std::find(set->begin(), set->end(), tab);\n  if (iter != set->end()) {\n    set->erase(iter);\n    return true;\n  }\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 1838,
        "func": "DEFUN(srchfor, SEARCH SEARCH_FORE WHEREIS, \"Search forward\")\n{\n    srch(forwardSearch, \"Forward: \");\n}",
        "target": 0
    },
    {
        "id": 1839,
        "func": "bool ChromeContentBrowserClient::AllowPepperSocketAPI(\n    content::BrowserContext* browser_context,\n    const GURL& url,\n    bool private_api,\n    const content::SocketPermissionRequest* params) {\n#if BUILDFLAG(ENABLE_PLUGINS) && BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientPluginsPart::AllowPepperSocketAPI(\n      browser_context, url, private_api, params, allowed_socket_origins_);\n#else\n  return false;\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 1840,
        "func": "static inline bool vrend_format_can_sample(enum virgl_formats format)\n{\n   return tex_conv_table[format].bindings & VREND_BIND_SAMPLER;\n}\n",
        "target": 0
    },
    {
        "id": 1841,
        "func": "LoadState ProxyResolverV8TracingImpl::GetLoadState(\n    ProxyResolver::RequestHandle request) const {\n  Job* job = reinterpret_cast<Job*>(request);\n  return job->GetLoadState();\n}\n",
        "target": 0
    },
    {
        "id": 1842,
        "func": "static MXFStructuralComponent* mxf_resolve_sourceclip(MXFContext *mxf, UID *strong_ref)\n{\n    MXFStructuralComponent *component = NULL;\n\n    component = mxf_resolve_strong_ref(mxf, strong_ref, AnyType);\n    if (!component)\n        return NULL;\n    switch (component->type) {\n        case SourceClip:\n            return component;\n        case EssenceGroup:\n            return mxf_resolve_essence_group_choice(mxf, (MXFEssenceGroup*) component);\n        default:\n            break;\n    }\n    return NULL;\n}",
        "target": 0
    },
    {
        "id": 1843,
        "func": "void DevToolsAgent::sendMessageToInspectorFrontend(\n    const WebKit::WebString& message) {\n  Send(new DevToolsHostMsg_ForwardToClient(\n      routing_id(),\n      DevToolsClientMsg_DispatchOnInspectorFrontend(MSG_ROUTING_NONE,\n                                                    message.utf8())));\n}\n",
        "target": 0
    },
    {
        "id": 1844,
        "func": "views::View* PageInfoWindowView::GetExtraView() {\n  if (!cert_id_)\n    return NULL;\n  scoped_refptr<net::X509Certificate> cert;\n  CertStore::GetSharedInstance()->RetrieveCert(cert_id_, &cert);\n  if (!cert.get() || !cert->os_cert_handle())\n    return NULL;\n\n  views::View* button_container = new views::View();\n  views::GridLayout* layout = new views::GridLayout(button_container);\n  button_container->SetLayoutManager(layout);\n\n  views::ColumnSet* column_set = layout->AddColumnSet(0);\n  column_set->AddPaddingColumn(0, kHorizontalPadding);\n  column_set->AddColumn(views::GridLayout::LEADING,\n                        views::GridLayout::LEADING, 0,\n                        views::GridLayout::USE_PREF, 0, 0);\n  layout->StartRow(0, 0);\n  layout->AddView(new views::NativeButton(this,\n      l10n_util::GetString(IDS_PAGEINFO_CERT_INFO_BUTTON)));\n\n  return button_container;\n}\n",
        "target": 0
    },
    {
        "id": 1845,
        "func": "void RenderWidgetHostImpl::WasShown(const ui::LatencyInfo& latency_info) {\n  if (!is_hidden_)\n    return;\n\n  TRACE_EVENT0(\"renderer_host\", \"RenderWidgetHostImpl::WasShown\");\n  is_hidden_ = false;\n \n  if (new_content_rendering_timeout_ &&\n      new_content_rendering_timeout_->IsRunning()) {\n    new_content_rendering_timeout_->Stop();\n    ClearDisplayedGraphics();\n  }\n \n   SendScreenRects();\n   RestartHangMonitorTimeoutIfNecessary();\n\n  bool needs_repainting = true;\n  needs_repainting_on_restore_ = false;\n  Send(new ViewMsg_WasShown(routing_id_, needs_repainting, latency_info));\n\n  process_->WidgetRestored();\n\n  bool is_visible = true;\n  NotificationService::current()->Notify(\n      NOTIFICATION_RENDER_WIDGET_VISIBILITY_CHANGED,\n      Source<RenderWidgetHost>(this),\n      Details<bool>(&is_visible));\n\n  WasResized();\n}\n",
        "target": 1
    },
    {
        "id": 1846,
        "func": "void WebContentsImpl::OnCreditCardInputShownOnHttp() {\n  controller_.ssl_manager()->DidShowCreditCardInputOnHttp();\n}\n",
        "target": 0
    },
    {
        "id": 1847,
        "func": "void WebSocketJob::OnConnected(\n    SocketStream* socket, int max_pending_send_allowed) {\n  if (state_ == CLOSED)\n    return;\n  DCHECK_EQ(CONNECTING, state_);\n  if (delegate_)\n    delegate_->OnConnected(socket, max_pending_send_allowed);\n}\n",
        "target": 0
    },
    {
        "id": 1848,
        "func": "gss_wrap_iov_length (minor_status,\n                     context_handle,\n                     conf_req_flag,\n                     qop_req,\n                     conf_state,\n                     iov,\n                     iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_wrap_iov_length) {\n\t    status = mech->gss_wrap_iov_length(\n\t\t\t\t\t      minor_status,\n\t\t\t\t\t      ctx->internal_ctx_id,\n\t\t\t\t\t      conf_req_flag,\n\t\t\t\t\t      qop_req,\n\t\t\t\t\t      conf_state,\n\t\t\t\t\t      iov,\n\t\t\t\t\t      iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}",
        "target": 1
    },
    {
        "id": 1849,
        "func": "static void ssl_mac_md5( unsigned char *secret,\n                         unsigned char *buf, size_t len,\n                         unsigned char *ctr, int type )\n{\n    unsigned char header[11];\n    unsigned char padding[48];\n    md5_context md5;\n\n    memcpy( header, ctr, 8 );\n    header[ 8] = (unsigned char)  type;\n    header[ 9] = (unsigned char)( len >> 8 );\n    header[10] = (unsigned char)( len      );\n\n    memset( padding, 0x36, 48 );\n    md5_starts( &md5 );\n    md5_update( &md5, secret,  16 );\n    md5_update( &md5, padding, 48 );\n    md5_update( &md5, header,  11 );\n    md5_update( &md5, buf,  len );\n    md5_finish( &md5, buf + len );\n\n    memset( padding, 0x5C, 48 );\n    md5_starts( &md5 );\n    md5_update( &md5, secret,  16 );\n    md5_update( &md5, padding, 48 );\n    md5_update( &md5, buf + len, 16 );\n    md5_finish( &md5, buf + len );\n}",
        "target": 0
    },
    {
        "id": 1850,
        "func": "static int unimac_mdio_write(struct mii_bus *bus, int phy_id,\n\t\t\t     int reg, u16 val)\n{\n\tstruct unimac_mdio_priv *priv = bus->priv;\n\tu32 cmd;\n\n\t/* Prepare the write operation */\n\tcmd = MDIO_WR | (phy_id << MDIO_PMD_SHIFT) |\n\t\t(reg << MDIO_REG_SHIFT) | (0xffff & val);\n\tunimac_mdio_writel(priv, cmd, MDIO_CMD);\n\n\tunimac_mdio_start(priv);\n\n\treturn priv->wait_func(priv->wait_func_data);\n}",
        "target": 0
    },
    {
        "id": 1851,
        "func": "static int ipxitf_delete(struct ipx_interface_definition *idef)\n{\n\tstruct net_device *dev = NULL;\n\t__be16 dlink_type = 0;\n\tstruct ipx_interface *intrfc;\n\tint rc = 0;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tif (idef->ipx_special == IPX_INTERNAL) {\n\t\tif (ipx_internal_net) {\n\t\t\t__ipxitf_put(ipx_internal_net);\n\t\t\tgoto out;\n\t\t}\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tdlink_type = ipx_map_frame_type(idef->ipx_dlink_type);\n\trc = -EPROTONOSUPPORT;\n\tif (!dlink_type)\n\t\tgoto out;\n\n\tdev = __dev_get_by_name(&init_net, idef->ipx_device);\n\trc = -ENODEV;\n\tif (!dev)\n\t\tgoto out;\n\n\tintrfc = __ipxitf_find_using_phys(dev, dlink_type);\n\trc = -EINVAL;\n\tif (!intrfc)\n\t\tgoto out;\n\t__ipxitf_put(intrfc);\n\n\trc = 0;\nout:\n\tspin_unlock_bh(&ipx_interfaces_lock);\n\treturn rc;\n}",
        "target": 0
    },
    {
        "id": 1852,
        "func": "void RTCPeerConnectionHandler::OnWebRtcEventLogWrite(\n    const std::string& output) {\n  DCHECK(task_runner_->RunsTasksInCurrentSequence());\n  if (peer_connection_tracker_) {\n    peer_connection_tracker_->TrackRtcEventLogWrite(this, output);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1853,
        "func": "\nstatic int ims_pcu_init_application_mode(struct ims_pcu *pcu)\n{\n\tstatic atomic_t device_no = ATOMIC_INIT(-1);\n\n\tconst struct ims_pcu_device_info *info;\n\tint error;\n\n\terror = ims_pcu_get_device_info(pcu);\n\tif (error) {\n\t\t/* Device does not respond to basic queries, hopeless */\n\t\treturn error;\n\t}\n\n\terror = ims_pcu_identify_type(pcu, &pcu->device_id);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failed to identify device, error: %d\\n\", error);\n\t\t/*\n\t\t * Do not signal error, but do not create input nor\n\t\t * backlight devices either, let userspace figure this\n\t\t * out (flash a new firmware?).\n\t\t */\n\t\treturn 0;\n\t}\n\n\tif (pcu->device_id >= ARRAY_SIZE(ims_pcu_device_info) ||\n\t    !ims_pcu_device_info[pcu->device_id].keymap) {\n\t\tdev_err(pcu->dev, \"Device ID %d is not valid\\n\", pcu->device_id);\n\t\t/* Same as above, punt to userspace */\n\t\treturn 0;\n\t}\n\n\t/* Device appears to be operable, complete initialization */\n\tpcu->device_no = atomic_inc_return(&device_no);\n\n\t/*\n\t * PCU-B devices, both GEN_1 and GEN_2 do not have OFN sensor\n\t */\n\tif (pcu->device_id != IMS_PCU_PCU_B_DEVICE_ID) {\n\t\terror = sysfs_create_group(&pcu->dev->kobj,\n\t\t\t\t\t   &ims_pcu_ofn_attr_group);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = ims_pcu_setup_backlight(pcu);\n\tif (error)\n\t\treturn error;\n\n\tinfo = &ims_pcu_device_info[pcu->device_id];\n\terror = ims_pcu_setup_buttons(pcu, info->keymap, info->keymap_len);\n\tif (error)\n\t\tgoto err_destroy_backlight;\n\n\tif (info->has_gamepad) {\n\t\terror = ims_pcu_setup_gamepad(pcu);\n\t\tif (error)\n\t\t\tgoto err_destroy_buttons;\n\t}\n\n\tpcu->setup_complete = true;\n\n\treturn 0;\n\nerr_destroy_buttons:\n\tims_pcu_destroy_buttons(pcu);\nerr_destroy_backlight:\n\tims_pcu_destroy_backlight(pcu);\n\treturn error;",
        "target": 0
    },
    {
        "id": 1854,
        "func": "void InjectedBundlePage::willRunJavaScriptPrompt(WKStringRef message, WKStringRef defaultValue, WKBundleFrameRef)\n{\n    StringBuilder stringBuilder;\n    stringBuilder.appendLiteral(\"PROMPT: \");\n    stringBuilder.append(toWTFString(message));\n    stringBuilder.appendLiteral(\", default text: \");\n    stringBuilder.append(toWTFString(defaultValue));\n    stringBuilder.append('\\n');\n    InjectedBundle::shared().outputText(stringBuilder.toString());\n}\n",
        "target": 0
    },
    {
        "id": 1855,
        "func": "bool PaintLayerScrollableArea::ShouldScrollOnMainThread() const {\n  if (HasBeenDisposed())\n    return true;\n  if (LocalFrame* frame = GetLayoutBox()->GetFrame()) {\n    if (frame->View()->GetMainThreadScrollingReasons())\n      return true;\n  }\n  if (HasNonCompositedStickyDescendants())\n    return true;\n  return ScrollableArea::ShouldScrollOnMainThread();\n}\n",
        "target": 0
    },
    {
        "id": 1856,
        "func": "static void *__videobuf_alloc(size_t size)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_buffer *vb;\n\n\tvb = kzalloc(size+sizeof(*mem),GFP_KERNEL);\n\n\tmem = vb->priv = ((char *)vb)+size;\n\tmem->magic=MAGIC_VMAL_MEM;\n\n\tdprintk(1,\"%s: allocated at %p(%ld+%ld) & %p(%ld)\\n\",\n\t\t__FUNCTION__,vb,(long)sizeof(*vb),(long)size-sizeof(*vb),\n\t\tmem,(long)sizeof(*mem));\n\n\treturn vb;\n}",
        "target": 0
    },
    {
        "id": 1857,
        "func": "  float SpoolSinglePage(cc::PaintCanvas* canvas, int page_number) {\n    DispatchEventsForPrintingOnAllFrames();\n    if (!GetFrame()->GetDocument() ||\n        !GetFrame()->GetDocument()->GetLayoutView())\n      return 0;\n\n    GetFrame()->View()->UpdateLifecyclePhasesForPrinting();\n    if (!GetFrame()->GetDocument() ||\n        !GetFrame()->GetDocument()->GetLayoutView())\n      return 0;\n\n    FloatRect bounds(0, 0, printed_page_height_, printed_page_width_);\n    PaintRecordBuilder builder(&canvas->getMetaData());\n    builder.Context().SetPrinting(true);\n    builder.Context().BeginRecording(bounds);\n    float scale = SpoolPage(builder.Context(), page_number);\n    canvas->drawPicture(builder.Context().EndRecording());\n    return scale;\n  }\n",
        "target": 0
    },
    {
        "id": 1858,
        "func": "xps_parse_digits(char *s, int *digit)\n{\n    *digit = 0;\n    while (*s >= '0' && *s <= '9')\n    {\n        *digit = *digit * 10 + (*s - '0');\n        s ++;\n    }\n    return s;\n}\n",
        "target": 0
    },
    {
        "id": 1859,
        "func": "  Ins_SDPVTL( TT_ExecContext  exc,\n              FT_Long*        args )\n  {\n    FT_Long    A, B, C;\n    FT_UShort  p1, p2;            /* was FT_Int in pas type ERROR */\n\n    FT_Byte  opcode = exc->opcode;\n\n\n    p1 = (FT_UShort)args[1];\n    p2 = (FT_UShort)args[0];\n\n    if ( BOUNDS( p2, exc->zp1.n_points ) ||\n         BOUNDS( p1, exc->zp2.n_points ) )\n    {\n      if ( exc->pedantic_hinting )\n        exc->error = FT_THROW( Invalid_Reference );\n      return;\n    }\n\n    {\n      FT_Vector*  v1 = exc->zp1.org + p2;\n      FT_Vector*  v2 = exc->zp2.org + p1;\n\n\n      A = SUB_LONG( v1->x, v2->x );\n      B = SUB_LONG( v1->y, v2->y );\n\n      /* If v1 == v2, SDPvTL behaves the same as */\n      /* SVTCA[X], respectively.                 */\n      /*                                         */\n      /* Confirmed by Greg Hitchcock.            */\n\n      if ( A == 0 && B == 0 )\n      {\n        A      = 0x4000;\n        opcode = 0;\n      }\n    }\n\n    if ( ( opcode & 1 ) != 0 )\n    {\n      C = B;   /* counter clockwise rotation */\n      B = A;\n      A = NEG_LONG( C );\n    }\n\n    Normalize( A, B, &exc->GS.dualVector );\n\n    {\n      FT_Vector*  v1 = exc->zp1.cur + p2;\n      FT_Vector*  v2 = exc->zp2.cur + p1;\n\n\n      A = SUB_LONG( v1->x, v2->x );\n      B = SUB_LONG( v1->y, v2->y );\n\n      if ( A == 0 && B == 0 )\n      {\n        A      = 0x4000;\n        opcode = 0;\n      }\n    }\n\n    if ( ( opcode & 1 ) != 0 )\n    {\n      C = B;   /* counter clockwise rotation */\n      B = A;\n      A = NEG_LONG( C );\n    }\n\n    Normalize( A, B, &exc->GS.projVector );\n    Compute_Funcs( exc );\n  }\n",
        "target": 0
    },
    {
        "id": 1860,
        "func": "void OnGetFileInfoByResourceId(Profile* profile,\n                               const std::string& resource_id,\n                               base::PlatformFileError error,\n                               const FilePath& /* gdata_file_path */,\n                               scoped_ptr<GDataFileProto> file_proto) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  if (error != base::PLATFORM_FILE_OK)\n    return;\n\n  DCHECK(file_proto.get());\n  const std::string& file_name = file_proto->gdata_entry().file_name();\n  const GURL edit_url = GetFileResourceUrl(resource_id, file_name);\n  OpenEditURLUIThread(profile, &edit_url);\n  DVLOG(1) << \"OnFindEntryByResourceId \" << edit_url;\n}\n",
        "target": 0
    },
    {
        "id": 1861,
        "func": " bool BluetoothDeviceChromeOS::ExpectingPinCode() const {\n  return !pincode_callback_.is_null();\n }\n",
        "target": 1
    },
    {
        "id": 1862,
        "func": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   sc->ctx_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}",
        "target": 0
    },
    {
        "id": 1863,
        "func": "MouseEventWithHitTestResults Document::prepareMouseEvent(const HitTestRequest& request, const LayoutPoint& documentPoint, const PlatformMouseEvent& event)\n{\n    ASSERT(!renderer() || renderer()->isRenderView());\n\n    if (!renderer() || !view() || !view()->didFirstLayout())\n        return MouseEventWithHitTestResults(event, HitTestResult(LayoutPoint()));\n\n    HitTestResult result(documentPoint);\n    renderView()->hitTest(request, result);\n\n    if (!request.readOnly())\n        updateHoverActiveState(request, result.innerElement(), &event);\n\n    return MouseEventWithHitTestResults(event, result);\n}\n",
        "target": 0
    },
    {
        "id": 1864,
        "func": "ssize_t wait_on_sync_kiocb(struct kiocb *iocb)\n{\n\twhile (iocb->ki_users) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!iocb->ki_users)\n\t\t\tbreak;\n\t\tio_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn iocb->ki_user_data;\n}",
        "target": 0
    },
    {
        "id": 1865,
        "func": "read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ret == 0) {\t\t/* EOF */\n\t\t\t/* Failure to read ANY length just means we're done */\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Otherwise, we got EOF mid-length, and that's\n\t\t\t * a protocol error.\n\t\t\t */\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tlen_buf_pos += ret;\n\t}\n\n\t/* Not done reading the length? */\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\n\t/* We have the complete length */\n\tlen = ntohl(*(uint32_t *)len_buf);\n\n\t/*\n\t * We make sure recvd length is reasonable, allowing for some\n\t * slop in enc overhead, beyond the actual maximum number of\n\t * bytes of decrypted payload.\n\t */\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\tgoto bail;\n\t}\n\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\tgoto bail;\n\t}\n\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\tgoto bail;\n\t}\n\n\ttmpbuf_pos += ret;\n\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\n\treturn -2;\n\nbail:\n\tfree(tmpbuf);\n\ttmpbuf = NULL;\n\n\treturn -1;\n}",
        "target": 0
    },
    {
        "id": 1866,
        "func": "\nstatic void skb_set_err_queue(struct sk_buff *skb)\n{\n\t/* pkt_type of skbs received on local sockets is never PACKET_OUTGOING.\n\t * So, it is safe to (mis)use it to mark skbs on the error queue.\n\t */\n\tskb->pkt_type = PACKET_OUTGOING;\n\tBUILD_BUG_ON(PACKET_OUTGOING == 0);",
        "target": 0
    },
    {
        "id": 1867,
        "func": "static char * php_zipobj_get_filename(ze_zip_object *obj TSRMLS_DC) /* {{{ */\n{\n\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\n\tif (obj->filename) {\n\t\treturn obj->filename;\n\t}\n\treturn NULL;\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 1868,
        "func": "static void set_stream_out_varyings(int prog_id, struct vrend_shader_info *sinfo)\n{\n   struct pipe_stream_output_info *so = &sinfo->so_info;\n   char *varyings[PIPE_MAX_SHADER_OUTPUTS*2];\n   int i, j;\n   int n_outputs = 0;\n   int last_buffer = 0;\n   char *start_skip;\n   int buf_offset = 0;\n   int skip;\n   if (!so->num_outputs)\n      return;\n\n   if (vrend_dump_shaders)\n      dump_stream_out(so);\n\n   for (i = 0; i < so->num_outputs; i++) {\n      if (last_buffer != so->output[i].output_buffer) {\n\n         skip = so->stride[last_buffer] - buf_offset;\n         while (skip) {\n            start_skip = get_skip_str(&skip);\n            if (start_skip)\n               varyings[n_outputs++] = start_skip;\n         }\n         for (j = last_buffer; j < so->output[i].output_buffer; j++)\n            varyings[n_outputs++] = strdup(\"gl_NextBuffer\");\n         last_buffer = so->output[i].output_buffer;\n         buf_offset = 0;\n      }\n\n      skip = so->output[i].dst_offset - buf_offset;\n      while (skip) {\n         start_skip = get_skip_str(&skip);\n         if (start_skip)\n            varyings[n_outputs++] = start_skip;\n      }\n      buf_offset = so->output[i].dst_offset;\n\n      buf_offset += so->output[i].num_components;\n      if (sinfo->so_names[i])\n         varyings[n_outputs++] = strdup(sinfo->so_names[i]);\n   }\n\n   skip = so->stride[last_buffer] - buf_offset;\n   while (skip) {\n      start_skip = get_skip_str(&skip);\n      if (start_skip)\n         varyings[n_outputs++] = start_skip;\n   }\n\n   glTransformFeedbackVaryings(prog_id, n_outputs,\n                               (const GLchar **)varyings, GL_INTERLEAVED_ATTRIBS_EXT);\n\n   for (i = 0; i < n_outputs; i++)\n      if (varyings[i])\n         free(varyings[i]);\n}\n",
        "target": 0
    },
    {
        "id": 1869,
        "func": "int crypto_register_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&crypto_chain, nb);\n}",
        "target": 0
    },
    {
        "id": 1870,
        "func": "put_be32(struct ofpbuf *b, ovs_be32 x)\n{\n    ofpbuf_put(b, &x, sizeof x);\n}\n",
        "target": 0
    },
    {
        "id": 1871,
        "func": "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file)\n{\n\tgit_oid hash_final;\n\tstruct index_header header;\n\tbool is_extended;\n\tuint32_t index_version_number;\n\n\tassert(index && file);\n\n\tif (index->version <= INDEX_VERSION_NUMBER_EXT)  {\n\t\tis_extended = is_index_extended(index);\n\t\tindex_version_number = is_extended ? INDEX_VERSION_NUMBER_EXT : INDEX_VERSION_NUMBER_LB;\n\t} else {\n\t\tindex_version_number = index->version;\n\t}\n\n\theader.signature = htonl(INDEX_HEADER_SIG);\n\theader.version = htonl(index_version_number);\n\theader.entry_count = htonl((uint32_t)index->entries.length);\n\n\tif (git_filebuf_write(file, &header, sizeof(struct index_header)) < 0)\n\t\treturn -1;\n\n\tif (write_entries(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the tree cache extension */\n\tif (index->tree != NULL && write_tree_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the rename conflict extension */\n\tif (index->names.length > 0 && write_name_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the reuc extension */\n\tif (index->reuc.length > 0 && write_reuc_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* get out the hash for all the contents we've appended to the file */\n\tgit_filebuf_hash(&hash_final, file);\n\tgit_oid_cpy(checksum, &hash_final);\n\n\t/* write it at the end of the file */\n\tif (git_filebuf_write(file, hash_final.id, GIT_OID_RAWSZ) < 0)\n\t\treturn -1;\n\n\t/* file entries are no longer up to date */\n\tclear_uptodate(index);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1872,
        "func": " void CachingPermutedEntropyProvider::ClearCache(PrefService* local_state) {\n  local_state->ClearPref(prefs::kVariationsPermutedEntropyCache);\n }\n",
        "target": 1
    },
    {
        "id": 1873,
        "func": "PHP_FUNCTION(openssl_get_md_methods)\n{\n\tzend_bool aliases = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &aliases) == FAILURE) {\n\t\treturn;\n\t}\n\tarray_init(return_value);\n\tOBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_MD_METH,\n\t\taliases ? openssl_add_method_or_alias: openssl_add_method,\n\t\treturn_value);\n}\n",
        "target": 0
    },
    {
        "id": 1874,
        "func": "control_stdin(GIOChannel *gio, GIOCondition condition) {\n    (void) condition;\n    gchar *ctl_line = NULL;\n    GIOStatus ret;\n\n    ret = g_io_channel_read_line(gio, &ctl_line, NULL, NULL, NULL);\n    if ( (ret == G_IO_STATUS_ERROR) || (ret == G_IO_STATUS_EOF) )\n        return FALSE;\n\n    parse_cmd_line(ctl_line, NULL);\n    g_free(ctl_line);\n\n    return TRUE;\n}",
        "target": 0
    },
    {
        "id": 1875,
        "func": "static void hns_xgmac_get_pausefrm_cfg(void *mac_drv, u32 *rx_en, u32 *tx_en)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\tu32 pause_ctrl;\n\n\tpause_ctrl = dsaf_read_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG);\n\t*rx_en = dsaf_get_bit(pause_ctrl, XGMAC_PAUSE_CTL_RX_B);\n\t*tx_en = dsaf_get_bit(pause_ctrl, XGMAC_PAUSE_CTL_TX_B);\n}",
        "target": 0
    },
    {
        "id": 1876,
        "func": "bool WebPage::isUserScalable() const\n{\n    return d->isUserScalable();\n}\n",
        "target": 0
    },
    {
        "id": 1877,
        "func": "void RegistrationManager::RegistrationStatus::DoRegister() {\n  CHECK(enabled);\n  registration_timer.Stop();\n  delay = base::TimeDelta();\n  registration_manager->DoRegisterId(id);\n  DCHECK(!last_registration_request.is_null());\n}\n",
        "target": 0
    },
    {
        "id": 1878,
        "func": "void AccessibilityUIElement::setSelectedTextRange(unsigned location, unsigned length)\n{\n}\n",
        "target": 0
    },
    {
        "id": 1879,
        "func": "SeekHead::~SeekHead()\n{\n    delete[] m_entries;\n    delete[] m_void_elements;\n }\n",
        "target": 1
    },
    {
        "id": 1880,
        "func": "mkvparser::IMkvReader::~IMkvReader()\n#ifdef _MSC_VER\n//// Disable MSVC warnings that suggest making code non-portable.\n#pragma warning(disable : 4996)\n#endif\n\nmkvparser::IMkvReader::~IMkvReader() {}\n\nvoid mkvparser::GetVersion(int& major, int& minor, int& build, int& revision) {\n  major = 1;\n  minor = 0;\n  build = 0;\n  revision = 28;\n }\n",
        "target": 0
    },
    {
        "id": 1881,
        "func": "void NetworkHandler::ContinueInterceptedRequest(\n    const std::string& interception_id,\n    Maybe<std::string> error_reason,\n    Maybe<std::string> base64_raw_response,\n    Maybe<std::string> url,\n    Maybe<std::string> method,\n    Maybe<std::string> post_data,\n    Maybe<protocol::Network::Headers> headers,\n     Maybe<protocol::Network::AuthChallengeResponse> auth_challenge_response,\n     std::unique_ptr<ContinueInterceptedRequestCallback> callback) {\n   DevToolsInterceptorController* interceptor =\n      DevToolsInterceptorController::FromBrowserContext(\n          process_->GetBrowserContext());\n   if (!interceptor) {\n     callback->sendFailure(Response::InternalError());\n     return;\n  }\n\n  base::Optional<std::string> raw_response;\n  if (base64_raw_response.isJust()) {\n    std::string decoded;\n    if (!base::Base64Decode(base64_raw_response.fromJust(), &decoded)) {\n      callback->sendFailure(Response::InvalidParams(\"Invalid rawResponse.\"));\n      return;\n    }\n    raw_response = decoded;\n  }\n\n  base::Optional<net::Error> error;\n  bool mark_as_canceled = false;\n  if (error_reason.isJust()) {\n    bool ok;\n    error = NetErrorFromString(error_reason.fromJust(), &ok);\n    if (!ok) {\n      callback->sendFailure(Response::InvalidParams(\"Invalid errorReason.\"));\n      return;\n    }\n\n    mark_as_canceled = true;\n  }\n\n  interceptor->ContinueInterceptedRequest(\n      interception_id,\n      std::make_unique<DevToolsURLRequestInterceptor::Modifications>(\n          std::move(error), std::move(raw_response), std::move(url),\n          std::move(method), std::move(post_data), std::move(headers),\n          std::move(auth_challenge_response), mark_as_canceled),\n      std::move(callback));\n}\n",
        "target": 1
    },
    {
        "id": 1882,
        "func": "static void DeleteSession( SESSION *session )\n{\n    SESSION_LIST_ENTRY *predSession;\n    void *newNextEntry;\n\n    if( session == &local_sessions_list->session )\n        local_sessions_list = 0;\n    else\n    {\n        // Find predecessor.\n        for( predSession = local_sessions_list;\n                predSession != 0 && &( ( ( SESSION_LIST_ENTRY *)predSession->nextEntry )->session ) != session;\n                predSession = predSession->nextEntry )\n            ;\n\n        if( predSession != 0 )\n        {\n            local_session_entries_used--;\n\n            newNextEntry = &( (SESSION_LIST_ENTRY *)predSession->nextEntry)->nextEntry;\n\n            free( predSession->nextEntry );\n\n            predSession->nextEntry = newNextEntry;\n        }\n    }\n}",
        "target": 0
    },
    {
        "id": 1883,
        "func": "TestSynchronousCompositor::~TestSynchronousCompositor() {\n  SetClient(NULL);\n}\n",
        "target": 0
    },
    {
        "id": 1884,
        "func": "terminate_cib(const char *caller, gboolean fast)\n{\n    if (remote_fd > 0) {\n        close(remote_fd);\n        remote_fd = 0;\n    }\n    if (remote_tls_fd > 0) {\n        close(remote_tls_fd);\n        remote_tls_fd = 0;\n    }\n    \n    if(!fast) {\n        crm_info(\"%s: Disconnecting from cluster infrastructure\", caller);\n        crm_cluster_disconnect(&crm_cluster);\n    }\n\n    uninitializeCib();\n\n    crm_info(\"%s: Exiting%s...\", caller, fast?\" fast\":mainloop?\" from mainloop\":\"\");\n\n    if(fast == FALSE && mainloop != NULL && g_main_is_running(mainloop)) {\n        g_main_quit(mainloop);\n\n    } else {\n        qb_ipcs_destroy(ipcs_ro);\n        qb_ipcs_destroy(ipcs_rw);\n        qb_ipcs_destroy(ipcs_shm);\n\n        if (fast) {\n            crm_exit(EX_USAGE);\n        } else {\n            crm_exit(EX_OK);\n        }\n    }\n}",
        "target": 0
    },
    {
        "id": 1885,
        "func": "void InitManagerMojoOnIO(mojom::DiscardableSharedMemoryManagerPtr* manager_mojo,\n                         mojom::DiscardableSharedMemoryManagerPtrInfo info) {\n  manager_mojo->Bind(std::move(info));\n}\n",
        "target": 0
    },
    {
        "id": 1886,
        "func": "  gfx::NativeViewAccessible GetNativeViewAccessible() {\n    return View::GetNativeViewAccessible();\n  }\n",
        "target": 0
    },
    {
        "id": 1887,
        "func": "void HTMLLinkElement::removedFromDocument()\n{\n    HTMLElement::removedFromDocument();\n\n    document()->removeStyleSheetCandidateNode(this);\n\n     if (document()->renderer())\n         document()->updateStyleSelector();\n    m_shouldProcessAfterAttach = false;\n }\n",
        "target": 1
    },
    {
        "id": 1888,
        "func": "void ImageLoader::DecodeRequest::Trace(blink::Visitor* visitor) {\n  visitor->Trace(resolver_);\n  visitor->Trace(loader_);\n}\n",
        "target": 0
    },
    {
        "id": 1889,
        "func": "static MagickBooleanType WriteJNGImage(const ImageInfo *image_info,\n  Image *image, ExceptionInfo *exception)\n{\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter WriteJNGImage()\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if ((image->columns > 65535UL) || (image->rows > 65535UL))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n\n  /*\n    Allocate a MngInfo structure.\n  */\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n  if (mng_info == (MngInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Initialize members of the MngInfo structure.\n  */\n  (void) memset(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n\n  (void) WriteBlob(image,8,(const unsigned char *) \"\\213JNG\\r\\n\\032\\n\");\n\n  status=WriteOneJNGImage(mng_info,image_info,image,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n  (void) CloseBlob(image);\n\n  (void) CatchImageException(image);\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit WriteJNGImage()\");\n  return(status);\n}",
        "target": 0
    },
    {
        "id": 1890,
        "func": "OMXNodeInstance::OMXNodeInstance(\n        OMX *owner, const sp<IOMXObserver> &observer, const char *name)\n : mOwner(owner),\n      mNodeID(0),\n      mHandle(NULL),\n      mObserver(observer),\n      mDying(false),\n      mBufferIDCount(0)\n{\n    mName = ADebug::GetDebugName(name);\n    DEBUG = ADebug::GetDebugLevelFromProperty(name, \"debug.stagefright.omx-debug\");\n    ALOGV(\"debug level for %s is %d\", name, DEBUG);\n    DEBUG_BUMP = DEBUG;\n    mNumPortBuffers[0] = 0;\n    mNumPortBuffers[1] = 0;\n    mDebugLevelBumpPendingBuffers[0] = 0;\n    mDebugLevelBumpPendingBuffers[1] = 0;\n    mMetadataType[0] = kMetadataBufferTypeInvalid;\n    mMetadataType[1] = kMetadataBufferTypeInvalid;\n    mIsSecure = AString(name).endsWith(\".secure\");\n}\n",
        "target": 0
    },
    {
        "id": 1891,
        "func": "void V8Console::timeEndCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    timeEndFunction(info, false);\n}\n",
        "target": 0
    },
    {
        "id": 1892,
        "func": "setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,\n                                            arg->keyblock);\n    } else {\n        log_unauth(\"kadm5_setv4key_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setv4key_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
        "target": 1
    },
    {
        "id": 1893,
        "func": "void FileAPIMessageFilter::OnOpen(\n    int request_id, const GURL& origin_url, fileapi::FileSystemType type,\n    int64 requested_size, bool create) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n  if (type == fileapi::kFileSystemTypeTemporary) {\n    RecordAction(UserMetricsAction(\"OpenFileSystemTemporary\"));\n  } else if (type == fileapi::kFileSystemTypePersistent) {\n    RecordAction(UserMetricsAction(\"OpenFileSystemPersistent\"));\n  }\n  context_->OpenFileSystem(origin_url, type, create, base::Bind(\n      &FileAPIMessageFilter::DidOpenFileSystem, this, request_id));\n}\n",
        "target": 0
    },
    {
        "id": 1894,
        "func": "display_sigset( const char *msg, sigset_t *mask )\n{\n\tint\t\t\t\t\tsigno;\n        NameTableIterator       next_sig( SigNames );\n \n        if( msg ) {\n               dprintf( D_ALWAYS, msg );\n        }\n        while( (signo = next_sig()) != -1 ) {\n                if( sigismember(mask,signo) ) {\n\t\t\tdprintf( D_ALWAYS | D_NOHEADER, \"%s \", SigNames.get_name(signo) );\n\t\t}\n\t}\n\tdprintf( D_ALWAYS | D_NOHEADER, \"\\n\" );\n}\n",
        "target": 1
    },
    {
        "id": 1895,
        "func": "chunk_message(struct chunk *chunk, const char *message)\n{\n   type_message(chunk->file, chunk->chunk_type, message);\n}\n",
        "target": 0
    },
    {
        "id": 1896,
        "func": "static int ablk_cbc_init(struct crypto_tfm *tfm)\n{\n\treturn ablk_init_common(tfm, \"__driver-cbc-aes-aesni\");\n}",
        "target": 0
    },
    {
        "id": 1897,
        "func": "bool InputDispatcher::isAppSwitchKeyCode(int32_t keyCode) {\n return keyCode == AKEYCODE_HOME\n || keyCode == AKEYCODE_ENDCALL\n || keyCode == AKEYCODE_APP_SWITCH;\n}\n",
        "target": 0
    },
    {
        "id": 1898,
        "func": "vips_foreign_load_gif_dispose( GObject *gobject )\n{\n\tVipsForeignLoadGif *gif = (VipsForeignLoadGif *) gobject;\n\n\tvips_foreign_load_gif_close( gif ); \n\n\tVIPS_UNREF( gif->frame ); \n\tVIPS_UNREF( gif->previous ); \n\tVIPS_FREE( gif->comment ); \n\tVIPS_FREE( gif->line ) \n\n\tG_OBJECT_CLASS( vips_foreign_load_gif_parent_class )->\n\t\tdispose( gobject );\n}",
        "target": 0
    },
    {
        "id": 1899,
        "func": "static void getKeySizes(redisReply *keys, int *types,\n                        unsigned long long *sizes)\n{\n    redisReply *reply;\n    char *sizecmds[] = {\"STRLEN\",\"LLEN\",\"SCARD\",\"HLEN\",\"ZCARD\"};\n    unsigned int i;\n\n    /* Pipeline size commands */\n    for(i=0;i<keys->elements;i++) {\n        /* Skip keys that were deleted */\n        if(types[i]==TYPE_NONE)\n            continue;\n\n        redisAppendCommand(context, \"%s %s\", sizecmds[types[i]],\n            keys->element[i]->str);\n    }\n\n    /* Retreive sizes */\n    for(i=0;i<keys->elements;i++) {\n        /* Skip keys that dissapeared between SCAN and TYPE */\n        if(types[i] == TYPE_NONE) {\n            sizes[i] = 0;\n            continue;\n        }\n\n        /* Retreive size */\n        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {\n            fprintf(stderr, \"Error getting size for key '%s' (%d: %s)\\n\",\n                keys->element[i]->str, context->err, context->errstr);\n            exit(1);\n        } else if(reply->type != REDIS_REPLY_INTEGER) {\n            /* Theoretically the key could have been removed and\n             * added as a different type between TYPE and SIZE */\n            fprintf(stderr,\n                \"Warning:  %s on '%s' failed (may have changed type)\\n\",\n                 sizecmds[types[i]], keys->element[i]->str);\n            sizes[i] = 0;\n        } else {\n            sizes[i] = reply->integer;\n        }\n\n        freeReplyObject(reply);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1900,
        "func": "static void cstmlist(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tcstm(J, F, list->a);\n\t\tlist = list->b;\n\t}\n}",
        "target": 0
    },
    {
        "id": 1901,
        "func": "static void hns_ppe_set_port_mode(struct hns_ppe_cb *ppe_cb,\n\t\t\t\t  enum ppe_port_mode mode)\n{\n\tdsaf_write_dev(ppe_cb, PPE_CFG_XGE_MODE_REG, mode);\n}",
        "target": 0
    },
    {
        "id": 1902,
        "func": "bool RenderWidgetHostImpl::IsFullscreen() const {\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 1903,
        "func": "static int iwgif_read_screen_descriptor(struct iwgifrcontext *rctx)\n{\n\tint has_global_ct;\n\tint global_ct_size;\n\tint aspect_ratio_code;\n\n\t// The screen descriptor is always 7 bytes in size.\n\tif(!iwgif_read(rctx,rctx->rbuf,7)) return 0;\n\trctx->screen_width = (int)iw_get_ui16le(&rctx->rbuf[0]);\n\trctx->screen_height = (int)iw_get_ui16le(&rctx->rbuf[2]);\n\t// screen_width and _height may be updated in iwgif_init_screen().\n\n\thas_global_ct = (int)((rctx->rbuf[4]>>7)&0x01);\n\n\tif(has_global_ct) {\n\t\t// Size of global color table\n\t\tglobal_ct_size = (int)(rctx->rbuf[4]&0x07);\n\t\trctx->colortable.num_entries = 1<<(1+global_ct_size);\n\n\t\t// Background color\n\t\trctx->bg_color_index = (int)rctx->rbuf[5];\n\t\tif(rctx->bg_color_index < rctx->colortable.num_entries)\n\t\t\trctx->has_bg_color = 1;\n\t}\n\n\taspect_ratio_code = (int)rctx->rbuf[6];\n\tif(aspect_ratio_code!=0) {\n\t\t// [aspect ratio = (pixel width)/(pixel height)]\n\t\trctx->img->density_code = IW_DENSITY_UNITS_UNKNOWN;\n\t\trctx->img->density_x = 64000.0/(double)(aspect_ratio_code + 15);\n\t\trctx->img->density_y = 1000.0;\n\t}\n\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 1904,
        "func": "str_matches_option(const char *s1, const char *optionname)\n{\n\t/* Option names are given as \"option:\" We accept either 'option' in\n\t * s1, or 'option:randomjunk'.  The latter form is to implement the\n\t * resolv.conf parser. */\n\tsize_t optlen = strlen(optionname);\n\tsize_t slen = strlen(s1);\n\tif (slen == optlen || slen == optlen - 1)\n\t\treturn !strncmp(s1, optionname, slen);\n\telse if (slen > optlen)\n\t\treturn !strncmp(s1, optionname, optlen);\n\telse\n\t\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1905,
        "func": "static uint8_t *extend_raw_data(LHAFileHeader **header,\n                                LHAInputStream *stream,\n                                size_t nbytes)\n{\n\tLHAFileHeader *new_header;\n\tsize_t new_raw_len;\n\tuint8_t *result;\n\n\t// Reallocate the header and raw_data area to be larger.\n\n\tnew_raw_len = RAW_DATA_LEN(header) + nbytes;\n\tnew_header = realloc(*header, sizeof(LHAFileHeader) + new_raw_len);\n\n\tif (new_header == NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Update the header pointer to point to the new area.\n\n\t*header = new_header;\n\tnew_header->raw_data = (uint8_t *) (new_header + 1);\n\tresult = new_header->raw_data + new_header->raw_data_len;\n\n\t// Read data from stream into new area.\n\n\tif (!lha_input_stream_read(stream, result, nbytes)) {\n\t\treturn NULL;\n\t}\n\n\tnew_header->raw_data_len = new_raw_len;\n\n\treturn result;\n}",
        "target": 1
    },
    {
        "id": 1906,
        "func": "MediaStreamManager::~MediaStreamManager() {\n  DCHECK(!BrowserThread::IsThreadInitialized(BrowserThread::IO));\n  DVLOG(1) << \"~MediaStreamManager\";\n  DCHECK(requests_.empty());\n\n  base::PowerMonitor* power_monitor = base::PowerMonitor::Get();\n  if (power_monitor)\n    power_monitor->RemoveObserver(this);\n}\n",
        "target": 0
    },
    {
        "id": 1907,
        "func": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(hash_slot);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 1908,
        "func": "void swallow_arg(int *argcp, char *argv[], char *which)\n{\n\tint i;\n\n\tfor (i = 1; argv[i]; i++) {\n\t\tif (strcmp(argv[i], which) != 0)\n\t\t\tcontinue;\n\t\tfor (; argv[i]; i++) {\n\t\t\targv[i] = argv[i+1];\n\t\t}\n\t\t(*argcp)--;\n\t\treturn;\n\t}\n}",
        "target": 0
    },
    {
        "id": 1909,
        "func": "  void Play() {\n    host_->OnPlayStream(kStreamId);\n    SyncWithAudioThread();\n  }\n",
        "target": 0
    },
    {
        "id": 1910,
        "func": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n     for (i = 0; i < 5; i++)\n         s->response[i] = qemu_get_be32(f);\n     s->arglen = qemu_get_be32(f);\n     s->response_pos = qemu_get_be32(f);\n     s->stopping = qemu_get_be32(f);\n \n     ss->cs = qemu_get_be32(f);\n    s->mode = SSI_SD_CMD;\n    dinfo = drive_get_next(IF_SD);\n    s->sd = sd_init(dinfo ? dinfo->bdrv : NULL, true);\n    if (s->sd == NULL) {\n        return -1;\n    }\n    register_savevm(dev, \"ssi_sd\", -1, 1, ssi_sd_save, ssi_sd_load, s);\n    return 0;\n}\n",
        "target": 1
    },
    {
        "id": 1911,
        "func": "UserImageView* OobeUI::GetUserImageView() {\n  return user_image_view_;\n}\n",
        "target": 0
    },
    {
        "id": 1912,
        "func": "static void ncq_finish(NCQTransferState *ncq_tfs)\n{\n    /* If we didn't error out, set our finished bit. Errored commands\n     * do not get a bit set for the SDB FIS ACT register, nor do they\n     * clear the outstanding bit in scr_act (PxSACT). */\n    if (!(ncq_tfs->drive->port_regs.scr_err & (1 << ncq_tfs->tag))) {\n        ncq_tfs->drive->finished |= (1 << ncq_tfs->tag);\n    }\n\n    ahci_write_fis_sdb(ncq_tfs->drive->hba, ncq_tfs);\n\n    DPRINTF(ncq_tfs->drive->port_no, \"NCQ transfer tag %d finished\\n\",\n            ncq_tfs->tag);\n\n    block_acct_done(blk_get_stats(ncq_tfs->drive->port.ifs[0].blk),\n                    &ncq_tfs->acct);\n    qemu_sglist_destroy(&ncq_tfs->sglist);\n    ncq_tfs->used = 0;\n}\n",
        "target": 0
    },
    {
        "id": 1913,
        "func": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n\t/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n\t   remove the evil cast below. */\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\tpx->ft->data = px;\n\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}",
        "target": 1
    },
    {
        "id": 1914,
        "func": "_warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)\n{\n\tstruct warc_s *w = a->format->data;\n\tconst char *rab;\n\tssize_t nrd;\n\n\tif (w->cntoff >= w->cntlen) {\n\teof:\n\t\t/* it's our lucky day, no work, we can leave early */\n\t\t*buf = NULL;\n\t\t*bsz = 0U;\n\t\t*off = w->cntoff + 4U/*for \\r\\n\\r\\n separator*/;\n\t\tw->unconsumed = 0U;\n \t\treturn (ARCHIVE_EOF);\n \t}\n \n \trab = __archive_read_ahead(a, 1U, &nrd);\n \tif (nrd < 0) {\n \t\t*bsz = 0U;\n\t\t/* big catastrophe */\n\t\treturn (int)nrd;\n\t} else if (nrd == 0) {\n\t\tgoto eof;\n\t} else if ((size_t)nrd > w->cntlen - w->cntoff) {\n\t\t/* clamp to content-length */\n\t\tnrd = w->cntlen - w->cntoff;\n\t}\n\t*off = w->cntoff;\n\t*bsz = nrd;\n\t*buf = rab;\n\n\tw->cntoff += nrd;\n\tw->unconsumed = (size_t)nrd;\n\treturn (ARCHIVE_OK);\n}\n",
        "target": 1
    },
    {
        "id": 1915,
        "func": "static int FLTHasUniqueTopLevelDuringFilter(FilterEncodingNode *psFilterNode)\n{\n  int nCount = 0;\n\n  if (!psFilterNode || !psFilterNode->pszValue)\n    return 1;\n\n  nCount = FLTNumberOfFilterType(psFilterNode, \"During\");\n\n  if (nCount > 1)\n    return 0;\n  else if (nCount == 0)\n    return 1;\n\n  /* nCount ==1  */\n  if (strcasecmp(psFilterNode->pszValue, \"During\") == 0)\n    return 1;\n\n  if (strcasecmp(psFilterNode->pszValue, \"AND\") == 0) {\n    return FLTHasUniqueTopLevelDuringFilter(psFilterNode->psLeftNode) &&\n           FLTHasUniqueTopLevelDuringFilter(psFilterNode->psRightNode);\n  }\n\n  return 0;\n}",
        "target": 0
    },
    {
        "id": 1916,
        "func": "    void doWriteWebCoreString(const String& string)\n    {\n        StringUTF8Adaptor stringUTF8(string);\n        doWriteString(stringUTF8.data(), stringUTF8.length());\n    }\n",
        "target": 0
    },
    {
        "id": 1917,
        "func": "ProcRenderCreatePicture (ClientPtr client)\n{\n    PicturePtr\t    pPicture;\n    DrawablePtr\t    pDrawable;\n    PictFormatPtr   pFormat;\n    int\t\t    len, error, rc;\n    REQUEST(xRenderCreatePictureReq);\n\n    REQUEST_AT_LEAST_SIZE(xRenderCreatePictureReq);\n\n    LEGAL_NEW_RESOURCE(stuff->pid, client);\n    rc = dixLookupDrawable(&pDrawable, stuff->drawable, client, 0,\n\t\t\t   DixReadAccess|DixAddAccess);\n    if (rc != Success)\n\treturn rc;\n\n    rc = dixLookupResourceByType((pointer *)&pFormat, stuff->format,\n\t\t\t\t PictFormatType, client, DixReadAccess);\n    if (rc != Success)\n\treturn rc;\n\n    if (pFormat->depth != pDrawable->depth)\n\treturn BadMatch;\n    len = client->req_len - bytes_to_int32(sizeof(xRenderCreatePictureReq));\n    if (Ones(stuff->mask) != len)\n\treturn BadLength;\n    \n    pPicture = CreatePicture (stuff->pid,\n\t\t\t      pDrawable,\n\t\t\t      pFormat,\n\t\t\t      stuff->mask,\n\t\t\t      (XID *) (stuff + 1),\n\t\t\t      client,\n\t\t\t      &error);\n    if (!pPicture)\n\treturn error;\n    if (!AddResource (stuff->pid, PictureType, (pointer)pPicture))\n\treturn BadAlloc;\n    return Success;\n}\n",
        "target": 0
    },
    {
        "id": 1918,
        "func": " ConnectionToClient::~ConnectionToClient() {\n }\n",
        "target": 1
    },
    {
        "id": 1919,
        "func": "WindowStateType TabletModeWindowState::GetSnappedWindowStateType(\n    wm::WindowState* window_state,\n    WindowStateType target_state) {\n  DCHECK(target_state == WindowStateType::kLeftSnapped ||\n         target_state == WindowStateType::kRightSnapped);\n  return CanSnapInSplitview(window_state->window())\n             ? target_state\n             : GetMaximizedOrCenteredWindowType(window_state);\n}\n",
        "target": 0
    },
    {
        "id": 1920,
        "func": "OMX_ERRORTYPE omx_vdec::is_video_session_supported()\n{\n if (!strncmp(drv_ctx.kind, \"OMX.qcom.video.decoder.avc\",\n                OMX_MAX_STRINGNAME_SIZE) &&\n (m_profile == HIGH_PROFILE || m_profile == MAIN_PROFILE)) {\n        m_decoder_capability.max_width = 1280;\n        m_decoder_capability.max_height = 720;\n        DEBUG_PRINT_HIGH(\"Set max_width=1280 & max_height=720 for H264 HP/MP\");\n }\n\n if ((drv_ctx.video_resolution.frame_width *\n                drv_ctx.video_resolution.frame_height >\n                m_decoder_capability.max_width *\n                m_decoder_capability.max_height) ||\n (drv_ctx.video_resolution.frame_width*\n             drv_ctx.video_resolution.frame_height <\n             m_decoder_capability.min_width *\n             m_decoder_capability.min_height)) {\n        DEBUG_PRINT_ERROR(\n \"Unsupported WxH = (%u)x(%u) supported range is min(%u)x(%u) - max(%u)x(%u)\",\n                drv_ctx.video_resolution.frame_width,\n                drv_ctx.video_resolution.frame_height,\n                m_decoder_capability.min_width,\n                m_decoder_capability.min_height,\n                m_decoder_capability.max_width,\n                m_decoder_capability.max_height);\n return OMX_ErrorUnsupportedSetting;\n }\n    DEBUG_PRINT_HIGH(\"video session supported\");\n return OMX_ErrorNone;\n}\n",
        "target": 0
    },
    {
        "id": 1921,
        "func": "void ConfirmEmailDialogDelegate::OnCanceled() {\n  base::ResetAndReturn(&callback_).Run(\n      IDS_ONE_CLICK_SIGNIN_CONFIRM_EMAIL_DIALOG_CANCEL_BUTTON);\n}\n",
        "target": 0
    },
    {
        "id": 1922,
        "func": "int o2nm_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n}",
        "target": 0
    },
    {
        "id": 1923,
        "func": "bool ExtensionApiTest::RunExtensionTestWithArg(\n    const std::string& extension_name,\n    const char* custom_arg) {\n  return RunExtensionTestImpl(extension_name, std::string(), custom_arg,\n                              kFlagEnableFileAccess);\n}\n",
        "target": 0
    },
    {
        "id": 1924,
        "func": "IntPoint WebPagePrivate::calculateReflowedScrollPosition(const FloatPoint& anchorOffset, double inverseScale)\n{\n    ASSERT(m_webPage->settings()->textReflowMode() == WebSettings::TextReflowEnabled);\n\n    int offsetY = 0;\n    int offsetX = 0;\n\n    IntRect nodeRect = rectForNode(m_currentPinchZoomNode.get());\n\n    if (m_currentPinchZoomNode->renderer() && m_anchorInNodeRectRatio.y() >= 0) {\n        offsetY = nodeRect.height() * m_anchorInNodeRectRatio.y();\n        if (m_currentPinchZoomNode->renderer()->isImage() && m_anchorInNodeRectRatio.x() > 0)\n            offsetX = nodeRect.width() * m_anchorInNodeRectRatio.x() - anchorOffset.x() / inverseScale;\n    }\n\n    IntRect reflowedRect = adjustRectOffsetForFrameOffset(nodeRect, m_currentPinchZoomNode.get());\n\n    return IntPoint(max(0, static_cast<int>(roundf(reflowedRect.x() + offsetX))),\n                    max(0, static_cast<int>(roundf(reflowedRect.y() + offsetY - anchorOffset.y() / inverseScale))));\n}\n",
        "target": 0
    },
    {
        "id": 1925,
        "func": "void TabStripModel::SetInsertionPolicy(InsertionPolicy policy) {\n  order_controller_->set_insertion_policy(policy);\n}\n",
        "target": 0
    },
    {
        "id": 1926,
        "func": "status_t OMX::updateGraphicBufferInMeta(\n        node_id node, OMX_U32 port_index,\n const sp<GraphicBuffer> &graphicBuffer, buffer_id buffer) {\n return findInstance(node)->updateGraphicBufferInMeta(\n            port_index, graphicBuffer, buffer);\n}\n",
        "target": 0
    },
    {
        "id": 1927,
        "func": "rend_service_path(const rend_service_t *service, const char *file_name)\n{\n  char *file_path = NULL;\n\n  tor_assert(service->directory);\n\n  /* Can never fail: asserts rather than leaving file_path NULL. */\n  tor_asprintf(&file_path, \"%s%s%s\",\n               service->directory, PATH_SEPARATOR, file_name);\n\n  return file_path;\n}",
        "target": 0
    },
    {
        "id": 1928,
        "func": "bool GetNetworkList(NetworkInterfaceList* networks, int policy) {\nIPAddress NetAddressToIPAddress(const netstack::NetAddress& addr) {\n  if (addr.ipv4) {\n    return IPAddress(addr.ipv4->addr.data(), addr.ipv4->addr.count());\n   }\n  if (addr.ipv6) {\n    return IPAddress(addr.ipv6->addr.data(), addr.ipv6->addr.count());\n   }\n  return IPAddress();\n}\n \nbool GetNetworkList(NetworkInterfaceList* networks, int policy) {\n  netstack::NetstackSyncPtr netstack =\n      base::fuchsia::ComponentContext::GetDefault()\n          ->ConnectToServiceSync<netstack::Netstack>();\n \n  fidl::VectorPtr<netstack::NetInterface> interfaces;\n  if (!netstack->GetInterfaces(&interfaces))\n    return false;\n \n  for (auto& interface : interfaces.get()) {\n    // Check if the interface is up.\n    if (!(interface.flags & netstack::NetInterfaceFlagUp))\n       continue;\n \n    // Skip loopback.\n    if (interface.features & netstack::interfaceFeatureLoopback)\n       continue;\n \n    NetworkChangeNotifier::ConnectionType connection_type =\n        (interface.features & netstack::interfaceFeatureWlan)\n            ? NetworkChangeNotifier::CONNECTION_WIFI\n            : NetworkChangeNotifier::CONNECTION_UNKNOWN;\n \n    // addresses. Currently Netstack doesn't provide this information.\n     int attributes = 0;\n \n    networks->push_back(NetworkInterface(\n        *interface.name, *interface.name, interface.id, connection_type,\n        NetAddressToIPAddress(interface.addr),\n        MaskPrefixLength(NetAddressToIPAddress(interface.netmask)),\n        attributes));\n   }\n \n   return true;\n }\n",
        "target": 0
    },
    {
        "id": 1929,
        "func": "R_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char * arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\t/* Hack to make baddr work on some corner */\n\t\tr_config_set_i (r->config, \"io.va\",\n\t\t\t(binobj->info)? binobj->info->has_va: 0);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "target": 1
    },
    {
        "id": 1930,
        "func": "static void VoidMethodDoubleOrLongOrBooleanSequenceArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"voidMethodDoubleOrLongOrBooleanSequenceArg\");\n\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n    return;\n  }\n\n  DoubleOrLongOrBooleanSequence arg;\n  V8DoubleOrLongOrBooleanSequence::ToImpl(info.GetIsolate(), info[0], arg, UnionTypeConversionMode::kNotNullable, exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->voidMethodDoubleOrLongOrBooleanSequenceArg(arg);\n}\n",
        "target": 0
    },
    {
        "id": 1931,
        "func": "void nf_tables_unbind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t  struct nft_set_binding *binding)\n{\n\tlist_del_rcu(&binding->list);\n\n\tif (list_empty(&set->bindings) && set->flags & NFT_SET_ANONYMOUS &&\n\t    !(set->flags & NFT_SET_INACTIVE))\n\t\tnf_tables_set_destroy(ctx, set);\n}",
        "target": 0
    },
    {
        "id": 1932,
        "func": "mac_deinit (digest_hd_st *td, opaque * res, int ver)\n{\n  if (ver == GNUTLS_SSL3)\n    {\t\t\t\t/* SSL 3.0 */\n      _gnutls_mac_deinit_ssl3 (td, res);\n    }\n  else\n    {\n      _gnutls_hmac_deinit (td, res);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 1933,
        "func": "GF_Err npck_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_NPCKBox *ptr = (GF_NPCKBox *)s;\n\tptr->nbPackets = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 1934,
        "func": " WorkerProcessLauncherTest::WorkerProcessLauncherTest()\n    : message_loop_(MessageLoop::TYPE_IO) {\n }\n",
        "target": 1
    },
    {
        "id": 1935,
        "func": "bool DirectoryBackingStore::LoadInfo(Directory::KernelLoadInfo* info) {\n  {\n    sqlite_utils::SQLStatement query;\n    query.prepare(load_dbhandle_,\n                  \"SELECT store_birthday, next_id, cache_guid, \"\n                  \"notification_state \"\n                  \"FROM share_info\");\n    if (SQLITE_ROW != query.step())\n      return false;\n    info->kernel_info.store_birthday = query.column_string(0);\n    info->kernel_info.next_id = query.column_int64(1);\n    info->cache_guid = query.column_string(2);\n    query.column_blob_as_string(3, &info->kernel_info.notification_state);\n  }\n  {\n    sqlite_utils::SQLStatement query;\n    query.prepare(load_dbhandle_,\n        \"SELECT model_id, progress_marker, initial_sync_ended \"\n        \"FROM models\");\n    while (SQLITE_ROW == query.step()) {\n      ModelType type = ModelIdToModelTypeEnum(query.column_blob(0),\n                                              query.column_bytes(0));\n      if (type != UNSPECIFIED && type != TOP_LEVEL_FOLDER) {\n        info->kernel_info.download_progress[type].ParseFromArray(\n            query.column_blob(1), query.column_bytes(1));\n        info->kernel_info.initial_sync_ended[type] = query.column_bool(2);\n      }\n    }\n  }\n  {\n    sqlite_utils::SQLStatement query;\n    query.prepare(load_dbhandle_,\n                  \"SELECT MAX(metahandle) FROM metas\");\n    if (SQLITE_ROW != query.step())\n      return false;\n    info->max_metahandle = query.column_int64(0);\n  }\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 1936,
        "func": "void WebPluginImpl::didReceiveResponse(WebURLLoader* loader,\n                                       const WebURLResponse& response) {\n  static const int kHttpPartialResponseStatusCode = 206;\n  static const int kHttpResponseSuccessStatusCode = 200;\n\n  WebPluginResourceClient* client = GetClientFromLoader(loader);\n  if (!client)\n    return;\n\n  ResponseInfo response_info;\n  GetResponseInfo(response, &response_info);\n\n  bool request_is_seekable = true;\n  if (client->IsMultiByteResponseExpected()) {\n    if (response.httpStatusCode() == kHttpPartialResponseStatusCode) {\n      HandleHttpMultipartResponse(response, client);\n      return;\n    } else if (response.httpStatusCode() == kHttpResponseSuccessStatusCode) {\n      if (!ReinitializePluginForResponse(loader)) {\n        NOTREACHED();\n        return;\n      }\n\n      request_is_seekable = false;\n\n      delete client;\n      client = NULL;\n\n       for (size_t i = 0; i < clients_.size(); ++i) {\n         if (clients_[i].loader.get() == loader) {\n           WebPluginResourceClient* resource_client =\n              delegate_->CreateResourceClient(clients_[i].id, plugin_url_,\n                                              false, 0, NULL);\n           clients_[i].client = resource_client;\n           client = resource_client;\n           break;\n        }\n      }\n\n      DCHECK(client != NULL);\n    }\n  }\n\n  loader->setDefersLoading(true);\n\n  client->DidReceiveResponse(\n      response_info.mime_type,\n      GetAllHeaders(response),\n      response_info.expected_length,\n      response_info.last_modified,\n      request_is_seekable);\n\n  if (WebDevToolsAgent* devtools_agent = GetDevToolsAgent()) {\n    ClientInfo* client_info = GetClientInfoFromLoader(loader);\n    if (client_info)\n      devtools_agent->didReceiveResponse(client_info->id, response);\n  }\n\n  const GURL& url = response.url();\n  if (url.SchemeIs(\"http\") || url.SchemeIs(\"https\")) {\n    if (response.httpStatusCode() < 100 || response.httpStatusCode() >= 400) {\n      ClientInfo* client_info = GetClientInfoFromLoader(loader);\n      if (client_info) {\n        client_info->pending_failure_notification = true;\n      }\n    }\n  }\n}\n",
        "target": 1
    },
    {
        "id": 1937,
        "func": "TransferType ConvertTransferTypeToApi(const UsbTransferType& input) {\n  switch (input) {\n    case device::USB_TRANSFER_CONTROL:\n      return usb::TRANSFER_TYPE_CONTROL;\n    case device::USB_TRANSFER_INTERRUPT:\n      return usb::TRANSFER_TYPE_INTERRUPT;\n    case device::USB_TRANSFER_ISOCHRONOUS:\n      return usb::TRANSFER_TYPE_ISOCHRONOUS;\n    case device::USB_TRANSFER_BULK:\n      return usb::TRANSFER_TYPE_BULK;\n    default:\n      NOTREACHED();\n      return usb::TRANSFER_TYPE_NONE;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 1938,
        "func": "static inline bool isHTTPOrHTTPSScheme(WKStringRef scheme)\n{\n    return WKStringIsEqualToUTF8CStringIgnoringCase(scheme, \"http\") || WKStringIsEqualToUTF8CStringIgnoringCase(scheme, \"https\");\n}\n",
        "target": 0
    },
    {
        "id": 1939,
        "func": "static int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some impementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        perror(\"bind()\");\n        close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        perror(\"listen()\");\n        close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base))) {\n        fprintf(stderr, \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    return 0;\n}",
        "target": 0
    },
    {
        "id": 1940,
        "func": "meter_update(struct meter *meter, const struct ofputil_meter_config *config)\n{\n    free(meter->bands);\n\n    meter->flags = config->flags;\n    meter->n_bands = config->n_bands;\n    meter->bands = xmemdup(config->bands,\n                           config->n_bands * sizeof *meter->bands);\n}\n",
        "target": 0
    },
    {
        "id": 1941,
        "func": "void TestingAutomationProvider::GetRedirectsFrom(int tab_handle,\n                                                 const GURL& source_url,\n                                                 IPC::Message* reply_message) {\n  if (redirect_query_) {\n    LOG(ERROR) << \"Can only handle one redirect query at once.\";\n  } else if (tab_tracker_->ContainsHandle(tab_handle)) {\n    NavigationController* tab = tab_tracker_->GetResource(tab_handle);\n    Profile* profile = Profile::FromBrowserContext(tab->GetBrowserContext());\n    HistoryService* history_service =\n        profile->GetHistoryService(Profile::EXPLICIT_ACCESS);\n\n    DCHECK(history_service) << \"Tab \" << tab_handle << \"'s profile \" <<\n                               \"has no history service\";\n    if (history_service) {\n      DCHECK(!reply_message_);\n      reply_message_ = reply_message;\n      redirect_query_ = history_service->QueryRedirectsFrom(\n          source_url, &consumer_,\n          base::Bind(&TestingAutomationProvider::OnRedirectQueryComplete,\n                     base::Unretained(this)));\n      return;  // Response will be sent when query completes.\n    }\n  }\n\n  std::vector<GURL> empty;\n  AutomationMsg_RedirectsFrom::WriteReplyParams(reply_message, false, empty);\n  Send(reply_message);\n}\n",
        "target": 0
    },
    {
        "id": 1942,
        "func": "static IHEVCD_ERROR_T ihevcd_parse_profile_tier_level_layer(bitstrm_t *ps_bitstrm,\n profile_tier_lvl_t *ps_ptl)\n{\n    WORD32 value;\n    WORD32 i;\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n\n    BITS_PARSE(\"XXX_profile_space[]\", value, ps_bitstrm, 2);\n    ps_ptl->i1_profile_space = value;\n\n    BITS_PARSE(\"XXX_tier_flag[]\", value, ps_bitstrm, 1);\n    ps_ptl->i1_tier_flag = value;\n\n    BITS_PARSE(\"XXX_profile_idc[]\", value, ps_bitstrm, 5);\n    ps_ptl->i1_profile_idc = value;\n\n for(i = 0; i < MAX_PROFILE_COMPATBLTY; i++)\n {\n        BITS_PARSE(\"XXX_profile_compatibility_flag[][j]\", value, ps_bitstrm, 1);\n        ps_ptl->ai1_profile_compatibility_flag[i] = value;\n }\n\n    BITS_PARSE(\"general_progressive_source_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_progressive_source_flag = value;\n\n    BITS_PARSE(\"general_interlaced_source_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_interlaced_source_flag = value;\n\n    BITS_PARSE(\"general_non_packed_constraint_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_non_packed_constraint_flag = value;\n\n    BITS_PARSE(\"general_frame_only_constraint_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_frame_only_constraint_flag = value;\n\n    BITS_PARSE(\"XXX_reserved_zero_44bits[0..15]\", value, ps_bitstrm, 16);\n\n    BITS_PARSE(\"XXX_reserved_zero_44bits[16..31]\", value, ps_bitstrm, 16);\n\n    BITS_PARSE(\"XXX_reserved_zero_44bits[32..43]\", value, ps_bitstrm, 12);\n return ret;\n}\n",
        "target": 0
    },
    {
        "id": 1943,
        "func": "Segment::Segment(\n    IMkvReader* pReader,\n    long long elem_start,\n    long long start,\n    long long size) :\n    m_pReader(pReader),\n    m_element_start(elem_start),\n    m_start(start),\n    m_size(size),\n    m_pos(start),\n    m_pUnknownSize(0),\n    m_pSeekHead(NULL),\n    m_pInfo(NULL),\n    m_pTracks(NULL),\n    m_pCues(NULL),\n    m_pChapters(NULL),\n    m_clusters(NULL),\n    m_clusterCount(0),\n    m_clusterPreloadCount(0),\n    m_clusterSize(0)\n{\n}\n",
        "target": 1
    },
    {
        "id": 1944,
        "func": "PHP_FUNCTION(pg_last_error)\n{\n\tphp_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_ERROR_MESSAGE);\n}\n",
        "target": 0
    },
    {
        "id": 1945,
        "func": "static int __init net_secret_init(void)\n{\n\tget_random_bytes(net_secret, sizeof(net_secret));\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1946,
        "func": "static void k90_cleanup_backlight(struct hid_device *dev)\n{\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\n\tif (drvdata->backlight) {\n\t\tdrvdata->backlight->removed = true;\n\t\tled_classdev_unregister(&drvdata->backlight->cdev);\n\t\tcancel_work_sync(&drvdata->backlight->work);\n\t\tkfree(drvdata->backlight->cdev.name);\n\t\tkfree(drvdata->backlight);\n\t}\n}",
        "target": 0
    },
    {
        "id": 1947,
        "func": "size_t GraphicBuffer::getFdCount() const {\n return handle ? handle->numFds : 0;\n}\n",
        "target": 0
    },
    {
        "id": 1948,
        "func": "static const char *set_errorlog_format(cmd_parms *cmd, void *dummy,\n                                       const char *arg1, const char *arg2)\n{\n    const char *err_string = NULL;\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (!arg2) {\n        conf->error_log_format = parse_errorlog_string(cmd->pool, arg1,\n                                                       &err_string, 1);\n    }\n    else if (!ap_cstr_casecmp(arg1, \"connection\")) {\n        if (!conf->error_log_conn) {\n            conf->error_log_conn = apr_array_make(cmd->pool, 5,\n                                                  sizeof(apr_array_header_t *));\n        }\n\n        if (*arg2) {\n            apr_array_header_t **e;\n            e = (apr_array_header_t **) apr_array_push(conf->error_log_conn);\n            *e = parse_errorlog_string(cmd->pool, arg2, &err_string, 0);\n        }\n    }\n    else if (!ap_cstr_casecmp(arg1, \"request\")) {\n        if (!conf->error_log_req) {\n            conf->error_log_req = apr_array_make(cmd->pool, 5,\n                                                 sizeof(apr_array_header_t *));\n        }\n\n        if (*arg2) {\n            apr_array_header_t **e;\n            e = (apr_array_header_t **) apr_array_push(conf->error_log_req);\n            *e = parse_errorlog_string(cmd->pool, arg2, &err_string, 0);\n        }\n    }\n    else {\n        err_string = \"ErrorLogFormat type must be one of request, connection\";\n    }\n\n    return err_string;\n}\n",
        "target": 0
    },
    {
        "id": 1949,
        "func": "ftrace_mod_callback(struct ftrace_hash *hash,\n\t\t    char *func, char *cmd, char *param, int enable)\n{\n\tchar *mod;\n\tint ret = -EINVAL;\n\n\t/*\n\t * cmd == 'mod' because we only registered this func\n\t * for the 'mod' ftrace_func_command.\n\t * But if you register one func with multiple commands,\n\t * you can tell which command was used by the cmd\n\t * parameter.\n\t */\n\n\t/* we must have a module name */\n\tif (!param)\n\t\treturn ret;\n\n\tmod = strsep(&param, \":\");\n\tif (!strlen(mod))\n\t\treturn ret;\n\n\tret = ftrace_match_module_records(hash, func, mod);\n\tif (!ret)\n\t\tret = -EINVAL;\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1950,
        "func": "static struct net_device * __init ipddp_init(void)\n{\n\tstatic unsigned version_printed;\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = alloc_etherdev(0);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnetif_keep_dst(dev);\n\tstrcpy(dev->name, \"ipddp%d\");\n\n\tif (version_printed++ == 0)\n                printk(version);\n\n\t/* Initialize the device structure. */\n\tdev->netdev_ops = &ipddp_netdev_ops;\n\n        dev->type = ARPHRD_IPDDP;       \t/* IP over DDP tunnel */\n        dev->mtu = 585;\n        dev->flags |= IFF_NOARP;\n\n        /*\n         *      The worst case header we will need is currently a\n         *      ethernet header (14 bytes) and a ddp header (sizeof ddpehdr+1)\n         *      We send over SNAP so that takes another 8 bytes.\n         */\n        dev->hard_header_len = 14+8+sizeof(struct ddpehdr)+1;\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* Let the user now what mode we are in */\n\tif(ipddp_mode == IPDDP_ENCAP)\n\t\tprintk(\"%s: Appletalk-IP Encap. mode by Bradford W. Johnson <johns393@maroon.tc.umn.edu>\\n\", \n\t\t\tdev->name);\n\tif(ipddp_mode == IPDDP_DECAP)\n\t\tprintk(\"%s: Appletalk-IP Decap. mode by Jay Schulist <jschlst@samba.org>\\n\", \n\t\t\tdev->name);\n\n        return dev;\n}",
        "target": 0
    },
    {
        "id": 1951,
        "func": "static void mp_send_xchar(struct tty_struct *tty, char ch)\n{\n\tstruct sb_uart_state *state = tty->driver_data;\n\tstruct sb_uart_port *port = state->port;\n\tunsigned long flags;\n\n\tif (port->ops->send_xchar)\n\t\tport->ops->send_xchar(port, ch);\n\telse {\n\t\tport->x_char = ch;\n\t\tif (ch) {\n\t\t\tspin_lock_irqsave(&port->lock, flags);\n\t\t\tport->ops->start_tx(port);\n\t\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 1952,
        "func": "static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 8, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 1953,
        "func": "void Document::loadPluginsSoon()\n{\n    if (!m_pluginLoadingTimer.isActive())\n        m_pluginLoadingTimer.startOneShot(0, BLINK_FROM_HERE);\n}\n",
        "target": 0
    },
    {
        "id": 1954,
        "func": "v8::Handle<v8::Value> V8DataView::setInt8Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.DataView.setInt8\");\n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     DataView* imp = V8DataView::toNative(args.Holder());\n     ExceptionCode ec = 0;\n    EXCEPTION_BLOCK(unsigned, byteOffset, toUInt32(args[0]));\n    EXCEPTION_BLOCK(int, value, toInt32(args[1]));\n    imp->setInt8(byteOffset, static_cast<int8_t>(value), ec);\n    if (UNLIKELY(ec))\n        V8Proxy::setDOMException(ec, args.GetIsolate());\n    return v8::Handle<v8::Value>();\n}\n",
        "target": 1
    },
    {
        "id": 1955,
        "func": "validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct pmu_hw_events fake_pmu;\n\tDECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);\n\n\t/*\n\t * Initialise the fake PMU. We only need to populate the\n\t * used_mask for the purposes of validation.\n\t */\n\tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n\tfake_pmu.used_mask = fake_used_mask;\n\n\tif (!validate_event(&fake_pmu, leader))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n\t\tif (!validate_event(&fake_pmu, sibling))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!validate_event(&fake_pmu, event))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 1956,
        "func": "int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\txcr0 = xcr;\n\tif (!(xcr0 & XSTATE_FP))\n\t\treturn 1;\n\tif ((xcr0 & XSTATE_YMM) && !(xcr0 & XSTATE_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see fx_init).\n\t */\n\tvalid_bits = vcpu->arch.guest_supported_xcr0 | XSTATE_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tkvm_put_guest_xcr0(vcpu);\n\tvcpu->arch.xcr0 = xcr0;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1957,
        "func": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 1958,
        "func": "void __audit_log_capset(const struct cred *new, const struct cred *old)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->capset.pid = task_pid_nr(current);\n\tcontext->capset.cap.effective   = new->cap_effective;\n\tcontext->capset.cap.inheritable = new->cap_effective;\n\tcontext->capset.cap.permitted   = new->cap_permitted;\n\tcontext->type = AUDIT_CAPSET;\n}",
        "target": 0
    },
    {
        "id": 1959,
        "func": "static const char *set_gprof_dir(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    void *sconf = cmd->server->module_config;\n    core_server_config *conf = ap_get_core_module_config(sconf);\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    conf->gprof_dir = arg;\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 1960,
        "func": "int usb_find_common_endpoints_reverse(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\tstruct usb_endpoint_descriptor *epd;\n\tint i;\n\n\tif (bulk_in)\n\t\t*bulk_in = NULL;\n\tif (bulk_out)\n\t\t*bulk_out = NULL;\n\tif (int_in)\n\t\t*int_in = NULL;\n\tif (int_out)\n\t\t*int_out = NULL;\n\n\tfor (i = alt->desc.bNumEndpoints - 1; i >= 0; --i) {\n\t\tepd = &alt->endpoint[i].desc;\n\n\t\tif (match_endpoint(epd, bulk_in, bulk_out, int_in, int_out))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENXIO;\n}",
        "target": 0
    },
    {
        "id": 1961,
        "func": "__weak void board_init_f_init_stack_protection(void)\n{\n#if CONFIG_IS_ENABLED(SYS_REPORT_STACK_F_USAGE)\n\tulong stack_bottom = gd->start_addr_sp -\n\t\tCONFIG_VAL(SIZE_LIMIT_PROVIDE_STACK);\n\n\t/* substact some safety margin (0x20) since stack is in use here */\n\tmemset((void *)stack_bottom, CONFIG_VAL(SYS_STACK_F_CHECK_BYTE),\n\t       CONFIG_VAL(SIZE_LIMIT_PROVIDE_STACK) - 0x20);\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 1962,
        "func": "DEFUN(undoPos, UNDO, \"Cancel the last cursor movement\")\n{\n    BufferPos *b = Currentbuf->undo;\n    int i;\n\n    if (!Currentbuf->firstLine)\n\treturn;\n    if (!b || !b->prev)\n\treturn;\n    for (i = 0; i < PREC_NUM && b->prev; i++, b = b->prev) ;\n    resetPos(b);\n}",
        "target": 0
    },
    {
        "id": 1963,
        "func": "png_get_x_offset_inches(png_structp png_ptr, png_infop info_ptr)\n{\n   return ((float)png_get_x_offset_microns(png_ptr, info_ptr)\n     *.00003937);\n}\n",
        "target": 0
    },
    {
        "id": 1964,
        "func": "static inline __u32 tcp_v4_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_tcp_sequence_number(ip_hdr(skb)->daddr,\n\t\t\t\t\t  ip_hdr(skb)->saddr,\n\t\t\t\t\t  tcp_hdr(skb)->dest,\n\t\t\t\t\t  tcp_hdr(skb)->source);\n}",
        "target": 0
    },
    {
        "id": 1965,
        "func": "int kvm_arm_get_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t/* We currently use nothing arch-specific in upper 32 bits */\n\tif ((reg->id & ~KVM_REG_SIZE_MASK) >> 32 != KVM_REG_ARM64 >> 32)\n\t\treturn -EINVAL;\n\n\t/* Register group 16 means we want a core register. */\n\tif ((reg->id & KVM_REG_ARM_COPROC_MASK) == KVM_REG_ARM_CORE)\n\t\treturn get_core_reg(vcpu, reg);\n\n\tif ((reg->id & KVM_REG_ARM_COPROC_MASK) == KVM_REG_ARM_FW)\n\t\treturn kvm_arm_get_fw_reg(vcpu, reg);\n\n\tif (is_timer_reg(reg->id))\n\t\treturn get_timer_reg(vcpu, reg);\n\n\treturn kvm_arm_sys_reg_get_reg(vcpu, reg);\n}",
        "target": 0
    },
    {
        "id": 1966,
        "func": "static inline int splashFloor(SplashCoord x) {\n  return (int)floor(x);\n}\n",
        "target": 0
    },
    {
        "id": 1967,
        "func": "static int has_stopped_jobs(struct pid *pgrp)\n{\n\tint retval = 0;\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (!task_is_stopped(p))\n\t\t\tcontinue;\n\t\tretval = 1;\n\t\tbreak;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn retval;\n}",
        "target": 0
    },
    {
        "id": 1968,
        "func": "bool ReportingIsEnforcedByPolicy(bool* crash_reporting_enabled) {\n  std::wstring policies_path = L\"SOFTWARE\\\\Policies\\\\\";\n  AppendChromeInstallSubDirectory(InstallDetails::Get().mode(),\n                                  false /* !include_suffix */, &policies_path);\n  DWORD value = 0;\n\n  if (nt::QueryRegValueDWORD(nt::HKLM, nt::NONE, policies_path.c_str(),\n                             kMetricsReportingEnabled, &value)) {\n    *crash_reporting_enabled = (value != 0);\n    return true;\n  }\n\n  if (nt::QueryRegValueDWORD(nt::HKCU, nt::NONE, policies_path.c_str(),\n                             kMetricsReportingEnabled, &value)) {\n    *crash_reporting_enabled = (value != 0);\n    return true;\n  }\n\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 1969,
        "func": "ProxyChannelDelegate::ProxyChannelDelegate()\n    : shutdown_event_(true, false) {\n}\n",
        "target": 1
    },
    {
        "id": 1970,
        "func": "int mem_cgroup_inactive_anon_is_low(struct mem_cgroup *memcg, struct zone *zone)\n{\n\tunsigned long inactive_ratio;\n\tint nid = zone_to_nid(zone);\n\tint zid = zone_idx(zone);\n\tunsigned long inactive;\n\tunsigned long active;\n\tunsigned long gb;\n\n\tinactive = mem_cgroup_zone_nr_lru_pages(memcg, nid, zid,\n\t\t\t\t\t\tBIT(LRU_INACTIVE_ANON));\n\tactive = mem_cgroup_zone_nr_lru_pages(memcg, nid, zid,\n\t\t\t\t\t      BIT(LRU_ACTIVE_ANON));\n\n\tgb = (inactive + active) >> (30 - PAGE_SHIFT);\n\tif (gb)\n\t\tinactive_ratio = int_sqrt(10 * gb);\n\telse\n\t\tinactive_ratio = 1;\n\n\treturn inactive * inactive_ratio < active;\n}\n",
        "target": 0
    },
    {
        "id": 1971,
        "func": "gs_malloc_wrap(gs_memory_t **wrapped, gs_malloc_memory_t *contents)\n{\n#  ifdef USE_RETRY_MEMORY_WRAPPER\n    /*\n     * This is deprecated since 'retry' for clist reversion/cycling\n     * will ONLY work for monochrome, simple PS or PCL, not for a\n     * color device and not for PDF or XPS with transparency\n     */\n    {\n        gs_memory_retrying_t *rmem;\n        rmem = (gs_memory_retrying_t *)\n            gs_alloc_bytes_immovable((gs_memory_t *)lmem,\n                                     sizeof(gs_memory_retrying_t),\n                                     \"gs_malloc_wrap(retrying)\");\n        if (rmem == 0) {\n            gs_memory_locked_release(lmem);\n            gs_free_object(cmem, lmem, \"gs_malloc_wrap(locked)\");\n            return_error(gs_error_VMerror);\n        }\n        code = gs_memory_retrying_init(rmem, (gs_memory_t *)lmem);\n        if (code < 0) {\n            gs_free_object((gs_memory_t *)lmem, rmem, \"gs_malloc_wrap(retrying)\");\n            gs_memory_locked_release(lmem);\n            gs_free_object(cmem, lmem, \"gs_malloc_wrap(locked)\");\n            return code;\n        }\n\n        *wrapped = (gs_memory_t *)rmem;\n    }\n#  endif /* retrying */\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 1972,
        "func": "int PDFiumEngine::GetMostVisiblePage() {\n   if (in_flight_visible_page_)\n     return *in_flight_visible_page_;\n \n  // We can call GetMostVisiblePage through a callback from PDFium. We have\n  // to defer the page deletion otherwise we could potentially delete the page\n  // that originated the calling JS request and destroy the objects that are\n  // currently being used.\n  defer_page_unload_ = true;\n   CalculateVisiblePages();\n  defer_page_unload_ = false;\n   return most_visible_page_;\n }\n",
        "target": 0
    },
    {
        "id": 1973,
        "func": "SchedulerObject::setAttribute(std::string key,\n\t\t\t\t\t\t\t  std::string name,\n\t\t\t\t\t\t\t  std::string value,\n                                                          std::string &text)\n {\n        PROC_ID id = getProcByString(key.c_str());\n       if (id.cluster <= 0 || id.proc < 0) {\n                dprintf(D_FULLDEBUG, \"SetAttribute: Failed to parse id: %s\\n\", key.c_str());\n                text = \"Invalid Id\";\n                return false;\n\t}\n\n\tif (isSubmissionChange(name.c_str())) {\n\t\ttext = \"Changes to submission name not allowed\";\n\t\treturn false;\n\t}\n\n\tif (isKeyword(name.c_str())) {\n\t\ttext = \"Attribute name is reserved: \" + name;\n\t\treturn false;\n\t}\n\n\tif (!isValidAttributeName(name,text)) {\n\t\treturn false;\n\t}\n\n\tif (::SetAttribute(id.cluster,\n\t\t\t\t\t   id.proc,\n\t\t\t\t\t   name.c_str(),\n\t\t\t\t\t   value.c_str())) {\n\t\ttext = \"Failed to set attribute \" + name + \" to \" + value;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
        "target": 0
    },
    {
        "id": 1974,
        "func": "static int __init key_proc_init(void)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create(\"keys\", 0, NULL, &proc_keys_fops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/keys\\n\");\n\n\tp = proc_create(\"key-users\", 0, NULL, &proc_key_users_fops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/key-users\\n\");\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 1975,
        "func": "bool AppCacheDatabase::InsertCache(const CacheRecord* record) {\n  if (!LazyOpen(kCreateIfNeeded))\n    return false;\n \n   static const char kSql[] =\n       \"INSERT INTO Caches (cache_id, group_id, online_wildcard,\"\n      \"                    update_time, cache_size)\"\n      \"  VALUES(?, ?, ?, ?, ?)\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n   statement.BindInt64(0, record->cache_id);\n   statement.BindInt64(1, record->group_id);\n   statement.BindBool(2, record->online_wildcard);\n   statement.BindInt64(3, record->update_time.ToInternalValue());\n   statement.BindInt64(4, record->cache_size);\n \n   return statement.Run();\n }\n",
        "target": 1
    },
    {
        "id": 1976,
        "func": " static void array_cleanup( char* arr[] , int arr_size)\n {\n \tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n \t\tif( arr[i*2] ){\n \t\t\tefree( arr[i*2]);\n \t\t}\n\t}\n\tefree(arr);\n}\n",
        "target": 1
    },
    {
        "id": 1977,
        "func": "XMLTokenizer::~XMLTokenizer()\n{\n    setCurrentNode(0);\n    if (m_parsingFragment && m_doc)\n        m_doc->deref();\n    if (m_pendingScript)\n        m_pendingScript->removeClient(this);\n    if (m_context)\n        xmlFreeParserCtxt(m_context);\n}\n",
        "target": 0
    },
    {
        "id": 1978,
        "func": "static void print_hex(const u8 * buf, size_t buflen, size_t depth)\n{\n\tsize_t lines_len = buflen * 5 + 128;\n\tchar *lines = malloc(lines_len);\n\tchar *line = lines;\n\n\tif (buf == NULL || buflen == 0 || lines == NULL) {\n\t\tfree(lines);\n\t\treturn;\n\t}\n\n\tsc_hex_dump(buf, buflen, lines, lines_len);\n\n\twhile (*line != '\\0') {\n\t\tchar *line_end = strchr(line, '\\n');\n\t\tptrdiff_t width = line_end - line;\n\t\tif (!line_end || width <= 1) {\n\t\t\t/* don't print empty lines */\n\t\t\tbreak;\n\t\t}\n\t\tif (buflen > 8) {\n\t\t\tputchar('\\n');\n\t\t\tprint_indent(depth);\n\t\t} else {\n\t\t\tprintf(\": \");\n\t\t}\n\t\tprintf(\"%.*s\", (int) width, line);\n\t\tline = line_end + 1;\n\t}\n\n\tfree(lines);\n}",
        "target": 0
    },
    {
        "id": 1979,
        "func": "LRESULT RootWindowHostWin::OnMouseRange(UINT message,\n                                        WPARAM w_param,\n                                        LPARAM l_param) {\n  MSG msg = { hwnd(), message, w_param, l_param, 0,\n              { GET_X_LPARAM(l_param), GET_Y_LPARAM(l_param) } };\n  MouseEvent event(msg);\n  bool handled = false;\n  if (!(event.flags() & ui::EF_IS_NON_CLIENT))\n    handled = root_window_->DispatchMouseEvent(&event);\n  SetMsgHandled(handled);\n  return 0;\n}\n",
        "target": 0
    },
    {
        "id": 1980,
        "func": "void _cgsem_init(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tint ret;\n\tif ((ret = sem_init(cgsem, 0, 0)))\n\t\tquitfrom(1, file, func, line, \"Failed to sem_init ret=%d errno=%d\", ret, errno);\n}",
        "target": 0
    },
    {
        "id": 1981,
        "func": "status_t ACodec::setupFlacCodec(\n bool encoder, int32_t numChannels, int32_t sampleRate, int32_t compressionLevel) {\n\n if (encoder) {\n        OMX_AUDIO_PARAM_FLACTYPE def;\n InitOMXParams(&def);\n        def.nPortIndex = kPortIndexOutput;\n\n status_t err = mOMX->getParameter(mNode, OMX_IndexParamAudioFlac, &def, sizeof(def));\n if (err != OK) {\n            ALOGE(\"setupFlacCodec(): Error %d getting OMX_IndexParamAudioFlac parameter\", err);\n return err;\n }\n        def.nCompressionLevel = compressionLevel;\n        err = mOMX->setParameter(mNode, OMX_IndexParamAudioFlac, &def, sizeof(def));\n if (err != OK) {\n            ALOGE(\"setupFlacCodec(): Error %d setting OMX_IndexParamAudioFlac parameter\", err);\n return err;\n }\n }\n\n return setupRawAudioFormat(\n            encoder ? kPortIndexInput : kPortIndexOutput,\n            sampleRate,\n            numChannels);\n}\n",
        "target": 0
    },
    {
        "id": 1982,
        "func": "PHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n \t\treturn;\n \t}\n \n \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n \n \tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\n\tRETURN_TRUE;\n}\n",
        "target": 1
    },
    {
        "id": 1983,
        "func": "static inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) ((buffer[3] << 24) | (buffer[2] << 16) |\n        (buffer[1] << 8 ) | (buffer[0]));\n      quantum.unsigned_value=(value & 0xffffffff);\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) ((buffer[0] << 24) | (buffer[1] << 16) |\n    (buffer[2] << 8) | buffer[3]);\n  quantum.unsigned_value=(value & 0xffffffff);\n  return(quantum.signed_value);\n}",
        "target": 1
    },
    {
        "id": 1984,
        "func": "static void voidMethodDefaultUndefinedTestInterfaceEmptyArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_VOID(TestInterfaceEmpty*, defaultUndefinedTestInterfaceEmptyArg, V8TestInterfaceEmpty::toNativeWithTypeCheck(info.GetIsolate(), info[0]));\n    imp->voidMethodDefaultUndefinedTestInterfaceEmptyArg(defaultUndefinedTestInterfaceEmptyArg);\n}\n",
        "target": 0
    },
    {
        "id": 1985,
        "func": "url_parse::Component UTF8ComponentToUTF16Component(\n    const std::string& text_utf8,\n    const url_parse::Component& component_utf8) {\n  if (component_utf8.len == -1)\n    return url_parse::Component();\n\n  std::string before_component_string =\n      text_utf8.substr(0, component_utf8.begin);\n  std::string component_string = text_utf8.substr(component_utf8.begin,\n                                                  component_utf8.len);\n  string16 before_component_string_16 = UTF8ToUTF16(before_component_string);\n  string16 component_string_16 = UTF8ToUTF16(component_string);\n  url_parse::Component component_16(before_component_string_16.length(),\n                                    component_string_16.length());\n  return component_16;\n}\n",
        "target": 0
    },
    {
        "id": 1986,
        "func": "CachedResource* Cache::resourceForURL(const String& url)\n{\n    return m_resources.get(url);\n}\n",
        "target": 0
    },
    {
        "id": 1987,
        "func": "static int ucma_open(struct inode *inode, struct file *filp)\n{\n\tstruct ucma_file *file;\n\n\tfile = kmalloc(sizeof *file, GFP_KERNEL);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\tfile->close_wq = create_singlethread_workqueue(\"ucma_close_id\");\n\tif (!file->close_wq) {\n\t\tkfree(file);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&file->event_list);\n\tINIT_LIST_HEAD(&file->ctx_list);\n\tinit_waitqueue_head(&file->poll_wait);\n\tmutex_init(&file->mut);\n\n\tfilp->private_data = file;\n\tfile->filp = filp;\n\n\treturn nonseekable_open(inode, filp);\n}",
        "target": 0
    },
    {
        "id": 1988,
        "func": "static PassOwnPtr<RuleSet> makeRuleSet(const Vector<RuleFeature>& rules)\n{\n    size_t size = rules.size();\n    if (!size)\n        return nullptr;\n    OwnPtr<RuleSet> ruleSet = RuleSet::create();\n    for (size_t i = 0; i < size; ++i)\n        ruleSet->addRule(rules[i].rule, rules[i].selectorIndex, rules[i].hasDocumentSecurityOrigin ? RuleHasDocumentSecurityOrigin : RuleHasNoSpecialState);\n    return ruleSet.release();\n}\n",
        "target": 0
    },
    {
        "id": 1989,
        "func": "int file_permission(struct file *file, int mask)\n{\n\treturn inode_permission(file->f_path.dentry->d_inode, mask);\n}",
        "target": 0
    },
    {
        "id": 1990,
        "func": "void ChildProcessSecurityPolicyImpl::RegisterFileSystemPermissionPolicy(\n    storage::FileSystemType type,\n    int policy) {\n  base::AutoLock lock(lock_);\n  file_system_policy_map_[type] = policy;\n}\n",
        "target": 0
    },
    {
        "id": 1991,
        "func": "struct ring_buffer *rb_alloc(int nr_pages, long watermark, int cpu, int flags)\n{\n\tstruct ring_buffer *rb;\n\tunsigned long size;\n\tvoid *all_buf;\n\n\tsize = sizeof(struct ring_buffer);\n\tsize += sizeof(void *);\n\n\trb = kzalloc(size, GFP_KERNEL);\n\tif (!rb)\n\t\tgoto fail;\n\n\tINIT_WORK(&rb->work, rb_free_work);\n\n\tall_buf = vmalloc_user((nr_pages + 1) * PAGE_SIZE);\n\tif (!all_buf)\n\t\tgoto fail_all_buf;\n\n\trb->user_page = all_buf;\n\trb->data_pages[0] = all_buf + PAGE_SIZE;\n\trb->page_order = ilog2(nr_pages);\n\trb->nr_pages = 1;\n\n\tring_buffer_init(rb, watermark, flags);\n\n\treturn rb;\n\nfail_all_buf:\n\tkfree(rb);\n\nfail:\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 1992,
        "func": "void RuleMatchCandidateTxArrayInit(DetectEngineThreadCtx *det_ctx, uint32_t size)\n{\n    DEBUG_VALIDATE_BUG_ON(det_ctx->tx_candidates);\n    det_ctx->tx_candidates = SCCalloc(size, sizeof(RuleMatchCandidateTx));\n    if (det_ctx->tx_candidates == NULL) {\n        FatalError(SC_ERR_MEM_ALLOC, \"failed to allocate %\"PRIu64\" bytes\",\n                (uint64_t)(size * sizeof(RuleMatchCandidateTx)));\n    }\n    det_ctx->tx_candidates_size = size;\n    SCLogDebug(\"array initialized to %u elements (%\"PRIu64\" bytes)\",\n            size, (uint64_t)(size * sizeof(RuleMatchCandidateTx)));\n}\n",
        "target": 0
    },
    {
        "id": 1993,
        "func": "v8::Local<v8::Context> ScriptController::mainWorldContext(Frame* frame)\n{\n    if (!frame)\n        return v8::Local<v8::Context>();\n\n    return contextForWorld(frame->script(), mainThreadNormalWorld());\n}\n",
        "target": 0
    },
    {
        "id": 1994,
        "func": "dist_ppath(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tPATH\t   *path = PG_GETARG_PATH_P(1);\n\tfloat8\t\tresult = 0.0;\t/* keep compiler quiet */\n\tbool\t\thave_min = false;\n\tfloat8\t\ttmp;\n\tint\t\t\ti;\n\tLSEG\t\tlseg;\n\n\tswitch (path->npts)\n\t{\n\t\tcase 0:\n\t\t\t/* no points in path? then result is undefined... */\n\t\t\tPG_RETURN_NULL();\n\t\tcase 1:\n\t\t\t/* one point in path? then get distance between two points... */\n\t\t\tresult = point_dt(pt, &path->p[0]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* make sure the path makes sense... */\n\t\t\tAssert(path->npts > 1);\n\n\t\t\t/*\n\t\t\t * the distance from a point to a path is the smallest distance\n\t\t\t * from the point to any of its constituent segments.\n\t\t\t */\n\t\t\tfor (i = 0; i < path->npts; i++)\n\t\t\t{\n\t\t\t\tint\t\t\tiprev;\n\n\t\t\t\tif (i > 0)\n\t\t\t\t\tiprev = i - 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!path->closed)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tiprev = path->npts - 1;\t\t/* include the closure segment */\n\t\t\t\t}\n\n\t\t\t\tstatlseg_construct(&lseg, &path->p[iprev], &path->p[i]);\n\t\t\t\ttmp = dist_ps_internal(pt, &lseg);\n\t\t\t\tif (!have_min || tmp < result)\n\t\t\t\t{\n\t\t\t\t\tresult = tmp;\n\t\t\t\t\thave_min = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tPG_RETURN_FLOAT8(result);\n}",
        "target": 0
    },
    {
        "id": 1995,
        "func": "sf_close\t(SNDFILE *sndfile)\n{\tSF_PRIVATE\t*psf ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\treturn psf_close (psf) ;\n} /* sf_close */",
        "target": 0
    },
    {
        "id": 1996,
        "func": "static TEE_Result check_ta_store(void)\n{\n\tconst struct user_ta_store_ops *op = NULL;\n\n\tSCATTERED_ARRAY_FOREACH(op, ta_stores, struct user_ta_store_ops)\n\t\tDMSG(\"TA store: \\\"%s\\\"\", op->description);\n\n\treturn TEE_SUCCESS;\n}",
        "target": 0
    },
    {
        "id": 1997,
        "func": "static const struct arm_pmu *__init xscale2pmu_init(void)\n{\n\treturn &xscale2pmu;\n}",
        "target": 0
    },
    {
        "id": 1998,
        "func": "Frame* V8Proxy::retrieveFrameForCallingContext()\n{\n    v8::Handle<v8::Context> context = v8::Context::GetCalling();\n    if (context.IsEmpty())\n        return 0;\n    return retrieveFrame(context);\n}\n",
        "target": 0
    },
    {
        "id": 1999,
        "func": "SPL_METHOD(Array, getArrayCopy)\n{\n\tzval *object = getThis(), *tmp;\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\n    array_init(return_value);\n\tzend_hash_copy(HASH_OF(return_value), spl_array_get_hash_table(intern, 0 TSRMLS_CC), (copy_ctor_func_t) zval_add_ref, &tmp, sizeof(zval*));\n} /* }}} */\n\nstatic HashTable *spl_array_get_properties(zval *object TSRMLS_DC) /* {{{ */\n",
        "target": 0
    },
    {
        "id": 2000,
        "func": " JSValue JSDirectoryEntry::getDirectory(ExecState* exec)\n {\n     if (exec->argumentCount() < 1)\n        return throwError(exec, createTypeError(exec, \"Not enough arguments\"));\n \n     DirectoryEntry* imp = static_cast<DirectoryEntry*>(impl());\n     const String& path = valueToStringWithUndefinedOrNullCheck(exec, exec->argument(0));\n    if (exec->hadException())\n        return jsUndefined();\n\n    int argsCount = exec->argumentCount();\n    if (argsCount <= 1) {\n        imp->getDirectory(path);\n        return jsUndefined();\n    }\n\n    RefPtr<WebKitFlags> flags;\n    if (!exec->argument(1).isNull() && !exec->argument(1).isUndefined() && exec->argument(1).isObject()) {\n        JSObject* object = exec->argument(1).getObject();\n        flags = WebKitFlags::create();\n        JSValue jsCreate = object->get(exec, Identifier(exec, \"create\"));\n        flags->setCreate(jsCreate.toBoolean(exec));\n        JSValue jsExclusive = object->get(exec, Identifier(exec, \"exclusive\"));\n        flags->setExclusive(jsExclusive.toBoolean(exec));\n    }\n    if (exec->hadException())\n        return jsUndefined();\n    RefPtr<EntryCallback> successCallback;\n    if (exec->argumentCount() > 2 && !exec->argument(2).isNull() && !exec->argument(2).isUndefined()) {\n        if (!exec->argument(2).isObject()) {\n            setDOMException(exec, TYPE_MISMATCH_ERR);\n            return jsUndefined();\n        }\n        successCallback = JSEntryCallback::create(asObject(exec->argument(2)), globalObject());\n    }\n    RefPtr<ErrorCallback> errorCallback;\n    if (exec->argumentCount() > 3 && !exec->argument(3).isNull() && !exec->argument(3).isUndefined()) {\n        if (!exec->argument(3).isObject()) {\n            setDOMException(exec, TYPE_MISMATCH_ERR);\n            return jsUndefined();\n        }\n        errorCallback = JSErrorCallback::create(asObject(exec->argument(3)), globalObject());\n    }\n\n    imp->getDirectory(path, flags, successCallback, errorCallback);\n    return jsUndefined();\n}\n",
        "target": 1
    },
    {
        "id": 2001,
        "func": "static void perf_event_context_sched_in(struct perf_event_context *ctx,\n\t\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_cpu_context *cpuctx;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tif (cpuctx->task_ctx == ctx)\n\t\treturn;\n\n\tperf_ctx_lock(cpuctx, ctx);\n\tperf_pmu_disable(ctx->pmu);\n\t/*\n\t * We want to keep the following priority order:\n\t * cpu pinned (that don't need to move), task pinned,\n\t * cpu flexible, task flexible.\n\t */\n\tcpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);\n\tperf_event_sched_in(cpuctx, ctx, task);\n\tperf_pmu_enable(ctx->pmu);\n\tperf_ctx_unlock(cpuctx, ctx);\n}",
        "target": 0
    },
    {
        "id": 2002,
        "func": "base::WeakPtr<FileSystemManagerImpl> FileSystemManagerImpl::GetWeakPtr() {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  return weak_factory_.GetWeakPtr();\n}\n",
        "target": 0
    },
    {
        "id": 2003,
        "func": "int FS_PathCmp( const char *s1, const char *s2 ) {\n\tint c1, c2;\n\n\tdo {\n\t\tc1 = *s1++;\n\t\tc2 = *s2++;\n\n\t\tif ( Q_islower( c1 ) ) {\n\t\t\tc1 -= ( 'a' - 'A' );\n\t\t}\n\t\tif ( Q_islower( c2 ) ) {\n\t\t\tc2 -= ( 'a' - 'A' );\n\t\t}\n\n\t\tif ( c1 == '\\\\' || c1 == ':' ) {\n\t\t\tc1 = '/';\n\t\t}\n\t\tif ( c2 == '\\\\' || c2 == ':' ) {\n\t\t\tc2 = '/';\n\t\t}\n\n\t\tif ( c1 < c2 ) {\n\t\t\treturn -1;      // strings not equal\n\t\t}\n\t\tif ( c1 > c2 ) {\n\t\t\treturn 1;\n\t\t}\n\t} while ( c1 );\n\n\treturn 0;       // strings are equal\n}\n",
        "target": 0
    },
    {
        "id": 2004,
        "func": "static int ip_vs_genl_fill_daemon(struct sk_buff *skb, __be32 state,\n\t\t\t\t  const char *mcast_ifn, __be32 syncid)\n{\n\tstruct nlattr *nl_daemon;\n\n\tnl_daemon = nla_nest_start(skb, IPVS_CMD_ATTR_DAEMON);\n\tif (!nl_daemon)\n\t\treturn -EMSGSIZE;\n\n\tNLA_PUT_U32(skb, IPVS_DAEMON_ATTR_STATE, state);\n\tNLA_PUT_STRING(skb, IPVS_DAEMON_ATTR_MCAST_IFN, mcast_ifn);\n\tNLA_PUT_U32(skb, IPVS_DAEMON_ATTR_SYNC_ID, syncid);\n\n\tnla_nest_end(skb, nl_daemon);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nl_daemon);\n\treturn -EMSGSIZE;\n}",
        "target": 0
    },
    {
        "id": 2005,
        "func": "gfx::Insets ScrollableShelfView::CalculateEdgePadding() const {\n  if (ShouldApplyDisplayCentering())\n    return CalculatePaddingForDisplayCentering();\n \n   const int icons_size = shelf_view_->GetSizeOfAppIcons(\n       shelf_view_->number_of_visible_apps(), false);\n  gfx::Insets padding_insets(\n      /*vertical= */ 0,\n      /*horizontal= */ ShelfConfig::Get()->app_icon_group_margin());\n \n   const int available_size_for_app_icons =\n       (GetShelf()->IsHorizontalAlignment() ? width() : height()) -\n      2 * ShelfConfig::Get()->app_icon_group_margin();\n\n  int gap =\n      layout_strategy_ == kNotShowArrowButtons\n           ? available_size_for_app_icons - icons_size  // shelf centering\n           : CalculateOverflowPadding(available_size_for_app_icons);  // overflow\n \n  padding_insets.set_left(padding_insets.left() + gap / 2);\n  padding_insets.set_right(padding_insets.right() +\n                           (gap % 2 ? gap / 2 + 1 : gap / 2));\n \n   return padding_insets;\n }\n",
        "target": 1
    },
    {
        "id": 2006,
        "func": "void WebPluginDelegateProxy::PluginDestroyed() {\n  if (window_)\n    WillDestroyWindow();\n\n#if defined(OS_MACOSX)\n  render_view_->UnregisterPluginDelegate(this);\n#endif\n\n  if (channel_host_) {\n    Send(new PluginMsg_DestroyInstance(instance_id_));\n\n    channel_host_->RemoveRoute(instance_id_);\n\n    channel_host_ = NULL;\n  }\n\n  if (window_script_object_) {\n    window_script_object_->OnPluginDestroyed();\n  }\n\n  plugin_ = NULL;\n\n  MessageLoop::current()->DeleteSoon(FROM_HERE, this);\n}\n",
        "target": 0
    },
    {
        "id": 2007,
        "func": "static void close_file_picker(FileSelectorData* fs_data)\n{\n    evas_object_event_callback_del(fs_data->parent, EVAS_CALLBACK_DEL, on_filepicker_parent_deletion);\n    evas_object_del(fs_data->window);\n    ewk_file_chooser_request_unref(fs_data->request);\n    free(fs_data);\n}\n",
        "target": 0
    },
    {
        "id": 2008,
        "func": "void OxideQQuickWebViewPrivate::killWebProcess(bool crash) {\n  if (!proxy_) {\n    return;\n  }\n\n  proxy_->killWebProcess(crash);\n}\n",
        "target": 0
    },
    {
        "id": 2009,
        "func": "static void VoidMethodAllowSharedUint8ArrayArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"voidMethodAllowSharedUint8ArrayArg\");\n\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n    return;\n  }\n\n  MaybeShared<DOMUint8Array> uint8_array_arg;\n  uint8_array_arg = ToMaybeShared<MaybeShared<DOMUint8Array>>(info.GetIsolate(), info[0], exception_state);\n  if (exception_state.HadException())\n    return;\n  if (!uint8_array_arg) {\n    exception_state.ThrowTypeError(ExceptionMessages::ArgumentNotOfType(0, \"Uint8Array\"));\n    return;\n  }\n\n  impl->voidMethodAllowSharedUint8ArrayArg(uint8_array_arg);\n}\n",
        "target": 0
    },
    {
        "id": 2010,
        "func": "void SoftAVCEncoder::unbindOutputBuffer(int32_t index) {\n    CHECK(index >= 0);\n}\n",
        "target": 0
    },
    {
        "id": 2011,
        "func": "sync_api::HttpPostProviderFactory* SyncBackendHost::MakeHttpBridgeFactory(\n    const scoped_refptr<net::URLRequestContextGetter>& getter) {\n  return new HttpBridgeFactory(getter);\n}\n",
        "target": 0
    },
    {
        "id": 2012,
        "func": "WebMediaPlayer* RenderFrameImpl::CreateWebMediaPlayerForMediaStream(\n    WebMediaPlayerClient* client) {\n#if defined(ENABLE_WEBRTC)\n#if defined(OS_ANDROID) && defined(ARCH_CPU_ARMEL)\n  bool found_neon =\n      (android_getCpuFeatures() & ANDROID_CPU_ARM_FEATURE_NEON) != 0;\n  UMA_HISTOGRAM_BOOLEAN(\"Platform.WebRtcNEONFound\", found_neon);\n#endif  // defined(OS_ANDROID) && defined(ARCH_CPU_ARMEL)\n  return new WebMediaPlayerMS(frame_, client, weak_factory_.GetWeakPtr(),\n                              new RenderMediaLog(),\n                              CreateRendererFactory());\n#else\n  return NULL;\n#endif  // defined(ENABLE_WEBRTC)\n}\n",
        "target": 0
    },
    {
        "id": 2013,
        "func": "static inline void free_signal_struct(struct signal_struct *sig)\n{\n\ttaskstats_tgid_free(sig);\n\tsched_autogroup_exit(sig);\n\t/*\n\t * __mmdrop is not safe to call from softirq context on x86 due to\n\t * pgd_dtor so postpone it to the async context\n\t */\n\tif (sig->oom_mm)\n\t\tmmdrop_async(sig->oom_mm);\n\tkmem_cache_free(signal_cachep, sig);\n}",
        "target": 0
    },
    {
        "id": 2014,
        "func": "void SerializerMarkupAccumulator::appendStartTag(Node& node, Namespaces* namespaces)\n{\n    MarkupAccumulator::appendStartTag(node, namespaces);\n    m_nodes.append(&node);\n}\n",
        "target": 0
    },
    {
        "id": 2015,
        "func": "bool WebPagePrivate::respectViewport() const\n{\n    return m_forceRespectViewportArguments || contentsSize().width() <= m_virtualViewportSize.width();\n}\n",
        "target": 0
    },
    {
        "id": 2016,
        "func": "void PrintWebViewHelper::UpdatePrintableSizeInPrintParameters(\n    WebFrame* frame,\n    const WebNode& node,\n    PrepareFrameAndViewForPrint* prepare,\n    PrintMsg_Print_Params* params) {\n  if (PrintingNodeOrPdfFrame(frame, node))\n    return;\n  PageSizeMargins page_layout_in_points;\n  PrintWebViewHelper::GetPageSizeAndMarginsInPoints(frame, 0, *params,\n                                                    &page_layout_in_points);\n  int dpi = GetDPI(params);\n  params->printable_size = gfx::Size(\n      static_cast<int>(ConvertUnitDouble(\n          page_layout_in_points.content_width,\n          printing::kPointsPerInch, dpi)),\n      static_cast<int>(ConvertUnitDouble(\n          page_layout_in_points.content_height,\n          printing::kPointsPerInch, dpi)));\n\n  double page_width_in_points =\n      page_layout_in_points.content_width +\n      page_layout_in_points.margin_left +\n      page_layout_in_points.margin_right;\n  double page_height_in_points =\n      page_layout_in_points.content_height +\n      page_layout_in_points.margin_top +\n      page_layout_in_points.margin_bottom;\n\n  params->page_size = gfx::Size(\n      static_cast<int>(ConvertUnitDouble(\n          page_width_in_points, printing::kPointsPerInch, dpi)),\n      static_cast<int>(ConvertUnitDouble(\n          page_height_in_points, printing::kPointsPerInch, dpi)));\n\n  params->margin_top = static_cast<int>(ConvertUnitDouble(\n      page_layout_in_points.margin_top, printing::kPointsPerInch, dpi));\n  params->margin_left = static_cast<int>(ConvertUnitDouble(\n      page_layout_in_points.margin_left, printing::kPointsPerInch, dpi));\n\n  prepare->UpdatePrintParams(*params);\n}\n",
        "target": 0
    },
    {
        "id": 2017,
        "func": "void OMXCodec::drainInputBuffers() {\n    CHECK(mState == EXECUTING || mState == RECONFIGURING);\n\n if (mFlags & kUseSecureInputBuffers) {\n Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];\n for (size_t i = 0; i < buffers->size(); ++i) {\n if (!drainAnyInputBuffer()\n || (mFlags & kOnlySubmitOneInputBufferAtOneTime)) {\n break;\n }\n }\n } else {\n Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];\n for (size_t i = 0; i < buffers->size(); ++i) {\n BufferInfo *info = &buffers->editItemAt(i);\n\n if (info->mStatus != OWNED_BY_US) {\n continue;\n }\n\n if (!drainInputBuffer(info)) {\n break;\n }\n\n if (mFlags & kOnlySubmitOneInputBufferAtOneTime) {\n break;\n }\n }\n }\n}\n",
        "target": 0
    },
    {
        "id": 2018,
        "func": "internal_error(png_store *ps, png_const_charp message)\n{\n   store_log(ps, NULL, message, 1 /* error */);\n\n /* And finally throw an exception. */\n {\n struct exception_context *the_exception_context = &ps->exception_context;\n Throw ps;\n }\n}\n",
        "target": 0
    },
    {
        "id": 2019,
        "func": "static void backtrace_address(void *data, unsigned long addr, int reliable)\n{\n\tstruct perf_callchain_entry *entry = data;\n\n\tperf_callchain_store(entry, addr);\n}",
        "target": 0
    },
    {
        "id": 2020,
        "func": "void InjectRawKeyEvent(WebContents* web_contents,\n                       blink::WebInputEvent::Type type,\n                       ui::DomKey key,\n                       ui::DomCode code,\n                       ui::KeyboardCode key_code,\n                       int modifiers) {\n  NativeWebKeyboardEvent event(type, modifiers, base::TimeTicks::Now());\n  BuildSimpleWebKeyEvent(type, key, code, key_code, &event);\n  WebContentsImpl* web_contents_impl =\n      static_cast<WebContentsImpl*>(web_contents);\n  RenderWidgetHostImpl* main_frame_rwh =\n      web_contents_impl->GetMainFrame()->GetRenderWidgetHost();\n  web_contents_impl->GetFocusedRenderWidgetHost(main_frame_rwh)\n      ->ForwardKeyboardEvent(event);\n}\n",
        "target": 0
    },
    {
        "id": 2021,
        "func": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 2022,
        "func": "static int cma_resolve_ib_addr(struct rdma_id_private *id_priv)\n{\n\tstruct cma_work *work;\n\tint ret;\n\n\twork = kzalloc(sizeof *work, GFP_KERNEL);\n\tif (!work)\n\t\treturn -ENOMEM;\n\n\tif (!id_priv->cma_dev) {\n\t\tret = cma_resolve_ib_dev(id_priv);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\trdma_addr_set_dgid(&id_priv->id.route.addr.dev_addr, (union ib_gid *)\n\t\t&(((struct sockaddr_ib *) &id_priv->id.route.addr.dst_addr)->sib_addr));\n\n\twork->id = id_priv;\n\tINIT_WORK(&work->work, cma_work_handler);\n\twork->old_state = RDMA_CM_ADDR_QUERY;\n\twork->new_state = RDMA_CM_ADDR_RESOLVED;\n\twork->event.event = RDMA_CM_EVENT_ADDR_RESOLVED;\n\tqueue_work(cma_wq, &work->work);\n\treturn 0;\nerr:\n\tkfree(work);\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 2023,
        "func": "check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->target_offset,\n\t\t\t\t\t    e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\n\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 2024,
        "func": "fz_drop_colorspace_imp(fz_context *ctx, fz_storable *cs_)\n{\n\tfz_colorspace *cs = (fz_colorspace *)cs_;\n\tint i;\n\n\tif (cs->free_data && cs->data)\n\t\tcs->free_data(ctx, cs);\n\tfor (i = 0; i < FZ_MAX_COLORS; i++)\n\t\tfz_free(ctx, cs->colorant[i]);\n\tfz_free(ctx, cs);\n}\n",
        "target": 0
    },
    {
        "id": 2025,
        "func": "void fz_new_colorspace_context(fz_context *ctx)\n{\n\tctx->colorspace = fz_malloc_struct(ctx, fz_colorspace_context);\n\tctx->colorspace->ctx_refs = 1;\n\tset_no_icc(ctx->colorspace);\n#ifdef NO_ICC\n\tfz_set_cmm_engine(ctx, NULL);\n#else\n\tfz_set_cmm_engine(ctx, &fz_cmm_engine_lcms);\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 2026,
        "func": "void WebPageProxy::focusedFrameChanged(uint64_t frameID)\n{\n    if (!frameID) {\n        m_focusedFrame = 0;\n        return;\n    }\n\n    WebFrameProxy* frame = process()->webFrame(frameID);\n    MESSAGE_CHECK(frame);\n\n    m_focusedFrame = frame;\n}\n",
        "target": 0
    },
    {
        "id": 2027,
        "func": "static inline long ldsem_atomic_update(long delta, struct ld_semaphore *sem)\n{\n\treturn atomic_long_add_return(delta, (atomic_long_t *)&sem->count);\n}",
        "target": 0
    },
    {
        "id": 2028,
        "func": "void ResourceFetcher::willTerminateResourceLoader(ResourceLoader* loader)\n{\n    if (m_loaders && m_loaders->contains(loader))\n        m_loaders->remove(loader);\n    if (m_multipartLoaders && m_multipartLoaders->contains(loader))\n        m_multipartLoaders->remove(loader);\n    if (LocalFrame* frame = this->frame())\n        frame->loader().checkLoadComplete();\n}\n",
        "target": 0
    },
    {
        "id": 2029,
        "func": "crm_ipc_connect(crm_ipc_t * client)\n{\n    client->need_reply = FALSE;\n    client->ipc = qb_ipcc_connect(client->name, client->buf_size);\n\n    if (client->ipc == NULL) {\n        crm_debug(\"Could not establish %s connection: %s (%d)\", client->name, pcmk_strerror(errno), errno);\n        return FALSE;\n    }\n\n    client->pfd.fd = crm_ipc_get_fd(client);\n    if (client->pfd.fd < 0) {\n        crm_debug(\"Could not obtain file descriptor for %s connection: %s (%d)\", client->name, pcmk_strerror(errno), errno);\n        return FALSE;\n    }\n\n    qb_ipcc_context_set(client->ipc, client);\n\n#ifdef HAVE_IPCS_GET_BUFFER_SIZE\n    client->max_buf_size = qb_ipcc_get_buffer_size(client->ipc);\n    if (client->max_buf_size > client->buf_size) {\n        free(client->buffer);\n        client->buffer = calloc(1, client->max_buf_size);\n        client->buf_size = client->max_buf_size;\n    }\n#endif\n\n    return TRUE;\n}\n",
        "target": 0
    },
    {
        "id": 2030,
        "func": "  QuotaManager* manager() const { return manager_; }\n",
        "target": 0
    },
    {
        "id": 2031,
        "func": "void V8TestObject::RaisesExceptionTestInterfaceEmptyVoidMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_raisesExceptionTestInterfaceEmptyVoidMethod\");\n\n  test_object_v8_internal::RaisesExceptionTestInterfaceEmptyVoidMethodMethod(info);\n}\n",
        "target": 0
    },
    {
        "id": 2032,
        "func": "void LauncherView::ShowOverflowMenu() {\n#if !defined(OS_MACOSX)\n  if (!delegate_)\n    return;\n \n  std::vector<LauncherItem> items;\n  GetOverflowItems(&items);\n  if (items.empty())\n    return;\n \n  MenuDelegateImpl menu_delegate;\n  ui::SimpleMenuModel menu_model(&menu_delegate);\n  for (size_t i = 0; i < items.size(); ++i)\n    menu_model.AddItem(static_cast<int>(i), delegate_->GetTitle(items[i]));\n  views::MenuModelAdapter menu_adapter(&menu_model);\n  overflow_menu_runner_.reset(new views::MenuRunner(menu_adapter.CreateMenu()));\n  gfx::Rect bounds(overflow_button_->size());\n  gfx::Point origin;\n  ConvertPointToScreen(overflow_button_, &origin);\n  if (overflow_menu_runner_->RunMenuAt(GetWidget(), NULL,\n          gfx::Rect(origin, size()), views::MenuItemView::TOPLEFT, 0) ==\n      views::MenuRunner::MENU_DELETED)\n    return;\n \n   Shell::GetInstance()->UpdateShelfVisibility();\n  if (menu_delegate.activated_command_id() == -1)\n    return;\n  LauncherID activated_id = items[menu_delegate.activated_command_id()].id;\n  LauncherItems::const_iterator window_iter = model_->ItemByID(activated_id);\n  if (window_iter == model_->items().end())\n    return;  // Window was deleted while menu was up.\n  delegate_->ItemClicked(*window_iter, ui::EF_NONE);\n#endif  // !defined(OS_MACOSX)\n }\n",
        "target": 1
    },
    {
        "id": 2033,
        "func": "errors_show(struct md_rdev *rdev, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", atomic_read(&rdev->corrected_errors));\n}",
        "target": 0
    },
    {
        "id": 2034,
        "func": "    FromMojom(media::mojom::DecodeError error,\n              media::JpegDecodeAccelerator::Error* out) {\n  switch (error) {\n    case media::mojom::DecodeError::NO_ERRORS:\n      *out = media::JpegDecodeAccelerator::Error::NO_ERRORS;\n      return true;\n    case media::mojom::DecodeError::INVALID_ARGUMENT:\n      *out = media::JpegDecodeAccelerator::Error::INVALID_ARGUMENT;\n      return true;\n    case media::mojom::DecodeError::UNREADABLE_INPUT:\n      *out = media::JpegDecodeAccelerator::Error::UNREADABLE_INPUT;\n      return true;\n    case media::mojom::DecodeError::PARSE_JPEG_FAILED:\n      *out = media::JpegDecodeAccelerator::Error::PARSE_JPEG_FAILED;\n      return true;\n    case media::mojom::DecodeError::UNSUPPORTED_JPEG:\n      *out = media::JpegDecodeAccelerator::Error::UNSUPPORTED_JPEG;\n      return true;\n    case media::mojom::DecodeError::PLATFORM_FAILURE:\n      *out = media::JpegDecodeAccelerator::Error::PLATFORM_FAILURE;\n      return true;\n  }\n  NOTREACHED();\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 2035,
        "func": "static void ffm_set_write_index(AVFormatContext *s, int64_t pos,\n                                int64_t file_size)\n{\n    av_opt_set_int(s, \"server_attached\", 1, AV_OPT_SEARCH_CHILDREN);\n    av_opt_set_int(s, \"ffm_write_index\", pos, AV_OPT_SEARCH_CHILDREN);\n    av_opt_set_int(s, \"ffm_file_size\", file_size, AV_OPT_SEARCH_CHILDREN);\n}",
        "target": 0
    },
    {
        "id": 2036,
        "func": "c_next (struct seq_file *m, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn c_start(m, pos);\n}",
        "target": 0
    },
    {
        "id": 2037,
        "func": "  Sampler* CreateSampler(\n      GLuint client_id, GLuint service_id) {\n    return sampler_manager()->CreateSampler(client_id, service_id);\n  }\n",
        "target": 0
    },
    {
        "id": 2038,
        "func": "static bool is_processing_finished()\n{\n    return !g_expert_mode && !g_auto_event_list;\n}",
        "target": 0
    },
    {
        "id": 2039,
        "func": "void BrowserOpenedNotificationObserver::Observe(\n    int type,\n    const content::NotificationSource& source,\n    const content::NotificationDetails& details) {\n  if (!automation_) {\n    delete this;\n    return;\n  }\n\n  if (type == chrome::NOTIFICATION_BROWSER_OPENED) {\n    new_window_id_ = ExtensionTabUtil::GetWindowId(\n        content::Source<Browser>(source).ptr());\n  } else {\n    DCHECK_EQ(content::NOTIFICATION_LOAD_STOP, type);\n    NavigationController* controller =\n        content::Source<NavigationController>(source).ptr();\n    SessionTabHelper* session_tab_helper =\n        SessionTabHelper::FromWebContents(controller->GetWebContents());\n    int window_id = session_tab_helper ? session_tab_helper->window_id().id()\n                                       : -1;\n    if (window_id == new_window_id_) {\n      if (use_json_interface_) {\n        AutomationJSONReply(automation_,\n                            reply_message_.release()).SendSuccess(NULL);\n      } else {\n        if (for_browser_command_) {\n          AutomationMsg_WindowExecuteCommand::WriteReplyParams(\n              reply_message_.get(), true);\n        }\n        automation_->Send(reply_message_.release());\n      }\n      delete this;\n      return;\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2040,
        "func": "int Elf_(r_bin_elf_has_nx)(ELFOBJ *bin) {\n\tint i;\n\tif (bin && bin->phdr) {\n\t\tfor (i = 0; i < bin->ehdr.e_phnum; i++) {\n\t\t\tif (bin->phdr[i].p_type == PT_GNU_STACK) {\n\t\t\t\treturn (!(bin->phdr[i].p_flags & 1))? 1: 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2041,
        "func": "void stco_del(GF_Box *s)\n{\n\tGF_ChunkOffsetBox *ptr = (GF_ChunkOffsetBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->offsets) gf_free(ptr->offsets);\n\tgf_free(ptr);\n}",
        "target": 0
    },
    {
        "id": 2042,
        "func": "size_t RTCPeerConnectionHandler::GetTransceiverIndex(\n    const blink::WebRTCRtpTransceiver& web_transceiver) {\n  if (web_transceiver.ImplementationType() ==\n      blink::WebRTCRtpTransceiverImplementationType::kFullTransceiver) {\n    for (size_t i = 0; i < rtp_transceivers_.size(); ++i) {\n      if (web_transceiver.Id() == rtp_transceivers_[i]->Id())\n        return i;\n    }\n  } else if (web_transceiver.ImplementationType() ==\n             blink::WebRTCRtpTransceiverImplementationType::kPlanBSenderOnly) {\n    const auto web_sender = web_transceiver.Sender();\n    for (size_t i = 0; i < rtp_senders_.size(); ++i) {\n      if (web_sender->Id() == rtp_senders_[i]->Id())\n        return i;\n    }\n  } else {\n    RTC_DCHECK(\n        web_transceiver.ImplementationType() ==\n        blink::WebRTCRtpTransceiverImplementationType::kPlanBReceiverOnly);\n    const auto web_receiver = web_transceiver.Receiver();\n    for (size_t i = 0; i < rtp_receivers_.size(); ++i) {\n      if (web_receiver->Id() == rtp_receivers_[i]->Id())\n        return i;\n    }\n  }\n  NOTREACHED();\n  return 0u;\n}\n",
        "target": 0
    },
    {
        "id": 2043,
        "func": "String HTMLInputElement::ResultForDialogSubmit() {\n  return input_type_->ResultForDialogSubmit();\n}\n",
        "target": 0
    },
    {
        "id": 2044,
        "func": "DefragTracker *DefragTrackerAlloc(void)\n{\n    if (!(DEFRAG_CHECK_MEMCAP(sizeof(DefragTracker)))) {\n        return NULL;\n    }\n\n    (void) SC_ATOMIC_ADD(defrag_memuse, sizeof(DefragTracker));\n\n    DefragTracker *dt = SCMalloc(sizeof(DefragTracker));\n    if (unlikely(dt == NULL))\n        goto error;\n\n    memset(dt, 0x00, sizeof(DefragTracker));\n\n    SCMutexInit(&dt->lock, NULL);\n    SC_ATOMIC_INIT(dt->use_cnt);\n    return dt;\n\nerror:\n    return NULL;\n}",
        "target": 0
    },
    {
        "id": 2045,
        "func": "static Vector<String> ParseAcceptAttribute(const String& accept_string,\n                                           bool (*predicate)(const String&)) {\n  Vector<String> types;\n  if (accept_string.IsEmpty())\n    return types;\n\n  Vector<String> split_types;\n  accept_string.Split(',', false, split_types);\n  for (const String& split_type : split_types) {\n    String trimmed_type = StripLeadingAndTrailingHTMLSpaces(split_type);\n    if (trimmed_type.IsEmpty())\n      continue;\n    if (!predicate(trimmed_type))\n      continue;\n    types.push_back(trimmed_type.DeprecatedLower());\n  }\n\n  return types;\n}\n",
        "target": 0
    },
    {
        "id": 2046,
        "func": "void WebPluginProxy::OnResourceCreated(int resource_id, HANDLE cookie) {\n  WebPluginResourceClient* resource_client =\n      reinterpret_cast<WebPluginResourceClient*>(cookie);\n  if (!resource_client) {\n    NOTREACHED();\n    return;\n  }\n   DCHECK(resource_clients_.find(resource_id) == resource_clients_.end());\n  resource_clients_[resource_id] = resource_client;\n }\n",
        "target": 1
    },
    {
        "id": 2047,
        "func": "    content::RenderView::FromWebView(WebKit::WebView* webview) {\n  return RenderViewImpl::FromWebView(webview);\n}\n",
        "target": 0
    },
    {
        "id": 2048,
        "func": "void PrintViewManager::OnShowScriptedPrintPreview(content::RenderFrameHost* rfh,\n                                                  bool source_is_modifiable) {\n  DCHECK(print_preview_rfh_);\n  if (rfh != print_preview_rfh_)\n    return;\n\n  PrintPreviewDialogController* dialog_controller =\n      PrintPreviewDialogController::GetInstance();\n  if (!dialog_controller) {\n    PrintPreviewDone();\n     return;\n   }\n \n   dialog_controller->PrintPreview(web_contents());\n   PrintHostMsg_RequestPrintPreview_Params params;\n   params.is_modifiable = source_is_modifiable;\n  PrintPreviewUI::SetInitialParams(\n      dialog_controller->GetPrintPreviewForContents(web_contents()), params);\n}\n",
        "target": 1
    },
    {
        "id": 2049,
        "func": "static SharedMemorySupport DoQuerySharedMemorySupport(Display* dpy) {\n  int dummy;\n  Bool pixmaps_supported;\n  if (!XShmQueryVersion(dpy, &dummy, &dummy, &pixmaps_supported))\n    return SHARED_MEMORY_NONE;\n\n#if defined(OS_FREEBSD)\n  int allow_removed;\n  size_t length = sizeof(allow_removed);\n\n  if ((sysctlbyname(\"kern.ipc.shm_allow_removed\", &allow_removed, &length,\n      NULL, 0) < 0) || allow_removed < 1) {\n    return SHARED_MEMORY_NONE;\n  }\n #endif\n \n  int shmkey = shmget(IPC_PRIVATE, 1, 0666);\n  if (shmkey == -1)\n     return SHARED_MEMORY_NONE;\n   void* address = shmat(shmkey, NULL, 0);\n   shmctl(shmkey, IPC_RMID, NULL);\n\n  XShmSegmentInfo shminfo;\n  memset(&shminfo, 0, sizeof(shminfo));\n  shminfo.shmid = shmkey;\n \n   gdk_error_trap_push();\n   bool result = XShmAttach(dpy, &shminfo);\n   XSync(dpy, False);\n   if (gdk_error_trap_pop())\n     result = false;\n   shmdt(address);\n  if (!result)\n     return SHARED_MEMORY_NONE;\n \n   XShmDetach(dpy, &shminfo);\n   return pixmaps_supported ? SHARED_MEMORY_PIXMAP : SHARED_MEMORY_PUTIMAGE;\n}\n",
        "target": 1
    },
    {
        "id": 2050,
        "func": "  static void Create(chrome::mojom::SafeArchiveAnalyzerRequest request) {\n    mojo::MakeStrongBinding(base::MakeUnique<SafeArchiveAnalyzerImpl>(),\n                            std::move(request));\n  }\n",
        "target": 0
    },
    {
        "id": 2051,
        "func": "static void fanout_release(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f;\n\n\tf = po->fanout;\n\tif (!f)\n\t\treturn;\n\n\tmutex_lock(&fanout_mutex);\n\tpo->fanout = NULL;\n\n\tif (atomic_dec_and_test(&f->sk_ref)) {\n\t\tlist_del(&f->list);\n\t\tdev_remove_pack(&f->prot_hook);\n\t\tfanout_release_data(f);\n\t\tkfree(f);\n\t}\n\tmutex_unlock(&fanout_mutex);\n\n\tif (po->rollover)\n\t\tkfree_rcu(po->rollover, rcu);\n}",
        "target": 1
    },
    {
        "id": 2052,
        "func": "  SiteInstance* parent_site_instance() const {\n",
        "target": 0
    },
    {
        "id": 2053,
        "func": "static void ucvector_init(ucvector* p)\n{\n  p->data = NULL;\n  p->size = p->allocsize = 0;\n}\n",
        "target": 0
    },
    {
        "id": 2054,
        "func": "JSGlobalContextRef webkit_web_frame_get_global_context(WebKitWebFrame* frame)\n{\n    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), NULL);\n\n    Frame* coreFrame = core(frame);\n     if (!coreFrame)\n         return NULL;\n \n    return toGlobalRef(coreFrame->script()->globalObject()->globalExec());\n }\n",
        "target": 1
    },
    {
        "id": 2055,
        "func": "static NICK_REC *nicklist_find_wildcards(CHANNEL_REC *channel,\n\t\t\t\t\t const char *mask)\n{\n\tNICK_REC *nick;\n\tGHashTableIter iter;\n\n\tg_hash_table_iter_init(&iter, channel->nicks);\n\twhile (g_hash_table_iter_next(&iter, NULL, (void*)&nick)) {\n\t\tfor (; nick != NULL; nick = nick->next) {\n\t\t\tif (mask_match_address(channel->server, mask,\n\t\t\t\t\t       nick->nick, nick->host))\n\t\t\t\treturn nick;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n",
        "target": 0
    },
    {
        "id": 2056,
        "func": "static void VCAPITYPE drdynvc_virtual_channel_open_event_ex(LPVOID lpUserParam, DWORD openHandle,\n        UINT event, LPVOID pData, UINT32 dataLength, UINT32 totalLength, UINT32 dataFlags)\n{\n\tUINT error = CHANNEL_RC_OK;\n\tdrdynvcPlugin* drdynvc = (drdynvcPlugin*) lpUserParam;\n\n\tif (!drdynvc || (drdynvc->OpenHandle != openHandle))\n\t{\n\t\tWLog_ERR(TAG, \"drdynvc_virtual_channel_open_event: error no match\");\n\t\treturn;\n\t}\n\n\tswitch (event)\n\t{\n\t\tcase CHANNEL_EVENT_DATA_RECEIVED:\n\t\t\tif ((error = drdynvc_virtual_channel_event_data_received(drdynvc, pData, dataLength, totalLength,\n\t\t\t             dataFlags)))\n\t\t\t\tWLog_Print(drdynvc->log, WLOG_ERROR,\n\t\t\t\t           \"drdynvc_virtual_channel_event_data_received failed with error %\"PRIu32\"\", error);\n\n\t\t\tbreak;\n\n\t\tcase CHANNEL_EVENT_WRITE_COMPLETE:\n\t\t\tbreak;\n\n\t\tcase CHANNEL_EVENT_USER:\n\t\t\tbreak;\n\t}\n\n\tif (error && drdynvc->rdpcontext)\n\t\tsetChannelError(drdynvc->rdpcontext, error, \"drdynvc_virtual_channel_open_event reported an error\");\n}\n",
        "target": 0
    },
    {
        "id": 2057,
        "func": "void RenderViewImpl::frameDetached(WebFrame* frame) {\n  FOR_EACH_OBSERVER(RenderViewObserver, observers_, FrameDetached(frame));\n}\n",
        "target": 0
    },
    {
        "id": 2058,
        "func": "initImageData (struct image_data *image)\n  {\n  image->xres = 0.0;\n  image->yres = 0.0;\n  image->width = 0;\n  image->length = 0;\n  image->res_unit = RESUNIT_NONE;\n  image->bps = 0;\n  image->spp = 0;\n  image->planar = 0;\n  image->photometric = 0;\n  image->orientation = 0;\n  image->compression = COMPRESSION_NONE;\n  image->adjustments = 0;\n  }\n",
        "target": 0
    },
    {
        "id": 2059,
        "func": "  base::FilePath base_path() const {\n    if (base::FeatureList::IsEnabled(chromeos::features::kMyFilesVolume))\n      return root_path().Append(\"Downloads\");\n\n    return root_path();\n  }\n",
        "target": 0
    },
    {
        "id": 2060,
        "func": "static void copy_asoundrc(void) {\n\tchar *src = RUN_ASOUNDRC_FILE ;\n \tchar *dest;\n \tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n \t\terrExit(\"asprintf\");\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n \t\texit(1);\n \t}\n \n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(0);\n\t\tint rv = copy_file(src, dest);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .asoundrc in private home directory\\n\");\n\t\telse {\n\t\t\tfs_logger2(\"clone\", dest);\n\t\t}\n\t\t_exit(0);\n\t}\n\twaitpid(child, NULL, 0);\n\tif (chown(dest, getuid(), getgid()) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n\t\terrExit(\"chmod\");\n \n \tunlink(src);\n}\n",
        "target": 1
    },
    {
        "id": 2061,
        "func": "void PresentationConnection::didClose(\n    WebPresentationConnectionCloseReason reason,\n    const String& message) {\n  if (m_state == WebPresentationConnectionState::Closed)\n    return;\n\n  m_state = WebPresentationConnectionState::Closed;\n  dispatchStateChangeEvent(PresentationConnectionCloseEvent::create(\n       EventTypeNames::close, connectionCloseReasonToString(reason), message));\n }\n",
        "target": 0
    },
    {
        "id": 2062,
        "func": "static bool modify_dci_qp_is_ok(enum ib_qp_state cur_state, enum ib_qp_state new_state,\n\t\t\t\tenum ib_qp_attr_mask attr_mask)\n{\n\tint req = IB_QP_STATE;\n\tint opt = 0;\n\n\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\treq |= IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_INIT) {\n\t\topt = IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR) {\n\t\treq |= IB_QP_PATH_MTU;\n\t\topt = IB_QP_PKEY_INDEX;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_RTR && new_state == IB_QPS_RTS) {\n\t\treq |= IB_QP_TIMEOUT | IB_QP_RETRY_CNT | IB_QP_RNR_RETRY |\n\t\t       IB_QP_MAX_QP_RD_ATOMIC | IB_QP_SQ_PSN;\n\t\topt = IB_QP_MIN_RNR_TIMER;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_RTS && new_state == IB_QPS_RTS) {\n\t\topt = IB_QP_MIN_RNR_TIMER;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state != IB_QPS_RESET && new_state == IB_QPS_ERR) {\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t}\n\treturn false;\n}",
        "target": 0
    },
    {
        "id": 2063,
        "func": "\tvoid testCompareRangeHelper(const char * a, const char * b, int expected, bool avoidNullRange = true) {\n\t\tUriTextRangeA ra;\n\t\tUriTextRangeA rb;\n\n\t\tif (a) {\n\t\t\tra.first = a;\n\t\t\tra.afterLast = a + strlen(a);\n\t\t} else {\n\t\t\tra.first = NULL;\n\t\t\tra.afterLast = NULL;\n\t\t}\n\n\t\tif (b) {\n\t\t\trb.first = b;\n\t\t\trb.afterLast = b + strlen(b);\n\t\t} else {\n\t\t\trb.first = NULL;\n\t\t\trb.afterLast = NULL;\n\t\t}\n\n\t\tconst int received = uriCompareRangeA(\n\t\t\t\t((a == NULL) && avoidNullRange) ? NULL : &ra,\n\t\t\t\t((b == NULL) && avoidNullRange) ? NULL : &rb);\n\t\tif (received != expected) {\n\t\t\tprintf(\"Comparing <%s> to <%s> yields %d, expected %d.\\n\",\n\t\t\t\t\ta, b, received, expected);\n\t\t}\n\t\tTEST_ASSERT(received == expected);\n\t}",
        "target": 0
    },
    {
        "id": 2064,
        "func": "int ChunkedUploadDataStream::InitInternal(const NetLogWithSource& net_log) {\n  DCHECK(!read_buffer_.get());\n  DCHECK_EQ(0u, read_index_);\n  DCHECK_EQ(0u, read_offset_);\n  return OK;\n}\n",
        "target": 0
    },
    {
        "id": 2065,
        "func": "static int __init ipx_init(void)\n{\n\tint rc = proto_register(&ipx_proto, 1);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tsock_register(&ipx_family_ops);\n\n\tpEII_datalink = make_EII_client();\n\tif (pEII_datalink)\n\t\tdev_add_pack(&ipx_dix_packet_type);\n\telse\n\t\tprintk(ipx_EII_err_msg);\n\n\tp8023_datalink = make_8023_client();\n\tif (p8023_datalink)\n\t\tdev_add_pack(&ipx_8023_packet_type);\n\telse\n\t\tprintk(ipx_8023_err_msg);\n\n\tp8022_datalink = register_8022_client(ipx_8022_type, ipx_rcv);\n\tif (!p8022_datalink)\n\t\tprintk(ipx_llc_err_msg);\n\n\tpSNAP_datalink = register_snap_client(ipx_snap_id, ipx_rcv);\n\tif (!pSNAP_datalink)\n\t\tprintk(ipx_snap_err_msg);\n\n\tregister_netdevice_notifier(&ipx_dev_notifier);\n\tipx_register_sysctl();\n\tipx_proc_init();\nout:\n\treturn rc;\n}",
        "target": 0
    },
    {
        "id": 2066,
        "func": " bool DataReductionProxySettings::IsDataReductionProxyEnabled() const {\n   if (base::FeatureList::IsEnabled(network::features::kNetworkService) &&\n       !params::IsEnabledWithNetworkService()) {\n     return false;\n   }\n  return IsDataSaverEnabledByUser();\n }\n",
        "target": 1
    },
    {
        "id": 2067,
        "func": "correlation_coefficient(double sxx, double syy, double sxy)\n{\n    double coe, tmp;\n    tmp = sxx * syy;\n    if (tmp < Tiny)\n\ttmp = Tiny;\n    coe = sxy / sqrt(tmp);\n    if (coe > 1.)\n\treturn 1.;\n    if (coe < -1.)\n\treturn -1.;\n    return coe;\n}",
        "target": 0
    },
    {
        "id": 2068,
        "func": "TabStrip::RemoveTabDelegate::RemoveTabDelegate(TabStrip* tab_strip,\n                                               Tab* tab)\n    : tabstrip_(tab_strip),\n      tab_(tab) {\n}\n",
        "target": 0
    },
    {
        "id": 2069,
        "func": "void WebContentsViewAura::CreateView(\n    const gfx::Size& initial_size, gfx::NativeView context) {\n\n  aura::Env::CreateInstance();\n  window_.reset(new aura::Window(this));\n  window_->set_owned_by_parent(false);\n  window_->SetType(ui::wm::WINDOW_TYPE_CONTROL);\n  window_->SetTransparent(false);\n  window_->Init(aura::WINDOW_LAYER_NOT_DRAWN);\n  aura::Window* root_window = context ? context->GetRootWindow() : NULL;\n  if (root_window) {\n    if (root_window) {\n      aura::client::ParentWindowWithContext(\n          window_.get(), root_window, root_window->GetBoundsInScreen());\n    }\n  }\n  window_->layer()->SetMasksToBounds(true);\n  window_->SetName(\"WebContentsViewAura\");\n\n  if (!web_contents_->GetRenderProcessHost()->IsGuest())\n    window_observer_.reset(new WindowObserver(this));\n\n  if (delegate_)\n    drag_dest_delegate_ = delegate_->GetDragDestDelegate();\n}\n",
        "target": 0
    },
    {
        "id": 2070,
        "func": "static void read_ascii_response(char *buffer, size_t size) {\n    off_t offset = 0;\n    bool need_more = true;\n    do {\n        ssize_t nr = read(sock, buffer + offset, 1);\n        if (nr == -1) {\n            if (errno != EINTR) {\n                fprintf(stderr, \"Failed to read: %s\\n\", strerror(errno));\n                abort();\n            }\n        } else {\n            assert(nr == 1);\n            if (buffer[offset] == '\\n') {\n                need_more = false;\n                buffer[offset + 1] = '\\0';\n            }\n            offset += nr;\n            assert(offset + 1 < size);\n        }\n    } while (need_more);\n}",
        "target": 0
    },
    {
        "id": 2071,
        "func": "void resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown(&console_sem);\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}\n",
        "target": 0
    },
    {
        "id": 2072,
        "func": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}\n",
        "target": 0
    },
    {
        "id": 2073,
        "func": "AutofillPopupViewNativeViews::~AutofillPopupViewNativeViews() {}\n",
        "target": 0
    },
    {
        "id": 2074,
        "func": "bool ContainerNode::checkAcceptChild(const Node* newChild, const Node* oldChild, ExceptionState& exceptionState) const\n{\n    if (!newChild) {\n        exceptionState.throwDOMException(NotFoundError, \"The new child element is null.\");\n        return false;\n    }\n\n    if ((newChild->isElementNode() || newChild->isTextNode()) && isElementNode()) {\n        ASSERT(isChildTypeAllowed(*newChild));\n        if (containsConsideringHostElements(*newChild)) {\n            exceptionState.throwDOMException(HierarchyRequestError, \"The new child element contains the parent.\");\n            return false;\n        }\n        return true;\n    }\n\n    ASSERT(!newChild->isPseudoElement());\n    if (newChild->isPseudoElement()) {\n        exceptionState.throwDOMException(HierarchyRequestError, \"The new child element is a pseudo-element.\");\n        return false;\n    }\n\n    return checkAcceptChildGuaranteedNodeTypes(*newChild, oldChild, exceptionState);\n}\n",
        "target": 0
    },
    {
        "id": 2075,
        "func": "swapTest(int swapIC, int *pos, const TranslationTableHeader *table, const InString *input,\n\t\tconst widechar *passInstructions) {\n\tint p = *pos;\n\tTranslationTableOffset swapRuleOffset;\n\tTranslationTableRule *swapRule;\n\tswapRuleOffset = (passInstructions[swapIC + 1] << 16) | passInstructions[swapIC + 2];\n\tswapRule = (TranslationTableRule *)&table->ruleArea[swapRuleOffset];\n\twhile (p - *pos < passInstructions[swapIC + 3]) {\n\t\tint test;\n\t\tif (swapRule->opcode == CTO_SwapDd) {\n\t\t\tfor (test = 1; test < swapRule->charslen; test += 2) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (test = 0; test < swapRule->charslen; test++) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t}\n\t\tif (test >= swapRule->charslen) return 0;\n\t\tp++;\n\t}\n\tif (passInstructions[swapIC + 3] == passInstructions[swapIC + 4]) {\n\t\t*pos = p;\n\t\treturn 1;\n\t}\n\twhile (p - *pos < passInstructions[swapIC + 4]) {\n\t\tint test;\n\t\tif (swapRule->opcode == CTO_SwapDd) {\n\t\t\tfor (test = 1; test < swapRule->charslen; test += 2) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (test = 0; test < swapRule->charslen; test++) {\n\t\t\t\tif (input->chars[p] == swapRule->charsdots[test]) break;\n\t\t\t}\n\t\t}\n\t\tif (test >= swapRule->charslen) {\n\t\t\t*pos = p;\n\t\t\treturn 1;\n\t\t}\n\t\tp++;\n\t}\n\t*pos = p;\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 2076,
        "func": "ScriptValue WebGL2RenderingContextBase::getTexParameter(\n    ScriptState* script_state,\n    GLenum target,\n    GLenum pname) {\n  if (isContextLost() || !ValidateTextureBinding(\"getTexParameter\", target))\n    return ScriptValue::CreateNull(script_state);\n\n  switch (pname) {\n    case GL_TEXTURE_WRAP_R:\n    case GL_TEXTURE_COMPARE_FUNC:\n    case GL_TEXTURE_COMPARE_MODE:\n    case GL_TEXTURE_IMMUTABLE_LEVELS: {\n      GLint value = 0;\n      ContextGL()->GetTexParameteriv(target, pname, &value);\n      return WebGLAny(script_state, static_cast<unsigned>(value));\n    }\n    case GL_TEXTURE_IMMUTABLE_FORMAT: {\n      GLint value = 0;\n      ContextGL()->GetTexParameteriv(target, pname, &value);\n      return WebGLAny(script_state, static_cast<bool>(value));\n    }\n    case GL_TEXTURE_BASE_LEVEL:\n    case GL_TEXTURE_MAX_LEVEL: {\n      GLint value = 0;\n      ContextGL()->GetTexParameteriv(target, pname, &value);\n      return WebGLAny(script_state, value);\n    }\n    case GL_TEXTURE_MAX_LOD:\n    case GL_TEXTURE_MIN_LOD: {\n      GLfloat value = 0.f;\n      ContextGL()->GetTexParameterfv(target, pname, &value);\n      return WebGLAny(script_state, value);\n    }\n    default:\n      return WebGLRenderingContextBase::getTexParameter(script_state, target,\n                                                        pname);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2077,
        "func": "static void corrupt_bio_data(struct bio *bio, struct flakey_c *fc)\n{\n\tunsigned bio_bytes = bio_cur_bytes(bio);\n\tchar *data = bio_data(bio);\n\n\t/*\n\t * Overwrite the Nth byte of the data returned.\n\t */\n\tif (data && bio_bytes >= fc->corrupt_bio_byte) {\n\t\tdata[fc->corrupt_bio_byte - 1] = fc->corrupt_bio_value;\n\n\t\tDMDEBUG(\"Corrupting data bio=%p by writing %u to byte %u \"\n\t\t\t\"(rw=%c bi_rw=%lu bi_sector=%llu cur_bytes=%u)\\n\",\n\t\t\tbio, fc->corrupt_bio_value, fc->corrupt_bio_byte,\n\t\t\t(bio_data_dir(bio) == WRITE) ? 'w' : 'r',\n\t\t\tbio->bi_rw, (unsigned long long)bio->bi_sector, bio_bytes);\n\t}\n}",
        "target": 0
    },
    {
        "id": 2078,
        "func": "int btrfs_search_old_slot(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct btrfs_path *p, u64 time_seq)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tu8 lowest_level = 0;\n\tint prev_cmp = -1;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(p->nodes[0] != NULL);\n\n\tif (p->search_commit_root) {\n\t\tBUG_ON(time_seq);\n\t\treturn btrfs_search_slot(NULL, root, key, p, 0, 0);\n\t}\n\nagain:\n\tb = get_old_root(root, time_seq);\n\tlevel = btrfs_header_level(b);\n\tp->locks[level] = BTRFS_READ_LOCK;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t */\n\t\tbtrfs_unlock_up_safe(p, level + 1);\n\n\t\t/*\n\t\t * Since we can unwind eb's we want to do a real search every\n\t\t * time.\n\t\t */\n\t\tprev_cmp = -1;\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(NULL, root, p, &b, level,\n\t\t\t\t\t\t    slot, key, time_seq);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\terr = btrfs_try_tree_read_lock(b);\n\t\t\tif (!err) {\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tb = tree_mod_log_rewind(root->fs_info, p, b, time_seq);\n\t\t\tif (!b) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\tp->nodes[level] = b;\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0)\n\t\tbtrfs_release_path(p);\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 2079,
        "func": "void RenderView::OnStopFinding(const ViewMsg_StopFinding_Params& params) {\n  WebView* view = webview();\n  if (!view)\n    return;\n\n  WebDocument doc = view->mainFrame()->document();\n  if (doc.isPluginDocument()) {\n    GetWebPluginFromPluginDocument()->stopFind();\n    return;\n  }\n\n  bool clear_selection =\n      params.action == ViewMsg_StopFinding_Params::kClearSelection;\n  if (clear_selection)\n    view->focusedFrame()->executeCommand(WebString::fromUTF8(\"Unselect\"));\n\n  WebFrame* frame = view->mainFrame();\n  while (frame) {\n    frame->stopFinding(clear_selection);\n    frame = frame->traverseNext(false);\n  }\n\n  if (params.action == ViewMsg_StopFinding_Params::kActivateSelection) {\n    WebFrame* focused_frame = view->focusedFrame();\n    if (focused_frame) {\n      WebDocument doc = focused_frame->document();\n      if (!doc.isNull()) {\n        WebNode node = doc.focusedNode();\n        if (!node.isNull())\n          node.simulateClick();\n      }\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2080,
        "func": "     void ping()\n     {\n        CCMainThread::postTask(createMainThreadTask(this, &PingPongTestUsingTasks::pong));\n         hit = true;\n     }\n",
        "target": 1
    },
    {
        "id": 2081,
        "func": "bool SpdyProxyClientSocket::WasEverUsed() const {\n  return was_ever_used_ || (spdy_stream_.get() && spdy_stream_->WasEverUsed());\n}\n",
        "target": 0
    },
    {
        "id": 2082,
        "func": "static MagickBooleanType ConstructOrdering(const size_t count,\n  const DDSVector4 *points, const DDSVector3 axis, DDSVector4 *pointsWeights,\n  DDSVector4 *xSumwSum, unsigned char *order, size_t iteration)\n{\n  float\n     dps[16],\n     f;\n\n  register ssize_t\n    i;\n\n  size_t\n    j;\n\n  unsigned char\n    c,\n    *o,\n    *p;\n\n  o = order + (16*iteration);\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    dps[i] = Dot(points[i],axis);\n    o[i] = (unsigned char)i;\n  }\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    for (j=i; j > 0 && dps[j] < dps[j - 1]; j--)\n    {\n      f = dps[j];\n      dps[j] = dps[j - 1];\n      dps[j - 1] = f;\n\n      c = o[j];\n      o[j] = o[j - 1];\n      o[j - 1] = c;\n    }\n  }\n\n  for (i=0; i < (ssize_t) iteration; i++)\n  {\n    MagickBooleanType\n      same;\n\n    p = order + (16*i);\n    same = MagickTrue;\n\n    for (j=0; j < count; j++)\n    {\n      if (o[j] != p[j])\n        {\n          same = MagickFalse;\n          break;\n        }\n    }\n\n    if (same != MagickFalse)\n      return MagickFalse;\n  }\n\n  xSumwSum->x = 0;\n  xSumwSum->y = 0;\n  xSumwSum->z = 0;\n  xSumwSum->w = 0;\n\n  for (i=0; i < (ssize_t) count; i++)\n  {\n    DDSVector4\n      v;\n\n    j = (size_t) o[i];\n\n    v.x = points[j].w * points[j].x;\n    v.y = points[j].w * points[j].y;\n    v.z = points[j].w * points[j].z;\n    v.w = points[j].w * 1.0f;\n\n    VectorCopy44(v,&pointsWeights[i]);\n    VectorAdd(*xSumwSum,v,xSumwSum);\n  }\n\n  return MagickTrue;\n}\n",
        "target": 0
    },
    {
        "id": 2083,
        "func": "size_t bgp_packet_mpattr_prefix_size(afi_t afi, safi_t safi, struct prefix *p)\n{\n\tint size = PSIZE(p->prefixlen);\n\tif (safi == SAFI_MPLS_VPN)\n\t\tsize += 88;\n\telse if (afi == AFI_L2VPN && safi == SAFI_EVPN)\n\t\tsize += 232; // TODO: Maximum possible for type-2, type-3 and\n\t\t\t     // type-5\n\treturn size;\n}",
        "target": 0
    },
    {
        "id": 2084,
        "func": "static void lsi_skip_msgbytes(LSIState *s, unsigned int n)\n{\n    s->dnad += n;\n    s->dbc  -= n;\n}\n",
        "target": 0
    },
    {
        "id": 2085,
        "func": "iperf_get_test_reporter_interval(struct iperf_test *ipt)\n{\n    return ipt->reporter_interval;\n}",
        "target": 0
    },
    {
        "id": 2086,
        "func": "WebContents* Browser::OpenURLFromTab(WebContents* source,\n                                     const OpenURLParams& params) {\n  if (is_devtools()) {\n    DevToolsWindow* window = DevToolsWindow::AsDevToolsWindow(source);\n    DCHECK(window);\n    return window->OpenURLFromTab(source, params);\n  }\n\n  chrome::NavigateParams nav_params(this, params.url, params.transition);\n  FillNavigateParamsFromOpenURLParams(&nav_params, params);\n  nav_params.source_contents = source;\n  nav_params.tabstrip_add_types = TabStripModel::ADD_NONE;\n  if (params.user_gesture)\n    nav_params.window_action = chrome::NavigateParams::SHOW_WINDOW;\n  nav_params.user_gesture = params.user_gesture;\n\n  PopupBlockerTabHelper* popup_blocker_helper = NULL;\n  if (source)\n    popup_blocker_helper = PopupBlockerTabHelper::FromWebContents(source);\n\n  if (popup_blocker_helper) {\n    if ((params.disposition == WindowOpenDisposition::NEW_POPUP ||\n         params.disposition == WindowOpenDisposition::NEW_FOREGROUND_TAB ||\n         params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB ||\n         params.disposition == WindowOpenDisposition::NEW_WINDOW) &&\n        !params.user_gesture &&\n        !base::CommandLine::ForCurrentProcess()->HasSwitch(\n            switches::kDisablePopupBlocking)) {\n      if (popup_blocker_helper->MaybeBlockPopup(nav_params,\n                                                WebWindowFeatures())) {\n        return NULL;\n      }\n    }\n  }\n\n  chrome::Navigate(&nav_params);\n\n  return nav_params.target_contents;\n}\n",
        "target": 0
    },
    {
        "id": 2087,
        "func": " PHP_FUNCTION(mcrypt_module_get_algo_block_size)\n {\n \tMCRYPT_GET_MODE_DIR_ARGS(algorithms_dir)\n \tRETURN_LONG(mcrypt_module_get_algo_block_size(module, dir));\n }\n",
        "target": 1
    },
    {
        "id": 2088,
        "func": "set_default_smtp_connection_timeout(data_t * data)\n{\n\tdata->smtp_connection_to = DEFAULT_SMTP_CONNECTION_TIMEOUT;\n}",
        "target": 0
    },
    {
        "id": 2089,
        "func": "find_expiring_intro_point(rend_service_t *service, origin_circuit_t *circ)\n{\n  tor_assert(service);\n  tor_assert(TO_CIRCUIT(circ)->purpose == CIRCUIT_PURPOSE_S_ESTABLISH_INTRO ||\n             TO_CIRCUIT(circ)->purpose == CIRCUIT_PURPOSE_S_INTRO);\n\n  SMARTLIST_FOREACH(service->expiring_nodes, rend_intro_point_t *,\n                    intro_point,\n    if (crypto_pk_eq_keys(intro_point->intro_key, circ->intro_key)) {\n      return intro_point;\n  });\n\n  return NULL;\n}",
        "target": 0
    },
    {
        "id": 2090,
        "func": "void sta_info_stop(struct ieee80211_local *local)\n{\n\tdel_timer_sync(&local->sta_cleanup);\n}",
        "target": 0
    },
    {
        "id": 2091,
        "func": "static inline int oo_order(struct kmem_cache_order_objects x)\n{\n\treturn x.x >> 16;\n}",
        "target": 0
    },
    {
        "id": 2092,
        "func": "RenderBlockFlow::MarginValues RenderBlockFlow::marginValuesForChild(RenderBox* child) const\n{\n    LayoutUnit childBeforePositive = 0;\n    LayoutUnit childBeforeNegative = 0;\n    LayoutUnit childAfterPositive = 0;\n    LayoutUnit childAfterNegative = 0;\n\n    LayoutUnit beforeMargin = 0;\n    LayoutUnit afterMargin = 0;\n\n    RenderBlockFlow* childRenderBlockFlow = child->isRenderBlockFlow() ? toRenderBlockFlow(child) : 0;\n\n    if (!child->isWritingModeRoot()) {\n        if (childRenderBlockFlow) {\n            childBeforePositive = childRenderBlockFlow->maxPositiveMarginBefore();\n            childBeforeNegative = childRenderBlockFlow->maxNegativeMarginBefore();\n            childAfterPositive = childRenderBlockFlow->maxPositiveMarginAfter();\n            childAfterNegative = childRenderBlockFlow->maxNegativeMarginAfter();\n        } else {\n            beforeMargin = child->marginBefore();\n            afterMargin = child->marginAfter();\n        }\n    } else if (child->isHorizontalWritingMode() == isHorizontalWritingMode()) {\n        if (childRenderBlockFlow) {\n            childBeforePositive = childRenderBlockFlow->maxPositiveMarginAfter();\n            childBeforeNegative = childRenderBlockFlow->maxNegativeMarginAfter();\n            childAfterPositive = childRenderBlockFlow->maxPositiveMarginBefore();\n            childAfterNegative = childRenderBlockFlow->maxNegativeMarginBefore();\n        } else {\n            beforeMargin = child->marginAfter();\n            afterMargin = child->marginBefore();\n        }\n    } else {\n        beforeMargin = marginBeforeForChild(child);\n        afterMargin = marginAfterForChild(child);\n    }\n\n    if (beforeMargin) {\n        if (beforeMargin > 0)\n            childBeforePositive = beforeMargin;\n        else\n            childBeforeNegative = -beforeMargin;\n    }\n    if (afterMargin) {\n        if (afterMargin > 0)\n            childAfterPositive = afterMargin;\n        else\n            childAfterNegative = -afterMargin;\n    }\n\n    return RenderBlockFlow::MarginValues(childBeforePositive, childBeforeNegative, childAfterPositive, childAfterNegative);\n}\n",
        "target": 0
    },
    {
        "id": 2093,
        "func": "bool BrowserView::IsBookmarkBarVisible() const {\n  return browser_->SupportsWindowFeature(Browser::FEATURE_BOOKMARKBAR) &&\n      active_bookmark_bar_ &&\n      (active_bookmark_bar_->GetPreferredSize().height() != 0);\n}\n",
        "target": 0
    },
    {
        "id": 2094,
        "func": "static gboolean match_hostname(const char *cert_hostname, const char *hostname)\n{\n\tconst char *hostname_left;\n\n\tif (!strcasecmp(cert_hostname, hostname)) { /* exact match */\n\t\treturn TRUE;\n\t} else if (cert_hostname[0] == '*' && cert_hostname[1] == '.' && cert_hostname[2] != 0) { /* wildcard match */\n\t\t/* The initial '*' matches exactly one hostname component */\n\t\thostname_left = strchr(hostname, '.');\n\t\tif (hostname_left != NULL && ! strcasecmp(hostname_left + 1, cert_hostname + 2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}",
        "target": 0
    },
    {
        "id": 2095,
        "func": "static ssize_t in_read(struct audio_stream_in *stream, void* buffer,\n size_t bytes)\n{\n struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;\n int read;\n\n    DEBUG(\"read %zu bytes, state: %d\", bytes, in->common.state);\n\n if (in->common.state == AUDIO_A2DP_STATE_SUSPENDED)\n {\n        DEBUG(\"stream suspended\");\n return -1;\n }\n\n /* only allow autostarting if we are in stopped or standby */\n if ((in->common.state == AUDIO_A2DP_STATE_STOPPED) ||\n (in->common.state == AUDIO_A2DP_STATE_STANDBY))\n {\n        pthread_mutex_lock(&in->common.lock);\n\n if (start_audio_datapath(&in->common) < 0)\n {\n /* emulate time this write represents to avoid very fast write\n               failures during transition periods or remote suspend */\n\n int us_delay = calc_audiotime(in->common.cfg, bytes);\n\n \n             DEBUG(\"emulate a2dp read delay (%d us)\", us_delay);\n \n            usleep(us_delay);\n             pthread_mutex_unlock(&in->common.lock);\n             return -1;\n         }\n\n        pthread_mutex_unlock(&in->common.lock);\n }\n else if (in->common.state != AUDIO_A2DP_STATE_STARTED)\n {\n        ERROR(\"stream not in stopped or standby\");\n return -1;\n }\n\n    read = skt_read(in->common.audio_fd, buffer, bytes);\n\n if (read == -1)\n {\n        skt_disconnect(in->common.audio_fd);\n        in->common.audio_fd = AUDIO_SKT_DISCONNECTED;\n        in->common.state = AUDIO_A2DP_STATE_STOPPED;\n } else if (read == 0) {\n        DEBUG(\"read time out - return zeros\");\n        memset(buffer, 0, bytes);\n        read = bytes;\n }\n\n    DEBUG(\"read %d bytes out of %zu bytes\", read, bytes);\n return read;\n}\n",
        "target": 1
    },
    {
        "id": 2096,
        "func": "ELFOBJ* Elf_(r_bin_elf_new_buf)(RBuffer *buf, bool verbose) {\n\tELFOBJ *bin = R_NEW0 (ELFOBJ);\n\tbin->kv = sdb_new0 ();\n\tbin->b = r_buf_new ();\n\tbin->size = (ut32)buf->length;\n\tbin->verbose = verbose;\n\tif (!r_buf_set_bytes (bin->b, buf->buf, buf->length)) {\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\tif (!elf_init (bin)) {\n\t\treturn Elf_(r_bin_elf_free) (bin);\n\t}\n\treturn bin;\n}",
        "target": 0
    },
    {
        "id": 2097,
        "func": "void AutofillDialogViews::ContentsChanged(views::Textfield* sender,\n                                          const base::string16& new_contents) {\n  InputEditedOrActivated(TypeForTextfield(sender),\n                         sender->GetBoundsInScreen(),\n                         true);\n\n  const ExpandingTextfield* expanding = static_cast<ExpandingTextfield*>(\n      sender->GetAncestorWithClassName(ExpandingTextfield::kViewClassName));\n  if (expanding && expanding->needs_layout())\n    ContentsPreferredSizeChanged();\n}\n",
        "target": 0
    },
    {
        "id": 2098,
        "func": "static int tg3_phy_auxctl_write(struct tg3 *tp, int reg, u32 set)\n{\n\tif (reg == MII_TG3_AUXCTL_SHDWSEL_MISC)\n\t\tset |= MII_TG3_AUXCTL_MISC_WREN;\n\n\treturn tg3_writephy(tp, MII_TG3_AUX_CTRL, set | reg);\n}",
        "target": 0
    },
    {
        "id": 2099,
        "func": "int arg_parse_enum(const struct arg *arg) {\n const struct arg_enum_list *listptr;\n long int                    rawval;\n char *endptr;\n\n /* First see if the value can be parsed as a raw value */\n  rawval = strtol(arg->val, &endptr, 10);\n if (arg->val[0] != '\\0' && endptr[0] == '\\0') {\n /* Got a raw value, make sure it's valid */\n for (listptr = arg->def->enums; listptr->name; listptr++)\n if (listptr->val == rawval)\n return rawval;\n }\n\n /* Next see if it can be parsed as a string */\n for (listptr = arg->def->enums; listptr->name; listptr++)\n if (!strcmp(arg->val, listptr->name))\n return listptr->val;\n\n  die(\"Option %s: Invalid value '%s'\\n\", arg->name, arg->val);\n return 0;\n}\n",
        "target": 0
    },
    {
        "id": 2100,
        "func": "void ChromeRenderMessageFilter::OnWriteTcmallocHeapProfile(\n    const FilePath::StringType& filepath,\n    const std::string& output) {\n  VLOG(0) << \"Writing renderer heap profile dump to: \" << filepath;\n  file_util::WriteFile(FilePath(filepath), output.c_str(), output.size());\n}\n",
        "target": 1
    },
    {
        "id": 2101,
        "func": "int CountScreenshots() {\n  DownloadPrefs* download_prefs = DownloadPrefs::FromBrowserContext(\n      ProfileManager::GetActiveUserProfile());\n  base::FileEnumerator enumerator(download_prefs->DownloadPath(),\n                                  false, base::FileEnumerator::FILES,\n                                  \"Screenshot*\");\n  int count = 0;\n  while (!enumerator.Next().empty())\n    count++;\n  return count;\n}\n",
        "target": 0
    },
    {
        "id": 2102,
        "func": "ScriptLoader::~ScriptLoader()\n{\n    stopLoadRequest();\n}\n",
        "target": 0
    },
    {
        "id": 2103,
        "func": "static inline int is_thumb(struct PE_(r_bin_pe_obj_t)* bin) {\n\treturn bin->nt_headers->optional_header.AddressOfEntryPoint & 1;\n}",
        "target": 0
    },
    {
        "id": 2104,
        "func": "void BeforeTranslateInfoBar::Layout() {\n   TranslateInfoBarBase::Layout();\n \n  int available_width = InfoBar::GetAvailableWidth();\n   gfx::Size pref_size = options_menu_button_->GetPreferredSize();\n   options_menu_button_->SetBounds(available_width - pref_size.width(),\n       OffsetY(this, pref_size), pref_size.width(), pref_size.height());\n \n   pref_size = label_1_->GetPreferredSize();\n  label_1_->SetBounds(icon_->bounds().right() + InfoBar::kIconLabelSpacing,\n      InfoBar::OffsetY(this, pref_size), pref_size.width(), pref_size.height());\n \n   pref_size = language_menu_button_->GetPreferredSize();\n   language_menu_button_->SetBounds(label_1_->bounds().right() +\n      InfoBar::kButtonInLabelSpacing, OffsetY(this, pref_size),\n       pref_size.width(), pref_size.height());\n \n   pref_size = label_2_->GetPreferredSize();\n   label_2_->SetBounds(language_menu_button_->bounds().right() +\n      InfoBar::kButtonInLabelSpacing , InfoBar::OffsetY(this, pref_size),\n       pref_size.width(), pref_size.height());\n \n   pref_size = accept_button_->GetPreferredSize();\n   accept_button_->SetBounds(\n      label_2_->bounds().right() + InfoBar::kEndOfLabelSpacing,\n       OffsetY(this, pref_size), pref_size.width(), pref_size.height());\n \n   pref_size = deny_button_->GetPreferredSize();\n   deny_button_->SetBounds(\n        accept_button_->bounds().right() + InfoBar::kButtonButtonSpacing,\n         OffsetY(this, pref_size), pref_size.width(), pref_size.height());\n \n   if (never_translate_button_) {\n     pref_size = never_translate_button_->GetPreferredSize();\n     never_translate_button_->SetBounds(\n          deny_button_->bounds().right() + InfoBar::kButtonButtonSpacing,\n           OffsetY(this, pref_size), pref_size.width(), pref_size.height());\n   }\n   if (always_translate_button_) {\n     DCHECK(!never_translate_button_);\n     pref_size = always_translate_button_->GetPreferredSize();\n     always_translate_button_->SetBounds(\n          deny_button_->bounds().right() + InfoBar::kButtonButtonSpacing,\n           OffsetY(this, pref_size), pref_size.width(), pref_size.height());\n   }\n }\n",
        "target": 1
    },
    {
        "id": 2105,
        "func": "int checkClientOutputBufferLimits(client *c) {\n    int soft = 0, hard = 0, class;\n    unsigned long used_mem = getClientOutputBufferMemoryUsage(c);\n\n    class = getClientType(c);\n    /* For the purpose of output buffer limiting, masters are handled\n     * like normal clients. */\n    if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;\n\n    if (server.client_obuf_limits[class].hard_limit_bytes &&\n        used_mem >= server.client_obuf_limits[class].hard_limit_bytes)\n        hard = 1;\n    if (server.client_obuf_limits[class].soft_limit_bytes &&\n        used_mem >= server.client_obuf_limits[class].soft_limit_bytes)\n        soft = 1;\n\n    /* We need to check if the soft limit is reached continuously for the\n     * specified amount of seconds. */\n    if (soft) {\n        if (c->obuf_soft_limit_reached_time == 0) {\n            c->obuf_soft_limit_reached_time = server.unixtime;\n            soft = 0; /* First time we see the soft limit reached */\n        } else {\n            time_t elapsed = server.unixtime - c->obuf_soft_limit_reached_time;\n\n            if (elapsed <=\n                server.client_obuf_limits[class].soft_limit_seconds) {\n                soft = 0; /* The client still did not reached the max number of\n                             seconds for the soft limit to be considered\n                             reached. */\n            }\n        }\n    } else {\n        c->obuf_soft_limit_reached_time = 0;\n    }\n    return soft || hard;\n}\n",
        "target": 0
    },
    {
        "id": 2106,
        "func": "pkinit_san_authorize(krb5_context context, krb5_certauth_moddata moddata,\n                     const uint8_t *cert, size_t cert_len,\n                     krb5_const_principal princ, const void *opts,\n                     const struct _krb5_db_entry_new *db_entry,\n                     char ***authinds_out)\n{\n    krb5_error_code ret;\n    int valid_san;\n    const struct certauth_req_opts *req_opts = opts;\n\n    *authinds_out = NULL;\n\n    ret = verify_client_san(context, req_opts->plgctx, req_opts->reqctx,\n                            req_opts->cb, req_opts->rock, princ, &valid_san);\n    if (ret == ENOENT)\n        return KRB5_PLUGIN_NO_HANDLE;\n    else if (ret)\n        return ret;\n\n    if (!valid_san) {\n        TRACE_PKINIT_SERVER_SAN_REJECT(context);\n        return KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 2107,
        "func": "bool HTMLInputElement::isRadioButton() const\n{\n    return m_inputType->isRadioButton();\n}\n",
        "target": 0
    },
    {
        "id": 2108,
        "func": "void ConnectionInfoPopupAndroid::SetPermissionInfo(\n    const PermissionInfoList& permission_info_list) {\n  NOTIMPLEMENTED();\n}\n",
        "target": 0
    },
    {
        "id": 2109,
        "func": "void ChromeMetricsServiceClient::RegisterUKMProviders() {\n  ukm_service_->RegisterMetricsProvider(\n      std::make_unique<metrics::NetworkMetricsProvider>(\n          content::CreateNetworkConnectionTrackerAsyncGetter(),\n          std::make_unique<metrics::NetworkQualityEstimatorProviderImpl>()));\n\n#if defined(OS_CHROMEOS)\n  ukm_service_->RegisterMetricsProvider(\n       std::make_unique<ChromeOSMetricsProvider>());\n #endif  // !defined(OS_CHROMEOS)\n \n   ukm_service_->RegisterMetricsProvider(\n       std::make_unique<variations::FieldTrialsProvider>(nullptr,\n                                                        kUKMFieldTrialSuffix));\n}\n",
        "target": 1
    },
    {
        "id": 2110,
        "func": "BOOL license_read_binary_blob(wStream* s, LICENSE_BLOB* blob)\n{\n\tUINT16 wBlobType;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, wBlobType); /* wBlobType (2 bytes) */\n\tStream_Read_UINT16(s, blob->length); /* wBlobLen (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < blob->length)\n\t\treturn FALSE;\n\n\t/*\n \t * Server can choose to not send data by setting length to 0.\n \t * If so, it may not bother to set the type, so shortcut the warning\n \t */\n\tif ((blob->type != BB_ANY_BLOB) && (blob->length == 0))\n\t\treturn TRUE;\n\n\tif ((blob->type != wBlobType) && (blob->type != BB_ANY_BLOB))\n\t{\n\t\tfprintf(stderr, \"license binary blob type (%x) does not match expected type (%x).\\n\", wBlobType, blob->type);\n\t}\n\n\tblob->type = wBlobType;\n\tblob->data = (BYTE*) malloc(blob->length);\n\n\tStream_Read(s, blob->data, blob->length); /* blobData */\n\treturn TRUE;\n}\n",
        "target": 0
    },
    {
        "id": 2111,
        "func": "perf_callchain_kernel(struct perf_callchain_entry *entry, struct pt_regs *regs)\n{\n\tif (perf_guest_cbs && perf_guest_cbs->is_in_guest()) {\n\t\t/* TODO: We don't support guest os callchain now */\n\t\treturn;\n\t}\n\n\tperf_callchain_store(entry, regs->ip);\n\n\tdump_trace(NULL, regs, NULL, 0, &backtrace_ops, entry);\n}",
        "target": 0
    },
    {
        "id": 2112,
        "func": "XFixesDestroyRegion (Display *dpy, XserverRegion region)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesDestroyRegionReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesDestroyRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesDestroyRegion;\n    req->region = region;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n",
        "target": 0
    },
    {
        "id": 2113,
        "func": "bool MediaStreamDevicesController::IsRequestAllowedByDefault() const {\n  if (ShouldAlwaysAllowOrigin())\n    return true;\n\n  struct {\n    bool has_capability;\n    const char* policy_name;\n    const char* list_policy_name;\n    ContentSettingsType settings_type;\n  } device_checks[] = {\n    { microphone_requested_, prefs::kAudioCaptureAllowed,\n      prefs::kAudioCaptureAllowedUrls, CONTENT_SETTINGS_TYPE_MEDIASTREAM_MIC },\n    { webcam_requested_, prefs::kVideoCaptureAllowed,\n      prefs::kVideoCaptureAllowedUrls,\n      CONTENT_SETTINGS_TYPE_MEDIASTREAM_CAMERA },\n  };\n\n  for (size_t i = 0; i < ARRAYSIZE_UNSAFE(device_checks); ++i) {\n    if (!device_checks[i].has_capability)\n      continue;\n \n     DevicePolicy policy = GetDevicePolicy(device_checks[i].policy_name,\n                                           device_checks[i].list_policy_name);\n    if (policy == ALWAYS_DENY ||\n        (policy == POLICY_NOT_SET &&\n         profile_->GetHostContentSettingsMap()->GetContentSetting(\n            request_.security_origin, request_.security_origin,\n            device_checks[i].settings_type, NO_RESOURCE_IDENTIFIER) !=\n         CONTENT_SETTING_ALLOW)) {\n       return false;\n     }\n  }\n\n  return true;\n}\n",
        "target": 1
    },
    {
        "id": 2114,
        "func": "static void MSLComment(void *context,const xmlChar *value)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    A comment has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.comment(%s)\",value);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}",
        "target": 0
    },
    {
        "id": 2115,
        "func": "cached_NPN_GetStringIdentifier(const NPUTF8 *name)\n{\n  NPIdentifier ident;\n  if (!use_npidentifier_cache())\n\tident = invoke_NPN_GetStringIdentifier(name);\n#if USE_NPIDENTIFIER_CACHE\n  else if (!npidentifier_cache_has_string(name, &ident)) {\n\tident = invoke_NPN_GetStringIdentifier(name);\n\tnpidentifier_cache_reserve(1);\n\tnpidentifier_cache_add_string(ident, name);\n  }\n#endif\n  return ident;\n}",
        "target": 0
    },
    {
        "id": 2116,
        "func": "void NativePanelTestingWin::FinishDragTitlebar() {\n  panel_browser_view_->OnTitlebarMouseReleased(panel::NO_MODIFIER);\n}\n",
        "target": 0
    },
    {
        "id": 2117,
        "func": "void InputDispatcher::traceInboundQueueLengthLocked() {\n if (ATRACE_ENABLED()) {\n        ATRACE_INT(\"iq\", mInboundQueue.count());\n }\n}\n",
        "target": 0
    },
    {
        "id": 2118,
        "func": "static void CopyDoubleToDoubleElements(FixedArrayBase* from_base,\n uint32_t from_start,\n FixedArrayBase* to_base,\n uint32_t to_start, int raw_copy_size) {\n DisallowHeapAllocation no_allocation;\n int copy_size = raw_copy_size;\n if (raw_copy_size < 0) {\n    DCHECK(raw_copy_size == ElementsAccessor::kCopyToEnd ||\n           raw_copy_size == ElementsAccessor::kCopyToEndAndInitializeToHole);\n    copy_size = Min(from_base->length() - from_start,\n                    to_base->length() - to_start);\n if (raw_copy_size == ElementsAccessor::kCopyToEndAndInitializeToHole) {\n for (int i = to_start + copy_size; i < to_base->length(); ++i) {\n FixedDoubleArray::cast(to_base)->set_the_hole(i);\n }\n }\n }\n  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&\n (copy_size + static_cast<int>(from_start)) <= from_base->length());\n if (copy_size == 0) return;\n FixedDoubleArray* from = FixedDoubleArray::cast(from_base);\n FixedDoubleArray* to = FixedDoubleArray::cast(to_base);\n Address to_address = to->address() + FixedDoubleArray::kHeaderSize;\n Address from_address = from->address() + FixedDoubleArray::kHeaderSize;\n  to_address += kDoubleSize * to_start;\n  from_address += kDoubleSize * from_start;\n int words_per_double = (kDoubleSize / kPointerSize);\n CopyWords(reinterpret_cast<Object**>(to_address),\n reinterpret_cast<Object**>(from_address),\n static_cast<size_t>(words_per_double * copy_size));\n}\n",
        "target": 0
    },
    {
        "id": 2119,
        "func": " static inline sp<IMemoryHeap> find_heap(const sp<IBinder>& binder) {\n return gHeapCache->find_heap(binder);\n }\n",
        "target": 0
    },
    {
        "id": 2120,
        "func": "int __init mdio_bus_init(void)\n{\n\tint ret;\n\n\tret = class_register(&mdio_bus_class);\n\tif (!ret) {\n\t\tret = bus_register(&mdio_bus_type);\n\t\tif (ret)\n\t\t\tclass_unregister(&mdio_bus_class);\n\t}\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 2121,
        "func": "  SafeBrowsingBlockingPage* CreateSafeBrowsingPage(\n      SafeBrowsingService* service,\n      TabContents* tab_contents,\n      const SafeBrowsingBlockingPage::UnsafeResourceList& unsafe_resources) {\n    return new SafeBrowsingBlockingPage(service, tab_contents,\n                                        unsafe_resources);\n  }\n",
        "target": 0
    },
    {
        "id": 2122,
        "func": "dccp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\n{\n        const unsigned int *timeouts = data;\n\tint i;\n\n\tfor (i=CTA_TIMEOUT_DCCP_UNSPEC+1; i<CTA_TIMEOUT_DCCP_MAX+1; i++) {\n\t\tif (nla_put_be32(skb, i, htonl(timeouts[i] / HZ)))\n\t\t\tgoto nla_put_failure;\n\t}\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}",
        "target": 0
    },
    {
        "id": 2123,
        "func": "void RenderWidgetHostViewGtk::DoPopupOrFullscreenInit(GtkWindow* window,\n                                                      const gfx::Rect& bounds) {\n  requested_size_.SetSize(std::min(bounds.width(), kMaxWindowWidth),\n                          std::min(bounds.height(), kMaxWindowHeight));\n  host_->WasResized();\n\n  ui::ActiveWindowWatcherX::AddObserver(this);\n\n  if (!is_fullscreen_) {\n    gtk_widget_set_size_request(\n        view_.get(), requested_size_.width(), requested_size_.height());\n\n    gtk_window_set_resizable(window, FALSE);\n    gtk_window_set_default_size(window, -1, -1);\n    gtk_window_move(window, bounds.x(), bounds.y());\n  }\n\n  gtk_widget_show_all(GTK_WIDGET(window));\n}\n",
        "target": 0
    },
    {
        "id": 2124,
        "func": "bool ChromeContentRendererClient::AllowPopup(const GURL& creator) {\n  ChromeV8Context* current_context =\n      extension_dispatcher_->v8_context_set().GetCurrent();\n  return current_context && !current_context->extension_id().empty();\n}\n",
        "target": 0
    },
    {
        "id": 2125,
        "func": "static v8::Handle<v8::Value> methodReturningSequenceCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodReturningSequence\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     return v8Array(imp->methodReturningSequence(intArg), args.GetIsolate());\n}\n",
        "target": 1
    },
    {
        "id": 2126,
        "func": "bool CNBL::ParsePriority()\n{\n    NDIS_NET_BUFFER_LIST_8021Q_INFO priorityInfo;\n    priorityInfo.Value = m_Context->ulPriorityVlanSetting ?\n        NET_BUFFER_LIST_INFO(m_NBL, Ieee8021QNetBufferListInfo) : nullptr;\n\n    if (!priorityInfo.TagHeader.VlanId)\n    {\n        priorityInfo.TagHeader.VlanId = m_Context->VlanId;\n    }\n\n    if (priorityInfo.TagHeader.CanonicalFormatId || !IsValidVlanId(m_Context, priorityInfo.TagHeader.VlanId))\n    {\n        DPrintf(0, (\"[%s] Discarded invalid priority tag %p\\n\", __FUNCTION__, priorityInfo.Value));\n        return false;\n    }\n    else if (priorityInfo.Value)\n    {\n        // ignore priority, if configured\n        if (!IsPrioritySupported(m_Context))\n            priorityInfo.TagHeader.UserPriority = 0;\n        // ignore VlanId, if specified\n        if (!IsVlanSupported(m_Context))\n            priorityInfo.TagHeader.VlanId = 0;\n        if (priorityInfo.Value)\n        {\n            m_TCI = static_cast<UINT16>(priorityInfo.TagHeader.UserPriority << 13 | priorityInfo.TagHeader.VlanId);\n            DPrintf(1, (\"[%s] Populated priority tag %p\\n\", __FUNCTION__, priorityInfo.Value));\n        }\n    }\n\n    return true;\n}",
        "target": 0
    },
    {
        "id": 2127,
        "func": "static int setup_pivot_root(const struct lxc_rootfs *rootfs)\n{\n\tif (!rootfs->path)\n\t\treturn 0;\n\n\tif (detect_ramfs_rootfs()) {\n\t\tif (prepare_ramfs_root(rootfs->mount))\n\t\t\treturn -1;\n\t} else if (setup_rootfs_pivot_root(rootfs->mount, rootfs->pivot)) {\n\t\tERROR(\"failed to setup pivot root\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2128,
        "func": "bool RenderFrameHostImpl::CreateNetworkServiceDefaultFactoryAndObserve(\n    const base::Optional<url::Origin>& origin,\n    network::mojom::URLLoaderFactoryRequest default_factory_request) {\n  bool bypass_redirect_checks = CreateNetworkServiceDefaultFactoryInternal(\n      origin, std::move(default_factory_request));\n\n  if (IsOutOfProcessNetworkService() &&\n      (!network_service_connection_error_handler_holder_ ||\n       network_service_connection_error_handler_holder_.encountered_error())) {\n    StoragePartition* storage_partition = BrowserContext::GetStoragePartition(\n        GetSiteInstance()->GetBrowserContext(), GetSiteInstance());\n    network::mojom::URLLoaderFactoryParamsPtr params =\n        network::mojom::URLLoaderFactoryParams::New();\n    params->process_id = GetProcess()->GetID();\n    storage_partition->GetNetworkContext()->CreateURLLoaderFactory(\n        mojo::MakeRequest(&network_service_connection_error_handler_holder_),\n        std::move(params));\n    network_service_connection_error_handler_holder_\n        .set_connection_error_handler(base::BindOnce(\n            &RenderFrameHostImpl::UpdateSubresourceLoaderFactories,\n            weak_ptr_factory_.GetWeakPtr()));\n  }\n  return bypass_redirect_checks;\n}\n",
        "target": 0
    },
    {
        "id": 2129,
        "func": "void tlb_remove_table(struct mmu_gather *tlb, void *table)\n{\n\tstruct mmu_table_batch **batch = &tlb->batch;\n\n\t/*\n\t * When there's less then two users of this mm there cannot be a\n\t * concurrent page-table walk.\n\t */\n\tif (atomic_read(&tlb->mm->mm_users) < 2) {\n\t\t__tlb_remove_table(table);\n\t\treturn;\n\t}\n\n\tif (*batch == NULL) {\n\t\t*batch = (struct mmu_table_batch *)__get_free_page(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (*batch == NULL) {\n\t\t\ttlb_remove_table_one(table);\n\t\t\treturn;\n\t\t}\n\t\t(*batch)->nr = 0;\n\t}\n\t(*batch)->tables[(*batch)->nr++] = table;\n\tif ((*batch)->nr == MAX_TABLE_BATCH)\n\t\ttlb_table_flush(tlb);\n}",
        "target": 0
    },
    {
        "id": 2130,
        "func": "void fib_add_ifaddr(struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct in_ifaddr *prim = ifa;\n\t__be32 mask = ifa->ifa_mask;\n\t__be32 addr = ifa->ifa_local;\n\t__be32 prefix = ifa->ifa_address & mask;\n\n\tif (ifa->ifa_flags & IFA_F_SECONDARY) {\n\t\tprim = inet_ifa_byprefix(in_dev, prefix, mask);\n\t\tif (!prim) {\n\t\t\tpr_warn(\"%s: bug: prim == NULL\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfib_magic(RTM_NEWROUTE, RTN_LOCAL, addr, 32, prim);\n\n\tif (!(dev->flags & IFF_UP))\n\t\treturn;\n\n\t/* Add broadcast address, if it is explicitly assigned. */\n\tif (ifa->ifa_broadcast && ifa->ifa_broadcast != htonl(0xFFFFFFFF))\n\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);\n\n\tif (!ipv4_is_zeronet(prefix) && !(ifa->ifa_flags & IFA_F_SECONDARY) &&\n\t    (prefix != addr || ifa->ifa_prefixlen < 32)) {\n\t\tif (!(ifa->ifa_flags & IFA_F_NOPREFIXROUTE))\n\t\t\tfib_magic(RTM_NEWROUTE,\n\t\t\t\t  dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\n\t\t\t\t  prefix, ifa->ifa_prefixlen, prim);\n\n\t\t/* Add network specific broadcasts, when it takes a sense */\n\t\tif (ifa->ifa_prefixlen < 31) {\n\t\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix, 32, prim);\n\t\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix | ~mask,\n\t\t\t\t  32, prim);\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 2131,
        "func": "  int GetAccessibilitySelectionFiredCount() {\n    return accessibility_selection_fired_count_;\n  }\n",
        "target": 0
    },
    {
        "id": 2132,
        "func": "static int mem_cgroup_soft_limit_tree_init(void)\n{\n\tstruct mem_cgroup_tree_per_node *rtpn;\n\tstruct mem_cgroup_tree_per_zone *rtpz;\n\tint tmp, node, zone;\n\n\tfor_each_node(node) {\n\t\ttmp = node;\n\t\tif (!node_state(node, N_NORMAL_MEMORY))\n\t\t\ttmp = -1;\n\t\trtpn = kzalloc_node(sizeof(*rtpn), GFP_KERNEL, tmp);\n\t\tif (!rtpn)\n\t\t\tgoto err_cleanup;\n\n\t\tsoft_limit_tree.rb_tree_per_node[node] = rtpn;\n\n\t\tfor (zone = 0; zone < MAX_NR_ZONES; zone++) {\n\t\t\trtpz = &rtpn->rb_tree_per_zone[zone];\n\t\t\trtpz->rb_root = RB_ROOT;\n\t\t\tspin_lock_init(&rtpz->lock);\n\t\t}\n\t}\n\treturn 0;\n\nerr_cleanup:\n\tfor_each_node(node) {\n\t\tif (!soft_limit_tree.rb_tree_per_node[node])\n\t\t\tbreak;\n\t\tkfree(soft_limit_tree.rb_tree_per_node[node]);\n\t\tsoft_limit_tree.rb_tree_per_node[node] = NULL;\n\t}\n\treturn 1;\n\n}",
        "target": 0
    },
    {
        "id": 2133,
        "func": "static void macvtap_put_queue(struct macvtap_queue *q)\n{\n\tstruct macvlan_dev *vlan;\n\n\tspin_lock(&macvtap_lock);\n\tvlan = rcu_dereference_protected(q->vlan,\n\t\t\t\t\t lockdep_is_held(&macvtap_lock));\n\tif (vlan) {\n\t\tint index = get_slot(vlan, q);\n\n\t\tRCU_INIT_POINTER(vlan->taps[index], NULL);\n\t\tRCU_INIT_POINTER(q->vlan, NULL);\n\t\tsock_put(&q->sk);\n\t\t--vlan->numvtaps;\n\t}\n\n\tspin_unlock(&macvtap_lock);\n\n\tsynchronize_rcu();\n\tsock_put(&q->sk);\n}",
        "target": 0
    },
    {
        "id": 2134,
        "func": "  static void IBusBusGlobalEngineChangedCallback(\n      IBusBus* bus, const gchar* engine_name, gpointer user_data) {\n     DCHECK(engine_name);\n    DLOG(INFO) << \"Global engine is changed to \" << engine_name;\n    g_return_if_fail(user_data);\n    InputMethodStatusConnection* self\n        = static_cast<InputMethodStatusConnection*>(user_data);\n    self->UpdateUI(engine_name);\n   }\n",
        "target": 1
    },
    {
        "id": 2135,
        "func": "void GDataFileSystem::OnRemovedDocument(\n    const FileOperationCallback& callback,\n    const FilePath& file_path,\n    GDataErrorCode status,\n    const GURL& document_url) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  GDataFileError error = util::GDataToGDataFileError(status);\n\n  if (error == GDATA_FILE_OK)\n    error = RemoveEntryFromFileSystem(file_path);\n\n  if (!callback.is_null()) {\n    callback.Run(error);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2136,
        "func": "std::set<RTCPeerConnectionHandler*>* GetPeerConnectionHandlers() {\n  static std::set<RTCPeerConnectionHandler*>* handlers =\n      new std::set<RTCPeerConnectionHandler*>();\n  return handlers;\n}\n",
        "target": 0
    },
    {
        "id": 2137,
        "func": "NTPResourceCache::WindowType NTPResourceCache::GetWindowType(\n    Profile* profile, content::RenderProcessHost* render_host) {\n  if (profile->IsGuestSession()) {\n    return NTPResourceCache::GUEST;\n  } else if (render_host) {\n    if (render_host->GetBrowserContext()->IsOffTheRecord())\n      return NTPResourceCache::INCOGNITO;\n  } else if (profile->IsOffTheRecord()) {\n    return NTPResourceCache::INCOGNITO;\n  }\n  return NTPResourceCache::NORMAL;\n}\n",
        "target": 0
    },
    {
        "id": 2138,
        "func": "void BrowserLauncherItemController::Init() {\n  tab_model_->AddObserver(this);\n  ash::LauncherItemStatus app_status =\n      ash::wm::IsActiveWindow(window_) ?\n      ash::STATUS_ACTIVE : ash::STATUS_RUNNING;\n  if (type() != TYPE_TABBED) {\n    launcher_controller()->CreateAppLauncherItem(this, app_id(), app_status);\n  } else {\n    launcher_controller()->CreateTabbedLauncherItem(\n        this,\n        is_incognito_ ? ChromeLauncherController::STATE_INCOGNITO :\n                        ChromeLauncherController::STATE_NOT_INCOGNITO,\n        app_status);\n  }\n  if (tab_model_->GetActiveTabContents())\n    UpdateLauncher(tab_model_->GetActiveTabContents());\n}\n",
        "target": 0
    },
    {
        "id": 2139,
        "func": "  void OnReadAllMetadata(\n      const SessionStore::SessionInfo& session_info,\n      SessionStore::FactoryCompletionCallback callback,\n      std::unique_ptr<ModelTypeStore> store,\n       std::unique_ptr<ModelTypeStore::RecordList> record_list,\n       const base::Optional<syncer::ModelError>& error,\n       std::unique_ptr<syncer::MetadataBatch> metadata_batch) {\n    // Remove after fixing https://crbug.com/902203.\n    TRACE_EVENT0(\"browser\", \"FactoryImpl::OnReadAllMetadata\");\n     if (error) {\n       std::move(callback).Run(error, /*store=*/nullptr,\n                               /*metadata_batch=*/nullptr);\n      return;\n    }\n\n    std::map<std::string, sync_pb::SessionSpecifics> initial_data;\n    for (ModelTypeStore::Record& record : *record_list) {\n      const std::string& storage_key = record.id;\n      SessionSpecifics specifics;\n      if (storage_key.empty() ||\n          !specifics.ParseFromString(std::move(record.value))) {\n        DVLOG(1) << \"Ignoring corrupt database entry with key: \" << storage_key;\n        continue;\n      }\n      initial_data[storage_key].Swap(&specifics);\n    }\n\n    auto session_store = std::make_unique<SessionStore>(\n        sessions_client_, session_info, std::move(store),\n        std::move(initial_data), metadata_batch->GetAllMetadata(),\n        restored_foreign_tab_callback_);\n\n    std::move(callback).Run(/*error=*/base::nullopt, std::move(session_store),\n                            std::move(metadata_batch));\n  }\n",
        "target": 0
    },
    {
        "id": 2140,
        "func": "const XMLObject* DynamicMetadataProvider::getMetadata() const\n{\n    throw MetadataException(\"getMetadata operation not implemented on this provider.\");\n}\n",
        "target": 0
    },
    {
        "id": 2141,
        "func": "void ImageLoader::DecodeRequest::ProcessForTask() {\n  if (!loader_)\n    return;\n\n  DCHECK_EQ(state_, kPendingMicrotask);\n  state_ = kPendingLoad;\n  loader_->DispatchDecodeRequestsIfComplete();\n}\n",
        "target": 0
    },
    {
        "id": 2142,
        "func": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  mutt_message(_(\"Logging in...\"));\n\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n\n  /* don't print the password unless we're at the ungodly debugging level\n   * of 5 or higher */\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); /* clear \"Logging in...\".  fixes #3524 */\n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}",
        "target": 1
    },
    {
        "id": 2143,
        "func": "  void ProcessOnTargetThread() {\n    RunWork();\n    origin_message_loop_proxy_->PostTask(\n        FROM_HERE,\n        NewRunnableMethod(this, &MessageLoopRelay::RunCallback));\n  }\n",
        "target": 0
    },
    {
        "id": 2144,
        "func": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00 };\n\n\tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n\n\tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 2145,
        "func": "static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n {\n \tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n \tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n \tobject->u.dir.index++;\n \tdo {\n \t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}\n",
        "target": 1
    },
    {
        "id": 2146,
        "func": "UsbUsageType GetUsageType(const libusb_endpoint_descriptor* descriptor) {\n  switch ((descriptor->bmAttributes & LIBUSB_ISO_USAGE_TYPE_MASK) >> 4) {\n    case LIBUSB_ISO_USAGE_TYPE_DATA:\n      return USB_USAGE_DATA;\n    case LIBUSB_ISO_USAGE_TYPE_FEEDBACK:\n      return USB_USAGE_FEEDBACK;\n    case LIBUSB_ISO_USAGE_TYPE_IMPLICIT:\n      return USB_USAGE_EXPLICIT_FEEDBACK;\n    default:\n      NOTREACHED();\n      return USB_USAGE_DATA;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2147,
        "func": "rdp_in_coord(STREAM s, sint16 * coord, RD_BOOL delta)\n{\n\tsint8 change;\n\n\tif (delta)\n\t{\n\t\tin_uint8(s, change);\n\t\t*coord += change;\n\t}\n\telse\n\t{\n\t\tin_uint16_le(s, *coord);\n\t}\n}",
        "target": 0
    },
    {
        "id": 2148,
        "func": "WebNotificationTray* Shell::GetWebNotificationTray() {\n  return GetPrimaryRootWindowController()->shelf()->\n      status_area_widget()->web_notification_tray();\n}\n",
        "target": 0
    },
    {
        "id": 2149,
        "func": " void WasmCompileStreamingImpl(const v8::FunctionCallbackInfo<v8::Value>& args) {\n   v8::Isolate* isolate = args.GetIsolate();\n  ScriptState* script_state = ScriptState::ForRelevantRealm(args);\n \n   v8::Local<v8::Function> compile_callback =\n       v8::Function::New(isolate, CompileFromResponseCallback);\n\n\n  V8SetReturnValue(args, ScriptPromise::Cast(script_state, args[0])\n                             .Then(compile_callback)\n                             .V8Value());\n\n}\n",
        "target": 1
    },
    {
        "id": 2150,
        "func": " */\nbool rps_may_expire_flow(struct net_device *dev, u16 rxq_index,\n\t\t\t u32 flow_id, u16 filter_id)\n{\n\tstruct netdev_rx_queue *rxqueue = dev->_rx + rxq_index;\n\tstruct rps_dev_flow_table *flow_table;\n\tstruct rps_dev_flow *rflow;\n\tbool expire = true;\n\tunsigned int cpu;\n\n\trcu_read_lock();\n\tflow_table = rcu_dereference(rxqueue->rps_flow_table);\n\tif (flow_table && flow_id <= flow_table->mask) {\n\t\trflow = &flow_table->flows[flow_id];\n\t\tcpu = ACCESS_ONCE(rflow->cpu);\n\t\tif (rflow->filter == filter_id && cpu < nr_cpu_ids &&\n\t\t    ((int)(per_cpu(softnet_data, cpu).input_queue_head -\n\t\t\t   rflow->last_qtail) <\n\t\t     (int)(10 * flow_table->mask)))\n\t\t\texpire = false;\n\t}\n\trcu_read_unlock();\n\treturn expire;",
        "target": 0
    },
    {
        "id": 2151,
        "func": "static int ppp_sock_fprog_ioctl_trans(unsigned int fd, unsigned int cmd,\n\t\t\tstruct sock_fprog32 __user *u_fprog32)\n{\n\tstruct sock_fprog __user *u_fprog64 = compat_alloc_user_space(sizeof(struct sock_fprog));\n\tvoid __user *fptr64;\n\tu32 fptr32;\n\tu16 flen;\n\n\tif (get_user(flen, &u_fprog32->len) ||\n\t    get_user(fptr32, &u_fprog32->filter))\n\t\treturn -EFAULT;\n\n\tfptr64 = compat_ptr(fptr32);\n\n\tif (put_user(flen, &u_fprog64->len) ||\n\t    put_user(fptr64, &u_fprog64->filter))\n\t\treturn -EFAULT;\n\n\tif (cmd == PPPIOCSPASS32)\n\t\tcmd = PPPIOCSPASS;\n\telse\n\t\tcmd = PPPIOCSACTIVE;\n\n\treturn sys_ioctl(fd, cmd, (unsigned long) u_fprog64);\n}",
        "target": 0
    },
    {
        "id": 2152,
        "func": "void RenderViewImpl::OnSetBackground(const SkBitmap& background) {\n  if (webview())\n    webview()->setIsTransparent(!background.empty());\n  if (compositor_)\n    compositor_->setHasTransparentBackground(!background.empty());\n\n  SetBackground(background);\n}\n",
        "target": 0
    },
    {
        "id": 2153,
        "func": "static void *userns_get(struct task_struct *task)\n{\n\tstruct user_namespace *user_ns;\n\n\trcu_read_lock();\n\tuser_ns = get_user_ns(__task_cred(task)->user_ns);\n\trcu_read_unlock();\n\n\treturn user_ns;\n}",
        "target": 0
    },
    {
        "id": 2154,
        "func": "enum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}\n",
        "target": 0
    },
    {
        "id": 2155,
        "func": "static void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\t/* In case we need an open_confirm, no cleanup! */\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}",
        "target": 1
    },
    {
        "id": 2156,
        "func": "long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {\n  assert(pReader);\n  assert(pos >= 0);\n  int status;\n \n   len = 1;\n   unsigned char b;\n  status = pReader->Read(pos, 1, &b);\n \n   if (status < 0)  // error or underflow\n     return status;\n\n if (status > 0) // interpreted as \"underflow\"\n return E_BUFFER_NOT_FULL;\n\n if (b == 0) // we can't handle u-int values larger than 8 bytes\n return E_FILE_FORMAT_INVALID;\n\n unsigned char m = 0x80;\n\n while (!(b & m)) {\n    m >>= 1;\n\n     ++len;\n   }\n \n   long long result = b & (~m);\n   ++pos;\n \n for (int i = 1; i < len; ++i) {\n    status = pReader->Read(pos, 1, &b);\n\n if (status < 0) {\n      len = 1;\n return status;\n }\n\n if (status > 0) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result <<= 8;\n    result |= b;\n\n ++pos;\n }\n\n\n   return result;\n }\n",
        "target": 1
    },
    {
        "id": 2157,
        "func": "bool HTMLFormControlElement::isRequired() const\n{\n    return m_isRequired;\n}\n",
        "target": 0
    },
    {
        "id": 2158,
        "func": "  void SetZoomLevel(double level) { view()->UpdateZoomLevel(level); }\n",
        "target": 0
    },
    {
        "id": 2159,
        "func": "void HTMLMediaElement::scheduleRejectPlayPromises(ExceptionCode code) {\n  DCHECK(m_playPromiseRejectList.isEmpty() ||\n         m_playPromiseRejectTaskHandle.isActive());\n  if (m_playPromiseResolvers.isEmpty())\n    return;\n\n  m_playPromiseRejectList.appendVector(m_playPromiseResolvers);\n  m_playPromiseResolvers.clear();\n\n  if (m_playPromiseRejectTaskHandle.isActive())\n    return;\n\n  m_playPromiseErrorCode = code;\n  m_playPromiseRejectTaskHandle =\n      TaskRunnerHelper::get(TaskType::MediaElementEvent, &document())\n          ->postCancellableTask(\n              BLINK_FROM_HERE,\n              WTF::bind(&HTMLMediaElement::rejectScheduledPlayPromises,\n                        wrapWeakPersistent(this)));\n}\n",
        "target": 0
    },
    {
        "id": 2160,
        "func": " void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,\n                                                  const std::string& result,\n                                                  bool success,\n                                                 bool notify_needed,\n                                                 intptr_t notify_data) {\n  instance()->SendJavaScriptStream(url, result, success, notify_needed,\n                                   notify_data);\n }\n",
        "target": 1
    },
    {
        "id": 2161,
        "func": "static void print_ucode(struct ucode_cpu_info *uci)\n{\n\tstruct microcode_intel *mc_intel;\n\tint *delay_ucode_info_p;\n\tint *current_mc_date_p;\n\n\tmc_intel = uci->mc;\n\tif (mc_intel == NULL)\n\t\treturn;\n\n\tdelay_ucode_info_p = (int *)__pa_nodebug(&delay_ucode_info);\n\tcurrent_mc_date_p = (int *)__pa_nodebug(&current_mc_date);\n\n\t*delay_ucode_info_p = 1;\n\t*current_mc_date_p = mc_intel->hdr.date;\n}",
        "target": 0
    },
    {
        "id": 2162,
        "func": "SECURITY_STATUS SEC_ENTRY AcceptSecurityContext(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tPSecBufferDesc pInput, ULONG fContextReq, ULONG TargetDataRep, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsTimeStamp)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->AcceptSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->AcceptSecurityContext(phCredential, phContext, pInput, fContextReq,\n\t\t\tTargetDataRep, phNewContext, pOutput, pfContextAttr, ptsTimeStamp);\n\n\treturn status;\n}",
        "target": 0
    },
    {
        "id": 2163,
        "func": "static std::string FixupPath(const std::string& text) {\n  DCHECK(!text.empty());\n\n  FilePath::StringType filename;\n#if defined(OS_WIN)\n  FilePath input_path(UTF8ToWide(text));\n  PrepareStringForFileOps(input_path, &filename);\n\n  if (filename.length() > 1 && filename[1] == '|')\n    filename[1] = ':';\n#elif defined(OS_POSIX)\n  FilePath input_path(text);\n  PrepareStringForFileOps(input_path, &filename);\n  if (filename.length() > 0 && filename[0] == '~')\n    filename = FixupHomedir(filename);\n#endif\n\n  GURL file_url = net::FilePathToFileURL(FilePath(filename));\n  if (file_url.is_valid()) {\n    return UTF16ToUTF8(net::FormatUrl(file_url, std::string(),\n        net::kFormatUrlOmitUsernamePassword, UnescapeRule::NORMAL, NULL,\n        NULL, NULL));\n  }\n\n  return text;\n}\n",
        "target": 0
    },
    {
        "id": 2164,
        "func": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tbacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);\n\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 2165,
        "func": "xsltNumberFormatGetValue(xmlXPathContextPtr context,\n\t\t\t xmlNodePtr node,\n\t\t\t const xmlChar *value,\n\t\t\t double *number)\n{\n    int amount = 0;\n    xmlBufferPtr pattern;\n    xmlXPathObjectPtr obj;\n\n    pattern = xmlBufferCreate();\n    if (pattern != NULL) {\n\txmlBufferCCat(pattern, \"number(\");\n\txmlBufferCat(pattern, value);\n\txmlBufferCCat(pattern, \")\");\n\tcontext->node = node;\n\tobj = xmlXPathEvalExpression(xmlBufferContent(pattern),\n\t\t\t\t     context);\n\tif (obj != NULL) {\n\t    *number = obj->floatval;\n\t    amount++;\n\t    xmlXPathFreeObject(obj);\n\t}\n\txmlBufferFree(pattern);\n    }\n    return amount;\n}\n",
        "target": 0
    },
    {
        "id": 2166,
        "func": "void PrintWebViewHelper::UpdateFrameAndViewFromCssPageLayout(\n    WebFrame* frame,\n    const WebNode& node,\n    PrepareFrameAndViewForPrint* prepare,\n    const PrintMsg_Print_Params& params,\n    bool ignore_css_margins) {\n  if (PrintingNodeOrPdfFrame(frame, node))\n    return;\n  bool fit_to_page = ignore_css_margins &&\n                     params.print_scaling_option ==\n                          WebKit::WebPrintScalingOptionFitToPrintableArea;\n  PrintMsg_Print_Params print_params = CalculatePrintParamsForCss(\n      frame, 0, params, ignore_css_margins, fit_to_page, NULL);\n  prepare->UpdatePrintParams(print_params);\n}\n",
        "target": 0
    },
    {
        "id": 2167,
        "func": "void LocalFrame::Reload(WebFrameLoadType load_type,\n                        ClientRedirectPolicy client_redirect_policy) {\n  DCHECK(IsReloadLoadType(load_type));\n  if (client_redirect_policy == ClientRedirectPolicy::kNotClientRedirect) {\n    if (!loader_.GetDocumentLoader()->GetHistoryItem())\n      return;\n    FrameLoadRequest request = FrameLoadRequest(\n        nullptr,\n        loader_.ResourceRequestForReload(load_type, client_redirect_policy));\n    request.SetClientRedirect(client_redirect_policy);\n    loader_.StartNavigation(request, load_type);\n  } else {\n    DCHECK_EQ(WebFrameLoadType::kReload, load_type);\n    navigation_scheduler_->ScheduleReload();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2168,
        "func": " static int php_stream_temp_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) /* {{{ */\n {\n        php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n        switch(option) {\n                case PHP_STREAM_OPTION_META_DATA_API:\n                        if (ts->meta) {\n\t\t\t\tzend_hash_copy(Z_ARRVAL_P((zval*)ptrparam), Z_ARRVAL_P(ts->meta), (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval*));\n\t\t\t}\n\t\t\treturn PHP_STREAM_OPTION_RETURN_OK;\n\t\tdefault:\n\t\t\tif (ts->innerstream) {\n\t\t\t\treturn php_stream_set_option(ts->innerstream, option, value, ptrparam);\n\t\t\t}\n\t\t\treturn PHP_STREAM_OPTION_RETURN_NOTIMPL;\n\t}\n}\n/* }}} */\n",
        "target": 1
    },
    {
        "id": 2169,
        "func": "struct request_queue *blk_mq_init_queue(struct blk_mq_tag_set *set)\n{\n\tstruct request_queue *uninit_q, *q;\n\n\tuninit_q = blk_alloc_queue_node(GFP_KERNEL, set->numa_node);\n\tif (!uninit_q)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tq = blk_mq_init_allocated_queue(set, uninit_q);\n\tif (IS_ERR(q))\n\t\tblk_cleanup_queue(uninit_q);\n\n\treturn q;\n}",
        "target": 0
    },
    {
        "id": 2170,
        "func": "iperf_set_test_get_server_output(struct iperf_test *ipt, int get_server_output)\n{\n    ipt->get_server_output = get_server_output;\n}",
        "target": 0
    },
    {
        "id": 2171,
        "func": "status_t OMXCodec::cancelBufferToNativeWindow(BufferInfo *info) {\n    CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);\n    CODEC_LOGV(\"Calling cancelBuffer on buffer %u\", info->mBuffer);\n int err = mNativeWindow->cancelBuffer(\n        mNativeWindow.get(), info->mMediaBuffer->graphicBuffer().get(), -1);\n if (err != 0) {\n      CODEC_LOGE(\"cancelBuffer failed w/ error 0x%08x\", err);\n\n      setState(ERROR);\n return err;\n }\n    info->mStatus = OWNED_BY_NATIVE_WINDOW;\n return OK;\n}\n",
        "target": 0
    },
    {
        "id": 2172,
        "func": "dtls1_get_bitmap(SSL *s, SSL3_RECORD *rr, unsigned int *is_next_epoch)\n    {\n    \n    *is_next_epoch = 0;\n\n    /* In current epoch, accept HM, CCS, DATA, & ALERT */\n    if (rr->epoch == s->d1->r_epoch)\n        return &s->d1->bitmap;\n\n    /* Only HM and ALERT messages can be from the next epoch */\n    else if (rr->epoch == (unsigned long)(s->d1->r_epoch + 1) &&\n        (rr->type == SSL3_RT_HANDSHAKE ||\n            rr->type == SSL3_RT_ALERT))\n        {\n        *is_next_epoch = 1;\n        return &s->d1->next_bitmap;\n        }\n\n    return NULL;\n    }\n",
        "target": 0
    },
    {
        "id": 2173,
        "func": "void keyring_gc(struct key *keyring, time_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}",
        "target": 0
    },
    {
        "id": 2174,
        "func": "URLPatternSet PermissionsData::GetEffectiveHostPermissions() const {\n  base::AutoLock auto_lock(runtime_lock_);\n  URLPatternSet effective_hosts = active_permissions_unsafe_->effective_hosts();\n  for (const auto& val : tab_specific_permissions_)\n    effective_hosts.AddPatterns(val.second->effective_hosts());\n  return effective_hosts;\n}\n",
        "target": 0
    },
    {
        "id": 2175,
        "func": " void ScreenRecorder::RemoveConnection(\n     scoped_refptr<ConnectionToClient> connection) {\n  network_loop_->PostTask(\n      FROM_HERE, base::Bind(&ScreenRecorder::DoRemoveClient, this, connection));\n }\n",
        "target": 1
    },
    {
        "id": 2176,
        "func": "static VirtIONetQueue *virtio_net_get_subqueue(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n\n    return &n->vqs[nc->queue_index];\n}\n",
        "target": 0
    },
    {
        "id": 2177,
        "func": "static void add_descendants_to_write_order(struct object_entry **wo,\n\t\t\t\t\t   unsigned int *endp,\n\t\t\t\t\t   struct object_entry *e)\n{\n\tint add_to_order = 1;\n\twhile (e) {\n\t\tif (add_to_order) {\n\t\t\tstruct object_entry *s;\n\t\t\t/* add this node... */\n\t\t\tadd_to_write_order(wo, endp, e);\n\t\t\t/* all its siblings... */\n\t\t\tfor (s = e->delta_sibling; s; s = s->delta_sibling) {\n\t\t\t\tadd_to_write_order(wo, endp, s);\n\t\t\t}\n\t\t}\n\t\t/* drop down a level to add left subtree nodes if possible */\n\t\tif (e->delta_child) {\n\t\t\tadd_to_order = 1;\n\t\t\te = e->delta_child;\n\t\t} else {\n\t\t\tadd_to_order = 0;\n\t\t\t/* our sibling might have some children, it is next */\n\t\t\tif (e->delta_sibling) {\n\t\t\t\te = e->delta_sibling;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* go back to our parent node */\n\t\t\te = e->delta;\n\t\t\twhile (e && !e->delta_sibling) {\n\t\t\t\t/* we're on the right side of a subtree, keep\n\t\t\t\t * going up until we can go right again */\n\t\t\t\te = e->delta;\n\t\t\t}\n\t\t\tif (!e) {\n\t\t\t\t/* done- we hit our original root node */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* pass it off to sibling at this level */\n\t\t\te = e->delta_sibling;\n\t\t}\n\t};\n}",
        "target": 0
    },
    {
        "id": 2178,
        "func": "NPError WebPluginDelegatePepper::Device3DFlushContext(\n    NPP id,\n    NPDeviceContext3D* context,\n    NPDeviceFlushContextCallbackPtr callback,\n    void* user_data) {\n  if (!context)\n    return NPERR_GENERIC_ERROR;\n\n#if defined(ENABLE_GPU)\n  gpu::CommandBuffer::State state;\n\n  if (context->waitForProgress) {\n    if (callback) {\n      command_buffer_->AsyncFlush(\n          context->putOffset,\n          method_factory3d_.NewRunnableMethod(\n              &WebPluginDelegatePepper::Device3DUpdateState,\n              id,\n              context,\n              callback,\n              user_data));\n    } else {\n      state = command_buffer_->Flush(context->putOffset);\n      Synchronize3DContext(context, state);\n    }\n  } else {\n    if (callback) {\n      command_buffer_->AsyncGetState(\n          method_factory3d_.NewRunnableMethod(\n              &WebPluginDelegatePepper::Device3DUpdateState,\n              id,\n              context,\n              callback,\n              user_data));\n    } else {\n      state = command_buffer_->GetState();\n      Synchronize3DContext(context, state);\n    }\n  }\n#endif  // ENABLE_GPU\n  return NPERR_NO_ERROR;\n}\n",
        "target": 0
    },
    {
        "id": 2179,
        "func": " */\nint sock_queue_err_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >=\n\t    (unsigned int)sk->sk_rcvbuf)\n\t\treturn -ENOMEM;\n\n\tskb_orphan(skb);\n\tskb->sk = sk;\n\tskb->destructor = sock_rmem_free;\n\tatomic_add(skb->truesize, &sk->sk_rmem_alloc);\n\n\t/* before exiting rcu section, make sure dst is refcounted */\n\tskb_dst_force(skb);\n\n\tskb_queue_tail(&sk->sk_error_queue, skb);\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\treturn 0;",
        "target": 1
    },
    {
        "id": 2180,
        "func": "bool ChromeContentBrowserClientExtensionsPart::ShouldLockToOrigin(\n    content::BrowserContext* browser_context,\n    const GURL& effective_site_url) {\n  if (effective_site_url.SchemeIs(extensions::kExtensionScheme)) {\n    const Extension* extension =\n        ExtensionRegistry::Get(browser_context)\n            ->enabled_extensions()\n            .GetExtensionOrAppByURL(effective_site_url);\n    if (extension && extension->is_hosted_app())\n      return false;\n\n    if (!base::CommandLine::ForCurrentProcess()->HasSwitch(\n            ::switches::kSitePerProcess))\n      return false;\n  }\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2181,
        "func": "void PageClickTracker::StopTrackingFrame(WebFrame* frame, bool frame_detached) {\n  FrameList::iterator iter =\n      std::find(tracked_frames_.begin(), tracked_frames_.end(), frame);\n  if (iter == tracked_frames_.end()) {\n    return;\n  }\n  tracked_frames_.erase(iter);\n  if (!frame_detached)\n    frame->document().removeEventListener(\"mousedown\", this, false);\n}\n",
        "target": 0
    },
    {
        "id": 2182,
        "func": "static plist_t parse_unicode_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    uint64_t i = 0;\n    uint16_t *unicodestr = NULL;\n    char *tmpstr = NULL;\n    long items_read = 0;\n    long items_written = 0;\n\n    data->type = PLIST_STRING;\n    unicodestr = (uint16_t*) malloc(sizeof(uint16_t) * size);\n    if (!unicodestr) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(uint16_t) * size);\n        return NULL;\n    }\n    for (i = 0; i < size; i++)\n        unicodestr[i] = be16toh(((uint16_t*)*bnode)[i]);\n\n    tmpstr = plist_utf16_to_utf8(unicodestr, size, &items_read, &items_written);\n    free(unicodestr);\n    if (!tmpstr) {\n        plist_free_data(data);\n        return NULL;\n    }\n    tmpstr[items_written] = '\\0';\n\n    data->type = PLIST_STRING;\n    data->strval = realloc(tmpstr, items_written+1);\n    if (!data->strval)\n        data->strval = tmpstr;\n    data->length = items_written;\n    return node_create(NULL, data);\n}",
        "target": 0
    },
    {
        "id": 2183,
        "func": " ScrollHitTestDisplayItem::ScrollHitTestDisplayItem(\n     const DisplayItemClient& client,\n     Type type,\n    scoped_refptr<const TransformPaintPropertyNode> scroll_offset_node)\n     : DisplayItem(client, type, sizeof(*this)),\n      scroll_offset_node_(std::move(scroll_offset_node)) {\n   DCHECK(RuntimeEnabledFeatures::SlimmingPaintV2Enabled());\n   DCHECK(IsScrollHitTestType(type));\n  DCHECK(scroll_offset_node_->ScrollNode());\n }\n",
        "target": 1
    },
    {
        "id": 2184,
        "func": "void FileAPIMessageFilter::BadMessageReceived() {\n  RecordAction(UserMetricsAction(\"BadMessageTerminate_FAMF\"));\n  BrowserMessageFilter::BadMessageReceived();\n}\n",
        "target": 0
    },
    {
        "id": 2185,
        "func": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len = 20 + level) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif /* ENABLE_CONDITIONALS */\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2186,
        "func": "static void arcmsr_start_adapter_bgrb(struct AdapterControlBlock *acb)\n{\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A:\n\t\tarcmsr_hbaA_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_B:\n\t\tarcmsr_hbaB_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C:\n\t\tarcmsr_hbaC_start_bgrb(acb);\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tarcmsr_hbaD_start_bgrb(acb);\n\t\tbreak;\n\t}\n}",
        "target": 0
    },
    {
        "id": 2187,
        "func": "void WebGLRenderingContextBase::AddToEvictedList(\n    WebGLRenderingContextBase* context) {\n  static int generation = 0;\n  ForciblyEvictedContexts().Set(context, generation++);\n}\n",
        "target": 0
    },
    {
        "id": 2188,
        "func": "static struct sock *udp4_lib_lookup2(struct net *net,\n\t\t__be32 saddr, __be16 sport,\n\t\t__be32 daddr, unsigned int hnum, int dif,\n\t\tstruct udp_hslot *hslot2, unsigned int slot2)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tint score, badness;\n\nbegin:\n\tresult = NULL;\n\tbadness = -1;\n\tudp_portaddr_for_each_entry_rcu(sk, node, &hslot2->head) {\n\t\tscore = compute_score2(sk, net, saddr, sport,\n\t\t\t\t      daddr, hnum, dif);\n\t\tif (score > badness) {\n\t\t\tresult = sk;\n\t\t\tbadness = score;\n\t\t\tif (score == SCORE2_MAX)\n\t\t\t\tgoto exact_match;\n\t\t}\n\t}\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (get_nulls_value(node) != slot2)\n\t\tgoto begin;\n\n\tif (result) {\nexact_match:\n\t\tif (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(compute_score2(result, net, saddr, sport,\n\t\t\t\t  daddr, hnum, dif) < badness)) {\n\t\t\tsock_put(result);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\treturn result;\n}",
        "target": 0
    },
    {
        "id": 2189,
        "func": "static struct se_cmd *tcm_loop_allocate_core_cmd(\n\tstruct tcm_loop_hba *tl_hba,\n\tstruct se_portal_group *se_tpg,\n\tstruct scsi_cmnd *sc)\n{\n\tstruct se_cmd *se_cmd;\n\tstruct se_session *se_sess;\n\tstruct tcm_loop_nexus *tl_nexus = tl_hba->tl_nexus;\n\tstruct tcm_loop_cmd *tl_cmd;\n\tint sam_task_attr;\n\n\tif (!tl_nexus) {\n\t\tscmd_printk(KERN_ERR, sc, \"TCM_Loop I_T Nexus\"\n\t\t\t\t\" does not exist\\n\");\n\t\tset_host_byte(sc, DID_ERROR);\n\t\treturn NULL;\n\t}\n\tse_sess = tl_nexus->se_sess;\n\n\ttl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_ATOMIC);\n\tif (!tl_cmd) {\n\t\tprintk(KERN_ERR \"Unable to allocate struct tcm_loop_cmd\\n\");\n\t\tset_host_byte(sc, DID_ERROR);\n\t\treturn NULL;\n\t}\n\tse_cmd = &tl_cmd->tl_se_cmd;\n\t/*\n\t * Save the pointer to struct scsi_cmnd *sc\n\t */\n\ttl_cmd->sc = sc;\n\t/*\n\t * Locate the SAM Task Attr from struct scsi_cmnd *\n\t */\n\tif (sc->device->tagged_supported) {\n\t\tswitch (sc->tag) {\n\t\tcase HEAD_OF_QUEUE_TAG:\n\t\t\tsam_task_attr = MSG_HEAD_TAG;\n\t\t\tbreak;\n\t\tcase ORDERED_QUEUE_TAG:\n\t\t\tsam_task_attr = MSG_ORDERED_TAG;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsam_task_attr = MSG_SIMPLE_TAG;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tsam_task_attr = MSG_SIMPLE_TAG;\n\n\t/*\n\t * Initialize struct se_cmd descriptor from target_core_mod infrastructure\n\t */\n\ttransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess,\n\t\t\tscsi_bufflen(sc), sc->sc_data_direction, sam_task_attr,\n\t\t\t&tl_cmd->tl_sense_buf[0]);\n\n\t/*\n\t * Signal BIDI usage with T_TASK(cmd)->t_tasks_bidi\n\t */\n\tif (scsi_bidi_cmnd(sc))\n\t\tse_cmd->t_tasks_bidi = 1;\n\t/*\n\t * Locate the struct se_lun pointer and attach it to struct se_cmd\n\t */\n\tif (transport_lookup_cmd_lun(se_cmd, tl_cmd->sc->device->lun) < 0) {\n\t\tkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\n\t\tset_host_byte(sc, DID_NO_CONNECT);\n\t\treturn NULL;\n\t}\n\n\treturn se_cmd;\n}",
        "target": 0
    },
    {
        "id": 2190,
        "func": "bool ExecuteScriptWithUserGestureControl(RenderFrameHost* frame,\n                                         const std::string& script,\n                                         bool user_gesture) {\n\n  std::string expected_response = \"ExecuteScript-\" + base::GenerateGUID();\n  std::string new_script = base::StringPrintf(\n      R\"( %s;  // Original script.\n          window.domAutomationController.send('%s'); )\",\n      script.c_str(), expected_response.c_str());\n\n  std::unique_ptr<base::Value> value;\n  if (!ExecuteScriptHelper(frame, new_script, user_gesture, &value) ||\n      !value.get()) {\n    return false;\n  }\n\n  DCHECK_EQ(base::Value::Type::STRING, value->type());\n  std::string actual_response;\n  if (value->GetAsString(&actual_response))\n    DCHECK_EQ(expected_response, actual_response);\n\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2191,
        "func": "  explicit FrozenMockFunction(const std::string& name) : MockFunction(name) {}\n",
        "target": 0
    },
    {
        "id": 2192,
        "func": "void WebFrameLoaderClient::setMainFrameDocumentReady(bool ready) {\n}\n",
        "target": 0
    },
    {
        "id": 2193,
        "func": "int PE_(bin_pe_get_claimed_checksum)(struct PE_(r_bin_pe_obj_t)* bin) {\n\tif (!bin || !bin->optional_header) {\n\t\treturn 0;\n\t}\n\treturn bin->optional_header->CheckSum;\n}",
        "target": 0
    },
    {
        "id": 2194,
        "func": "cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE4(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset), info,\n\t    count, &maxcount) == -1)\n\t\treturn -1;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2195,
        "func": "static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,\n  jas_image_t *image)\n{\n\tint pad;\n\tint nz;\n\tint z;\n\tint c;\n\tint y;\n\tint x;\n\tint v;\n\tint i;\n\tjas_matrix_t *data[3];\n\n/* Note: This function does not properly handle images with a colormap. */\n\t/* Avoid compiler warnings about unused parameters. */\n\tcmap = 0;\n\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tdata[i] = jas_matrix_create(1, jas_image_width(image));\n\t\tassert(data[i]);\n\t}\n\n\tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tnz = 0;\n\t\tz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\twhile (nz < hdr->depth) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tz = (z << 8) | c;\n\t\t\t\tnz += 8;\n\t\t\t}\n\n\t\t\tv = (z >> (nz - hdr->depth)) & RAS_ONES(hdr->depth);\n\t\t\tz &= RAS_ONES(nz - hdr->depth);\n\t\t\tnz -= hdr->depth;\n\n\t\t\tif (jas_image_numcmpts(image) == 3) {\n\t\t\t\tjas_matrix_setv(data[0], x, (RAS_GETRED(v)));\n\t\t\t\tjas_matrix_setv(data[1], x, (RAS_GETGREEN(v)));\n\t\t\t\tjas_matrix_setv(data[2], x, (RAS_GETBLUE(v)));\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(data[0], x, (v));\n\t\t\t}\n\t\t}\n\t\tif (pad) {\n\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,\n\t\t\t  data[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t}\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 2196,
        "func": "static int php_zip_ops_flush(php_stream *stream TSRMLS_DC)\n{\n\tif (!stream) {\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 2197,
        "func": "void AppCacheDispatcherHost::OnMarkAsForeignEntry(\n    int host_id, const GURL& document_url,\n    int64 cache_document_was_loaded_from) {\n  if (appcache_service_.get()) {\n    if (!backend_impl_.MarkAsForeignEntry(\n            host_id, document_url, cache_document_was_loaded_from)) {\n      bad_message::ReceivedBadMessage(this,\n                                      bad_message::ACDH_MARK_AS_FOREIGN_ENTRY);\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2198,
        "func": "static inline void build_tablename(smart_str *querystr, PGconn *pg_link, const char *table) /* {{{ */\n{\n\tchar *table_copy, *escaped, *token, *tmp;\n\tsize_t len;\n\n        /* schame.table should be \"schame\".\"table\" */\n        table_copy = estrdup(table);\n        token = php_strtok_r(table_copy, \".\", &tmp);\n       if (token == NULL) {\n               token = table;\n       }\n        len = strlen(token);\n        if (_php_pgsql_detect_identifier_escape(token, len) == SUCCESS) {\n                smart_str_appendl(querystr, token, len);\n\t\tPGSQLfree(escaped);\n\t}\n\tif (tmp && *tmp) {\n\t\tlen = strlen(tmp);\n\t\t/* \"schema\".\"table\" format */\n\t\tif (_php_pgsql_detect_identifier_escape(tmp, len) == SUCCESS) {\n\t\t\tsmart_str_appendc(querystr, '.');\n\t\t\tsmart_str_appendl(querystr, tmp, len);\n\t\t} else {\n\t\t\tescaped = PGSQLescapeIdentifier(pg_link, tmp, len);\n\t\t\tsmart_str_appendc(querystr, '.');\n\t\t\tsmart_str_appends(querystr, escaped);\n\t\t\tPGSQLfree(escaped);\n\t\t}\n\t}\n\tefree(table_copy);\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 2199,
        "func": "error::Error GLES2DecoderPassthroughImpl::DoIsSync(GLuint sync,\n                                                   uint32_t* result) {\n  *result = api()->glIsSyncFn(GetSyncServiceID(sync, resources_));\n  return error::kNoError;\n}\n",
        "target": 0
    },
    {
        "id": 2200,
        "func": "xfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_attr_leafblock *leaf = bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_ATTR3_LEAF_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_ATTR_LEAF_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/* XXX: need to range check rest of attr header values */\n\t/* XXX: hash order check? */\n\n\treturn true;\n}",
        "target": 0
    },
    {
        "id": 2201,
        "func": "static ZIPARCHIVE_METHOD(addPattern)\n{\n\tphp_zip_add_from_pattern(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n",
        "target": 0
    },
    {
        "id": 2202,
        "func": "unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename)\n{\n  FILE* file;\n  int ret = 0;\n  file = fopen(filename, \"wb\" );\n  if(!file) return 79;\n  if (fwrite((char*)buffer , 1 , buffersize, file) != buffersize)\n    ret = 91;\n  fclose(file);\n  return ret;\n}\n",
        "target": 0
    },
    {
        "id": 2203,
        "func": "static RenderObject* nearestCommonHoverAncestor(RenderObject* obj1, RenderObject* obj2)\n{\n    if (!obj1 || !obj2)\n        return 0;\n\n    for (RenderObject* currObj1 = obj1; currObj1; currObj1 = currObj1->hoverAncestor()) {\n        for (RenderObject* currObj2 = obj2; currObj2; currObj2 = currObj2->hoverAncestor()) {\n            if (currObj1 == currObj2)\n                return currObj1;\n        }\n    }\n\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 2204,
        "func": "static inline ssize_t MagickMin(const ssize_t x,const ssize_t y)\n{\n  if (x < y)\n    return(x);\n  return(y);\n}\n",
        "target": 0
    },
    {
        "id": 2205,
        "func": "static int PC4500_accessrid(struct airo_info *ai, u16 rid, u16 accmd)\n{\n\tCmd cmd; /* for issuing commands */\n\tResp rsp; /* response from commands */\n\tu16 status;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd = accmd;\n\tcmd.parm0 = rid;\n\tstatus = issuecommand(ai, &cmd, &rsp);\n\tif (status != 0) return status;\n\tif ( (rsp.status & 0x7F00) != 0) {\n\t\treturn (accmd << 8) + (rsp.rsp0 & 0xFF);\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2206,
        "func": "RSA *d2i_RSAPublicKey_fp(FILE *fp, RSA **rsa)\n\t{\n\treturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(RSAPublicKey), fp, rsa);\n\t}\n",
        "target": 0
    },
    {
        "id": 2207,
        "func": "bool ExtensionFunctionDispatcher::OverrideFunction(\n    const std::string& name, ExtensionFunctionFactory factory) {\n  return ExtensionFunctionRegistry::GetInstance()->OverrideFunction(name,\n                                                                    factory);\n}\n",
        "target": 0
    },
    {
        "id": 2208,
        "func": "long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)\n{\n\tstruct file *eventfp, *filep = NULL;\n\tstruct eventfd_ctx *ctx = NULL;\n\tu64 p;\n\tlong r;\n\tint i, fd;\n\n\t/* If you are not the owner, you can become one */\n\tif (ioctl == VHOST_SET_OWNER) {\n\t\tr = vhost_dev_set_owner(d);\n\t\tgoto done;\n\t}\n\n\t/* You must be the owner to do anything else */\n\tr = vhost_dev_check_owner(d);\n\tif (r)\n\t\tgoto done;\n\n\tswitch (ioctl) {\n\tcase VHOST_SET_MEM_TABLE:\n\t\tr = vhost_set_memory(d, argp);\n\t\tbreak;\n\tcase VHOST_SET_LOG_BASE:\n\t\tif (copy_from_user(&p, argp, sizeof p)) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif ((u64)(unsigned long)p != p) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < d->nvqs; ++i) {\n\t\t\tstruct vhost_virtqueue *vq;\n\t\t\tvoid __user *base = (void __user *)(unsigned long)p;\n\t\t\tvq = d->vqs[i];\n\t\t\tmutex_lock(&vq->mutex);\n\t\t\t/* If ring is inactive, will check when it's enabled. */\n\t\t\tif (vq->private_data && !vq_log_access_ok(vq, base))\n\t\t\t\tr = -EFAULT;\n\t\t\telse\n\t\t\t\tvq->log_base = base;\n\t\t\tmutex_unlock(&vq->mutex);\n\t\t}\n\t\tbreak;\n\tcase VHOST_SET_LOG_FD:\n\t\tr = get_user(fd, (int __user *)argp);\n\t\tif (r < 0)\n\t\t\tbreak;\n\t\teventfp = fd == -1 ? NULL : eventfd_fget(fd);\n\t\tif (IS_ERR(eventfp)) {\n\t\t\tr = PTR_ERR(eventfp);\n\t\t\tbreak;\n\t\t}\n\t\tif (eventfp != d->log_file) {\n\t\t\tfilep = d->log_file;\n\t\t\tctx = d->log_ctx;\n\t\t\td->log_ctx = eventfp ?\n\t\t\t\teventfd_ctx_fileget(eventfp) : NULL;\n\t\t} else\n\t\t\tfilep = eventfp;\n\t\tfor (i = 0; i < d->nvqs; ++i) {\n\t\t\tmutex_lock(&d->vqs[i]->mutex);\n\t\t\td->vqs[i]->log_ctx = d->log_ctx;\n\t\t\tmutex_unlock(&d->vqs[i]->mutex);\n\t\t}\n\t\tif (ctx)\n\t\t\teventfd_ctx_put(ctx);\n\t\tif (filep)\n\t\t\tfput(filep);\n\t\tbreak;\n\tdefault:\n\t\tr = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\ndone:\n\treturn r;\n}",
        "target": 1
    },
    {
        "id": 2209,
        "func": "unsigned int get_random_int(void)\n{\n\tstruct keydata *keyptr;\n\t__u32 *hash = get_cpu_var(get_random_int_hash);\n\tint ret;\n\n\tkeyptr = get_keyptr();\n\thash[0] += current->pid + jiffies + get_cycles();\n\n\tret = half_md4_transform(hash, keyptr->secret);\n\tput_cpu_var(get_random_int_hash);\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 2210,
        "func": "void InputHandler::ensureFocusPluginElementVisible()\n{\n    if (!isActivePlugin() || !m_currentFocusElement->document())\n        return;\n\n    Frame* elementFrame = m_currentFocusElement->document()->frame();\n    if (!elementFrame)\n        return;\n\n    Frame* mainFrame = m_webPage->mainFrame();\n    if (!mainFrame)\n        return;\n\n    FrameView* mainFrameView = mainFrame->view();\n    if (!mainFrameView)\n        return;\n\n    WebCore::IntRect selectionFocusRect;\n\n    RenderWidget* renderWidget = static_cast<RenderWidget*>(m_currentFocusElement->renderer());\n    if (renderWidget) {\n        PluginView* pluginView = static_cast<PluginView*>(renderWidget->widget());\n\n        if (pluginView)\n            selectionFocusRect = pluginView->ensureVisibleRect();\n    }\n\n    if (selectionFocusRect.isEmpty())\n        return;\n\n    if (elementFrame != mainFrame) { // Element is in a subframe.\n        selectionFocusRect.move(-elementFrame->view()->scrollPosition().x(), -elementFrame->view()->scrollPosition().y());\n\n        if (elementFrame->ownerRenderer()) {\n            WebCore::IntPoint frameOffset = elementFrame->ownerRenderer()->absoluteContentBox().location();\n            selectionFocusRect.move(frameOffset.x(), frameOffset.y());\n        }\n    }\n\n    WebCore::IntRect actualScreenRect = WebCore::IntRect(mainFrameView->scrollPosition(), m_webPage->actualVisibleSize());\n    if (actualScreenRect.contains(selectionFocusRect))\n        return;\n\n    WebCore::IntPoint pos(selectionFocusRect.center().x() - actualScreenRect.width() / 2,\n                 selectionFocusRect.center().y() - actualScreenRect.height() / 2);\n\n    mainFrameView->setScrollPosition(pos);\n}\n",
        "target": 0
    },
    {
        "id": 2211,
        "func": "  static AwContents* GetContents(WebContents* web_contents) {\n    if (!web_contents)\n      return NULL;\n    AwContentsUserData* data = static_cast<AwContentsUserData*>(\n        web_contents->GetUserData(kAwContentsUserDataKey));\n    return data ? data->contents_ : NULL;\n  }\n",
        "target": 0
    },
    {
        "id": 2212,
        "func": "change_env (timezone_t tz)\n{\n  if (setenv_TZ (tz->tz_is_set ? tz->abbrs : NULL) != 0)\n    return false;\n  tzset ();\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2213,
        "func": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 112 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n\t\t\trdesc[106] == 0x03) {\n\t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n\t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}",
        "target": 0
    },
    {
        "id": 2214,
        "func": "static void ext4_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tINIT_LIST_HEAD(&inode->i_dentry);\n\tkmem_cache_free(ext4_inode_cachep, EXT4_I(inode));\n}",
        "target": 0
    },
    {
        "id": 2215,
        "func": "void RenderViewImpl::didCancelCompositionOnSelectionChange() {\n  Send(new ViewHostMsg_ImeCancelComposition(routing_id()));\n}\n",
        "target": 0
    },
    {
        "id": 2216,
        "func": "static int mqueue_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *inode;\n\tstruct ipc_namespace *ns = sb->s_fs_info;\n\n\tsb->s_iflags |= SB_I_NOEXEC | SB_I_NODEV;\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = MQUEUE_MAGIC;\n\tsb->s_op = &mqueue_super_ops;\n\n\tinode = mqueue_get_inode(sb, ns, S_IFDIR | S_ISVTX | S_IRWXUGO, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2217,
        "func": "ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\t/* note: a 0-length skb is used as an error indication */\n\tif (skb->len > 0) {\n\t\tskb_checksum_complete_unset(skb);\n#ifdef CONFIG_PPP_MULTILINK\n\t\t/* XXX do channel-level decompression here */\n\t\tif (PPP_PROTO(skb) == PPP_MP)\n\t\t\tppp_receive_mp_frame(ppp, skb, pch);\n\t\telse\n#endif /* CONFIG_PPP_MULTILINK */\n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t} else {\n\t\tkfree_skb(skb);\n\t\tppp_receive_error(ppp);\n\t}\n}",
        "target": 0
    },
    {
        "id": 2218,
        "func": "void Location::assign(LocalDOMWindow* current_window,\n                      LocalDOMWindow* entered_window,\n                      const USVStringOrTrustedURL& stringOrUrl,\n                      ExceptionState& exception_state) {\n  if (!BindingSecurity::ShouldAllowAccessTo(current_window, this,\n                                            exception_state)) {\n    return;\n  }\n\n  String url = GetStringFromTrustedURL(stringOrUrl, current_window->document(),\n                                       exception_state);\n  if (!exception_state.HadException()) {\n    SetLocation(url, current_window, entered_window, &exception_state);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2219,
        "func": "void BaseMultipleFieldsDateAndTimeInputType::updateClearButtonVisibility()\n{\n    ClearButtonElement* clearButton = clearButtonElement();\n    if (!clearButton)\n        return;\n\n    if (element()->isRequired() || !dateTimeEditElement()->anyEditableFieldsHaveValues())\n        clearButton->setInlineStyleProperty(CSSPropertyVisibility, CSSValueHidden);\n    else\n        clearButton->removeInlineStyleProperty(CSSPropertyVisibility);\n}\n",
        "target": 0
    },
    {
        "id": 2220,
        "func": "static void *tcp_v6_tw_get_peer(struct sock *sk)\n{\n\tstruct inet6_timewait_sock *tw6 = inet6_twsk(sk);\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\n\tif (tw->tw_family == AF_INET)\n\t\treturn tcp_v4_tw_get_peer(sk);\n\n\treturn inet_getpeer_v6(&tw6->tw_v6_daddr, 1);\n}",
        "target": 0
    },
    {
        "id": 2221,
        "func": "GF_Box *prft_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}",
        "target": 0
    },
    {
        "id": 2222,
        "func": "static struct pending_req *alloc_req(struct xen_blkif *blkif)\n{\n\tstruct pending_req *req = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&blkif->pending_free_lock, flags);\n\tif (!list_empty(&blkif->pending_free)) {\n\t\treq = list_entry(blkif->pending_free.next, struct pending_req,\n\t\t\t\t free_list);\n\t\tlist_del(&req->free_list);\n\t}\n\tspin_unlock_irqrestore(&blkif->pending_free_lock, flags);\n\treturn req;\n}",
        "target": 0
    },
    {
        "id": 2223,
        "func": "void MessageService::OpenChannelToExtension(\n    int source_process_id, int source_routing_id, int receiver_port_id,\n    const std::string& source_extension_id,\n    const std::string& target_extension_id,\n    const std::string& channel_name) {\n  content::RenderProcessHost* source =\n      content::RenderProcessHost::FromID(source_process_id);\n  if (!source)\n    return;\n  Profile* profile = Profile::FromBrowserContext(source->GetBrowserContext());\n\n  MessagePort* receiver = new ExtensionMessagePort(\n      GetExtensionProcess(profile, target_extension_id), MSG_ROUTING_CONTROL,\n      target_extension_id);\n  WebContents* source_contents = tab_util::GetWebContentsByID(\n      source_process_id, source_routing_id);\n\n   std::string tab_json = \"null\";\n   if (source_contents) {\n     scoped_ptr<DictionaryValue> tab_value(ExtensionTabUtil::CreateTabValue(\n        source_contents, ExtensionTabUtil::INCLUDE_PRIVACY_SENSITIVE_FIELDS));\n     base::JSONWriter::Write(tab_value.get(), &tab_json);\n   }\n \n  OpenChannelParams* params = new OpenChannelParams(source, tab_json, receiver,\n                                                    receiver_port_id,\n                                                    source_extension_id,\n                                                    target_extension_id,\n                                                    channel_name);\n\n  if (MaybeAddPendingOpenChannelTask(profile, params)) {\n    return;\n  }\n\n  OpenChannelImpl(scoped_ptr<OpenChannelParams>(params));\n}\n",
        "target": 1
    },
    {
        "id": 2224,
        "func": "template<class T, size_t n> static void removeFromVector(Vector<T*, n> & vec, T* item)\n{\n    size_t size = vec.size();\n    for (size_t i = 0; i != size; ++i)\n        if (vec[i] == item) {\n            vec.remove(i);\n            break;\n        }\n}\n",
        "target": 0
    },
    {
        "id": 2225,
        "func": "void WebView::updateActiveStateSoon()\n{\n\n    ::SetTimer(m_window, UpdateActiveStateTimer, 0, 0);\n}\n",
        "target": 0
    },
    {
        "id": 2226,
        "func": "void iwl_update_tkip_key(struct iwl_priv *priv,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_key_conf *keyconf,\n\t\t\t struct ieee80211_sta *sta, u32 iv32, u16 *phase1key)\n{\n\tu8 sta_id = iwlagn_key_sta_id(priv, vif, sta);\n\n\tif (sta_id == IWL_INVALID_STATION)\n\t\treturn;\n\n\tif (iwl_scan_cancel(priv)) {\n\t\t/* cancel scan failed, just live w/ bad key and rely\n\t\t   briefly on SW decryption */\n\t\treturn;\n\t}\n\n\tiwlagn_send_sta_key(priv, keyconf, sta_id,\n\t\t\t    iv32, phase1key, CMD_ASYNC);\n}",
        "target": 0
    },
    {
        "id": 2227,
        "func": "void user_free_preparse(struct key_preparsed_payload *prep)\n{\n\tkfree(prep->payload.data[0]);\n}",
        "target": 0
    },
    {
        "id": 2228,
        "func": "struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n\t\t\t\t     unsigned long data_len, int noblock,\n\t\t\t\t     int *errcode, int max_page_order)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint err;\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\tfor (;;) {\n\t\terr = sock_error(sk);\n\t\tif (err != 0)\n\t\t\tgoto failure;\n\n\t\terr = -EPIPE;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tgoto failure;\n\n\t\tif (sk_wmem_alloc_get(sk) < sk->sk_sndbuf)\n\t\t\tbreak;\n\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto failure;\n\t\tif (signal_pending(current))\n\t\t\tgoto interrupted;\n\t\ttimeo = sock_wait_for_wmem(sk, timeo);\n\t}\n\tskb = alloc_skb_with_frags(header_len, data_len, max_page_order,\n\t\t\t\t   errcode, sk->sk_allocation);\n\tif (skb)\n\t\tskb_set_owner_w(skb, sk);\n\treturn skb;\n\ninterrupted:\n\terr = sock_intr_errno(timeo);\nfailure:\n\t*errcode = err;\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 2229,
        "func": "bool Textfield::IsIMEComposing() const {\n  return model_->HasCompositionText();\n}\n",
        "target": 0
    },
    {
        "id": 2230,
        "func": "void WebContentsImpl::OnPepperInstanceCreated() {\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_, PepperInstanceCreated());\n}\n",
        "target": 0
    },
    {
        "id": 2231,
        "func": "static int _hid_set_report(struct hid_device_priv* dev, HANDLE hid_handle, int id, void *data,\n\t\t\t\t\t\t   struct windows_transfer_priv *tp, size_t *size, OVERLAPPED* overlapped,\n\t\t\t\t\t\t   int report_type)\n{\n\tuint8_t *buf = NULL;\n\tDWORD ioctl_code, write_size= (DWORD)*size;\n\tif (tp->hid_buffer != NULL) {\n\t\tusbi_dbg(\"program assertion failed: hid_buffer is not NULL\");\n\t}\n\tif ((*size == 0) || (*size > MAX_HID_REPORT_SIZE)) {\n\t\tusbi_dbg(\"invalid size (%d)\", *size);\n\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\tswitch (report_type) {\n\t\tcase HID_REPORT_TYPE_OUTPUT:\n\t\t\tioctl_code = IOCTL_HID_SET_OUTPUT_REPORT;\n\t\t\tbreak;\n\t\tcase HID_REPORT_TYPE_FEATURE:\n\t\t\tioctl_code = IOCTL_HID_SET_FEATURE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusbi_dbg(\"unknown HID report type %d\", report_type);\n\t\t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\tusbi_dbg(\"report ID: 0x%02X\", id);\n\tif (id == 0) {\n\t\twrite_size++;\n\t}\n\tbuf = (uint8_t*) malloc(write_size);\n\tif (buf == NULL) {\n\t\treturn LIBUSB_ERROR_NO_MEM;\n\t}\n\tif (id == 0) {\n\t\tbuf[0] = 0;\n\t\tmemcpy(buf + 1, data, *size);\n\t} else {\n\t\tmemcpy(buf, data, *size);\n\t\tif (buf[0] != id) {\n\t\t\tusbi_warn(NULL, \"mismatched report ID (data is %02X, parameter is %02X)\", buf[0], id);\n\t\t}\n\t}\n\tif (!DeviceIoControl(hid_handle, ioctl_code, buf, write_size,\n\t\tbuf, write_size, &write_size, overlapped)) {\n\t\tif (GetLastError() != ERROR_IO_PENDING) {\n\t\t\tusbi_dbg(\"Failed to Write HID Output Report: %s\", windows_error_str(0));\n\t\t\tsafe_free(buf);\n\t\t\treturn LIBUSB_ERROR_IO;\n\t\t}\n\t\ttp->hid_buffer = buf;\n\t\ttp->hid_dest = NULL;\n\t\treturn LIBUSB_SUCCESS;\n\t}\n\t*size = write_size;\n\tif (write_size == 0) {\n\t\tusbi_dbg(\"program assertion failed - write completed synchronously, but no data was written\");\n\t}\n\tsafe_free(buf);\n\treturn LIBUSB_COMPLETED;\n}\n",
        "target": 1
    },
    {
        "id": 2232,
        "func": "void tlb_flush_mmu(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tif (!tlb->need_flush)\n\t\treturn;\n\ttlb->need_flush = 0;\n\ttlb_flush(tlb);\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb_table_flush(tlb);\n#endif\n\n\tif (tlb_fast_mode(tlb))\n\t\treturn;\n\n\tfor (batch = &tlb->local; batch; batch = batch->next) {\n\t\tfree_pages_and_swap_cache(batch->pages, batch->nr);\n\t\tbatch->nr = 0;\n\t}\n\ttlb->active = &tlb->local;\n}\n",
        "target": 0
    },
    {
        "id": 2233,
        "func": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\n\treturn TEE_SUCCESS;\n}",
        "target": 1
    },
    {
        "id": 2234,
        "func": "PHP_METHOD(Phar, createDefaultStub)\n{\n\tchar *index = NULL, *webindex = NULL, *error;\n        zend_string *stub;\n        size_t index_len = 0, webindex_len = 0;\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS(), \"|ss\", &index, &index_len, &webindex, &webindex_len) == FAILURE) {\n                return;\n        }\n \n\tstub = phar_create_default_stub(index, webindex, &error);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"%s\", error);\n\t\tefree(error);\n\t\treturn;\n\t}\n\tRETURN_NEW_STR(stub);\n}\n",
        "target": 1
    },
    {
        "id": 2235,
        "func": "   virtual ~Trans4x4TestBase() {}\n",
        "target": 0
    },
    {
        "id": 2236,
        "func": "void ChromePasswordManagerClient::ShowManualFallbackForSaving(\n    std::unique_ptr<password_manager::PasswordFormManagerForUI> form_to_save,\n    bool has_generated_password,\n    bool is_update) {\n  if (!CanShowBubbleOnURL(web_contents()->GetLastCommittedURL()))\n    return;\n\n#if !defined(OS_ANDROID)\n  PasswordsClientUIDelegate* manage_passwords_ui_controller =\n      PasswordsClientUIDelegateFromWebContents(web_contents());\n  if (manage_passwords_ui_controller) {\n    manage_passwords_ui_controller->OnShowManualFallbackForSaving(\n        std::move(form_to_save), has_generated_password, is_update);\n  }\n#endif  // !defined(OS_ANDROID)\n}\n",
        "target": 0
    },
    {
        "id": 2237,
        "func": "void AppListControllerDelegateImpl::DoCreateShortcutsFlow(\n     Profile* profile,\n     const std::string& extension_id) {\n   DCHECK(CanDoCreateShortcutsFlow());\n  extensions::ExtensionRegistry* registry =\n      extensions::ExtensionRegistry::Get(profile);\n  const extensions::Extension* extension = registry->GetInstalledExtension(\n       extension_id);\n   DCHECK(extension);\n \n  gfx::NativeWindow parent_window = GetAppListWindow();\n  if (!parent_window)\n    return;\n  OnShowChildDialog();\n  chrome::ShowCreateChromeAppShortcutsDialog(\n      parent_window, profile, extension,\n      base::Bind(&AppListControllerDelegateImpl::OnCloseCreateShortcutsPrompt,\n                 base::Unretained(this)));\n}\n",
        "target": 0
    },
    {
        "id": 2238,
        "func": "static inline u32 nfsd4_layoutreturn_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t1 /* lrs_stateid */ +\n\t\top_encode_stateid_maxsz) * sizeof(__be32);\n}\n",
        "target": 0
    },
    {
        "id": 2239,
        "func": "bool check_selective_cr0_intercepted(struct vcpu_svm *svm, unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 2240,
        "func": "static int do_send_NPString(rpc_message_t *message, void *p_value)\n{\n  NPString *string = (NPString *)p_value;\n  if (string == NULL)\n\treturn RPC_ERROR_MESSAGE_ARGUMENT_INVALID;\n\n  int error = rpc_message_send_uint32(message, string->UTF8Length);\n  if (error < 0)\n\treturn error;\n  if (string->UTF8Length && string->UTF8Characters)\n\treturn rpc_message_send_bytes(message, (unsigned char *)string->UTF8Characters, string->UTF8Length);\n  return RPC_ERROR_NO_ERROR;\n}",
        "target": 0
    },
    {
        "id": 2241,
        "func": "void tcp6_proc_exit(struct net *net)\n{\n\ttcp_proc_unregister(net, &tcp6_seq_afinfo);\n}",
        "target": 0
    },
    {
        "id": 2242,
        "func": "static void local_socket_close_locked(asocket* s) {\n    D(\"entered local_socket_close_locked. LS(%d) fd=%d\", s->id, s->fd);\n     if (s->peer) {\n         D(\"LS(%d): closing peer. peer->id=%d peer->fd=%d\", s->id, s->peer->id, s->peer->fd);\n         /* Note: it's important to call shutdown before disconnecting from\n         * the peer, this ensures that remote sockets can still get the id\n         * of the local socket they're connected to, to send a CLOSE()\n         * protocol event. */\n\n         if (s->peer->shutdown) {\n             s->peer->shutdown(s->peer);\n         }\n        s->peer->peer = 0;\n        if (s->peer->close == local_socket_close) {\n            local_socket_close_locked(s->peer);\n        } else {\n            s->peer->close(s->peer);\n        }\n        s->peer = 0;\n     }\n \n     /* If we are already closing, or if there are no\n    ** pending packets, destroy immediately\n    */\n if (s->closing || s->has_write_error || s->pkt_first == NULL) {\n int id = s->id;\n        local_socket_destroy(s);\n        D(\"LS(%d): closed\", id);\n return;\n }\n\n /* otherwise, put on the closing list\n    */\n    D(\"LS(%d): closing\", s->id);\n    s->closing = 1;\n    fdevent_del(&s->fde, FDE_READ);\n    remove_socket(s);\n    D(\"LS(%d): put on socket_closing_list fd=%d\", s->id, s->fd);\n    insert_local_socket(s, &local_socket_closing_list);\n    CHECK_EQ(FDE_WRITE, s->fde.state & FDE_WRITE);\n}\n",
        "target": 1
    },
    {
        "id": 2243,
        "func": "HTMLImportLoader* Document::importLoader() const\n{\n    if (!m_importsController)\n        return 0;\n    return m_importsController->loaderFor(*this);\n}\n",
        "target": 0
    },
    {
        "id": 2244,
        "func": "static void copyNodeContent(MemPage *pFrom, MemPage *pTo, int *pRC){\n  if( (*pRC)==SQLITE_OK ){\n    BtShared * const pBt = pFrom->pBt;\n    u8 * const aFrom = pFrom->aData;\n    u8 * const aTo = pTo->aData;\n    int const iFromHdr = pFrom->hdrOffset;\n    int const iToHdr = ((pTo->pgno==1) ? 100 : 0);\n    int rc;\n    int iData;\n\n\n    assert( pFrom->isInit );\n    assert( pFrom->nFree>=iToHdr );\n    assert( get2byte(&aFrom[iFromHdr+5]) <= (int)pBt->usableSize );\n\n    /* Copy the b-tree node content from page pFrom to page pTo. */\n    iData = get2byte(&aFrom[iFromHdr+5]);\n    memcpy(&aTo[iData], &aFrom[iData], pBt->usableSize-iData);\n    memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom->cellOffset + 2*pFrom->nCell);\n\n    /* Reinitialize page pTo so that the contents of the MemPage structure\n    ** match the new data. The initialization of pTo can actually fail under\n    ** fairly obscure circumstances, even though it is a copy of initialized\n    ** page pFrom.\n    */\n    pTo->isInit = 0;\n    rc = btreeInitPage(pTo);\n    if( rc!=SQLITE_OK ){\n      *pRC = rc;\n      return;\n    }\n\n    /* If this is an auto-vacuum database, update the pointer-map entries\n    ** for any b-tree or overflow pages that pTo now contains the pointers to.\n    */\n    if( ISAUTOVACUUM ){\n      *pRC = setChildPtrmaps(pTo);\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2245,
        "func": "  PolicyTest() {}\n",
        "target": 0
    },
    {
        "id": 2246,
        "func": "static void mmtimer_clr_int_pending(int comparator)\n{\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_EVENT_OCCURRED_ALIAS),\n\t\tSH_EVENT_OCCURRED_RTC1_INT_MASK << comparator);\n}",
        "target": 0
    },
    {
        "id": 2247,
        "func": " bool RenderFrameHostManager::CanSubframeSwapProcess(\n     const GURL& dest_url,\n     SiteInstance* source_instance,\n    SiteInstance* dest_instance,\n    bool was_server_redirect) {\n  DCHECK(!source_instance || !dest_instance);\n\n  GURL resolved_url = dest_url;\n  if (url::Origin::Create(resolved_url).unique()) {\n    if (source_instance) {\n      resolved_url = source_instance->GetSiteURL();\n    } else if (dest_instance) {\n       resolved_url = dest_instance->GetSiteURL();\n     } else {\n      if (!was_server_redirect)\n         return false;\n     }\n   }\n \n  if (!IsRendererTransferNeededForNavigation(render_frame_host_.get(),\n                                             resolved_url)) {\n    DCHECK(!dest_instance ||\n           dest_instance == render_frame_host_->GetSiteInstance());\n    return false;\n  }\n\n  return true;\n}\n",
        "target": 1
    },
    {
        "id": 2248,
        "func": "MagickExport void DestroyBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickBooleanType\n    destroy;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->signature == MagickCoreSignature);\n  blob_info=image->blob;\n  destroy=MagickFalse;\n  LockSemaphoreInfo(blob_info->semaphore);\n  blob_info->reference_count--;\n  assert(blob_info->reference_count >= 0);\n  if (blob_info->reference_count == 0)\n    destroy=MagickTrue;\n  UnlockSemaphoreInfo(blob_info->semaphore);\n  if (destroy == MagickFalse)\n    {\n      image->blob=(BlobInfo *) NULL;\n      return;\n    }\n  (void) CloseBlob(image);\n  if (blob_info->mapped != MagickFalse)\n    {\n      (void) UnmapBlob(blob_info->data,blob_info->length);\n      RelinquishMagickResource(MapResource,blob_info->length);\n    }\n  if (blob_info->semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&blob_info->semaphore);\n  blob_info->signature=(~MagickCoreSignature);\n  image->blob=(BlobInfo *) RelinquishMagickMemory(blob_info);\n}\n",
        "target": 0
    },
    {
        "id": 2249,
        "func": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tchar *tmpptr = key + strlen(key);\n\t\t\t\t*tmpptr = '=';\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tstart += strlen(key) + strlen(value) + 2;\n\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\n\tkfree(tmpbuf);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 2250,
        "func": "static gboolean irssi_ssl_verify_hostname(X509 *cert, const char *hostname)\n{\n\tint gen_index, gen_count;\n\tgboolean matched = FALSE, has_dns_name = FALSE;\n\tconst char *cert_dns_name;\n\tchar *cert_subject_cn;\n\tconst GENERAL_NAME *gn;\n\tSTACK_OF(GENERAL_NAME) * gens;\n\n\t/* Verify the dNSName(s) in the peer certificate against the hostname. */\n\tgens = X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0);\n\tif (gens) {\n\t\tgen_count = sk_GENERAL_NAME_num(gens);\n\t\tfor (gen_index = 0; gen_index < gen_count && !matched; ++gen_index) {\n\t\t\tgn = sk_GENERAL_NAME_value(gens, gen_index);\n\t\t\tif (gn->type != GEN_DNS)\n\t\t\t\tcontinue;\n\n\t\t\t/* Even if we have an invalid DNS name, we still ultimately\n\t\t\t   ignore the CommonName, because subjectAltName:DNS is\n\t\t\t   present (though malformed). */\n\t\t\thas_dns_name = TRUE;\n\t\t\tcert_dns_name = tls_dns_name(gn);\n\t\t\tif (cert_dns_name && *cert_dns_name) {\n\t\t\t\tmatched = match_hostname(cert_dns_name, hostname);\n\t\t\t}\n    \t}\n\n\t    /* Free stack *and* member GENERAL_NAME objects */\n\t    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n\t}\n\n\tif (has_dns_name) {\n\t\tif (! matched) {\n\t\t\t/* The CommonName in the issuer DN is obsolete when SubjectAltName is available. */\n\t\t\tg_warning(\"None of the Subject Alt Names in the certificate match hostname '%s'\", hostname);\n\t\t}\n\t\treturn matched;\n\t} else { /* No subjectAltNames, look at CommonName */\n\t\tcert_subject_cn = tls_text_name(X509_get_subject_name(cert), NID_commonName);\n\t    if (cert_subject_cn && *cert_subject_cn) {\n\t    \tmatched = match_hostname(cert_subject_cn, hostname);\n\t    \tif (! matched) {\n\t\t\t\tg_warning(\"SSL certificate common name '%s' doesn't match host name '%s'\", cert_subject_cn, hostname);\n\t    \t}\n\t    } else {\n\t    \tg_warning(\"No subjectAltNames and no valid common name in certificate\");\n\t    }\n\t    free(cert_subject_cn);\n\t}\n\n\treturn matched;\n}",
        "target": 0
    },
    {
        "id": 2251,
        "func": "static int posix_get_monotonic_coarse(clockid_t which_clock,\n\t\t\t\t\t\tstruct timespec64 *tp)\n{\n\t*tp = get_monotonic_coarse64();\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2252,
        "func": "  ChromePluginPrintContext(LocalFrame* frame,\n                           WebPluginContainerImpl* plugin,\n                           const WebPrintParams& print_params)\n      : ChromePrintContext(frame, print_params.use_printing_layout),\n        plugin_(plugin),\n        print_params_(print_params) {}\n",
        "target": 0
    },
    {
        "id": 2253,
        "func": " ExtensionsGuestViewMessageFilter::~ExtensionsGuestViewMessageFilter() {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;\n  base::PostTaskWithTraits(\n      FROM_HERE, BrowserThread::UI,\n      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));\n }\n",
        "target": 1
    },
    {
        "id": 2254,
        "func": "void PrintPreviewUI::OnCancelPendingPreviewRequest() {\n  g_print_preview_request_id_map.Get().Set(preview_ui_addr_str_, -1);\n}\n",
        "target": 0
    },
    {
        "id": 2255,
        "func": "static int cdrom_ioctl_disc_status(struct cdrom_device_info *cdi)\n{\n\ttracktype tracks;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DISC_STATUS\\n\");\n\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error)\n\t\treturn tracks.error;\n\n\t/* Policy mode on */\n\tif (tracks.audio > 0) {\n\t\tif (!tracks.data && !tracks.cdi && !tracks.xa)\n\t\t\treturn CDS_AUDIO;\n\t\telse\n\t\t\treturn CDS_MIXED;\n\t}\n\n\tif (tracks.cdi > 0)\n\t\treturn CDS_XA_2_2;\n\tif (tracks.xa > 0)\n\t\treturn CDS_XA_2_1;\n\tif (tracks.data > 0)\n\t\treturn CDS_DATA_1;\n\t/* Policy mode off */\n\n\tcd_dbg(CD_WARNING, \"This disc doesn't have any tracks I recognize!\\n\");\n\treturn CDS_NO_INFO;\n}",
        "target": 0
    },
    {
        "id": 2256,
        "func": "static void _ffs_free_dev(struct ffs_dev *dev)\n{\n\tlist_del(&dev->entry);\n\tif (dev->name_allocated)\n\t\tkfree(dev->name);\n\tkfree(dev);\n\tif (list_empty(&ffs_devices))\n\t\tfunctionfs_cleanup();\n}",
        "target": 0
    },
    {
        "id": 2257,
        "func": "void WmOverviewSnapshot::Init(const gfx::Size& size,\n                              Browser* browser,\n                              int index) {\n  snapshot_view_ = new views::ImageView();\n  MakeTransparent();\n\n  snapshot_view_->set_background(\n      views::Background::CreateSolidBackground(SK_ColorWHITE));\n   snapshot_view_->set_border(\n       views::Border::CreateSolidBorder(1, SkColorSetRGB(176, 176, 176)));\n \n  WidgetGtk::Init(NULL, gfx::Rect(size));\n \n   SetContentsView(snapshot_view_);\n \n  UpdateIndex(browser, index);\n}\n",
        "target": 0
    },
    {
        "id": 2258,
        "func": "void ResourceDispatcherHostImpl::InitializeURLRequest(\n    net::URLRequest* request,\n    const Referrer& referrer,\n    bool is_download,\n     int render_process_host_id,\n     int render_view_routing_id,\n     int render_frame_routing_id,\n     PreviewsState previews_state,\n     ResourceContext* context) {\n   DCHECK(io_thread_task_runner_->BelongsToCurrentThread());\n  DCHECK(!request->is_pending());\n\n  Referrer::SetReferrerForRequest(request, referrer);\n \n   ResourceRequestInfoImpl* info = CreateRequestInfo(\n       render_process_host_id, render_view_routing_id, render_frame_routing_id,\n      previews_state, is_download, context);\n   info->AssociateWithRequest(request);\n }\n",
        "target": 1
    },
    {
        "id": 2259,
        "func": "GLSurfaceEGLOzoneX11::~GLSurfaceEGLOzoneX11() {\n  Destroy();\n}\n",
        "target": 0
    },
    {
        "id": 2260,
        "func": "bool RenderFrameImpl::IsPluginHandledExternally(\n    const blink::WebElement& plugin_element,\n    const blink::WebURL& url,\n    const blink::WebString& suggested_mime_type) {\n#if BUILDFLAG(ENABLE_PLUGINS)\n  if (!BrowserPluginManager::Get()) {\n    return false;\n  }\n  int32_t tentative_element_instance_id =\n      BrowserPluginManager::Get()->GetNextInstanceID();\n  return GetContentClient()->renderer()->MaybeCreateMimeHandlerView(\n      this, plugin_element, GURL(url), suggested_mime_type.Utf8(),\n      tentative_element_instance_id);\n#else\n  return false;\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 2261,
        "func": "pgp_read_blob(sc_card_t *card, pgp_blob_t *blob)\n{\n\tstruct pgp_priv_data *priv = DRVDATA(card);\n\n\tif (blob->data != NULL)\n\t\treturn SC_SUCCESS;\n\tif (blob->info == NULL)\n\t\treturn blob->status;\n\n\tif (blob->info->get_fn) {\t/* readable, top-level DO */\n\t\tu8 \tbuffer[2048];\n\t\tsize_t\tbuf_len = sizeof(buffer);\n\t\tint r = SC_SUCCESS;\n\n\t\t/* buffer length for certificate */\n\t\tif (blob->id == DO_CERT && priv->max_cert_size > 0) {\n\t\t\tbuf_len = MIN(priv->max_cert_size, sizeof(buffer));\n\t\t}\n\n\t\t/* buffer length for Gnuk pubkey */\n\t\tif (card->type == SC_CARD_TYPE_OPENPGP_GNUK &&\n\t\t    (blob->id == DO_AUTH ||\n\t\t     blob->id == DO_SIGN ||\n\t\t     blob->id == DO_ENCR ||\n\t\t     blob->id == DO_AUTH_SYM ||\n\t\t     blob->id == DO_SIGN_SYM ||\n\t\t     blob->id == DO_ENCR_SYM)) {\n\t\t\tbuf_len = MAXLEN_RESP_PUBKEY_GNUK;\n\t\t}\n\n\t\tr = blob->info->get_fn(card, blob->id, buffer, buf_len);\n\n\t\tif (r < 0) {\t/* an error occurred */\n\t\t\tblob->status = r;\n\t\t\treturn r;\n\t\t}\n\n\t\treturn pgp_set_blob(blob, buffer, r);\n\t}\n\telse {\t\t/* un-readable DO or part of a constructed DO */\n\t\treturn SC_SUCCESS;\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 2262,
        "func": "gstd_get_display_name(gss_name_t client)\n{\n\tOM_uint32\tmaj;\n\tOM_uint32\tmin;\n\tgss_buffer_desc\tbuf;\n\tchar\t\t*ret;\n\n\tmaj = gss_display_name(&min, client, &buf, NULL);\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_display_name\");\n\n\tif ((ret = (char *)malloc(buf.length + 1)) == NULL) {\n\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\t\tgss_release_buffer(&min, &buf);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(ret, buf.value, buf.length);\n\tret[buf.length] = '\\0';\n\n\tgss_release_buffer(&min, &buf);\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 2263,
        "func": "raptor_turtle_writer_comment(raptor_turtle_writer* turtle_writer,\n                             const unsigned char *string)\n{\n  unsigned char c;\n  size_t len = strlen((const char*)string);\n\n  raptor_iostream_counted_string_write((const unsigned char*)\"# \", 2,\n                                       turtle_writer->iostr);\n\n  for(; (c=*string); string++, len--) {\n    if(c == '\\n') {\n      raptor_turtle_writer_newline(turtle_writer);\n      raptor_iostream_counted_string_write((const unsigned char*)\"# \", 2,\n                                           turtle_writer->iostr);\n    } else if(c != '\\r') { \n      /* skip carriage returns (windows... *sigh*) */\n      raptor_iostream_write_byte(c, turtle_writer->iostr);\n    }\n  }\n  \n  raptor_turtle_writer_newline(turtle_writer);\n}",
        "target": 0
    },
    {
        "id": 2264,
        "func": "static int nfs4_xattr_get_nfs4_acl(struct dentry *dentry, const char *key,\n\t\t\t\t   void *buf, size_t buflen, int type)\n{\n\tif (strcmp(key, \"\") != 0)\n\t\treturn -EINVAL;\n\n\treturn nfs4_proc_get_acl(dentry->d_inode, buf, buflen);\n}",
        "target": 0
    },
    {
        "id": 2265,
        "func": " static void locationAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n {\n     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());\n    TestNode* imp = WTF::getPtr(proxyImp->location());\n     if (!imp)\n         return;\n     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);\n    imp->setHref(cppValue);\n}\n",
        "target": 1
    },
    {
        "id": 2266,
        "func": "Eina_Bool ewk_view_setting_auto_shrink_images_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    return priv->settings.autoShrinkImages;\n}\n",
        "target": 0
    },
    {
        "id": 2267,
        "func": "ProcXFixesCreatePointerBarrier(ClientPtr client)\n{\n    REQUEST(xXFixesCreatePointerBarrierReq);\n\n    REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));\n    LEGAL_NEW_RESOURCE(stuff->barrier, client);\n\n    return XICreatePointerBarrier(client, stuff);\n}\n",
        "target": 0
    },
    {
        "id": 2268,
        "func": "void WebPagePrivate::setCursor(PlatformCursor handle)\n{\n    if (m_currentCursor.type() != handle.type()) {\n        m_currentCursor = handle;\n        m_client->cursorChanged(handle.type(), handle.url().c_str(), handle.hotspot());\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2269,
        "func": "static void l2cap_sock_clear_timer(struct sock *sk)\n{\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tsk_stop_timer(sk, &sk->sk_timer);\n}",
        "target": 0
    },
    {
        "id": 2270,
        "func": "void H264DPB::GetNotOutputtedPicsAppending(H264Picture::PtrVector& out) {\n  for (size_t i = 0; i < pics_.size(); ++i) {\n    H264Picture* pic = pics_[i];\n    if (!pic->outputted)\n      out.push_back(pic);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2271,
        "func": "static int nfc_genl_dump_targets_done(struct netlink_callback *cb)\n{\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\n\tif (dev)\n\t\tnfc_put_device(dev);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2272,
        "func": "openssl_callback_ignore_crls(int ok, X509_STORE_CTX * ctx)\n{\n    if (!ok) {\n        switch (ctx->error) {\n        case X509_V_ERR_UNABLE_TO_GET_CRL:\n            return 1;\n        default:\n            return 0;\n        }\n    }\n    return ok;\n}\n",
        "target": 0
    },
    {
        "id": 2273,
        "func": "static bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
        "target": 1
    },
    {
        "id": 2274,
        "func": "bool EditorClientBlackBerry::shouldApplyStyle(StylePropertySet*, Range*)\n{\n    notImplemented();\n    return true;\n}\n",
        "target": 0
    },
    {
        "id": 2275,
        "func": "AttachUnboundGPU(ScreenPtr pScreen, ScreenPtr new)\n{\n    assert(new->isGPU);\n    assert(!new->current_master);\n    xorg_list_add(&new->slave_head, &pScreen->slave_list);\n    new->current_master = pScreen;\n}\n",
        "target": 0
    },
    {
        "id": 2276,
        "func": "err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n\n    /* actual exponentiation; see PKCS#1 v2.0 5.1 */\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\n\ttemp_s = mpz_to_n(&c, sig_len);\t/* back to octets */\n        if(s_max_octets < sig_len) {\n            return \"2\"\"exponentiation failed; too many octets\";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n\n    /* check signature contents */\n    /* verify padding (not including any DER digest info! */\n    padlen = sig_len - 3 - hash_len;\n    /* now check padding */\n\n    DBG(DBG_CRYPT,\n\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n\n    /* skip padding */\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n\n    s += padlen + 3;\n    (*psig) = s;\n\n    /* return SUCCESS */\n    return NULL;\n}",
        "target": 1
    },
    {
        "id": 2277,
        "func": "ppp_channel_push(struct channel *pch)\n{\n\tstruct sk_buff *skb;\n\tstruct ppp *ppp;\n\n\tspin_lock_bh(&pch->downl);\n\tif (pch->chan) {\n\t\twhile (!skb_queue_empty(&pch->file.xq)) {\n\t\t\tskb = skb_dequeue(&pch->file.xq);\n\t\t\tif (!pch->chan->ops->start_xmit(pch->chan, skb)) {\n\t\t\t\t/* put the packet back and try again later */\n\t\t\t\tskb_queue_head(&pch->file.xq, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* channel got deregistered */\n\t\tskb_queue_purge(&pch->file.xq);\n\t}\n\tspin_unlock_bh(&pch->downl);\n\t/* see if there is anything from the attached unit to be sent */\n\tif (skb_queue_empty(&pch->file.xq)) {\n\t\tread_lock_bh(&pch->upl);\n\t\tppp = pch->ppp;\n\t\tif (ppp)\n\t\t\tppp_xmit_process(ppp);\n\t\tread_unlock_bh(&pch->upl);\n\t}\n}",
        "target": 0
    },
    {
        "id": 2278,
        "func": "_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,\n\t\t\t\t\tTALLOC_CTX *ctx, const char *src, size_t n)\n{\n\tsize_t size=0;\n\tchar *dest;\n\n\tif (!src) {\n\t\treturn NULL;\n\t}\n\n\t/* this takes advantage of the fact that upper/lower can't\n\t   change the length of a character by more than 1 byte */\n\tdest = talloc_array(ctx, char, 2*(n+1));\n\tif (dest == NULL) {\n                return NULL;\n        }\n \n       while (n-- && *src) {\n                size_t c_size;\n                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,\n                                                          CH_UNIX, &c_size);\n                src += c_size;\n \n                c = toupper_m(c);\n\t\tif (c_size == -1) {\n\t\t\ttalloc_free(dest);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize += c_size;\n\t}\n\n\tdest[size] = 0;\n\n\t/* trim it so talloc_append_string() works */\n\tdest = talloc_realloc(ctx, dest, char, size+1);\n\n\ttalloc_set_name_const(dest, dest);\n\n\treturn dest;\n}\n",
        "target": 1
    },
    {
        "id": 2279,
        "func": "cmsBool IsDegenerated(const cmsToneCurve* g)\n{\n    int i, Zeros = 0, Poles = 0;\n    int nEntries = g ->nEntries;\n\n    for (i=0; i < nEntries; i++) {\n\n        if (g ->Table16[i] == 0x0000) Zeros++;\n        if (g ->Table16[i] == 0xffff) Poles++;\n    }\n\n    if (Zeros == 1 && Poles == 1) return FALSE;  // For linear tables\n    if (Zeros > (nEntries / 4)) return TRUE;  // Degenerated, mostly zeros\n    if (Poles > (nEntries / 4)) return TRUE;  // Degenerated, mostly poles\n\n    return FALSE;\n}",
        "target": 0
    },
    {
        "id": 2280,
        "func": "static jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}",
        "target": 0
    },
    {
        "id": 2281,
        "func": "int CJSON_CDECL main(void)\n{\n    UNITY_BEGIN();\n\n    RUN_TEST(cjson_array_foreach_should_loop_over_arrays);\n    RUN_TEST(cjson_array_foreach_should_not_dereference_null_pointer);\n    RUN_TEST(cjson_get_object_item_should_get_object_items);\n    RUN_TEST(cjson_get_object_item_case_sensitive_should_get_object_items);\n    RUN_TEST(typecheck_functions_should_check_type);\n    RUN_TEST(cjson_should_not_parse_to_deeply_nested_jsons);\n    RUN_TEST(cjson_set_number_value_should_set_numbers);\n    RUN_TEST(cjson_detach_item_via_pointer_should_detach_items);\n    RUN_TEST(cjson_replace_item_via_pointer_should_replace_items);\n    RUN_TEST(cjson_replace_item_in_object_should_preserve_name);\n    RUN_TEST(cjson_functions_shouldnt_crash_with_null_pointers);\n    RUN_TEST(ensure_should_fail_on_failed_realloc);\n    RUN_TEST(skip_utf8_bom_should_skip_bom);\n    RUN_TEST(skip_utf8_bom_should_not_skip_bom_if_not_at_beginning);\n    RUN_TEST(cjson_get_string_value_should_get_a_string);\n    RUN_TEST(cjson_create_string_reference_should_create_a_string_reference);\n    RUN_TEST(cjson_create_object_reference_should_create_an_object_reference);\n    RUN_TEST(cjson_create_array_reference_should_create_an_array_reference);\n    RUN_TEST(cjson_add_item_to_object_should_not_use_after_free_when_string_is_aliased);\n\n    return UNITY_END();\n}",
        "target": 1
    },
    {
        "id": 2282,
        "func": "GF_Err m4ds_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 descSize = 0;\n\tGF_MPEG4ExtensionDescriptorsBox *ptr = (GF_MPEG4ExtensionDescriptorsBox *)s;\n\te = gf_odf_desc_list_size(ptr->descriptors, &descSize);\n\tptr->size += descSize;\n\treturn e;\n}",
        "target": 0
    },
    {
        "id": 2283,
        "func": "TestObject* V8TestObject::toNativeWithTypeCheck(v8::Isolate* isolate, v8::Handle<v8::Value> value)\n{\n    return hasInstance(value, isolate) ? fromInternalPointer(v8::Handle<v8::Object>::Cast(value)->GetAlignedPointerFromInternalField(v8DOMWrapperObjectIndex)) : 0;\n}\n",
        "target": 0
    },
    {
        "id": 2284,
        "func": "void DevToolsWindow::CreateDevToolsBrowser() {\n  PrefService* prefs = profile_->GetPrefs();\n  if (!prefs->GetDictionary(prefs::kAppWindowPlacement)->HasKey(kDevToolsApp)) {\n    DictionaryPrefUpdate update(prefs, prefs::kAppWindowPlacement);\n    base::DictionaryValue* wp_prefs = update.Get();\n    auto dev_tools_defaults = base::MakeUnique<base::DictionaryValue>();\n    dev_tools_defaults->SetInteger(\"left\", 100);\n    dev_tools_defaults->SetInteger(\"top\", 100);\n    dev_tools_defaults->SetInteger(\"right\", 740);\n    dev_tools_defaults->SetInteger(\"bottom\", 740);\n    dev_tools_defaults->SetBoolean(\"maximized\", false);\n    dev_tools_defaults->SetBoolean(\"always_on_top\", false);\n    wp_prefs->Set(kDevToolsApp, std::move(dev_tools_defaults));\n  }\n\n  browser_ = new Browser(Browser::CreateParams::CreateForDevTools(profile_));\n  browser_->tab_strip_model()->AddWebContents(\n      main_web_contents_, -1, ui::PAGE_TRANSITION_AUTO_TOPLEVEL,\n      TabStripModel::ADD_ACTIVE);\n  main_web_contents_->GetRenderViewHost()->SyncRendererPrefs();\n}\n",
        "target": 0
    },
    {
        "id": 2285,
        "func": "static ssize_t rd_set_configfs_dev_params(struct se_device *dev,\n\t\tconst char *page, ssize_t count)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\tchar *orig, *ptr, *opts;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = 0, arg, token;\n\n\topts = kstrdup(page, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\torig = opts;\n\n\twhile ((ptr = strsep(&opts, \",\\n\")) != NULL) {\n\t\tif (!*ptr)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(ptr, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_rd_pages:\n\t\t\tmatch_int(args, &arg);\n\t\t\trd_dev->rd_page_count = arg;\n\t\t\tpr_debug(\"RAMDISK: Referencing Page\"\n\t\t\t\t\" Count: %u\\n\", rd_dev->rd_page_count);\n\t\t\trd_dev->rd_flags |= RDF_HAS_PAGE_COUNT;\n\t\t\tbreak;\n\t\tcase Opt_rd_nullio:\n\t\t\tmatch_int(args, &arg);\n\t\t\tif (arg != 1)\n\t\t\t\tbreak;\n\n\t\t\tpr_debug(\"RAMDISK: Setting NULLIO flag: %d\\n\", arg);\n\t\t\trd_dev->rd_flags |= RDF_NULLIO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(orig);\n\treturn (!ret) ? count : ret;\n}",
        "target": 0
    },
    {
        "id": 2286,
        "func": "static uint64_t vapic_read(void *opaque, hwaddr addr, unsigned size)\n{\n    return 0xffffffff;\n}\n",
        "target": 0
    },
    {
        "id": 2287,
        "func": "void Range::detach(ExceptionCode& ec)\n{\n    if (!m_start.container()) {\n        ec = INVALID_STATE_ERR;\n        return;\n    }\n\n    m_ownerDocument->detachRange(this);\n\n    m_start.clear();\n    m_end.clear();\n}\n",
        "target": 0
    },
    {
        "id": 2288,
        "func": "v8::Handle<v8::Value> toV8NoInline(TestObjectPython* impl, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)\n{\n    return toV8(impl, creationContext, isolate);\n}\n",
        "target": 0
    },
    {
        "id": 2289,
        "func": "static void sycc_to_rgb(int offset, int upb, int y, int cb, int cr,\n                        int *out_r, int *out_g, int *out_b)\n{\n    int r, g, b;\n\n    cb -= offset;\n    cr -= offset;\n    r = y + (int)(1.402 * (float)cr);\n    if (r < 0) {\n        r = 0;\n    } else if (r > upb) {\n        r = upb;\n    }\n    *out_r = r;\n\n    g = y - (int)(0.344 * (float)cb + 0.714 * (float)cr);\n    if (g < 0) {\n        g = 0;\n    } else if (g > upb) {\n        g = upb;\n    }\n    *out_g = g;\n\n    b = y + (int)(1.772 * (float)cb);\n    if (b < 0) {\n        b = 0;\n    } else if (b > upb) {\n        b = upb;\n    }\n    *out_b = b;\n}",
        "target": 0
    },
    {
        "id": 2290,
        "func": "void sctp_assoc_update_retran_path(struct sctp_association *asoc)\n{\n\tstruct sctp_transport *trans = asoc->peer.retran_path;\n\tstruct sctp_transport *trans_next = NULL;\n\n\t/* We're done as we only have the one and only path. */\n\tif (asoc->peer.transport_count == 1)\n\t\treturn;\n\t/* If active_path and retran_path are the same and active,\n\t * then this is the only active path. Use it.\n\t */\n\tif (asoc->peer.active_path == asoc->peer.retran_path &&\n\t    asoc->peer.active_path->state == SCTP_ACTIVE)\n\t\treturn;\n\n\t/* Iterate from retran_path's successor back to retran_path. */\n\tfor (trans = list_next_entry(trans, transports); 1;\n\t     trans = list_next_entry(trans, transports)) {\n\t\t/* Manually skip the head element. */\n\t\tif (&trans->transports == &asoc->peer.transport_addr_list)\n\t\t\tcontinue;\n\t\tif (trans->state == SCTP_UNCONFIRMED)\n\t\t\tcontinue;\n\t\ttrans_next = sctp_trans_elect_best(trans, trans_next);\n\t\t/* Active is good enough for immediate return. */\n\t\tif (trans_next->state == SCTP_ACTIVE)\n\t\t\tbreak;\n\t\t/* We've reached the end, time to update path. */\n\t\tif (trans == asoc->peer.retran_path)\n\t\t\tbreak;\n\t}\n\n\tasoc->peer.retran_path = trans_next;\n\n\tpr_debug(\"%s: association:%p updated new path to addr:%pISpc\\n\",\n\t\t __func__, asoc, &asoc->peer.retran_path->ipaddr.sa);\n}",
        "target": 0
    },
    {
        "id": 2291,
        "func": "void *Type_Measurement_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsICCMeasurementConditions mc;\n\n\t\n    memset(&mc, 0, sizeof(mc));\n\t\n    if (!_cmsReadUInt32Number(io, &mc.Observer)) return NULL;\n    if (!_cmsReadXYZNumber(io,    &mc.Backing)) return NULL;\n    if (!_cmsReadUInt32Number(io, &mc.Geometry)) return NULL;\n    if (!_cmsRead15Fixed16Number(io, &mc.Flare)) return NULL;\n    if (!_cmsReadUInt32Number(io, &mc.IlluminantType)) return NULL;\n\n    *nItems = 1;\n    return _cmsDupMem(self ->ContextID, &mc, sizeof(cmsICCMeasurementConditions));\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}",
        "target": 0
    },
    {
        "id": 2292,
        "func": "ValidityMessage::~ValidityMessage() {}\n",
        "target": 0
    },
    {
        "id": 2293,
        "func": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}",
        "target": 1
    },
    {
        "id": 2294,
        "func": "deep_count_start (NautilusDirectory *directory,\n                  NautilusFile      *file,\n                  gboolean          *doing_io)\n{\n    GFile *location;\n    DeepCountState *state;\n\n    if (directory->details->deep_count_in_progress != NULL)\n    {\n        *doing_io = TRUE;\n        return;\n    }\n\n    if (!is_needy (file,\n                   lacks_deep_count,\n                   REQUEST_DEEP_COUNT))\n    {\n        return;\n    }\n    *doing_io = TRUE;\n\n    if (!nautilus_file_is_directory (file))\n    {\n        file->details->deep_counts_status = NAUTILUS_REQUEST_DONE;\n\n        nautilus_directory_async_state_changed (directory);\n        return;\n    }\n\n    if (!async_job_start (directory, \"deep count\"))\n    {\n        return;\n    }\n\n    /* Start counting. */\n    file->details->deep_counts_status = NAUTILUS_REQUEST_IN_PROGRESS;\n    file->details->deep_directory_count = 0;\n    file->details->deep_file_count = 0;\n    file->details->deep_unreadable_count = 0;\n    file->details->deep_size = 0;\n    directory->details->deep_count_file = file;\n\n    state = g_new0 (DeepCountState, 1);\n    state->directory = directory;\n    state->cancellable = g_cancellable_new ();\n    state->seen_deep_count_inodes = g_array_new (FALSE, TRUE, sizeof (guint64));\n    state->fs_id = NULL;\n\n    directory->details->deep_count_in_progress = state;\n\n    location = nautilus_file_get_location (file);\n    g_file_query_info_async (location,\n                             G_FILE_ATTRIBUTE_ID_FILESYSTEM,\n                             G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                             G_PRIORITY_DEFAULT,\n                             NULL,\n                             deep_count_got_info,\n                             state);\n    g_object_unref (location);\n}",
        "target": 0
    },
    {
        "id": 2295,
        "func": "new_node(struct huffman_code *code)\n{\n  void *new_tree;\n  if (code->numallocatedentries == code->numentries) {\n    int new_num_entries = 256;\n    if (code->numentries > 0) {\n        new_num_entries = code->numentries * 2;\n    }\n    new_tree = realloc(code->tree, new_num_entries * sizeof(*code->tree));\n    if (new_tree == NULL)\n        return (-1);\n    code->tree = (struct huffman_tree_node *)new_tree;\n    code->numallocatedentries = new_num_entries;\n  }\n  code->tree[code->numentries].branches[0] = -1;\n  code->tree[code->numentries].branches[1] = -2;\n  return 1;\n}",
        "target": 0
    },
    {
        "id": 2296,
        "func": "void ContextualSearchDelegate::StartSearchTermResolutionRequest(\n    const std::string& selection,\n    bool use_resolved_search_term,\n    content::WebContents* web_contents,\n    bool may_send_base_page_url) {\n  GatherSurroundingTextWithCallback(\n      selection, use_resolved_search_term, web_contents, may_send_base_page_url,\n      base::Bind(&ContextualSearchDelegate::StartSearchTermRequestFromSelection,\n                 AsWeakPtr()));\n}\n",
        "target": 0
    },
    {
        "id": 2297,
        "func": "void AutoFillHelper::DidAcceptAutoFillSuggestion(const WebNode& node,\n                                                 const WebString& value,\n                                                 const WebString& label,\n                                                 int unique_id,\n                                                 unsigned index) {\n  if (suggestions_options_index_ != -1 &&\n      index == static_cast<unsigned>(suggestions_options_index_)) {\n    render_view_->Send(new ViewHostMsg_ShowAutoFillDialog(\n        render_view_->routing_id()));\n  } else if (suggestions_clear_index_ != -1 &&\n             index == static_cast<unsigned>(suggestions_clear_index_)) {\n    form_manager_.ClearFormWithNode(node);\n  } else if (form_manager_.FormWithNodeIsAutoFilled(node) || !unique_id) {\n    WebInputElement element = node.toConst<WebInputElement>();\n\n    element.setSuggestedValue(value);\n    element.setValue(value);\n\n    WebFrame* webframe = node.document().frame();\n    if (webframe)\n      webframe->notifiyPasswordListenerOfAutocomplete(element);\n  } else {\n    QueryAutoFillFormData(node, value, label, unique_id, AUTOFILL_FILL);\n  }\n\n  suggestions_clear_index_ = -1;\n  suggestions_options_index_ = -1;\n}\n",
        "target": 0
    },
    {
        "id": 2298,
        "func": "void ptrace_disable(struct task_struct *child)\n{\n\t/* make sure the single step bit is not set. */\n\tuser_disable_single_step(child);\n}",
        "target": 0
    },
    {
        "id": 2299,
        "func": "cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type)\n{\n    int rc = pcmk_ok;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    if (private->passwd == NULL) {\n        struct termios settings;\n        int rc;\n\n        rc = tcgetattr(0, &settings);\n        settings.c_lflag &= ~ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n\n        fprintf(stderr, \"Password: \");\n        private->passwd = calloc(1, 1024);\n        rc = scanf(\"%s\", private->passwd);\n        fprintf(stdout, \"\\n\");\n        /* fprintf(stderr, \"entered: '%s'\\n\", buffer); */\n        if (rc < 1) {\n            private->passwd = NULL;\n        }\n\n        settings.c_lflag |= ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n    }\n\n    if (private->server == NULL || private->user == NULL) {\n        rc = -EINVAL;\n    }\n\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->command));\n    }\n\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->callback));\n    }\n\n    if (rc == pcmk_ok) {\n        xmlNode *hello =\n            cib_create_op(0, private->callback.token, CRM_OP_REGISTER, NULL, NULL, NULL, 0, NULL);\n        crm_xml_add(hello, F_CIB_CLIENTNAME, name);\n        crm_send_remote_msg(private->command.session, hello, private->command.encrypted);\n        free_xml(hello);\n    }\n\n    if (rc == pcmk_ok) {\n        fprintf(stderr, \"%s: Opened connection to %s:%d\\n\", name, private->server, private->port);\n        cib->state = cib_connected_command;\n        cib->type = cib_command;\n\n    } else {\n        fprintf(stderr, \"%s: Connection to %s:%d failed: %s\\n\",\n                name, private->server, private->port, pcmk_strerror(rc));\n    }\n\n    return rc;\n}",
        "target": 1
    },
    {
        "id": 2300,
        "func": "QueuedRequest* CoordinatorImpl::GetCurrentRequest() {\n  if (queued_memory_dump_requests_.empty()) {\n    return nullptr;\n  }\n  return &queued_memory_dump_requests_.front();\n}\n",
        "target": 0
    },
    {
        "id": 2301,
        "func": "  TestAudioObserver() : output_mute_changed_count_(0) {\n  }\n",
        "target": 0
    },
    {
        "id": 2302,
        "func": "static int bt_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct bt_sock_list *sk_list;\n\tstruct bt_seq_state *s;\n\n\tsk_list = PDE(inode)->data;\n\ts = __seq_open_private(file, &bt_seq_ops,\n\t\t\t       sizeof(struct bt_seq_state));\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ts->l = sk_list;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2303,
        "func": "CurrentHistoryCleaner::CurrentHistoryCleaner(content::WebContents* contents)\n    : WebContentsObserver(contents) {\n  history_index_to_remove_ =\n      web_contents()->GetController().GetLastCommittedEntryIndex();\n}\n",
        "target": 0
    },
    {
        "id": 2304,
        "func": "dashedSet (gdImagePtr im, int x, int y, int color,\n\t\t   int *onP, int *dashStepP, int wid, int vert)\n{\n\tint dashStep = *dashStepP;\n\tint on = *onP;\n\tint w, wstart;\n\n\tdashStep++;\n\tif (dashStep == gdDashSize) {\n\t\tdashStep = 0;\n\t\ton = !on;\n\t}\n\tif (on) {\n\t\tif (vert) {\n\t\t\twstart = y - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t} else {\n\t\t\twstart = x - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t}\n\t}\n\t*dashStepP = dashStep;\n\t*onP = on;\n}",
        "target": 0
    },
    {
        "id": 2305,
        "func": " usage(int iExitCode)\n {\n        char word[32];\n       sprintf( word, getJobActionString(mode) );\n        fprintf( stderr, \"Usage: %s [options] [constraints]\\n\", MyName );\n        fprintf( stderr, \" where [options] is zero or more of:\\n\" );\n        fprintf( stderr, \"  -help               Display this message and exit\\n\" );\n\tfprintf( stderr, \"  -version            Display version information and exit\\n\" );\n\n\n\tfprintf( stderr, \"  -name schedd_name   Connect to the given schedd\\n\" );\n\tfprintf( stderr, \"  -pool hostname      Use the given central manager to find daemons\\n\" );\n\tfprintf( stderr, \"  -addr <ip:port>     Connect directly to the given \\\"sinful string\\\"\\n\" );\n\tif( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) {\n\t\tfprintf( stderr, \"  -reason reason      Use the given RemoveReason\\n\");\n\t} else if( mode == JA_RELEASE_JOBS ) {\n\t\tfprintf( stderr, \"  -reason reason      Use the given ReleaseReason\\n\");\n\t} else if( mode == JA_HOLD_JOBS ) {\n\t\tfprintf( stderr, \"  -reason reason      Use the given HoldReason\\n\");\n\t\tfprintf( stderr, \"  -subcode number     Set HoldReasonSubCode\\n\");\n\t}\n\n\tif( mode == JA_REMOVE_JOBS || mode == JA_REMOVE_X_JOBS ) {\n\t\tfprintf( stderr,\n\t\t\t\t     \"  -forcex             Force the immediate local removal of jobs in the X state\\n\"\n\t\t         \"                      (only affects jobs already being removed)\\n\" );\n\t}\n\tif( mode == JA_VACATE_JOBS || mode == JA_VACATE_FAST_JOBS ) {\n\t\tfprintf( stderr,\n\t\t\t\t     \"  -fast               Use a fast vacate (hardkill)\\n\" );\n\t}\n\tfprintf( stderr, \" and where [constraints] is one of:\\n\" );\n\tfprintf( stderr, \"  cluster.proc        %s the given job\\n\", word );\n\tfprintf( stderr, \"  cluster             %s the given cluster of jobs\\n\", word );\n\tfprintf( stderr, \"  user                %s all jobs owned by user\\n\", word );\n\tfprintf( stderr, \"  -constraint expr    %s all jobs matching the boolean expression\\n\", word );\n\tfprintf( stderr, \"  -all                %s all jobs \"\n\t\t\t \"(cannot be used with other constraints)\\n\", word );\n\texit( iExitCode );\n}\n",
        "target": 1
    },
    {
        "id": 2306,
        "func": "static struct user_namespace *netns_owner(struct ns_common *ns)\n{\n\treturn to_net_ns(ns)->user_ns;\n}",
        "target": 0
    },
    {
        "id": 2307,
        "func": "static int add_recvbuf_small(struct virtnet_info *vi, struct receive_queue *rq,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tstruct virtio_net_hdr_mrg_rxbuf *hdr;\n\tint err;\n\n\tskb = __netdev_alloc_skb_ip_align(vi->dev, GOOD_PACKET_LEN, gfp);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, GOOD_PACKET_LEN);\n\n\thdr = skb_vnet_hdr(skb);\n\tsg_init_table(rq->sg, MAX_SKB_FRAGS + 2);\n\tsg_set_buf(rq->sg, hdr, vi->hdr_len);\n\tskb_to_sgvec(skb, rq->sg + 1, 0, skb->len);\n\n\terr = virtqueue_add_inbuf(rq->vq, rq->sg, 2, skb, gfp);\n\tif (err < 0)\n\t\tdev_kfree_skb(skb);\n\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 2308,
        "func": "IDAT_list_extend(struct IDAT_list *tail)\n{\n /* Use the previous cached value if available. */\n struct IDAT_list *next = tail->next;\n\n if (next == NULL)\n {\n /* Insert a new, malloc'ed, block of IDAT information buffers, this\n       * one twice as large as the previous one:\n       */\n unsigned int length = 2 * tail->length;\n\n \n       if (length < tail->length) /* arithmetic overflow */\n          length = tail->length;\n      next = png_voidcast(IDAT_list*, malloc(IDAT_list_size(NULL, length)));\n       CLEAR(*next);\n \n       /* The caller must handle this: */\n if (next == NULL)\n return NULL;\n\n      next->next = NULL;\n      next->length = length;\n      tail->next = next;\n }\n\n return next;\n}\n",
        "target": 1
    },
    {
        "id": 2309,
        "func": "struct file *alloc_file(struct path *path, fmode_t mode,\n\t\tconst struct file_operations *fop)\n{\n\tstruct file *file;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_path = *path;\n\tfile->f_inode = path->dentry->d_inode;\n\tfile->f_mapping = path->dentry->d_inode->i_mapping;\n\tfile->f_mode = mode;\n\tfile->f_op = fop;\n\n\t/*\n\t * These mounts don't really matter in practice\n\t * for r/o bind mounts.  They aren't userspace-\n\t * visible.  We do this for consistency, and so\n\t * that we can do debugging checks at __fput()\n\t */\n\tif ((mode & FMODE_WRITE) && !special_file(path->dentry->d_inode->i_mode)) {\n\t\tfile_take_write(file);\n\t\tWARN_ON(mnt_clone_write(path->mnt));\n\t}\n\tif ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(path->dentry->d_inode);\n\treturn file;\n}",
        "target": 0
    },
    {
        "id": 2310,
        "func": "static void udf_load_logicalvolint(struct super_block *sb, struct kernel_extent_ad loc)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint16_t ident;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDesc *lvid;\n\n\twhile (loc.extLength > 0 &&\n\t       (bh = udf_read_tagged(sb, loc.extLocation,\n\t\t\t\t     loc.extLocation, &ident)) &&\n\t       ident == TAG_IDENT_LVID) {\n\t\tsbi->s_lvid_bh = bh;\n\t\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\n\t\tif (lvid->nextIntegrityExt.extLength)\n\t\t\tudf_load_logicalvolint(sb,\n\t\t\t\tleea_to_cpu(lvid->nextIntegrityExt));\n\n\t\tif (sbi->s_lvid_bh != bh)\n\t\t\tbrelse(bh);\n\t\tloc.extLength -= sb->s_blocksize;\n\t\tloc.extLocation++;\n\t}\n\tif (sbi->s_lvid_bh != bh)\n\t\tbrelse(bh);\n}",
        "target": 0
    },
    {
        "id": 2311,
        "func": " int main(int argc, char *argv[]) {\n\tp_fm_config_conx_hdlt\thdl;\n \tint\t\t\t\t\t\tinstance = 0;\n \tfm_mgr_config_errno_t\tres;\n \tchar\t\t\t\t\t*rem_addr = NULL;\n\tchar\t\t\t\t\t*community = \"public\";\n\tchar            \t\tOpts[256];\n    int             \t\targ;\n\tchar \t\t\t\t\t*command;\n\tint\t\t\t\t\t\ti;\n\n\t/* Get options at the command line (overide default values) */\n    strcpy(Opts, \"i:d:h-\");\n\n    while ((arg = getopt(argc, argv, Opts)) != EOF) {\n        switch (arg) {\n\t\tcase 'h':\n\t\tcase '-':\n\t\t\tusage(argv[0]);\n\t\t\treturn(0);\n\t\tcase 'i':\n\t\t\tinstance = atol(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\trem_addr = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\treturn(-1);\n\t\t}\n\t}\n\n\tif(optind >= argc){\n        fprintf(stderr, \"Command required\\n\");\n\t\tusage(argv[0]);\n\t\treturn -1;\n\t}\n\n\tcommand = argv[optind++];\n\tprintf(\"Connecting to %s FM instance %d\\n\", (rem_addr==NULL) ? \"LOCAL\":rem_addr, instance);\n \tif((res = fm_mgr_config_init(&hdl,instance, rem_addr, community)) != FM_CONF_OK)\n \t{\n \t\tfprintf(stderr, \"Failed to initialize the client handle: %d\\n\", res);\n\t\tgoto die_clean;\n \t}\n \n \tif((res = fm_mgr_config_connect(hdl)) != FM_CONF_OK)\n \t{\n \t\tfprintf(stderr, \"Failed to connect: (%d) %s\\n\",res,fm_mgr_get_error_str(res));\n\t\tgoto die_clean;\n \t}\n \n \tfor(i=0;i<commandListLen;i++){\n \t\tif(strcmp(command,commandList[i].name) == 0){\n\t\t\treturn commandList[i].cmdPtr(hdl, commandList[i].mgr, (argc - optind), &argv[optind]);\n \t\t}\n \t}\n \n \tfprintf(stderr, \"Command (%s) is not valid\\n\",command);\n \tusage(argv[0]);\n \tres = -1;\n \ndie_clean:\n\tif (hdl) free(hdl);\n \treturn res;\n }\n",
        "target": 1
    },
    {
        "id": 2312,
        "func": "randomize_range(unsigned long start, unsigned long end, unsigned long len)\n{\n\tunsigned long range = end - len - start;\n\n\tif (end <= start + len)\n\t\treturn 0;\n\treturn PAGE_ALIGN(get_random_int() % range + start);\n}",
        "target": 0
    },
    {
        "id": 2313,
        "func": "static int packet_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t int kern)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\t__be16 proto = (__force __be16)protocol; /* weird, but documented */\n\tint err;\n\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\tif (sock->type != SOCK_DGRAM && sock->type != SOCK_RAW &&\n\t    sock->type != SOCK_PACKET)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->state = SS_UNCONNECTED;\n\n\terr = -ENOBUFS;\n\tsk = sk_alloc(net, PF_PACKET, GFP_KERNEL, &packet_proto);\n\tif (sk == NULL)\n\t\tgoto out;\n\n\tsock->ops = &packet_ops;\n\tif (sock->type == SOCK_PACKET)\n\t\tsock->ops = &packet_ops_spkt;\n\n\tsock_init_data(sock, sk);\n\n\tpo = pkt_sk(sk);\n\tsk->sk_family = PF_PACKET;\n\tpo->num = proto;\n\n\tsk->sk_destruct = packet_sock_destruct;\n\tsk_refcnt_debug_inc(sk);\n\n\t/*\n\t *\tAttach a protocol block\n\t */\n\n\tspin_lock_init(&po->bind_lock);\n\tmutex_init(&po->pg_vec_lock);\n\tpo->prot_hook.func = packet_rcv;\n\n\tif (sock->type == SOCK_PACKET)\n\t\tpo->prot_hook.func = packet_rcv_spkt;\n\n\tpo->prot_hook.af_packet_priv = sk;\n\n\tif (proto) {\n\t\tpo->prot_hook.type = proto;\n\t\tdev_add_pack(&po->prot_hook);\n\t\tsock_hold(sk);\n\t\tpo->running = 1;\n\t}\n\n\tspin_lock_bh(&net->packet.sklist_lock);\n\tsk_add_node_rcu(sk, &net->packet.sklist);\n\tsock_prot_inuse_add(net, &packet_proto, 1);\n\tspin_unlock_bh(&net->packet.sklist_lock);\n\n\treturn 0;\nout:\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 2314,
        "func": "void WebMediaPlayerImpl::OnPause() {\n  client_->RequestPause();\n}\n",
        "target": 0
    },
    {
        "id": 2315,
        "func": "static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\n\t/* Get flash device data */\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (cs > CQSPI_MAX_CHIPSELECT) {\n\t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n\t\t\tgoto err;\n\t\t}\n\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\n\t\tmtd->priv = nor;\n\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tf_pdata->registered = true;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 2316,
        "func": "void TemplateURL::CopyFrom(const TemplateURL& other) {\n  if (this == &other)\n    return;\n\n  data_ = other.data_;\n  ResizeURLRefVector();\n  InvalidateCachedValues();\n  SetPrepopulateId(other.data_.prepopulate_id);\n}\n",
        "target": 0
    },
    {
        "id": 2317,
        "func": "xsltFreeCompMatchList(xsltCompMatchPtr comp) {\n    xsltCompMatchPtr cur;\n\n    while (comp != NULL) {\n\tcur = comp;\n\tcomp = comp->next;\n\txsltFreeCompMatch(cur);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2318,
        "func": "void kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}",
        "target": 0
    },
    {
        "id": 2319,
        "func": "static v8::Handle<v8::Value> methodWithNonOptionalArgAndOptionalArgCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodWithNonOptionalArgAndOptionalArg\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     if (args.Length() <= 1) {\n        imp->methodWithNonOptionalArgAndOptionalArg(nonOpt);\n        return v8::Handle<v8::Value>();\n    }\n    EXCEPTION_BLOCK(int, opt, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));\n    imp->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);\n    return v8::Handle<v8::Value>();\n}\n",
        "target": 1
    },
    {
        "id": 2320,
        "func": "BlockGroup::BlockGroup(\n    Cluster* pCluster,\n    long idx,\n    long long block_start,\n    long long block_size,\n    long long prev,\n    long long next,\n    long long duration,\n    long long discard_padding) :\n    BlockEntry(pCluster, idx),\n    m_block(block_start, block_size, discard_padding),\n    m_prev(prev),\n    m_next(next),\n    m_duration(duration)\n{\n}\n",
        "target": 1
    },
    {
        "id": 2321,
        "func": "CString fileSystemRepresentation(const String&)\nCString fileSystemRepresentation(const String& path)\n {\n    const UChar* characters = path.characters();\n    int size = WideCharToMultiByte(CP_ACP, 0, characters, path.length(), 0, 0, 0, 0) - 1;\n\n    char* buffer;\n    CString string = CString::newUninitialized(size, buffer);\n\n    WideCharToMultiByte(CP_ACP, 0, characters, path.length(), buffer, size, 0, 0);\n\n    return string;\n }\n",
        "target": 0
    },
    {
        "id": 2322,
        "func": "Element* SVGDocumentExtensions::removeElementFromPendingResourcesForRemoval(const AtomicString& id)\n{\n    if (id.isEmpty())\n        return 0;\n\n    SVGPendingElements* resourceSet = m_pendingResourcesForRemoval.get(id);\n    if (!resourceSet || resourceSet->isEmpty())\n        return 0;\n\n    SVGPendingElements::iterator firstElement = resourceSet->begin();\n    Element* element = *firstElement;\n\n    resourceSet->remove(firstElement);\n\n    if (resourceSet->isEmpty())\n        removePendingResourceForRemoval(id);\n\n    return element;\n}\n",
        "target": 0
    },
    {
        "id": 2323,
        "func": "static const std::string& GetMessagePrefix() {\n  CR_DEFINE_STATIC_LOCAL(std::string, message_prefix, (\"Manifest: \"));\n  return message_prefix;\n}\n",
        "target": 0
    },
    {
        "id": 2324,
        "func": "ftrace_suspend_notifier_call(struct notifier_block *bl, unsigned long state,\n\t\t\t\t\t\t\tvoid *unused)\n{\n\tswitch (state) {\n\tcase PM_HIBERNATION_PREPARE:\n\t\tpause_graph_tracing();\n\t\tbreak;\n\n\tcase PM_POST_HIBERNATION:\n\t\tunpause_graph_tracing();\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}",
        "target": 0
    },
    {
        "id": 2325,
        "func": "void cgsleep_us_r(cgtimer_t *ts_start, int64_t us)\n{\n\tstruct timespec ts_end;\n\n\tus_to_timespec(&ts_end, us);\n\ttimeraddspec(&ts_end, ts_start);\n\tnanosleep_abstime(&ts_end);\n}",
        "target": 0
    },
    {
        "id": 2326,
        "func": "static void OverloadedMethodN1Method(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  TestInterfaceImplementation* test_interface_arg;\n  test_interface_arg = V8TestInterface::ToImplWithTypeCheck(info.GetIsolate(), info[0]);\n  if (!test_interface_arg) {\n    V8ThrowException::ThrowTypeError(info.GetIsolate(), ExceptionMessages::FailedToExecute(\"overloadedMethodN\", \"TestObject\", ExceptionMessages::ArgumentNotOfType(0, \"TestInterface\")));\n    return;\n  }\n\n  impl->overloadedMethodN(test_interface_arg);\n}\n",
        "target": 0
    },
    {
        "id": 2327,
        "func": "SetInputCheck(HWEventQueuePtr c0, HWEventQueuePtr c1)\n{\n    checkForInput[0] = c0;\n    checkForInput[1] = c1;\n}\n",
        "target": 0
    },
    {
        "id": 2328,
        "func": "void FileAPIMessageFilter::OnOpenFile(\n    int request_id, const GURL& path, int file_flags) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n  base::PlatformFileError error;\n  const int open_permissions = base::PLATFORM_FILE_OPEN |\n                               (file_flags & kOpenFilePermissions);\n  FileSystemURL url(path);\n  if (!HasPermissionsForFile(url, open_permissions, &error)) {\n    Send(new FileSystemMsg_DidFail(request_id, error));\n    return;\n  }\n\n  FileSystemOperation* operation = GetNewOperation(url, request_id);\n  if (!operation)\n    return;\n  operation->OpenFile(\n      url, file_flags, peer_handle(),\n      base::Bind(&FileAPIMessageFilter::DidOpenFile, this, request_id, path));\n}\n",
        "target": 0
    },
    {
        "id": 2329,
        "func": "void RTCPeerConnectionHandler::OnIceGatheringChange(\n    webrtc::PeerConnectionInterface::IceGatheringState new_state) {\n  DCHECK(task_runner_->RunsTasksInCurrentSequence());\n  TRACE_EVENT0(\"webrtc\", \"RTCPeerConnectionHandler::OnIceGatheringChange\");\n\n  if (new_state == webrtc::PeerConnectionInterface::kIceGatheringComplete) {\n    UMA_HISTOGRAM_COUNTS_100(\"WebRTC.PeerConnection.IPv4LocalCandidates\",\n                             num_local_candidates_ipv4_);\n\n    UMA_HISTOGRAM_COUNTS_100(\"WebRTC.PeerConnection.IPv6LocalCandidates\",\n                             num_local_candidates_ipv6_);\n  } else if (new_state ==\n             webrtc::PeerConnectionInterface::kIceGatheringGathering) {\n    ResetUMAStats();\n  }\n\n  if (peer_connection_tracker_)\n    peer_connection_tracker_->TrackIceGatheringStateChange(this, new_state);\n  if (!is_closed_)\n    client_->DidChangeIceGatheringState(new_state);\n}\n",
        "target": 0
    },
    {
        "id": 2330,
        "func": "config_ntpdsim(\n\tconfig_tree *ptree\n\t)\n{\n\tprintf(\"Configuring Simulator...\\n\");\n\tprintf(\"Some ntpd-specific commands in the configuration file will be ignored.\\n\");\n\n\tconfig_tos(ptree);\n\tconfig_monitor(ptree);\n\tconfig_tinker(ptree);\n\tconfig_system_opts(ptree);\n\tconfig_logconfig(ptree);\n\tconfig_vars(ptree);\n\tconfig_sim(ptree);\n}",
        "target": 0
    },
    {
        "id": 2331,
        "func": "static double outerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n    /* There is a serious error in the 2 and 4 bit grayscale transform because\n     * the gamma table value (8 bits) is simply shifted, not rounded, so the\n    * error in 4 bit grayscale gamma is up to the value below.  This is a hack\n    * to allow pngvalid to succeed:\n    *\n    * TODO: fix this in libpng\n    */\n if (out_depth == 2)\n return .73182-.5;\n\n if (out_depth == 4)\n return .90644-.5;\n\n if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n return pm->maxout16;\n\n /* This is the case where the value was calculated at 8-bit precision then\n    * scaled to 16 bits.\n    */\n else if (out_depth == 16)\n return pm->maxout8 * 257;\n\n else\n return pm->maxout8;\n}\n",
        "target": 1
    },
    {
        "id": 2332,
        "func": "const blink::WebView* RenderViewImpl::webview() const {\n  return webview_;\n}\n",
        "target": 0
    },
    {
        "id": 2333,
        "func": "void SupervisedUserService::ReportURL(const GURL& url,\n                                      SuccessCallback callback) {\n  if (url_reporter_)\n    url_reporter_->ReportUrl(url, std::move(callback));\n  else\n    std::move(callback).Run(false);\n}\n",
        "target": 0
    },
    {
        "id": 2334,
        "func": "void ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta)\n{\n\tu8 ignore_for_response = sta->sta.uapsd_queues;\n\n\t/*\n\t * If all ACs are delivery-enabled then we should reply\n\t * from any of them, if only some are enabled we reply\n\t * only from the non-enabled ones.\n\t */\n\tif (ignore_for_response == BIT(IEEE80211_NUM_ACS) - 1)\n\t\tignore_for_response = 0;\n\n\tieee80211_sta_ps_deliver_response(sta, 1, ignore_for_response,\n\t\t\t\t\t  IEEE80211_FRAME_RELEASE_PSPOLL);\n}",
        "target": 0
    },
    {
        "id": 2335,
        "func": "bool DrawingBuffer::SetupRGBEmulationForBlitFramebuffer() {\n\n  if (want_alpha_channel_ || anti_aliasing_mode_ != kNone)\n    return false;\n\n  if (!(ShouldUseChromiumImage() &&\n        ContextProvider()->GetCapabilities().chromium_image_rgb_emulation))\n    return false;\n\n  if (!back_color_buffer_)\n    return false;\n\n  if (!back_color_buffer_->image_id)\n    return false;\n\n\n  GLuint rgb_texture = back_color_buffer_->rgb_workaround_texture_id;\n  GLenum target = GC3D_TEXTURE_RECTANGLE_ARB;\n  if (!rgb_texture) {\n    gl_->GenTextures(1, &rgb_texture);\n    gl_->BindTexture(target, rgb_texture);\n    gl_->TexParameteri(target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    gl_->TexParameteri(target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    gl_->TexParameteri(target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    gl_->TexParameteri(target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\n    gl_->BindTexImage2DWithInternalformatCHROMIUM(target, GL_RGB,\n                                                  back_color_buffer_->image_id);\n    back_color_buffer_->rgb_workaround_texture_id = rgb_texture;\n  }\n\n  gl_->FramebufferTexture2D(GL_DRAW_FRAMEBUFFER_ANGLE, GL_COLOR_ATTACHMENT0,\n                            target, rgb_texture, 0);\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2336,
        "func": "static void testInspectorManualAttachDetach(CustomInspectorTest* test, gconstpointer)\n{\n    test->showInWindowAndWaitUntilMapped(GTK_WINDOW_TOPLEVEL);\n    test->resizeView(200, 200);\n    test->loadHtml(\"<html><body><p>WebKitGTK+ Inspector test</p></body></html>\", 0);\n    test->waitUntilLoadFinished();\n\n    test->showAndWaitUntilFinished(false);\n    test->assertObjectIsDeletedWhenTestFinishes(G_OBJECT(webkit_web_inspector_get_web_view(test->m_inspector)));\n    g_assert(!webkit_web_inspector_is_attached(test->m_inspector));\n    Vector<InspectorTest::InspectorEvents>& events = test->m_events;\n    g_assert_cmpint(events.size(), ==, 2);\n    g_assert_cmpint(events[0], ==, InspectorTest::BringToFront);\n    g_assert_cmpint(events[1], ==, InspectorTest::OpenWindow);\n    test->m_events.clear();\n \n     test->resizeViewAndAttach();\n     g_assert(webkit_web_inspector_is_attached(test->m_inspector));\n     events = test->m_events;\n     g_assert_cmpint(events.size(), ==, 1);\n     g_assert_cmpint(events[0], ==, InspectorTest::Attach);\n    test->m_events.clear();\n\n    test->detachAndWaitUntilWindowOpened();\n    g_assert(!webkit_web_inspector_is_attached(test->m_inspector));\n    events = test->m_events;\n    g_assert_cmpint(events.size(), ==, 2);\n    g_assert_cmpint(events[0], ==, InspectorTest::Detach);\n    g_assert_cmpint(events[1], ==, InspectorTest::OpenWindow);\n    test->m_events.clear();\n\n    test->resizeViewAndAttach();\n    g_assert(webkit_web_inspector_is_attached(test->m_inspector));\n    test->m_events.clear();\n    test->closeAndWaitUntilClosed();\n    events = test->m_events;\n    g_assert_cmpint(events.size(), ==, 2);\n    g_assert_cmpint(events[0], ==, InspectorTest::Detach);\n    g_assert_cmpint(events[1], ==, InspectorTest::Closed);\n    test->m_events.clear();\n}\n",
        "target": 1
    },
    {
        "id": 2337,
        "func": "static void GetConfigurationEntry(NDIS_HANDLE cfg, tConfigurationEntry *pEntry)\n{\n    NDIS_STATUS status;\n    const char *statusName;\n    NDIS_STRING name = {0};\n    PNDIS_CONFIGURATION_PARAMETER pParam = NULL;\n    NDIS_PARAMETER_TYPE ParameterType = NdisParameterInteger;\n    NdisInitializeString(&name, (PUCHAR)pEntry->Name);\n#pragma warning(push)\n#pragma warning(disable:6102)\n    NdisReadConfiguration(\n        &status,\n        &pParam,\n        cfg,\n        &name,\n        ParameterType);\n    if (status == NDIS_STATUS_SUCCESS)\n    {\n        ULONG ulValue = pParam->ParameterData.IntegerData;\n        if (ulValue >= pEntry->ulMinimal && ulValue <= pEntry->ulMaximal)\n        {\n            pEntry->ulValue = ulValue;\n            statusName = \"value\";\n        }\n        else\n        {\n            statusName = \"out of range\";\n        }\n    }\n    else\n    {\n        statusName = \"nothing\";\n    }\n#pragma warning(pop)\n    DPrintf(2, (\"[%s] %s read for %s - 0x%x\\n\",\n        __FUNCTION__,\n        statusName,\n        pEntry->Name,\n        pEntry->ulValue));\n    if (name.Buffer) NdisFreeString(name);\n}",
        "target": 0
    },
    {
        "id": 2338,
        "func": "static int get_debug_info(struct PE_(r_bin_pe_obj_t)* bin, PE_(image_debug_directory_entry)* dbg_dir_entry, ut8* dbg_data, int dbg_data_len, SDebugInfo* res) {\n\t#define SIZEOF_FILE_NAME 255\n\tint i = 0;\n\tconst char* basename;\n\tif (!dbg_data) {\n\t\treturn 0;\n\t}\n\tswitch (dbg_dir_entry->Type) {\n\tcase IMAGE_DEBUG_TYPE_CODEVIEW:\n\t\tif (!strncmp ((char*) dbg_data, \"RSDS\", 4)) {\n\t\t\tSCV_RSDS_HEADER rsds_hdr;\n\t\t\tinit_rsdr_hdr (&rsds_hdr);\n\t\t\tif (!get_rsds (dbg_data, dbg_data_len, &rsds_hdr)) {\n\t\t\t\tbprintf (\"Warning: Cannot read PE debug info\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsnprintf (res->guidstr, GUIDSTR_LEN,\n\t\t\t\t\"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x\",\n\t\t\t\trsds_hdr.guid.data1,\n\t\t\t\trsds_hdr.guid.data2,\n\t\t\t\trsds_hdr.guid.data3,\n\t\t\t\trsds_hdr.guid.data4[0],\n\t\t\t\trsds_hdr.guid.data4[1],\n\t\t\t\trsds_hdr.guid.data4[2],\n\t\t\t\trsds_hdr.guid.data4[3],\n\t\t\t\trsds_hdr.guid.data4[4],\n\t\t\t\trsds_hdr.guid.data4[5],\n\t\t\t\trsds_hdr.guid.data4[6],\n\t\t\t\trsds_hdr.guid.data4[7],\n\t\t\t\trsds_hdr.age);\n\t\t\tbasename = r_file_basename ((char*) rsds_hdr.file_name);\n\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\tbasename, sizeof (res->file_name));\n\t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n\t\t\trsds_hdr.free ((struct SCV_RSDS_HEADER*) &rsds_hdr);\n\t\t} else if (strncmp ((const char*) dbg_data, \"NB10\", 4) == 0) {\n\t\t\tSCV_NB10_HEADER nb10_hdr;\n\t\t\tinit_cv_nb10_header (&nb10_hdr);\n\t\t\tget_nb10 (dbg_data, &nb10_hdr);\n\t\t\tsnprintf (res->guidstr, sizeof (res->guidstr),\n\t\t\t\t\"%x%x\", nb10_hdr.timestamp, nb10_hdr.age);\n\t\t\tstrncpy (res->file_name, (const char*)\n\t\t\t\tnb10_hdr.file_name, sizeof(res->file_name) - 1);\n\t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n\t\t\tnb10_hdr.free ((struct SCV_NB10_HEADER*) &nb10_hdr);\n\t\t} else {\n\t\t\tbprintf (\"CodeView section not NB10 or RSDS\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t//bprintf(\"get_debug_info(): not supported type\\n\");\n\t\treturn 0;\n\t}\n\n\twhile (i < 33) {\n\t\tres->guidstr[i] = toupper ((int) res->guidstr[i]);\n\t\ti++;\n\t}\n\n\treturn 1;\n}",
        "target": 1
    },
    {
        "id": 2339,
        "func": "static void receive_packet(node_t *n, vpn_packet_t *packet) {\n\tifdebug(TRAFFIC) logger(LOG_DEBUG, \"Received packet of %d bytes from %s (%s)\",\n\t\t\t   packet->len, n->name, n->hostname);\n\n\troute(n, packet);\n}",
        "target": 0
    },
    {
        "id": 2340,
        "func": "static void *tcp_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tvoid *rc = NULL;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\trc = tcp_get_idx(seq, 0);\n\t\tgoto out;\n\t}\n\n\tswitch (st->state) {\n\tcase TCP_SEQ_STATE_LISTENING:\n\t\trc = listening_get_next(seq, v);\n\t\tif (!rc) {\n\t\t\tst->state = TCP_SEQ_STATE_ESTABLISHED;\n\t\t\tst->bucket = 0;\n\t\t\tst->offset = 0;\n\t\t\trc\t  = established_get_first(seq);\n\t\t}\n\t\tbreak;\n\tcase TCP_SEQ_STATE_ESTABLISHED:\n\t\trc = established_get_next(seq, v);\n\t\tbreak;\n\t}\nout:\n\t++*pos;\n\tst->last_pos = *pos;\n\treturn rc;\n}",
        "target": 0
    },
    {
        "id": 2341,
        "func": "static void overloadedMethodG2Method(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    if (UNLIKELY(info.Length() < 1)) {\n        throwTypeError(ExceptionMessages::failedToExecute(\"overloadedMethodG\", \"TestObjectPython\", ExceptionMessages::notEnoughArguments(1, info.Length())), info.GetIsolate());\n        return;\n    }\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, strictTypeCheckingStringArg, info[0]);\n    imp->overloadedMethodG(strictTypeCheckingStringArg);\n}\n",
        "target": 0
    },
    {
        "id": 2342,
        "func": "EncodedJSValue JSC_HOST_CALL JSTestInterfaceConstructor::constructJSTestInterface(ExecState* exec)\n {\n     JSTestInterfaceConstructor* castedThis = jsCast<JSTestInterfaceConstructor*>(exec->callee());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     ExceptionCode ec = 0;\n     const String& str1(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    const String& str2(ustringToString(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    ScriptExecutionContext* context = castedThis->scriptExecutionContext();\n    if (!context)\n        return throwVMError(exec, createReferenceError(exec, \"TestInterface constructor associated document is unavailable\"));\n    RefPtr<TestInterface> object = TestInterface::create(context, str1, str2, ec);\n    if (ec) {\n        setDOMException(exec, ec);\n        return JSValue::encode(JSValue());\n    }\n    return JSValue::encode(asObject(toJS(exec, castedThis->globalObject(), object.get())));\n}\n",
        "target": 1
    },
    {
        "id": 2343,
        "func": "v8::Handle<v8::Value> V8DirectoryEntry::getDirectoryCallback(const v8::Arguments& args)\n{\n    INC_STATS(\"DOM.DirectoryEntry.getDirectory\");\n     DirectoryEntry* imp = V8DirectoryEntry::toNative(args.Holder());\n \n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<WithUndefinedOrNullCheck>, path, args[0]);\n     if (args.Length() <= 1) {\n        imp->getDirectory(path);\n        return v8::Handle<v8::Value>();\n    }\n    RefPtr<WebKitFlags> flags;\n    if (!isUndefinedOrNull(args[1]) && args[1]->IsObject()) {\n        EXCEPTION_BLOCK(v8::Handle<v8::Object>, object, v8::Handle<v8::Object>::Cast(args[1]));\n        flags = WebKitFlags::create();\n        v8::Local<v8::Value> v8Create = object->Get(v8::String::New(\"create\"));\n        if (!v8Create.IsEmpty() && !isUndefinedOrNull(v8Create)) {\n            EXCEPTION_BLOCK(bool, isCreate, v8Create->BooleanValue());\n            flags->setCreate(isCreate);\n        }\n        v8::Local<v8::Value> v8Exclusive = object->Get(v8::String::New(\"exclusive\"));\n        if (!v8Exclusive.IsEmpty() && !isUndefinedOrNull(v8Exclusive)) {\n            EXCEPTION_BLOCK(bool, isExclusive, v8Exclusive->BooleanValue());\n            flags->setExclusive(isExclusive);\n        }\n    }\n    RefPtr<EntryCallback> successCallback;\n    if (args.Length() > 2 && !args[2]->IsNull() && !args[2]->IsUndefined()) {\n        if (!args[2]->IsObject())\n            return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n        successCallback = V8EntryCallback::create(args[2], getScriptExecutionContext());\n    }\n    RefPtr<ErrorCallback> errorCallback;\n    if (args.Length() > 3 && !args[3]->IsNull() && !args[3]->IsUndefined()) {\n        if (!args[3]->IsObject())\n            return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n        errorCallback = V8ErrorCallback::create(args[3], getScriptExecutionContext());\n    }\n    imp->getDirectory(path, flags, successCallback, errorCallback);\n    return v8::Handle<v8::Value>();\n}\n",
        "target": 1
    },
    {
        "id": 2344,
        "func": "static struct ppp *ppp_create_interface(struct net *net, int unit,\n\t\t\t\t\tstruct file *file, int *retp)\n{\n\tstruct ppp *ppp;\n\tstruct ppp_net *pn;\n\tstruct net_device *dev = NULL;\n\tint ret = -ENOMEM;\n\tint i;\n\n\tdev = alloc_netdev(sizeof(struct ppp), \"\", NET_NAME_ENUM, ppp_setup);\n\tif (!dev)\n\t\tgoto out1;\n\n\tpn = ppp_pernet(net);\n\n\tppp = netdev_priv(dev);\n\tppp->dev = dev;\n\tppp->mru = PPP_MRU;\n\tinit_ppp_file(&ppp->file, INTERFACE);\n\tppp->file.hdrlen = PPP_HDRLEN - 2;\t/* don't count proto bytes */\n\tppp->owner = file;\n\tfor (i = 0; i < NUM_NP; ++i)\n\t\tppp->npmode[i] = NPMODE_PASS;\n\tINIT_LIST_HEAD(&ppp->channels);\n\tspin_lock_init(&ppp->rlock);\n\tspin_lock_init(&ppp->wlock);\n#ifdef CONFIG_PPP_MULTILINK\n\tppp->minseq = -1;\n\tskb_queue_head_init(&ppp->mrq);\n#endif /* CONFIG_PPP_MULTILINK */\n#ifdef CONFIG_PPP_FILTER\n\tppp->pass_filter = NULL;\n\tppp->active_filter = NULL;\n#endif /* CONFIG_PPP_FILTER */\n\n\t/*\n\t * drum roll: don't forget to set\n\t * the net device is belong to\n\t */\n\tdev_net_set(dev, net);\n\n\trtnl_lock();\n\tmutex_lock(&pn->all_ppp_mutex);\n\n\tif (unit < 0) {\n\t\tunit = unit_get(&pn->units_idr, ppp);\n\t\tif (unit < 0) {\n\t\t\tret = unit;\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (unit_find(&pn->units_idr, unit))\n\t\t\tgoto out2; /* unit already exists */\n\t\t/*\n\t\t * if caller need a specified unit number\n\t\t * lets try to satisfy him, otherwise --\n\t\t * he should better ask us for new unit number\n\t\t *\n\t\t * NOTE: yes I know that returning EEXIST it's not\n\t\t * fair but at least pppd will ask us to allocate\n\t\t * new unit in this case so user is happy :)\n\t\t */\n\t\tunit = unit_set(&pn->units_idr, ppp, unit);\n\t\tif (unit < 0)\n\t\t\tgoto out2;\n\t}\n\n\t/* Initialize the new ppp unit */\n\tppp->file.index = unit;\n\tsprintf(dev->name, \"ppp%d\", unit);\n\n\tret = register_netdevice(dev);\n\tif (ret != 0) {\n\t\tunit_put(&pn->units_idr, unit);\n\t\tnetdev_err(ppp->dev, \"PPP: couldn't register device %s (%d)\\n\",\n\t\t\t   dev->name, ret);\n\t\tgoto out2;\n\t}\n\n\tppp->ppp_net = net;\n\n\tatomic_inc(&ppp_unit_count);\n\tmutex_unlock(&pn->all_ppp_mutex);\n\trtnl_unlock();\n\n\t*retp = 0;\n\treturn ppp;\n\nout2:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\trtnl_unlock();\n\tfree_netdev(dev);\nout1:\n\t*retp = ret;\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 2345,
        "func": "void DownloadItemImpl::SetTotalBytes(int64 total_bytes) {\n  total_bytes_ = total_bytes;\n}\n",
        "target": 0
    },
    {
        "id": 2346,
        "func": "bool GLES2DecoderImpl::CheckBoundReadFramebufferValid(\n    const char* func_name, GLenum gl_error) {\n  Framebuffer* framebuffer = GetBoundReadFramebuffer();\n  bool valid = CheckFramebufferValid(\n      framebuffer, GetReadFramebufferTarget(), gl_error, func_name);\n  return valid;\n}\n",
        "target": 0
    },
    {
        "id": 2347,
        "func": "int32_t EqualizerGetBand(EffectContext *pContext __unused, uint32_t targetFreq){\n int band = 0;\n\n if(targetFreq < bandFreqRange[0][0]){\n return -EINVAL;\n }else if(targetFreq == bandFreqRange[0][0]){\n return 0;\n }\n for(int i=0; i<FIVEBAND_NUMBANDS;i++){\n if((targetFreq > bandFreqRange[i][0])&&(targetFreq <= bandFreqRange[i][1])){\n            band = i;\n }\n }\n return band;\n}\n",
        "target": 0
    },
    {
        "id": 2348,
        "func": "std::unique_ptr<JSONObject> PaintArtifactCompositor::LayersAsJSON(\n    LayerTreeFlags flags) const {\n  ContentLayerClientImpl::LayerAsJSONContext context(flags);\n  std::unique_ptr<JSONArray> layers_json = JSONArray::Create();\n  for (const auto& client : content_layer_clients_) {\n    layers_json->PushObject(client->LayerAsJSON(context));\n  }\n  std::unique_ptr<JSONObject> json = JSONObject::Create();\n  json->SetArray(\"layers\", std::move(layers_json));\n  if (context.transforms_json)\n    json->SetArray(\"transforms\", std::move(context.transforms_json));\n  return json;\n}\n",
        "target": 0
    },
    {
        "id": 2349,
        "func": "void ChromotingInstance::HandlePauseVideo(const base::DictionaryValue& data) {\n  if (!data.HasKey(\"pause\")) {\n    LOG(ERROR) << \"Invalid pauseVideo.\";\n    return;\n  }\n  HandleVideoControl(data);\n}\n",
        "target": 0
    },
    {
        "id": 2350,
        "func": "void InputEngine::ProcessText(const std::string& message,\n                              ProcessTextCallback callback) {\n  NOTIMPLEMENTED();  // Text message not used in the rulebased engine.\n}\n",
        "target": 1
    },
    {
        "id": 2351,
        "func": "void ass_pre_blur3_vert_c(int16_t *dst, const int16_t *src,\n                          uintptr_t src_width, uintptr_t src_height)\n{\n    uintptr_t dst_height = src_height + 6;\n    uintptr_t step = STRIPE_WIDTH * src_height;\n\n    for (uintptr_t x = 0; x < src_width; x += STRIPE_WIDTH) {\n        uintptr_t offs = 0;\n        for (uintptr_t y = 0; y < dst_height; ++y) {\n            const int16_t *p3 = get_line(src, offs - 6 * STRIPE_WIDTH, step);\n            const int16_t *p2 = get_line(src, offs - 5 * STRIPE_WIDTH, step);\n            const int16_t *p1 = get_line(src, offs - 4 * STRIPE_WIDTH, step);\n            const int16_t *z0 = get_line(src, offs - 3 * STRIPE_WIDTH, step);\n            const int16_t *n1 = get_line(src, offs - 2 * STRIPE_WIDTH, step);\n            const int16_t *n2 = get_line(src, offs - 1 * STRIPE_WIDTH, step);\n            const int16_t *n3 = get_line(src, offs - 0 * STRIPE_WIDTH, step);\n            for (int k = 0; k < STRIPE_WIDTH; ++k)\n                dst[k] = pre_blur3_func(p3[k], p2[k], p1[k], z0[k], n1[k], n2[k], n3[k]);\n            dst += STRIPE_WIDTH;\n            offs += STRIPE_WIDTH;\n        }\n        src += step;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2352,
        "func": "void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle& newStyle)\n{\n    RenderStyle* oldStyle = style();\n \n     setReplaced(newStyle.isDisplayInlineType());\n \n    if (oldStyle && parent() && diff.needsFullLayout() && oldStyle->position() != newStyle.position()) {\n         if (newStyle.position() == StaticPosition)\n            removePositionedObjects(0, NewContainingBlock);\n        else if (oldStyle->position() == StaticPosition) {\n            RenderObject* cb = parent();\n            while (cb && (cb->style()->position() == StaticPosition || (cb->isInline() && !cb->isReplaced())) && !cb->isRenderView()) {\n                if (cb->style()->position() == RelativePosition && cb->isInline() && !cb->isReplaced()) {\n                    cb = cb->containingBlock();\n                    break;\n                }\n                cb = cb->parent();\n            }\n\n            if (cb->isRenderBlock())\n                toRenderBlock(cb)->removePositionedObjects(this, NewContainingBlock);\n        }\n    }\n\n    RenderBox::styleWillChange(diff, newStyle);\n}\n",
        "target": 0
    },
    {
        "id": 2353,
        "func": "static zend_object_value spl_filesystem_object_clone(zval *zobject TSRMLS_DC)\n{\n\tzend_object_value new_obj_val;\n\tzend_object *old_object;\n\tzend_object *new_object;\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tspl_filesystem_object *intern;\n\tspl_filesystem_object *source;\n\tint index, skip_dots;\n\n\told_object = zend_objects_get_address(zobject TSRMLS_CC);\n\tsource = (spl_filesystem_object*)old_object;\n\n\tnew_obj_val = spl_filesystem_object_new_ex(old_object->ce, &intern TSRMLS_CC);\n\tnew_object = &intern->std;\n\n\tintern->flags = source->flags;\n\n\tswitch (source->type) {\n\tcase SPL_FS_INFO:\n\t\tintern->_path_len = source->_path_len;\n\t\tintern->_path = estrndup(source->_path, source->_path_len);\n\t\tintern->file_name_len = source->file_name_len;\n\t\tintern->file_name = estrndup(source->file_name, intern->file_name_len);\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tspl_filesystem_dir_open(intern, source->_path TSRMLS_CC);\n\t\t/* read until we hit the position in which we were before */\n\t\tskip_dots = SPL_HAS_FLAG(source->flags, SPL_FILE_DIR_SKIPDOTS);\n\t\tfor(index = 0; index < source->u.dir.index; ++index) {\n\t\t\tdo {\n\t\t\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t\t\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\t\t}\n\t\tintern->u.dir.index = index;\n\t\tbreak;\n\tcase SPL_FS_FILE:\n \t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n \t\tbreak;\n \t}\n \tintern->file_class = source->file_class;\n \tintern->info_class = source->info_class;\n \tintern->oth = source->oth;\n\tintern->oth_handler = source->oth_handler;\n\n\tzend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC);\n\n\tif (intern->oth_handler && intern->oth_handler->clone) {\n\t\tintern->oth_handler->clone(source, intern TSRMLS_CC);\n\t}\n\n\treturn new_obj_val;\n}\n",
        "target": 1
    },
    {
        "id": 2354,
        "func": "void * calloc(size_t n, size_t lb)\n{\n    if (lb && n > SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n        /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}",
        "target": 1
    },
    {
        "id": 2355,
        "func": "static void emitstring(JF, int opcode, const char *str)\n{\n\temit(J, F, opcode);\n\temitarg(J, F, addstring(J, F, str));\n}",
        "target": 0
    },
    {
        "id": 2356,
        "func": "static void loadDone(WebKitWebFrame* frame, bool didSucceed)\n{\n    g_signal_emit_by_name(frame, \"load-done\", didSucceed);\n    notifyStatus(frame, WEBKIT_LOAD_FINISHED);\n}\n",
        "target": 0
    },
    {
        "id": 2357,
        "func": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( end - *p < 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}",
        "target": 0
    },
    {
        "id": 2358,
        "func": "bool MatchFilter::MatchesBoolean(const wchar_t* key, bool value) {\n  if (!details_->HasKey(key))\n    return true;\n  bool filter_value = false;\n  return (details_->GetBoolean(key, &filter_value) &&\n          value == filter_value);\n}\n",
        "target": 0
    },
    {
        "id": 2359,
        "func": "static int hmac_setkey(struct crypto_shash *parent,\n\t\t       const u8 *inkey, unsigned int keylen)\n{\n\tint bs = crypto_shash_blocksize(parent);\n\tint ds = crypto_shash_digestsize(parent);\n\tint ss = crypto_shash_statesize(parent);\n\tchar *ipad = crypto_shash_ctx_aligned(parent);\n\tchar *opad = ipad + ss;\n\tstruct hmac_ctx *ctx = align_ptr(opad + ss,\n\t\t\t\t\t crypto_tfm_ctx_alignment());\n\tstruct crypto_shash *hash = ctx->hash;\n\tSHASH_DESC_ON_STACK(shash, hash);\n\tunsigned int i;\n\n\tshash->tfm = hash;\n\tshash->flags = crypto_shash_get_flags(parent)\n\t\t& CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\tif (keylen > bs) {\n\t\tint err;\n\n\t\terr = crypto_shash_digest(shash, inkey, keylen, ipad);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tkeylen = ds;\n\t} else\n\t\tmemcpy(ipad, inkey, keylen);\n\n\tmemset(ipad + keylen, 0, bs - keylen);\n\tmemcpy(opad, ipad, bs);\n\n\tfor (i = 0; i < bs; i++) {\n\t\tipad[i] ^= HMAC_IPAD_VALUE;\n\t\topad[i] ^= HMAC_OPAD_VALUE;\n\t}\n\n\treturn crypto_shash_init(shash) ?:\n\t       crypto_shash_update(shash, ipad, bs) ?:\n\t       crypto_shash_export(shash, ipad) ?:\n\t       crypto_shash_init(shash) ?:\n\t       crypto_shash_update(shash, opad, bs) ?:\n\t       crypto_shash_export(shash, opad);\n}",
        "target": 0
    },
    {
        "id": 2360,
        "func": "void esp_request_cancelled(SCSIRequest *req)\n{\n    ESPState *s = req->hba_private;\n\n    if (req == s->current_req) {\n        scsi_req_unref(s->current_req);\n        s->current_req = NULL;\n        s->current_dev = NULL;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2361,
        "func": "static int inet_validate_link_af(const struct net_device *dev,\n\t\t\t\t const struct nlattr *nla)\n{\n\tstruct nlattr *a, *tb[IFLA_INET_MAX+1];\n\tint err, rem;\n\n\tif (dev && !__in_dev_get_rtnl(dev))\n\t\treturn -EAFNOSUPPORT;\n\n\terr = nla_parse_nested(tb, IFLA_INET_MAX, nla, inet_af_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_INET_CONF]) {\n\t\tnla_for_each_nested(a, tb[IFLA_INET_CONF], rem) {\n\t\t\tint cfgid = nla_type(a);\n\n\t\t\tif (nla_len(a) < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (cfgid <= 0 || cfgid > IPV4_DEVCONF_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2362,
        "func": "void gdImageRectangle (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2;\n\tint thick = im->thick;\n\tint t;\n\n\tif (x1 == x2 && y1 == y2 && thick == 1) {\n\t\tgdImageSetPixel(im, x1, y1, color);\n\t\treturn;\n\t}\n\n\tif (y2 < y1) {\n\t\tt=y1;\n\t\ty1 = y2;\n\t\ty2 = t;\n\t}\n\t\n\tif (x2 < x1) {\n\t\tt = x1;\n\t\tx1 = x2;\n\t\tx2 = t;\n\t}\n\n\tx1h = x1; x1v = x1; y1h = y1; y1v = y1; x2h = x2; x2v = x2; y2h = y2; y2v = y2;\n\tif (thick > 1) {\n\t\tint cx, cy, x1ul, y1ul, x2lr, y2lr;\n\t\tint half = thick >> 1;\n\n\t\tx1ul = x1 - half;\n\t\ty1ul = y1 - half;\n\n\t\tx2lr = x2 + half;\n\t\ty2lr = y2 + half;\n\n\t\tcy = y1ul + thick;\n\t\twhile (cy-- > y1ul) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y2lr - thick;\n\t\twhile (cy++ < y2lr) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x1ul - 1;\n\t\t\twhile (cx++ < x1ul + thick) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\tcy = y1ul + thick - 1;\n\t\twhile (cy++ < y2lr -thick) {\n\t\t\tcx = x2lr - thick - 1;\n\t\t\twhile (cx++ < x2lr) {\n\t\t\t\tgdImageSetPixel(im, cx, cy, color);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t} else {\n\t\tif (x1 == x2 || y1 == y2) {\n\t\t\tgdImageLine(im, x1, y1, x2, y2, color);\n\t\t} else {\n\t\t\ty1v = y1h + 1;\n\t\t\ty2v = y2h - 1;\n\t\t\tgdImageLine(im, x1h, y1h, x2h, y1h, color);\n\t\t\tgdImageLine(im, x1h, y2h, x2h, y2h, color);\n\t\t\tgdImageLine(im, x1v, y1v, x1v, y2v, color);\n\t\t\tgdImageLine(im, x2v, y1v, x2v, y2v, color);\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 2363,
        "func": "  const Extension* GetExtension() {\n    extensions::ExtensionRegistry* registry =\n        extensions::ExtensionRegistry::Get(browser()->profile());\n    for (const scoped_refptr<const extensions::Extension>& extension :\n         registry->enabled_extensions()) {\n      if (extension->name() == \"App Test\")\n        return extension.get();\n    }\n    NOTREACHED();\n    return NULL;\n  }\n",
        "target": 0
    },
    {
        "id": 2364,
        "func": "void xt_free_table_info(struct xt_table_info *info)\n{\n\tint cpu;\n\n\tif (info->jumpstack != NULL) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tkvfree(info->jumpstack[cpu]);\n\t\tkvfree(info->jumpstack);\n\t}\n\n\tkvfree(info);\n}",
        "target": 0
    },
    {
        "id": 2365,
        "func": "static noinline int mmc_ioctl_cdrom_volume(struct cdrom_device_info *cdi,\n\t\t\t\t\t   void __user *arg,\n\t\t\t\t\t   struct packet_command *cgc,\n\t\t\t\t\t   unsigned int cmd)\n{\n\tstruct cdrom_volctrl volctrl;\n\tunsigned char buffer[32];\n\tchar mask[sizeof(buffer)];\n\tunsigned short offset;\n\tint ret;\n\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMVOLUME\\n\");\n\n\tif (copy_from_user(&volctrl, (struct cdrom_volctrl __user *)arg,\n\t\t\t   sizeof(volctrl)))\n\t\treturn -EFAULT;\n\n\tcgc->buffer = buffer;\n\tcgc->buflen = 24;\n\tret = cdrom_mode_sense(cdi, cgc, GPMODE_AUDIO_CTL_PAGE, 0);\n\tif (ret)\n\t\treturn ret;\n\t\t\n\t/* originally the code depended on buffer[1] to determine\n\t   how much data is available for transfer. buffer[1] is\n\t   unfortunately ambigious and the only reliable way seem\n\t   to be to simply skip over the block descriptor... */\n\toffset = 8 + be16_to_cpu(*(__be16 *)(buffer + 6));\n\n\tif (offset + 16 > sizeof(buffer))\n\t\treturn -E2BIG;\n\n\tif (offset + 16 > cgc->buflen) {\n\t\tcgc->buflen = offset + 16;\n\t\tret = cdrom_mode_sense(cdi, cgc,\n\t\t\t\t       GPMODE_AUDIO_CTL_PAGE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* sanity check */\n\tif ((buffer[offset] & 0x3f) != GPMODE_AUDIO_CTL_PAGE ||\n\t    buffer[offset + 1] < 14)\n\t\treturn -EINVAL;\n\n\t/* now we have the current volume settings. if it was only\n\t   a CDROMVOLREAD, return these values */\n\tif (cmd == CDROMVOLREAD) {\n\t\tvolctrl.channel0 = buffer[offset+9];\n\t\tvolctrl.channel1 = buffer[offset+11];\n\t\tvolctrl.channel2 = buffer[offset+13];\n\t\tvolctrl.channel3 = buffer[offset+15];\n\t\tif (copy_to_user((struct cdrom_volctrl __user *)arg, &volctrl,\n\t\t\t\t sizeof(volctrl)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\t\t\n\t/* get the volume mask */\n\tcgc->buffer = mask;\n\tret = cdrom_mode_sense(cdi, cgc, GPMODE_AUDIO_CTL_PAGE, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tbuffer[offset + 9]  = volctrl.channel0 & mask[offset + 9];\n\tbuffer[offset + 11] = volctrl.channel1 & mask[offset + 11];\n\tbuffer[offset + 13] = volctrl.channel2 & mask[offset + 13];\n\tbuffer[offset + 15] = volctrl.channel3 & mask[offset + 15];\n\n\t/* set volume */\n\tcgc->buffer = buffer + offset - 8;\n\tmemset(cgc->buffer, 0, 8);\n\treturn cdrom_mode_select(cdi, cgc);\n}",
        "target": 0
    },
    {
        "id": 2366,
        "func": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\treturn -EIO;\n\t}\n\treturn brightness;\n}",
        "target": 1
    },
    {
        "id": 2367,
        "func": "  void VerifyPrintPreviewFailed(bool did_fail) {\n    bool print_preview_failed =\n        (render_thread_->sink().GetUniqueMessageMatching(\n            PrintHostMsg_PrintPreviewFailed::ID) != NULL);\n    EXPECT_EQ(did_fail, print_preview_failed);\n  }\n",
        "target": 0
    },
    {
        "id": 2368,
        "func": " void BrowserActionsContainer::Observe(NotificationType type,\n                                       const NotificationSource& source,\n                                       const NotificationDetails& details) {\n   switch (type.value) {\n     case NotificationType::EXTENSION_HOST_VIEW_SHOULD_CLOSE:\n       if (!popup_ || Details<ExtensionHost>(popup_->host()) != details)\n        return;\n\n      HidePopup();\n      break;\n\n    default:\n      NOTREACHED() << \"Unexpected notification\";\n  }\n}\n",
        "target": 1
    },
    {
        "id": 2369,
        "func": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tint i;\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i++) {\n\t\tif (!hlist_empty(&xfrm6_tunnel_spi_byaddr[i]))\n\t\t\treturn;\n\t}\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i++) {\n\t\tif (!hlist_empty(&xfrm6_tunnel_spi_byspi[i]))\n\t\t\treturn;\n\t}\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n\txfrm6_tunnel_spi_kmem = NULL;\n}",
        "target": 0
    },
    {
        "id": 2370,
        "func": "ipt_get_target_c(const struct ipt_entry *e)\n{\n\treturn ipt_get_target((struct ipt_entry *)e);\n}",
        "target": 0
    },
    {
        "id": 2371,
        "func": "struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,\n\t\tuint32_t id, uint32_t type)\n{\n\tstruct drm_mode_object *obj = NULL;\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tobj = idr_find(&dev->mode_config.crtc_idr, id);\n\tif (!obj || (obj->type != type) || (obj->id != id))\n\t\tobj = NULL;\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\n\treturn obj;\n}",
        "target": 0
    },
    {
        "id": 2372,
        "func": "void GpuProcessHost::OnChannelEstablished(\n    const IPC::ChannelHandle& channel_handle) {\n  TRACE_EVENT0(\"gpu\", \"GpuProcessHostUIShim::OnChannelEstablished\");\n\n  EstablishChannelCallback callback = channel_requests_.front();\n  channel_requests_.pop();\n\n  if (!channel_handle.name.empty() &&\n      !GpuDataManagerImpl::GetInstance()->GpuAccessAllowed()) {\n    Send(new GpuMsg_CloseChannel(channel_handle));\n    EstablishChannelError(callback,\n                          IPC::ChannelHandle(),\n                          base::kNullProcessHandle,\n                          content::GPUInfo());\n    RouteOnUIThread(GpuHostMsg_OnLogMessage(\n        logging::LOG_WARNING,\n        \"WARNING\",\n        \"Hardware acceleration is unavailable.\"));\n    return;\n  }\n\n  callback.Run(channel_handle,\n               GpuDataManagerImpl::GetInstance()->GetGPUInfo());\n}\n",
        "target": 0
    },
    {
        "id": 2373,
        "func": "  Ins_SMD( INS_ARG )\n  {\n    DO_SMD\n  }\n",
        "target": 0
    },
    {
        "id": 2374,
        "func": "\nvoid nl80211_send_unprot_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *buf,\n\t\t\t\tsize_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_UNPROT_DEAUTHENTICATE, gfp);",
        "target": 0
    },
    {
        "id": 2375,
        "func": "ffs_sb_make_inode(struct super_block *sb, void *data,\n\t\t  const struct file_operations *fops,\n\t\t  const struct inode_operations *iops,\n\t\t  struct ffs_file_perms *perms)\n{\n\tstruct inode *inode;\n\n\tENTER();\n\n\tinode = new_inode(sb);\n\n\tif (likely(inode)) {\n\t\tstruct timespec current_time = CURRENT_TIME;\n\n\t\tinode->i_ino\t = get_next_ino();\n\t\tinode->i_mode    = perms->mode;\n\t\tinode->i_uid     = perms->uid;\n\t\tinode->i_gid     = perms->gid;\n\t\tinode->i_atime   = current_time;\n\t\tinode->i_mtime   = current_time;\n\t\tinode->i_ctime   = current_time;\n\t\tinode->i_private = data;\n\t\tif (fops)\n\t\t\tinode->i_fop = fops;\n\t\tif (iops)\n\t\t\tinode->i_op  = iops;\n\t}\n\n\treturn inode;\n}",
        "target": 0
    },
    {
        "id": 2376,
        "func": "bool WebContentsImpl::GotResponseToLockMouseRequest(bool allowed) {\n  if (!GuestMode::IsCrossProcessFrameGuest(GetWebContents()) &&\n      GetBrowserPluginGuest())\n    return GetBrowserPluginGuest()->LockMouse(allowed);\n\n  if (mouse_lock_widget_) {\n    if (mouse_lock_widget_->delegate()->GetAsWebContents() != this) {\n      return mouse_lock_widget_->delegate()\n          ->GetAsWebContents()\n          ->GotResponseToLockMouseRequest(allowed);\n    }\n\n    if (mouse_lock_widget_->GotResponseToLockMouseRequest(allowed))\n      return true;\n  }\n\n  for (WebContentsImpl* current = this; current;\n       current = current->GetOuterWebContents()) {\n    current->mouse_lock_widget_ = nullptr;\n  }\n\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 2377,
        "func": "static int vmci_transport_send_negotiate2(struct sock *sk, size_t size,\n\t\t\t\t\t  u16 version)\n{\n\treturn vmci_transport_send_control_pkt(\n\t\t\t\t\tsk,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2,\n\t\t\t\t\tsize, 0, NULL, version,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}",
        "target": 0
    },
    {
        "id": 2378,
        "func": "MPEG4Extractor::Track *MPEG4Extractor::findTrackByMimePrefix(\n const char *mimePrefix) {\n for (Track *track = mFirstTrack; track != NULL; track = track->next) {\n const char *mime;\n if (track->meta != NULL\n && track->meta->findCString(kKeyMIMEType, &mime)\n && !strncasecmp(mime, mimePrefix, strlen(mimePrefix))) {\n return track;\n }\n }\n\n return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 2379,
        "func": "static inline int iswhite(int ch)\n{\n\treturn\n\t\tch == '\\000' || ch == '\\011' || ch == '\\012' ||\n\t\tch == '\\014' || ch == '\\015' || ch == '\\040';\n}\n",
        "target": 0
    },
    {
        "id": 2380,
        "func": "static int asf_build_simple_index(AVFormatContext *s, int stream_index)\n{\n    ff_asf_guid g;\n    ASFContext *asf     = s->priv_data;\n    int64_t current_pos = avio_tell(s->pb);\n    int64_t ret;\n\n    if((ret = avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET)) < 0) {\n        return ret;\n    }\n\n    if ((ret = ff_get_guid(s->pb, &g)) < 0)\n        goto end;\n\n    /* the data object can be followed by other top-level objects,\n     * skip them until the simple index object is reached */\n    while (ff_guidcmp(&g, &ff_asf_simple_index_header)) {\n        int64_t gsize = avio_rl64(s->pb);\n        if (gsize < 24 || avio_feof(s->pb)) {\n            goto end;\n        }\n        avio_skip(s->pb, gsize - 24);\n        if ((ret = ff_get_guid(s->pb, &g)) < 0)\n            goto end;\n    }\n\n    {\n        int64_t itime, last_pos = -1;\n        int pct, ict;\n        int i;\n        int64_t av_unused gsize = avio_rl64(s->pb);\n        if ((ret = ff_get_guid(s->pb, &g)) < 0)\n            goto end;\n        itime = avio_rl64(s->pb);\n        pct   = avio_rl32(s->pb);\n        ict   = avio_rl32(s->pb);\n        av_log(s, AV_LOG_DEBUG,\n               \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);\n\n        for (i = 0; i < ict; i++) {\n            int pktnum        = avio_rl32(s->pb);\n            int pktct         = avio_rl16(s->pb);\n            int64_t pos       = s->internal->data_offset + s->packet_size * (int64_t)pktnum;\n            int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);\n\n            if (pos != last_pos) {\n                av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",\n                       pktnum, pktct, index_pts);\n                av_add_index_entry(s->streams[stream_index], pos, index_pts,\n                                   s->packet_size, 0, AVINDEX_KEYFRAME);\n                last_pos = pos;\n            }\n        }\n        asf->index_read = ict > 1;\n    }\nend:\n//     if (avio_feof(s->pb)) {\n//         ret = 0;\n//     }\n    avio_seek(s->pb, current_pos, SEEK_SET);\n    return ret;\n}",
        "target": 1
    },
    {
        "id": 2381,
        "func": " OTRBrowserContextImpl::OTRBrowserContextImpl(\n     BrowserContextImpl* original,\n     BrowserContextIODataImpl* original_io_data)\n     : BrowserContext(new OTRBrowserContextIODataImpl(original_io_data)),\n      original_context_(original),\n      weak_ptr_factory_(this) {\n   BrowserContextDependencyManager::GetInstance()\n       ->CreateBrowserContextServices(this);\n }\n",
        "target": 1
    },
    {
        "id": 2382,
        "func": " bool ChildProcessSecurityPolicyImpl::CanCommitURL(int child_id,\n                                                  const GURL& url) {\n   if (!url.is_valid())\n     return false;  // Can't commit invalid URLs.\n \n  const std::string& scheme = url.scheme();\n\n  if (IsPseudoScheme(scheme))\n    return url == url::kAboutBlankURL || url == kAboutSrcDocURL;\n\n  if (url.SchemeIsBlob() || url.SchemeIsFileSystem()) {\n    if (IsMalformedBlobUrl(url))\n       return false;\n \n     url::Origin origin = url::Origin::Create(url);\n    return origin.unique() || CanCommitURL(child_id, GURL(origin.Serialize()));\n   }\n \n   {\n     base::AutoLock lock(lock_);\n \n     if (base::ContainsKey(schemes_okay_to_commit_in_any_process_, scheme))\n       return true;\n\n    SecurityStateMap::iterator state = security_state_.find(child_id);\n    if (state == security_state_.end())\n      return false;\n\n    return state->second->CanCommitURL(url);\n   }\n }\n",
        "target": 1
    },
    {
        "id": 2383,
        "func": "static HashTable* spl_object_storage_debug_info(zval *obj, int *is_temp) /* {{{ */\n{\n\tspl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(obj);\n\tspl_SplObjectStorageElement *element;\n\tHashTable *props;\n\tzval tmp, storage;\n\tzend_string *md5str;\n\tzend_string *zname;\n\tHashTable *debug_info;\n\n\t*is_temp = 1;\n\n\tprops = Z_OBJPROP_P(obj);\n\n\tALLOC_HASHTABLE(debug_info);\n\tZEND_INIT_SYMTABLE_EX(debug_info, zend_hash_num_elements(props) + 1, 0);\n\tzend_hash_copy(debug_info, props, (copy_ctor_func_t)zval_add_ref);\n\n\tarray_init(&storage);\n\n\tZEND_HASH_FOREACH_PTR(&intern->storage, element) {\n\t\tmd5str = php_spl_object_hash(&element->obj);\n\t\tarray_init(&tmp);\n\t\t/* Incrementing the refcount of obj and inf would confuse the garbage collector.\n\t\t * Prefer to null the destructor */\n\t\tZ_ARRVAL_P(&tmp)->pDestructor = NULL;\n\t\tadd_assoc_zval_ex(&tmp, \"obj\", sizeof(\"obj\") - 1, &element->obj);\n\t\tadd_assoc_zval_ex(&tmp, \"inf\", sizeof(\"inf\") - 1, &element->inf);\n\t\tzend_hash_update(Z_ARRVAL(storage), md5str, &tmp);\n\t\tzend_string_release(md5str);\n\t} ZEND_HASH_FOREACH_END();\n\n\tzname = spl_gen_private_prop_name(spl_ce_SplObjectStorage, \"storage\", sizeof(\"storage\")-1);\n\tzend_symtable_update(debug_info, zname, &storage);\n\tzend_string_release(zname);\n\n\treturn debug_info;\n}",
        "target": 0
    },
    {
        "id": 2384,
        "func": "void GLES2Implementation::ScheduleCALayerCHROMIUM(GLuint contents_texture_id,\n                                                  const GLfloat* contents_rect,\n                                                  GLuint background_color,\n                                                  GLuint edge_aa_mask,\n                                                  const GLfloat* bounds_rect,\n                                                  GLuint filter) {\n  uint32_t shm_size = 8 * sizeof(GLfloat);\n  ScopedTransferBufferPtr buffer(shm_size, helper_, transfer_buffer_);\n  if (!buffer.valid() || buffer.size() < shm_size) {\n    SetGLError(GL_OUT_OF_MEMORY, \"GLES2::ScheduleCALayerCHROMIUM\",\n               \"out of memory\");\n    return;\n  }\n  GLfloat* mem = static_cast<GLfloat*>(buffer.address());\n  memcpy(mem + 0, contents_rect, 4 * sizeof(GLfloat));\n  memcpy(mem + 4, bounds_rect, 4 * sizeof(GLfloat));\n  helper_->ScheduleCALayerCHROMIUM(contents_texture_id, background_color,\n                                   edge_aa_mask, filter, buffer.shm_id(),\n                                   buffer.offset());\n}\n",
        "target": 0
    },
    {
        "id": 2385,
        "func": "  FT_Stream_ReadLong( FT_Stream  stream,\n                      FT_Error*  error )\n  {\n    FT_Byte   reads[4];\n    FT_Byte*  p = 0;\n    FT_Long   result = 0;\n\n\n    FT_ASSERT( stream );\n\n    *error = FT_Err_Ok;\n\n    if ( stream->pos + 3 < stream->size )\n    {\n      if ( stream->read )\n      {\n        if ( stream->read( stream, stream->pos, reads, 4L ) != 4L )\n          goto Fail;\n\n        p = reads;\n      }\n      else\n      {\n        p = stream->base + stream->pos;\n      }\n\n      if ( p )\n        result = FT_NEXT_LONG( p );\n    }\n    else\n      goto Fail;\n\n    stream->pos += 4;\n\n    return result;\n\n  Fail:\n    *error = FT_Err_Invalid_Stream_Operation;\n    FT_ERROR(( \"FT_Stream_ReadLong:\"\n               \" invalid i/o; pos = 0x%lx, size = 0x%lx\\n\",\n               stream->pos, stream->size ));\n\n    return 0;\n  }\n",
        "target": 0
    },
    {
        "id": 2386,
        "func": "void GLES2DecoderTestBase::TearDown() {\n  EXPECT_EQ(GL_NO_ERROR, GetGLError());\n  EXPECT_CALL(*gl_, DeleteTextures(1, _))\n      .Times(2)\n      .RetiresOnSaturation();\n  EXPECT_CALL(*gl_, DeleteBuffersARB(1, _))\n      .Times(1)\n      .RetiresOnSaturation();\n  decoder_->Destroy();\n  decoder_.reset();\n  group_.Destroy(false);\n  engine_.reset();\n  ::gfx::GLInterface::SetGLInterface(NULL);\n  gl_.reset();\n}\n",
        "target": 0
    },
    {
        "id": 2387,
        "func": "bool UserCloudPolicyManagerFactoryChromeOS::HasTestingFactory(\n    content::BrowserContext* context) {\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 2388,
        "func": "  virtual ~MockCanceledBeforeSentPluginProcessHostClient() {}\n",
        "target": 0
    },
    {
        "id": 2389,
        "func": "static void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clverifier_counter++;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}\n",
        "target": 0
    },
    {
        "id": 2390,
        "func": "void InspectorAccessibilityAgent::addAncestors(\n    AXObject& firstAncestor,\n    AXObject* inspectedAXObject,\n    std::unique_ptr<protocol::Array<AXNode>>& nodes,\n    AXObjectCacheImpl& cache) const {\n  AXObject* ancestor = &firstAncestor;\n  while (ancestor) {\n    nodes->addItem(buildProtocolAXObject(*ancestor, inspectedAXObject, true,\n                                         nodes, cache));\n    ancestor = ancestor->parentObjectUnignored();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2391,
        "func": "static void *saved_tgids_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tint *ptr = v;\n\n\tif (*pos || m->count)\n\t\tptr++;\n\n\t(*pos)++;\n\n\tfor (; ptr <= &tgid_map[PID_MAX_DEFAULT]; ptr++) {\n\t\tif (trace_find_tgid(*ptr))\n\t\t\treturn ptr;\n\t}\n\n\treturn NULL;\n}\n",
        "target": 0
    },
    {
        "id": 2392,
        "func": "  void ProcessRequest() {\n    DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n    timer.Stop();  // Erase reference to self.\n\n    WallpaperManager* manager = WallpaperManager::Get();\n    if (manager->pending_inactive_ == this)\n      manager->pending_inactive_ = NULL;\n\n     started_load_at_ = base::Time::Now();\n \n     if (default_) {\n      manager->DoSetDefaultWallpaper(account_id_, std::move(on_finish_));\n     } else if (!user_wallpaper_.isNull()) {\n       SetWallpaper(user_wallpaper_, info_);\n     } else if (!wallpaper_path_.empty()) {\n      manager->task_runner_->PostTask(\n          FROM_HERE,\n          base::BindOnce(&WallpaperManager::GetCustomWallpaperInternal,\n                         account_id_, info_, wallpaper_path_,\n                         true /* update wallpaper */,\n                         base::ThreadTaskRunnerHandle::Get(),\n                          base::Passed(std::move(on_finish_)),\n                          manager->weak_factory_.GetWeakPtr()));\n     } else if (!info_.location.empty()) {\n      manager->LoadWallpaper(account_id_, info_, true, std::move(on_finish_));\n     } else {\n       NOTREACHED();\n      started_load_at_ = base::Time();\n    }\n    on_finish_.reset();\n  }\n",
        "target": 1
    },
    {
        "id": 2393,
        "func": "qedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}",
        "target": 1
    },
    {
        "id": 2394,
        "func": "FakeDownloadItem* DownloadPathReservationTrackerTest::CreateDownloadItem(\n    int32 id) {\n  FakeDownloadItem* item = new ::testing::StrictMock<FakeDownloadItem>;\n  DownloadId download_id(reinterpret_cast<void*>(this), id);\n  EXPECT_CALL(*item, GetGlobalId())\n      .WillRepeatedly(Return(download_id));\n  EXPECT_CALL(*item, GetTargetFilePath())\n      .WillRepeatedly(ReturnRefOfCopy(base::FilePath()));\n  return item;\n}\n",
        "target": 0
    },
    {
        "id": 2395,
        "func": "bool PrintRenderFrameHelper::FinalizePrintReadyDocument() {\n  DCHECK(!is_print_ready_metafile_sent_);\n  print_preview_context_.FinalizePrintReadyDocument();\n\n  PdfMetafileSkia* metafile = print_preview_context_.metafile();\n  PrintHostMsg_DidPreviewDocument_Params preview_params;\n\n  if (!CopyMetafileDataToSharedMem(*metafile,\n                                   &preview_params.metafile_data_handle)) {\n    LOG(ERROR) << \"CopyMetafileDataToSharedMem failed\";\n    print_preview_context_.set_error(PREVIEW_ERROR_METAFILE_COPY_FAILED);\n    return false;\n  }\n\n  preview_params.data_size = metafile->GetDataSize();\n  preview_params.document_cookie = print_pages_params_->params.document_cookie;\n  preview_params.expected_pages_count =\n      print_preview_context_.total_page_count();\n  preview_params.modifiable = print_preview_context_.IsModifiable();\n  preview_params.preview_request_id =\n      print_pages_params_->params.preview_request_id;\n\n  is_print_ready_metafile_sent_ = true;\n\n  Send(new PrintHostMsg_MetafileReadyForPrinting(routing_id(), preview_params));\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2396,
        "func": "do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n            const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t       &dec_tables);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t     &dec_tables);\n#else\n  return do_decrypt_fn (ctx, bx, ax);\n#endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/\n}",
        "target": 1
    },
    {
        "id": 2397,
        "func": "static void enforcedRangeLongLongAttrAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    v8SetReturnValue(info, static_cast<double>(imp->enforcedRangeLongLongAttr()));\n}\n",
        "target": 0
    },
    {
        "id": 2398,
        "func": "static int sctp_setsockopt_recvnxtinfo(struct sock *sk,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       unsigned int optlen)\n{\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *) optval))\n\t\treturn -EFAULT;\n\n\tsctp_sk(sk)->recvnxtinfo = (val == 0) ? 0 : 1;\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2399,
        "func": "begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_xobject *softmask = gstate->softmask;\n\tfz_rect mask_bbox;\n\tfz_matrix tos_save[2], save_ctm;\n\tfz_matrix mask_matrix;\n\tfz_colorspace *mask_colorspace;\n\n\tsave->softmask = softmask;\n\tif (softmask == NULL)\n\t\treturn gstate;\n\tsave->page_resources = gstate->softmask_resources;\n\tsave->ctm = gstate->softmask_ctm;\n\tsave_ctm = gstate->ctm;\n\n\tpdf_xobject_bbox(ctx, softmask, &mask_bbox);\n\tpdf_xobject_matrix(ctx, softmask, &mask_matrix);\n\n\tpdf_tos_save(ctx, &pr->tos, tos_save);\n\n\tif (gstate->luminosity)\n\t\tmask_bbox = fz_infinite_rect;\n\telse\n\t{\n\t\tfz_transform_rect(&mask_bbox, &mask_matrix);\n\t\tfz_transform_rect(&mask_bbox, &gstate->softmask_ctm);\n\t}\n\tgstate->softmask = NULL;\n\tgstate->softmask_resources = NULL;\n\tgstate->ctm = gstate->softmask_ctm;\n\n\tmask_colorspace = pdf_xobject_colorspace(ctx, softmask);\n\n\tif (gstate->luminosity && !mask_colorspace)\n\t\tmask_colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));\n\n\tfz_try(ctx)\n\t{\n\t\tfz_begin_mask(ctx, pr->dev, &mask_bbox, gstate->luminosity, mask_colorspace, gstate->softmask_bc, &gstate->fill.color_params);\n\t\tpdf_run_xobject(ctx, pr, softmask, save->page_resources, &fz_identity, 1);\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_colorspace(ctx, mask_colorspace);\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t/* FIXME: Ignore error - nasty, but if we throw from\n\t\t * here the clip stack would be messed up. */\n\t\t/* TODO: pass cookie here to increase the cookie error count */\n\t}\n\n\tfz_end_mask(ctx, pr->dev);\n\n\tpdf_tos_restore(ctx, &pr->tos, tos_save);\n\n\tgstate = pr->gstate + pr->gtop;\n\tgstate->ctm = save_ctm;\n\n\treturn gstate;\n}\n",
        "target": 0
    },
    {
        "id": 2400,
        "func": "void ASessionDescription::getFormatType(\n size_t index, unsigned long *PT,\n AString *desc, AString *params) const {\n AString format;\n    getFormat(index, &format);\n\n const char *lastSpacePos = strrchr(format.c_str(), ' ');\n    CHECK(lastSpacePos != NULL);\n\n char *end;\n unsigned long x = strtoul(lastSpacePos + 1, &end, 10);\n    CHECK_GT(end, lastSpacePos + 1);\n    CHECK_EQ(*end, '\\0');\n\n \n     *PT = x;\n \n    char key[20];\n    sprintf(key, \"a=rtpmap:%lu\", x);\n \n     CHECK(findAttribute(index, key, desc));\n \n    sprintf(key, \"a=fmtp:%lu\", x);\n     if (!findAttribute(index, key, params)) {\n         params->clear();\n     }\n}\n",
        "target": 1
    },
    {
        "id": 2401,
        "func": "bool ASessionDescription::parseNTPRange(\n const char *s, float *npt1, float *npt2) {\n if (s[0] == '-') {\n return false; // no start time available.\n }\n\n if (!strncmp(\"now\", s, 3)) {\n return false; // no absolute start time available\n }\n\n char *end;\n *npt1 = strtof(s, &end);\n\n if (end == s || *end != '-') {\n return false;\n }\n\n    s = end + 1; // skip the dash.\n\n if (*s == '\\0') {\n *npt2 = FLT_MAX; // open ended.\n return true;\n }\n\n if (!strncmp(\"now\", s, 3)) {\n return false; // no absolute end time available\n }\n\n *npt2 = strtof(s, &end);\n\n if (end == s || *end != '\\0') {\n return false;\n }\n\n return *npt2 > *npt1;\n}\n",
        "target": 0
    },
    {
        "id": 2402,
        "func": "static inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}",
        "target": 0
    },
    {
        "id": 2403,
        "func": "int json_object_set_new(json_t *json, const char *key, json_t *value)\n{\n    if(!key || !utf8_check_string(key, -1))\n    {\n        json_decref(value);\n        return -1;\n    }\n\n    return json_object_set_new_nocheck(json, key, value);\n}",
        "target": 0
    },
    {
        "id": 2404,
        "func": "horizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n/* assumption is unsigned pixel values */\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n \t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n \t    }\n \t} else {\n\t    ip += n - 1;\t/* point to last one */\n\t    wp += n - 1;\t/* point to last one */\n \t    n -= stride;\n \t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n \t}\n     }\n }\n",
        "target": 1
    },
    {
        "id": 2405,
        "func": "void reactor_free(reactor_t *reactor) {\n if (!reactor)\n return;\n\n  list_free(reactor->invalidation_list);\n  close(reactor->event_fd);\n  close(reactor->epoll_fd);\n  osi_free(reactor);\n}\n",
        "target": 0
    },
    {
        "id": 2406,
        "func": "struct hd_struct *disk_part_iter_next(struct disk_part_iter *piter)\n{\n\tstruct disk_part_tbl *ptbl;\n\tint inc, end;\n\n\t/* put the last partition */\n\tdisk_put_part(piter->part);\n\tpiter->part = NULL;\n\n\t/* get part_tbl */\n\trcu_read_lock();\n\tptbl = rcu_dereference(piter->disk->part_tbl);\n\n\t/* determine iteration parameters */\n\tif (piter->flags & DISK_PITER_REVERSE) {\n\t\tinc = -1;\n\t\tif (piter->flags & (DISK_PITER_INCL_PART0 |\n\t\t\t\t    DISK_PITER_INCL_EMPTY_PART0))\n\t\t\tend = -1;\n\t\telse\n\t\t\tend = 0;\n\t} else {\n\t\tinc = 1;\n\t\tend = ptbl->len;\n\t}\n\n\t/* iterate to the next partition */\n\tfor (; piter->idx != end; piter->idx += inc) {\n\t\tstruct hd_struct *part;\n\n\t\tpart = rcu_dereference(ptbl->part[piter->idx]);\n\t\tif (!part)\n\t\t\tcontinue;\n\t\tif (!part_nr_sects_read(part) &&\n\t\t    !(piter->flags & DISK_PITER_INCL_EMPTY) &&\n\t\t    !(piter->flags & DISK_PITER_INCL_EMPTY_PART0 &&\n\t\t      piter->idx == 0))\n\t\t\tcontinue;\n\n\t\tget_device(part_to_dev(part));\n\t\tpiter->part = part;\n\t\tpiter->idx += inc;\n\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\treturn piter->part;\n}",
        "target": 0
    },
    {
        "id": 2407,
        "func": "static inline u64 vgettsc(cycle_t *cycle_now)\n{\n\tlong v;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\t*cycle_now = read_tsc();\n\n\tv = (*cycle_now - gtod->clock.cycle_last) & gtod->clock.mask;\n\treturn v * gtod->clock.mult;\n}",
        "target": 0
    },
    {
        "id": 2408,
        "func": "  bool Init(HWND owner) {\n    const int kMaxAttemptsToOpenClipboard = 5;\n    const base::TimeDelta kSleepTimeBetweenAttempts =\n        base::TimeDelta::FromMilliseconds(5);\n\n    if (opened_) {\n      NOTREACHED();\n      return true;\n    }\n\n    for (int attempt = 0; attempt < kMaxAttemptsToOpenClipboard; ++attempt) {\n      if (attempt > 0) {\n        base::PlatformThread::Sleep(kSleepTimeBetweenAttempts);\n      }\n      if (::OpenClipboard(owner)) {\n        opened_ = true;\n        return true;\n      }\n    }\n    return false;\n  }\n",
        "target": 0
    },
    {
        "id": 2409,
        "func": "static int compat_siocwandev(struct net *net, struct compat_ifreq __user *uifr32)\n{\n\tcompat_uptr_t uptr32;\n\tstruct ifreq ifr;\n\tvoid __user *saved;\n\tint err;\n\n\tif (copy_from_user(&ifr, uifr32, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\tif (get_user(uptr32, &uifr32->ifr_settings.ifs_ifsu))\n\t\treturn -EFAULT;\n\n\tsaved = ifr.ifr_settings.ifs_ifsu.raw_hdlc;\n\tifr.ifr_settings.ifs_ifsu.raw_hdlc = compat_ptr(uptr32);\n\n\terr = dev_ioctl(net, SIOCWANDEV, &ifr, NULL);\n\tif (!err) {\n\t\tifr.ifr_settings.ifs_ifsu.raw_hdlc = saved;\n\t\tif (copy_to_user(uifr32, &ifr, sizeof(struct compat_ifreq)))\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 2410,
        "func": "dissect_spoolss_doc_info_1(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_DOC_INFO_1, NULL, \"Document info level 1\");\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Document name\", hf_documentname, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Output file\", hf_outputfile, 0);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, subtree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Data type\", hf_datatype, 0);\n\n\treturn offset;\n}",
        "target": 0
    },
    {
        "id": 2411,
        "func": "static ssize_t show_tabletExecute(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\t/* There is nothing useful to display, so a one-line manual\n\t * is in order...\n\t */\n\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\"Write anything to this file to program your tablet.\\n\");\n}",
        "target": 0
    },
    {
        "id": 2412,
        "func": "void init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime)\n{\n\trt_b->rt_period = ns_to_ktime(period);\n\trt_b->rt_runtime = runtime;\n\n\traw_spin_lock_init(&rt_b->rt_runtime_lock);\n\n\thrtimer_init(&rt_b->rt_period_timer,\n\t\t\tCLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\trt_b->rt_period_timer.function = sched_rt_period_timer;\n}",
        "target": 0
    },
    {
        "id": 2413,
        "func": "void AddHistogramFramesPerBuffer(int param) {\n  AudioFramesPerBuffer afpb = AsAudioFramesPerBuffer(param);\n  if (afpb != kUnexpectedAudioBufferSize) {\n    UMA_HISTOGRAM_ENUMERATION(\"WebRTC.AudioOutputFramesPerBuffer\",\n                              afpb, kUnexpectedAudioBufferSize);\n  } else {\n    UMA_HISTOGRAM_COUNTS(\"WebRTC.AudioOutputFramesPerBufferUnexpected\", param);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2414,
        "func": "mode_pass(struct cpio *cpio, const char *destdir)\n{\n\tstruct lafe_line_reader *lr;\n\tconst char *p;\n\tint r;\n\n\t/* Ensure target dir has a trailing '/' to simplify path surgery. */\n\tcpio->destdir = malloc(strlen(destdir) + 8);\n\tstrcpy(cpio->destdir, destdir);\n\tif (destdir[strlen(destdir) - 1] != '/')\n\t\tstrcat(cpio->destdir, \"/\");\n\n\tcpio->archive = archive_write_disk_new();\n\tif (cpio->archive == NULL)\n\t\tlafe_errc(1, 0, \"Failed to allocate archive object\");\n\tr = archive_write_disk_set_options(cpio->archive, cpio->extract_flags);\n\tif (r != ARCHIVE_OK)\n\t\tlafe_errc(1, 0, \"%s\", archive_error_string(cpio->archive));\n\tcpio->linkresolver = archive_entry_linkresolver_new();\n\tarchive_write_disk_set_standard_lookup(cpio->archive);\n\n\tcpio->archive_read_disk = archive_read_disk_new();\n\tif (cpio->archive_read_disk == NULL)\n\t\tlafe_errc(1, 0, \"Failed to allocate archive object\");\n\tif (cpio->option_follow_links)\n\t\tarchive_read_disk_set_symlink_logical(cpio->archive_read_disk);\n\telse\n\t\tarchive_read_disk_set_symlink_physical(cpio->archive_read_disk);\n\tarchive_read_disk_set_standard_lookup(cpio->archive_read_disk);\n\n\tlr = lafe_line_reader(\"-\", cpio->option_null);\n\twhile ((p = lafe_line_reader_next(lr)) != NULL)\n\t\tfile_to_archive(cpio, p);\n\tlafe_line_reader_free(lr);\n\n\tarchive_entry_linkresolver_free(cpio->linkresolver);\n\tr = archive_write_close(cpio->archive);\n\tif (cpio->dot)\n\t\tfprintf(stderr, \"\\n\");\n\tif (r != ARCHIVE_OK)\n\t\tlafe_errc(1, 0, \"%s\", archive_error_string(cpio->archive));\n\n\tif (!cpio->quiet) {\n\t\tint64_t blocks =\n\t\t\t(archive_filter_bytes(cpio->archive, 0) + 511)\n\t\t\t/ 512;\n\t\tfprintf(stderr, \"%lu %s\\n\", (unsigned long)blocks,\n\t\t    blocks == 1 ? \"block\" : \"blocks\");\n\t}\n\n\tarchive_write_free(cpio->archive);\n}",
        "target": 0
    },
    {
        "id": 2415,
        "func": "void RunClosureAfterCookiesCleared(const base::Closure& task,\n                                   uint32_t cookies_deleted) {\n  task.Run();\n}\n",
        "target": 0
    },
    {
        "id": 2416,
        "func": "void WebPluginImpl::InitiateHTTPRangeRequest(const char* url,\n                                             const char* range_info,\n                                             intptr_t existing_stream,\n                                             bool notify_needed,\n                                             intptr_t notify_data) {\n   unsigned long resource_id = GetNextResourceId();\n   if (!resource_id)\n     return;\n \n   GURL complete_url = CompleteURL(url);\n \n  WebPluginResourceClient* resource_client = delegate_->CreateResourceClient(\n      resource_id, complete_url, notify_needed, notify_data, existing_stream);\n   InitiateHTTPRequest(\n      resource_id, resource_client, \"GET\", NULL, 0, complete_url, range_info,\n       load_manually_ ? NO_REFERRER : PLUGIN_SRC);\n }\n",
        "target": 1
    },
    {
        "id": 2417,
        "func": "GURL DevToolsWindow::GetDevToolsURL(Profile* profile,\n                                    const GURL& base_url,\n                                    bool shared_worker_frontend,\n                                    bool v8_only_frontend,\n                                    const std::string& remote_frontend,\n                                    bool can_dock,\n                                    const std::string& panel) {\n  if (base_url.SchemeIs(\"data\"))\n    return base_url;\n\n  std::string frontend_url(\n      !remote_frontend.empty() ?\n          remote_frontend :\n          base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());\n  std::string url_string(\n      frontend_url +\n      ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\"));\n  if (shared_worker_frontend)\n    url_string += \"&isSharedWorker=true\";\n  if (v8_only_frontend)\n    url_string += \"&v8only=true\";\n  if (remote_frontend.size()) {\n    url_string += \"&remoteFrontend=true\";\n  } else {\n    url_string += \"&remoteBase=\" + DevToolsUI::GetRemoteBaseURL().spec();\n  }\n  if (can_dock)\n     url_string += \"&can_dock=true\";\n   if (panel.size())\n     url_string += \"&panel=\" + panel;\n  return DevToolsUI::SanitizeFrontendURL(GURL(url_string));\n }\n",
        "target": 1
    },
    {
        "id": 2418,
        "func": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lock/lxc/var/lib/lxc/\";\n\tret = stat(pathname, &sb);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\ttest_two_locks();\n\n\tfprintf(stderr, \"all tests passed\\n\");\n\n\texit(ret);\n}",
        "target": 1
    },
    {
        "id": 2419,
        "func": "static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod7(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     DOMStringList* arrayArg(toDOMStringList(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->overloadedMethod(arrayArg);\n    return JSValue::encode(jsUndefined());\n}\n",
        "target": 1
    },
    {
        "id": 2420,
        "func": "BackingStore* RenderWidgetHostViewAura::AllocBackingStore(\n    const gfx::Size& size) {\n  return new BackingStoreAura(host_, size);\n}\n",
        "target": 0
    },
    {
        "id": 2421,
        "func": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n\t\t\t     unsigned char __user *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}",
        "target": 1
    },
    {
        "id": 2422,
        "func": "void SetBuildInfoAnnotations(std::map<std::string, std::string>* annotations) {\n  base::android::BuildInfo* info = base::android::BuildInfo::GetInstance();\n \n   (*annotations)[\"android_build_id\"] = info->android_build_id();\n   (*annotations)[\"android_build_fp\"] = info->android_build_fp();\n   (*annotations)[\"device\"] = info->device();\n   (*annotations)[\"model\"] = info->model();\n   (*annotations)[\"brand\"] = info->brand();\n  (*annotations)[\"board\"] = info->board();\n  (*annotations)[\"installer_package_name\"] = info->installer_package_name();\n  (*annotations)[\"abi_name\"] = info->abi_name();\n  (*annotations)[\"custom_themes\"] = info->custom_themes();\n  (*annotations)[\"resources_verison\"] = info->resources_version();\n  (*annotations)[\"gms_core_version\"] = info->gms_version_code();\n\n  if (info->firebase_app_id()[0] != '\\0') {\n    (*annotations)[\"package\"] = std::string(info->firebase_app_id()) + \" v\" +\n                                info->package_version_code() + \" (\" +\n                                info->package_version_name() + \")\";\n  }\n}\n",
        "target": 1
    },
    {
        "id": 2423,
        "func": "static int setflashmode (struct airo_info *ai) {\n\tset_bit (FLAG_FLASHING, &ai->flags);\n\n\tOUT4500(ai, SWS0, FLASH_COMMAND);\n\tOUT4500(ai, SWS1, FLASH_COMMAND);\n\tif (probe) {\n\t\tOUT4500(ai, SWS0, FLASH_COMMAND);\n\t\tOUT4500(ai, COMMAND,0x10);\n\t} else {\n\t\tOUT4500(ai, SWS2, FLASH_COMMAND);\n\t\tOUT4500(ai, SWS3, FLASH_COMMAND);\n\t\tOUT4500(ai, COMMAND,0);\n\t}\n\tmsleep(500);\t\t/* 500ms delay */\n\n\tif(!waitbusy(ai)) {\n\t\tclear_bit (FLAG_FLASHING, &ai->flags);\n\t\tairo_print_info(ai->dev->name, \"Waitbusy hang after setflash mode\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2424,
        "func": "void skcipher_geniv_exit(struct crypto_tfm *tfm)\n{\n\tcrypto_free_ablkcipher(tfm->crt_ablkcipher.base);\n}",
        "target": 0
    },
    {
        "id": 2425,
        "func": "nautilus_mime_types_group_get_mimetypes (gint group_index)\n{\n    GList *mimetypes;\n    gint i;\n\n    g_return_val_if_fail (group_index < G_N_ELEMENTS (mimetype_groups), NULL);\n\n    mimetypes = NULL;\n\n    /* Setup the new mimetypes set */\n    for (i = 0; mimetype_groups[group_index].mimetypes[i]; i++)\n    {\n        mimetypes = g_list_append (mimetypes, mimetype_groups[group_index].mimetypes[i]);\n    }\n\n    return mimetypes;\n}",
        "target": 0
    },
    {
        "id": 2426,
        "func": "EventReaderLibevdevCros::~EventReaderLibevdevCros() {\n  Stop();\n  EvdevClose(&evdev_);\n}\n",
        "target": 0
    },
    {
        "id": 2427,
        "func": "static void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tif (l2cap_pi(sk)->force_reliable)\n\t\t\tsk->sk_err = err;\n\t}\n\n\tread_unlock(&l->lock);\n}",
        "target": 0
    },
    {
        "id": 2428,
        "func": "bool RenderFrameHostManager::ShouldSwapBrowsingInstancesForNavigation(\n    const GURL& current_effective_url,\n    bool current_is_view_source_mode,\n    SiteInstance* new_site_instance,\n    const GURL& new_effective_url,\n    bool new_is_view_source_mode,\n    bool is_failure) const {\n  if (!frame_tree_node_->IsMainFrame())\n    return false;\n\n  if (is_failure && SiteIsolationPolicy::IsErrorPageIsolationEnabled(\n                        frame_tree_node_->IsMainFrame())) {\n    return false;\n  }\n\n  if (new_site_instance) {\n    return !new_site_instance->IsRelatedSiteInstance(\n        render_frame_host_->GetSiteInstance());\n  }\n\n  BrowserContext* browser_context =\n      delegate_->GetControllerForRenderManager().GetBrowserContext();\n\n  if (IsRendererDebugURL(new_effective_url))\n    return false;\n\n  DCHECK_EQ(browser_context,\n            render_frame_host_->GetSiteInstance()->GetBrowserContext());\n  if (browser_context !=\n      render_frame_host_->GetSiteInstance()->GetBrowserContext()) {\n    return true;\n  }\n\n  if (ChildProcessSecurityPolicyImpl::GetInstance()->HasWebUIBindings(\n          render_frame_host_->GetProcess()->GetID()) ||\n      WebUIControllerFactoryRegistry::GetInstance()->UseWebUIBindingsForURL(\n          browser_context, current_effective_url)) {\n    if (!WebUIControllerFactoryRegistry::GetInstance()->IsURLAcceptableForWebUI(\n            browser_context, new_effective_url)) {\n      return true;\n    }\n\n    if (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(\n            browser_context, current_effective_url) !=\n        WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(\n            browser_context, new_effective_url)) {\n      return true;\n    }\n  } else {\n    if (WebUIControllerFactoryRegistry::GetInstance()->UseWebUIBindingsForURL(\n            browser_context, new_effective_url)) {\n      return true;\n    }\n  }\n\n  if (GetContentClient()->browser()->ShouldSwapBrowsingInstancesForNavigation(\n          render_frame_host_->GetSiteInstance(),\n          current_effective_url, new_effective_url)) {\n    return true;\n  }\n\n  if (current_is_view_source_mode != new_is_view_source_mode)\n    return true;\n\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 2429,
        "func": "void RenderWidgetHostViewAura::OnCandidateWindowShown() {\n  host_->CandidateWindowShown();\n}\n",
        "target": 0
    },
    {
        "id": 2430,
        "func": "  void InitReadBuf(WebSocket* websocket) {\n    websocket->current_read_buf_ = new GrowableIOBuffer();\n  }\n",
        "target": 0
    },
    {
        "id": 2431,
        "func": "void ExtensionRegistry::RemoveObserver(ExtensionRegistryObserver* observer) {\n  observers_.RemoveObserver(observer);\n}\n",
        "target": 0
    },
    {
        "id": 2432,
        "func": "   virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n\n     inv_txfm_ = GET_PARAM(1);\n     version_  = GET_PARAM(2);  // 0: high precision forward transform\n    bit_depth_ = GET_PARAM(3);\n    mask_ = (1 << bit_depth_) - 1;\n   }\n",
        "target": 0
    },
    {
        "id": 2433,
        "func": "static unsigned long mmap_rnd(void)\n{\n\tunsigned long rnd = 0;\n\n\t/*\n\t*  8 bits of randomness in 32bit mmaps, 20 address space bits\n\t* 28 bits of randomness in 64bit mmaps, 40 address space bits\n\t*/\n\tif (current->flags & PF_RANDOMIZE) {\n\t\tif (mmap_is_ia32())\n\t\t\trnd = get_random_int() % (1<<8);\n\t\telse\n\t\t\trnd = get_random_int() % (1<<28);\n\t}\n\treturn rnd << PAGE_SHIFT;\n}",
        "target": 0
    },
    {
        "id": 2434,
        "func": "void PageHandler::Observe(int type,\n                          const NotificationSource& source,\n                          const NotificationDetails& details) {\n  if (!screencast_enabled_)\n    return;\n  DCHECK(type == content::NOTIFICATION_RENDER_WIDGET_VISIBILITY_CHANGED);\n  bool visible = *Details<bool>(details).ptr();\n  NotifyScreencastVisibility(visible);\n}\n",
        "target": 0
    },
    {
        "id": 2435,
        "func": "static int sctp_getsockopt_sctp_status(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_status status;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_transport *transport;\n\tsctp_assoc_t associd;\n\tint retval = 0;\n\n\tif (len < sizeof(status)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(status);\n\tif (copy_from_user(&status, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tassocid = status.sstat_assoc_id;\n\tasoc = sctp_id2assoc(sk, associd);\n\tif (!asoc) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttransport = asoc->peer.primary_path;\n\n\tstatus.sstat_assoc_id = sctp_assoc2id(asoc);\n\tstatus.sstat_state = sctp_assoc_to_state(asoc);\n\tstatus.sstat_rwnd =  asoc->peer.rwnd;\n\tstatus.sstat_unackdata = asoc->unack_data;\n\n\tstatus.sstat_penddata = sctp_tsnmap_pending(&asoc->peer.tsn_map);\n\tstatus.sstat_instrms = asoc->c.sinit_max_instreams;\n\tstatus.sstat_outstrms = asoc->c.sinit_num_ostreams;\n\tstatus.sstat_fragmentation_point = asoc->frag_point;\n\tstatus.sstat_primary.spinfo_assoc_id = sctp_assoc2id(transport->asoc);\n\tmemcpy(&status.sstat_primary.spinfo_address, &transport->ipaddr,\n\t\t\ttransport->af_specific->sockaddr_len);\n\t/* Map ipv4 address into v4-mapped-on-v6 address.  */\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sctp_sk(sk),\n\t\t(union sctp_addr *)&status.sstat_primary.spinfo_address);\n\tstatus.sstat_primary.spinfo_state = transport->state;\n\tstatus.sstat_primary.spinfo_cwnd = transport->cwnd;\n\tstatus.sstat_primary.spinfo_srtt = transport->srtt;\n\tstatus.sstat_primary.spinfo_rto = jiffies_to_msecs(transport->rto);\n\tstatus.sstat_primary.spinfo_mtu = transport->pathmtu;\n\n\tif (status.sstat_primary.spinfo_state == SCTP_UNKNOWN)\n\t\tstatus.sstat_primary.spinfo_state = SCTP_ACTIVE;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"%s: len:%d, state:%d, rwnd:%d, assoc_id:%d\\n\",\n\t\t __func__, len, status.sstat_state, status.sstat_rwnd,\n\t\t status.sstat_assoc_id);\n\n\tif (copy_to_user(optval, &status, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}",
        "target": 0
    },
    {
        "id": 2436,
        "func": " MockRenderThread::MockRenderThread()\n    : routing_id_(0), surface_id_(0), opener_id_(0) {\n }\n",
        "target": 1
    },
    {
        "id": 2437,
        "func": "void PersistentSampleMapRecords::Release(const void* user) {\n  DCHECK_EQ(user_, user);\n  user_ = nullptr;\n}\n",
        "target": 0
    },
    {
        "id": 2438,
        "func": "PrintMsg_Print_Params::~PrintMsg_Print_Params() {}\n",
        "target": 0
    },
    {
        "id": 2439,
        "func": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "id": 2440,
        "func": "static void return_hosed_msg(struct smi_info *smi_info, int cCode)\n{\n\tstruct ipmi_smi_msg *msg = smi_info->curr_msg;\n\n\tif (cCode < 0 || cCode > IPMI_ERR_UNSPECIFIED)\n\t\tcCode = IPMI_ERR_UNSPECIFIED;\n\t/* else use it as is */\n\n\t/* Make it a response */\n\tmsg->rsp[0] = msg->data[0] | 4;\n\tmsg->rsp[1] = msg->data[1];\n\tmsg->rsp[2] = cCode;\n\tmsg->rsp_size = 3;\n\n\tsmi_info->curr_msg = NULL;\n\tdeliver_recv_msg(smi_info, msg);\n}",
        "target": 0
    },
    {
        "id": 2441,
        "func": "struct kobject *dm_kobject(struct mapped_device *md)\n{\n\treturn &md->kobj_holder.kobj;\n}",
        "target": 0
    },
    {
        "id": 2442,
        "func": "void OmniboxPopupViewGtk::InvalidateLine(size_t line) {\n  GdkWindow* gdk_window = gtk_widget_get_window(GTK_WIDGET(window_));\n  GdkRectangle line_rect = GetRectForLine(\n      line, GetWindowRect(gdk_window).width()).ToGdkRectangle();\n  gdk_window_invalidate_rect(gdk_window, &line_rect, FALSE);\n}\n",
        "target": 0
    },
    {
        "id": 2443,
        "func": "RequestSender::~RequestSender() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n}\n",
        "target": 0
    },
    {
        "id": 2444,
        "func": "void InspectorController::processGPUEvent(double timestamp, int phase, bool foreign, uint64_t usedGPUMemoryBytes, uint64_t limitGPUMemoryBytes)\n{\n    if (InspectorTimelineAgent* timelineAgent = m_instrumentingAgents->inspectorTimelineAgent())\n        timelineAgent->processGPUEvent(InspectorTimelineAgent::GPUEvent(timestamp, phase, foreign, usedGPUMemoryBytes, limitGPUMemoryBytes));\n}\n",
        "target": 0
    },
    {
        "id": 2445,
        "func": "  tt_size_done_bytecode( FT_Size  ftsize )\n  {\n    TT_Size    size   = (TT_Size)ftsize;\n    TT_Face    face   = (TT_Face)ftsize->face;\n    FT_Memory  memory = face->root.memory;\n\n    if ( size->context )\n    {\n      TT_Done_Context( size->context );\n      size->context = NULL;\n    }\n\n    FT_FREE( size->cvt );\n    size->cvt_size = 0;\n\n    /* free storage area */\n    FT_FREE( size->storage );\n    size->storage_size = 0;\n\n    /* twilight zone */\n    tt_glyphzone_done( &size->twilight );\n\n    FT_FREE( size->function_defs );\n    FT_FREE( size->instruction_defs );\n\n    size->num_function_defs    = 0;\n    size->max_function_defs    = 0;\n    size->num_instruction_defs = 0;\n    size->max_instruction_defs = 0;\n\n    size->max_func = 0;\n    size->max_ins  = 0;\n\n    size->bytecode_ready = -1;\n    size->cvt_ready      = -1;\n  }\n",
        "target": 0
    },
    {
        "id": 2446,
        "func": "sp<MetaData> MPEG4Extractor::getTrackMetaData(\n size_t index, uint32_t flags) {\n status_t err;\n if ((err = readMetaData()) != OK) {\n return NULL;\n }\n\n Track *track = mFirstTrack;\n while (index > 0) {\n if (track == NULL) {\n return NULL;\n }\n\n        track = track->next;\n --index;\n }\n\n if (track == NULL) {\n return NULL;\n }\n\n if ((flags & kIncludeExtensiveMetaData)\n && !track->includes_expensive_metadata) {\n        track->includes_expensive_metadata = true;\n\n const char *mime;\n        CHECK(track->meta->findCString(kKeyMIMEType, &mime));\n if (!strncasecmp(\"video/\", mime, 6)) {\n if (!strcmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG2)) {\n off64_t offset;\n size_t size;\n if (track->sampleTable->getMetaDataForSample(\n 0 /* sampleIndex */, &offset, &size, NULL /* sampleTime */) == OK) {\n if (size > kMaxTrackHeaderSize) {\n                        size = kMaxTrackHeaderSize;\n }\n uint8_t header[kMaxTrackHeaderSize];\n if (mDataSource->readAt(offset, &header, size) == (ssize_t)size) {\n                        track->meta->setData(kKeyStreamHeader, 'mdat', header, size);\n }\n }\n }\n\n if (mMoofOffset > 0) {\n int64_t duration;\n if (track->meta->findInt64(kKeyDuration, &duration)) {\n                    track->meta->setInt64(\n                            kKeyThumbnailTime, duration / 4);\n }\n } else {\n uint32_t sampleIndex;\n uint32_t sampleTime;\n if (track->timescale != 0 &&\n                        track->sampleTable->findThumbnailSample(&sampleIndex) == OK\n && track->sampleTable->getMetaDataForSample(\n                            sampleIndex, NULL /* offset */, NULL /* size */,\n &sampleTime) == OK) {\n                    track->meta->setInt64(\n                            kKeyThumbnailTime,\n ((int64_t)sampleTime * 1000000) / track->timescale);\n }\n }\n }\n }\n\n return track->meta;\n}\n",
        "target": 0
    },
    {
        "id": 2447,
        "func": "static void ex_assign_report_general(struct domain_device *dev,\n\t\t\t\t\t    struct smp_resp *resp)\n{\n\tstruct report_general_resp *rg = &resp->rg;\n\n\tdev->ex_dev.ex_change_count = be16_to_cpu(rg->change_count);\n\tdev->ex_dev.max_route_indexes = be16_to_cpu(rg->route_indexes);\n\tdev->ex_dev.num_phys = min(rg->num_phys, (u8)MAX_EXPANDER_PHYS);\n\tdev->ex_dev.t2t_supp = rg->t2t_supp;\n\tdev->ex_dev.conf_route_table = rg->conf_route_table;\n\tdev->ex_dev.configuring = rg->configuring;\n\tmemcpy(dev->ex_dev.enclosure_logical_id, rg->enclosure_logical_id, 8);\n}",
        "target": 0
    },
    {
        "id": 2448,
        "func": "bool GLES2Implementation::DeleteShaderHelper(GLuint shader) {\n  if (!GetIdHandler(SharedIdNamespaces::kProgramsAndShaders)\n           ->FreeIds(this, 1, &shader,\n                     &GLES2Implementation::DeleteShaderStub)) {\n    SetGLError(GL_INVALID_VALUE, \"glDeleteShader\",\n               \"id not created by this context.\");\n    return false;\n  }\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2449,
        "func": "static struct VP8D_COMP * create_decompressor(VP8D_CONFIG *oxcf)\n{\n    VP8D_COMP *pbi = vpx_memalign(32, sizeof(VP8D_COMP));\n\n if (!pbi)\n return NULL;\n\n    memset(pbi, 0, sizeof(VP8D_COMP));\n\n if (setjmp(pbi->common.error.jmp))\n {\n        pbi->common.error.setjmp = 0;\n        remove_decompressor(pbi);\n return 0;\n }\n\n    pbi->common.error.setjmp = 1;\n\n    vp8_create_common(&pbi->common);\n\n    pbi->common.current_video_frame = 0;\n    pbi->ready_for_new_data = 1;\n\n /* vp8cx_init_de_quantizer() is first called here. Add check in frame_init_dequantizer() to avoid\n     *  unnecessary calling of vp8cx_init_de_quantizer() for every frame.\n     */\n    vp8cx_init_de_quantizer(pbi);\n\n    vp8_loop_filter_init(&pbi->common);\n\n    pbi->common.error.setjmp = 0;\n\n#if CONFIG_ERROR_CONCEALMENT\n    pbi->ec_enabled = oxcf->error_concealment;\n    pbi->overlaps = NULL;\n#else\n (void)oxcf;\n    pbi->ec_enabled = 0;\n#endif\n /* Error concealment is activated after a key frame has been\n     * decoded without errors when error concealment is enabled.\n     */\n    pbi->ec_active = 0;\n\n    pbi->decoded_key_frame = 0;\n\n /* Independent partitions is activated when a frame updates the\n     * token probability table to have equal probabilities over the\n     * PREV_COEF context.\n     */\n    pbi->independent_partitions = 0;\n\n    vp8_setup_block_dptrs(&pbi->mb);\n\n    once(initialize_dec);\n\n return pbi;\n}\n",
        "target": 0
    },
    {
        "id": 2450,
        "func": "void unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}",
        "target": 0
    },
    {
        "id": 2451,
        "func": "static bool ExecuteUnlink(LocalFrame& frame,\n                          Event*,\n                          EditorCommandSource,\n                          const String&) {\n  DCHECK(frame.GetDocument());\n  return UnlinkCommand::Create(*frame.GetDocument())->Apply();\n}\n",
        "target": 0
    },
    {
        "id": 2452,
        "func": " int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)\n {\n     int ok = 0;\n    BIGNUM *q = NULL;\n \n     *ret = 0;\n    q = BN_new();\n    if (q == NULL)\n         goto err;\n    BN_set_word(q, 1);\n    if (BN_cmp(pub_key, q) <= 0)\n         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;\n    BN_copy(q, dh->p);\n    BN_sub_word(q, 1);\n    if (BN_cmp(pub_key, q) >= 0)\n         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;\n \n     ok = 1;\n  err:\n    if (q != NULL)\n        BN_free(q);\n     return (ok);\n }\n",
        "target": 1
    },
    {
        "id": 2453,
        "func": "static void ib_uverbs_release_dev(struct device *device)\n{\n\tstruct ib_uverbs_device *dev =\n\t\t\tcontainer_of(device, struct ib_uverbs_device, dev);\n\n\tuverbs_destroy_api(dev->uapi);\n\tcleanup_srcu_struct(&dev->disassociate_srcu);\n\tkfree(dev);\n}",
        "target": 0
    },
    {
        "id": 2454,
        "func": "static inline int set_dawr(struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE)) \\\n\t\t                   << (63 - 58); //* read/write bits */\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) \\\n\t\t                   << (63 - 59); //* translate */\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) \\\n\t\t                   >> 3; //* PRIM bits */\n\t/* dawr length is stored in field MDR bits 48:53.  Matches range in\n\t   doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t   0b111111=64DW.\n\t   brk->len is in bytes.\n\t   This aligns up to double word size, shifts and does the bias.\n\t*/\n\tmrd = ((brk->len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(dawr, dawrx);\n\tmtspr(SPRN_DAWR, dawr);\n\tmtspr(SPRN_DAWRX, dawrx);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2455,
        "func": "static void coroutine_fn virtfs_reset(V9fsPDU *pdu)\n{\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp = NULL;\n\n    /* Free all fids */\n    while (s->fid_list) {\n        fidp = s->fid_list;\n        s->fid_list = fidp->next;\n\n        if (fidp->ref) {\n            fidp->clunked = 1;\n        } else {\n            free_fid(pdu, fidp);\n        }\n    }\n    if (fidp) {\n        /* One or more unclunked fids found... */\n        error_report(\"9pfs:%s: One or more uncluncked fids \"\n                     \"found during reset\", __func__);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2456,
        "func": "void nfs_commit_free(struct nfs_commit_data *p)\n{\n\tmempool_free(p, nfs_commit_mempool);\n}",
        "target": 0
    },
    {
        "id": 2457,
        "func": "HRESULT DataObjectImpl::QueryInterface(const IID& iid, void** object) {\n  if (!object)\n    return E_POINTER;\n  if (IsEqualIID(iid, IID_IDataObject) || IsEqualIID(iid, IID_IUnknown)) {\n    *object = static_cast<IDataObject*>(this);\n  } else if (in_async_mode_ &&\n             IsEqualIID(iid, __uuidof(IDataObjectAsyncCapability))) {\n    *object = static_cast<IDataObjectAsyncCapability*>(this);\n  } else {\n    *object = NULL;\n    return E_NOINTERFACE;\n  }\n  AddRef();\n  return S_OK;\n}\n",
        "target": 0
    },
    {
        "id": 2458,
        "func": "  void SetupBlacklist(const std::string& json_blacklist) {\n    GpuBlacklist* blacklist = GpuBlacklist::GetInstance();\n    ASSERT_TRUE(blacklist->LoadGpuBlacklist(\n        \"1.0\", json_blacklist, GpuBlacklist::kAllOs));\n    blacklist->UpdateGpuDataManager();\n  }\n",
        "target": 0
    },
    {
        "id": 2459,
        "func": "Element* Document::SequentialFocusNavigationStartingPoint(\n    WebFocusType type) const {\n  if (focused_element_)\n    return focused_element_.Get();\n  if (!sequential_focus_navigation_starting_point_)\n    return nullptr;\n  DCHECK(sequential_focus_navigation_starting_point_->IsConnected());\n  if (!sequential_focus_navigation_starting_point_->collapsed()) {\n    Node* node = sequential_focus_navigation_starting_point_->startContainer();\n    DCHECK_EQ(node,\n              sequential_focus_navigation_starting_point_->endContainer());\n    if (node->IsElementNode())\n      return ToElement(node);\n    if (Element* neighbor_element = type == kWebFocusTypeForward\n                                        ? ElementTraversal::Previous(*node)\n                                        : ElementTraversal::Next(*node))\n      return neighbor_element;\n    return node->ParentOrShadowHostElement();\n  }\n\n  if (sequential_focus_navigation_starting_point_->startContainer()\n          ->IsElementNode() &&\n      !sequential_focus_navigation_starting_point_->startContainer()\n           ->hasChildren() &&\n      sequential_focus_navigation_starting_point_->startOffset() == 0)\n    return ToElement(\n        sequential_focus_navigation_starting_point_->startContainer());\n\n  if (Node* next_node =\n          sequential_focus_navigation_starting_point_->FirstNode()) {\n    if (next_node->IsShadowRoot())\n      return next_node->OwnerShadowHost();\n    if (type == kWebFocusTypeForward) {\n      Node* previous = next_node;\n      do {\n        previous = FlatTreeTraversal::Previous(*previous);\n      } while (previous && !previous->IsElementNode());\n      return ToElement(previous);\n    }\n    if (next_node->IsElementNode())\n      return ToElement(next_node);\n    Node* next = next_node;\n    do {\n      next = FlatTreeTraversal::Next(*next);\n    } while (next && !next->IsElementNode());\n    return ToElement(next);\n  }\n  return nullptr;\n}\n",
        "target": 0
    },
    {
        "id": 2460,
        "func": "static int ip_vs_flush(void)\n{\n\tint idx;\n\tstruct ip_vs_service *svc, *nxt;\n\n\t/*\n\t * Flush the service table hashed by <protocol,addr,port>\n\t */\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(svc, nxt, &ip_vs_svc_table[idx], s_list) {\n\t\t\twrite_lock_bh(&__ip_vs_svc_lock);\n\t\t\tip_vs_svc_unhash(svc);\n\t\t\t/*\n\t\t\t * Wait until all the svc users go away.\n\t\t\t */\n\t\t\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 0);\n\t\t\t__ip_vs_del_service(svc);\n\t\t\twrite_unlock_bh(&__ip_vs_svc_lock);\n\t\t}\n\t}\n\n\t/*\n\t * Flush the service table hashed by fwmark\n\t */\n\tfor(idx = 0; idx < IP_VS_SVC_TAB_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(svc, nxt,\n\t\t\t\t\t &ip_vs_svc_fwm_table[idx], f_list) {\n\t\t\twrite_lock_bh(&__ip_vs_svc_lock);\n\t\t\tip_vs_svc_unhash(svc);\n\t\t\t/*\n\t\t\t * Wait until all the svc users go away.\n\t\t\t */\n\t\t\tIP_VS_WAIT_WHILE(atomic_read(&svc->usecnt) > 0);\n\t\t\t__ip_vs_del_service(svc);\n\t\t\twrite_unlock_bh(&__ip_vs_svc_lock);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2461,
        "func": "bool PrintRenderFrameHelper::IsPrintingEnabled() const {\n  return is_printing_enabled_;\n}\n",
        "target": 0
    },
    {
        "id": 2462,
        "func": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}",
        "target": 1
    },
    {
        "id": 2463,
        "func": " void WebPageProxy::gestureDidEnd()\n{\n    process()->send(Messages::WebPage::GestureDidEnd(), m_pageID);\n}\n",
        "target": 0
    },
    {
        "id": 2464,
        "func": "static void bta_av_accept_signalling_timer_cback(void* data) {\n uint32_t inx = PTR_TO_UINT(data);\n  tBTA_AV_CB* p_cb = &bta_av_cb;\n  tBTA_AV_SCB* p_scb = NULL;\n if (inx < BTA_AV_NUM_STRS) {\n    p_scb = p_cb->p_scb[inx];\n }\n if (p_scb) {\n    APPL_TRACE_DEBUG(\"%s: coll_mask = 0x%02X\", __func__, p_scb->coll_mask);\n\n if (p_scb->coll_mask & BTA_AV_COLL_INC_TMR) {\n      p_scb->coll_mask &= ~BTA_AV_COLL_INC_TMR;\n\n if (bta_av_is_scb_opening(p_scb)) {\n        APPL_TRACE_DEBUG(\"%s: stream state opening: SDP started = %d\", __func__,\n                         p_scb->sdp_discovery_started);\n if (p_scb->sdp_discovery_started) {\n /* We are still doing SDP. Run the timer again. */\n          p_scb->coll_mask |= BTA_AV_COLL_INC_TMR;\n\n          alarm_set_on_mloop(p_cb->accept_signalling_timer,\n                             BTA_AV_ACCEPT_SIGNALLING_TIMEOUT_MS,\n                             bta_av_accept_signalling_timer_cback,\n                             UINT_TO_PTR(inx));\n } else {\n /* SNK did not start signalling, resume signalling process. */\n          bta_av_discover_req(p_scb, NULL);\n }\n } else if (bta_av_is_scb_incoming(p_scb)) {\n /* Stay in incoming state if SNK does not start signalling */\n\n        APPL_TRACE_DEBUG(\"%s: stream state incoming\", __func__);\n /* API open was called right after SNK opened L2C connection. */\n if (p_scb->coll_mask & BTA_AV_COLL_API_CALLED) {\n          p_scb->coll_mask &= ~BTA_AV_COLL_API_CALLED;\n\n /* BTA_AV_API_OPEN_EVT */\n          tBTA_AV_API_OPEN* p_buf =\n (tBTA_AV_API_OPEN*)osi_malloc(sizeof(tBTA_AV_API_OPEN));\n          memcpy(p_buf, &(p_scb->open_api), sizeof(tBTA_AV_API_OPEN));\n          bta_sys_sendmsg(p_buf);\n }\n }\n }\n }\n}\n",
        "target": 0
    },
    {
        "id": 2465,
        "func": " ContentEncoding::ContentCompression::ContentCompression()\n    : algo(0),\n      settings(NULL),\n      settings_len(0) {\n}\n",
        "target": 1
    },
    {
        "id": 2466,
        "func": " sample(png_const_bytep row, png_byte colour_type, png_byte bit_depth,\n    png_uint_32 x, unsigned int sample_index)\n {\n    png_uint_32 bit_index, result;\n \n /* Find a sample index for the desired sample: */\n   x *= bit_depth;\n   bit_index = x;\n\n if ((colour_type & 1) == 0) /* !palette */\n {\n if (colour_type & 2)\n         bit_index *= 3;\n\n if (colour_type & 4)\n         bit_index += x; /* Alpha channel */\n\n /* Multiple channels; select one: */\n if (colour_type & (2+4))\n         bit_index += sample_index * bit_depth;\n }\n\n /* Return the sample from the row as an integer. */\n   row += bit_index >> 3;\n   result = *row;\n\n if (bit_depth == 8)\n\n       return result;\n \n    else if (bit_depth > 8)\n      return (result << 8) + *++row;\n \n   /* Less than 8 bits per sample. */\n    bit_index &= 7;\n   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);\n }\n",
        "target": 1
    },
    {
        "id": 2467,
        "func": "u8 gf_mp3_object_type_indication(u32 hdr)\n{\n\tswitch (gf_mp3_version(hdr)) {\n\tcase 3:\n\t\treturn GPAC_OTI_AUDIO_MPEG1;\n\tcase 2:\n\tcase 0:\n\t\treturn GPAC_OTI_AUDIO_MPEG2_PART3;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}",
        "target": 0
    },
    {
        "id": 2468,
        "func": "base::Optional<DOMExceptionCode> HTMLMediaElement::Play() {\n  BLINK_MEDIA_LOG << \"play(\" << (void*)this << \")\";\n\n  base::Optional<DOMExceptionCode> exception_code =\n      autoplay_policy_->RequestPlay();\n\n  if (exception_code == DOMExceptionCode::kNotAllowedError) {\n    if (!paused_) {\n      PlayInternal();\n      return base::nullopt;\n    }\n    return exception_code;\n  }\n\n  autoplay_policy_->StopAutoplayMutedWhenVisible();\n\n  if (error_ && error_->code() == MediaError::kMediaErrSrcNotSupported)\n    return DOMExceptionCode::kNotSupportedError;\n\n  DCHECK(!exception_code.has_value());\n\n  PlayInternal();\n\n  return base::nullopt;\n}\n",
        "target": 0
    },
    {
        "id": 2469,
        "func": "static Bool node_in_commands_subtree(GF_Node *node, GF_List *commands)\n{\n#ifndef GPAC_DISABLE_VRML\n\tu32 i, j, count, nb_fields;\n\n\tcount = gf_list_count(commands);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Command *com = gf_list_get(commands, i);\n\t\tif (com->tag>=GF_SG_LAST_BIFS_COMMAND) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] Command check for LASeR/DIMS not supported\\n\"));\n\t\t\treturn 0;\n\t\t}\n\t\tif (com->tag==GF_SG_SCENE_REPLACE) {\n\t\t\tif (gf_node_parent_of(com->node, node)) return 1;\n\t\t\tcontinue;\n\t\t}\n\t\tnb_fields = gf_list_count(com->command_fields);\n\t\tfor (j=0; j<nb_fields; j++) {\n\t\t\tGF_CommandField *field = gf_list_get(com->command_fields, j);\n\t\t\tswitch (field->fieldType) {\n\t\t\tcase GF_SG_VRML_SFNODE:\n\t\t\t\tif (field->new_node) {\n\t\t\t\t\tif (gf_node_parent_of(field->new_node, node)) return 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_SG_VRML_MFNODE:\n\t\t\t\tif (field->field_ptr) {\n\t\t\t\t\tGF_ChildNodeItem *child;\n\t\t\t\t\tchild = field->node_list;\n\t\t\t\t\twhile (child) {\n\t\t\t\t\t\tif (gf_node_parent_of(child->node, node)) return 1;\n\t\t\t\t\t\tchild = child->next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2470,
        "func": "bool config_remove_key(config_t *config, const char *section, const char *key) {\n  assert(config != NULL);\n  assert(section != NULL);\n  assert(key != NULL);\n\n section_t *sec = section_find(config, section);\n entry_t *entry = entry_find(config, section, key);\n if (!sec || !entry)\n return false;\n\n return list_remove(sec->entries, entry);\n}\n",
        "target": 0
    },
    {
        "id": 2471,
        "func": "Browser* Browser::GetTabbedBrowser(Profile* profile, bool match_incognito) {\n  return BrowserList::FindBrowserWithType(profile, TYPE_NORMAL,\n                                          match_incognito);\n}\n",
        "target": 0
    },
    {
        "id": 2472,
        "func": "bool AutofillDownloadManager::StartUploadRequest(\n    const FormStructure& form,\n    bool form_was_autofilled,\n    const FieldTypeSet& available_field_types) {\n  if (next_upload_request_ > base::Time::Now()) {\n    VLOG(1) << \"AutofillDownloadManager: Upload request is throttled.\";\n    return false;\n  }\n\n   double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :\n                                              GetNegativeUploadRate();\n  if (base::RandDouble() > upload_rate) {\n     VLOG(1) << \"AutofillDownloadManager: Upload request is ignored.\";\n     return false;\n  }\n\n  std::string form_xml;\n  if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,\n                                &form_xml))\n    return false;\n\n  FormRequestData request_data;\n  request_data.form_signatures.push_back(form.FormSignature());\n  request_data.request_type = AutofillDownloadManager::REQUEST_UPLOAD;\n\n  return StartRequest(form_xml, request_data);\n}\n",
        "target": 1
    },
    {
        "id": 2473,
        "func": "int Document::LockedDisplayLockCount() const {\n  return locked_display_lock_count_;\n}\n",
        "target": 0
    },
    {
        "id": 2474,
        "func": "parse_asntime_into_isotime (unsigned char const **buf, size_t *len,\n                            ksba_isotime_t isotime)\n{\n  struct tag_info ti;\n  gpg_error_t err;\n\n  err = _ksba_ber_parse_tl (buf, len, &ti);\n  if (err)\n    ;\n  else if ( !(ti.class == CLASS_UNIVERSAL\n               && (ti.tag == TYPE_UTC_TIME || ti.tag == TYPE_GENERALIZED_TIME)\n               && !ti.is_constructed) )\n     err = gpg_error (GPG_ERR_INV_OBJ);\n  else if (ti.length > *len)\n    err = gpg_error (GPG_ERR_INV_BER);\n   else if (!(err = _ksba_asntime_to_iso (*buf, ti.length,\n                                          ti.tag == TYPE_UTC_TIME, isotime)))\n     parse_skip (buf, len, &ti);\n}\n",
        "target": 0
    },
    {
        "id": 2475,
        "func": "    void onLoadingChanged(QWebLoadRequest* loadRequest)\n    {\n        if (loadRequest->status() == QQuickWebView::LoadStartedStatus) {\n            QMetaObject::invokeMethod(this, \"finished\", Qt::QueuedConnection);\n\n            QCOMPARE(m_webView->loading(), true);\n        }\n    }\n",
        "target": 0
    },
    {
        "id": 2476,
        "func": "void ass_shaper_set_kerning(ASS_Shaper *shaper, int kern)\n{\n#ifdef CONFIG_HARFBUZZ\n    shaper->features[KERN].value = !!kern;\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 2477,
        "func": "void ShellWindow::ToggleFullscreenModeForTab(content::WebContents* source,\n                                             bool enter_fullscreen) {\n  DCHECK(source == web_contents_);\n  SetFullscreen(enter_fullscreen);\n}\n",
        "target": 0
    },
    {
        "id": 2478,
        "func": "PHP_FUNCTION(openssl_pbkdf2)\n{\n\tlong key_length = 0, iterations = 0;\n\tchar *password; int password_len;\n\tchar *salt; int salt_len;\n\tchar *method; int method_len = 0;\n\tunsigned char *out_buffer;\n\n\tconst EVP_MD *digest;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ssll|s\",\n\t\t\t\t&password, &password_len,\n\t\t\t\t&salt, &salt_len,\n\t\t\t\t&key_length, &iterations,\n\t\t\t\t&method, &method_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (key_length <= 0 || key_length > INT_MAX) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (method_len) {\n\t\tdigest = EVP_get_digestbyname(method);\n\t} else {\n\t\tdigest = EVP_sha1();\n\t}\n\n\tif (!digest) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown signature algorithm\");\n\t\tRETURN_FALSE;\n\t}\n\n\tout_buffer = emalloc(key_length + 1);\n\tout_buffer[key_length] = '\\0';\n\n\tif (PKCS5_PBKDF2_HMAC(password, password_len, (unsigned char *)salt, salt_len, iterations, digest, key_length, out_buffer) == 1) {\n\t\tRETVAL_STRINGL((char *)out_buffer, key_length, 0);\n\t} else {\n\t\tefree(out_buffer);\n\t\tRETURN_FALSE;\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 2479,
        "func": "GpuCommandBufferStub::GpuCommandBufferStub(\n    GpuChannel* channel,\n    GpuCommandBufferStub* share_group,\n    const gfx::GLSurfaceHandle& handle,\n    const gfx::Size& size,\n    const gpu::gles2::DisallowedFeatures& disallowed_features,\n    const std::string& allowed_extensions,\n    const std::vector<int32>& attribs,\n    gfx::GpuPreference gpu_preference,\n    int32 route_id,\n    int32 surface_id,\n    GpuWatchdog* watchdog,\n    bool software)\n    : channel_(channel),\n      handle_(handle),\n      initial_size_(size),\n      disallowed_features_(disallowed_features),\n      allowed_extensions_(allowed_extensions),\n      requested_attribs_(attribs),\n      gpu_preference_(gpu_preference),\n      route_id_(route_id),\n      software_(software),\n      last_flush_count_(0),\n      allocation_(GpuMemoryAllocation::INVALID_RESOURCE_SIZE, true, true),\n      parent_stub_for_initialization_(),\n      parent_texture_for_initialization_(0),\n      watchdog_(watchdog) {\n  if (share_group) {\n    context_group_ = share_group->context_group_;\n  } else {\n    context_group_ = new gpu::gles2::ContextGroup(true);\n  }\n  if (surface_id != 0)\n    surface_state_.reset(new GpuCommandBufferStubBase::SurfaceState(\n        surface_id, true, base::TimeTicks::Now()));\n}\n",
        "target": 0
    },
    {
        "id": 2480,
        "func": "static NTSTATUS do_connect(TALLOC_CTX *ctx,\n\t\t\t\t\tconst char *server,\n\t\t\t\t\tconst char *share,\n\t\t\t\t\tconst struct user_auth_info *auth_info,\n\t\t\t\t\tbool show_sessetup,\n\t\t\t\t\tbool force_encrypt,\n\t\t\t\t\tint max_protocol,\n\t\t\t\t\tint port,\n\t\t\t\t\tint name_type,\n\t\t\t\t\tstruct cli_state **pcli)\n{\n\tstruct cli_state *c = NULL;\n\tchar *servicename;\n\tchar *sharename;\n\tchar *newserver, *newshare;\n\tconst char *username;\n\tconst char *password;\n        const char *domain;\n        NTSTATUS status;\n        int flags = 0;\n \n        /* make a copy so we don't modify the global string 'service' */\n        servicename = talloc_strdup(ctx,share);\n\t\tsharename += 2;\n\t\tif (server == NULL) {\n\t\t\tserver = sharename;\n\t\t}\n\t\tsharename = strchr_m(sharename,'\\\\');\n\t\tif (!sharename) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\t*sharename = 0;\n\t\tsharename++;\n\t}\n",
        "target": 1
    },
    {
        "id": 2481,
        "func": "void TestingAutomationProvider::NavigationAsync(int handle,\n                                                const GURL& url,\n                                                bool* status) {\n  NavigationAsyncWithDisposition(handle, url, CURRENT_TAB, status);\n}\n",
        "target": 0
    },
    {
        "id": 2482,
        "func": "static int mov_write_enda_tag_be(AVIOContext *pb)\n{\n  avio_wb32(pb, 10);\n  ffio_wfourcc(pb, \"enda\");\n  avio_wb16(pb, 0); /* big endian */\n  return 10;\n}",
        "target": 0
    },
    {
        "id": 2483,
        "func": "luks_unlock_completed_cb (DBusGMethodInvocation *context,\n                          Device *device,\n                          gboolean job_was_cancelled,\n                          int status,\n                          const char *stderr,\n                          const char *stdout,\n                          gpointer user_data)\n{\n  UnlockEncryptionData *data = user_data;\n\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n\n      luks_unlock_start_waiting_for_cleartext_device (unlock_encryption_data_ref (data));\n\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error unlocking device: cryptsetup exited with exit code %d: %s\",\n                       WEXITSTATUS (status),\n                       stderr);\n        }\n      if (data->hook_func != NULL)\n        {\n          data->hook_func (data->context, NULL, data->hook_user_data);\n        }\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2484,
        "func": "static void add_assoc_asn1_string(zval * val, char * key, ASN1_STRING * str) /* {{{ */\n{\n\tadd_assoc_stringl(val, key, (char *)str->data, str->length);\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 2485,
        "func": "xmlXPathDebugDumpLocationSet(FILE *output, xmlLocationSetPtr cur, int depth) {\n    int i;\n    char shift[100];\n\n    for (i = 0;((i < depth) && (i < 25));i++)\n        shift[2 * i] = shift[2 * i + 1] = ' ';\n    shift[2 * i] = shift[2 * i + 1] = 0;\n\n    if (cur == NULL) {\n\tfprintf(output, \"%s\", shift);\n\tfprintf(output, \"LocationSet is NULL !\\n\");\n\treturn;\n\n    }\n\n    for (i = 0;i < cur->locNr;i++) {\n\tfprintf(output, \"%s\", shift);\n        fprintf(output, \"%d : \", i + 1);\n\txmlXPathDebugDumpObject(output, cur->locTab[i], depth + 1);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2486,
        "func": "  int64 global_unlimited_usage() const { return global_unlimited_usage_; }\n",
        "target": 0
    },
    {
        "id": 2487,
        "func": "void freeClientAsync(client *c) {\n    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_LUA) return;\n    c->flags |= CLIENT_CLOSE_ASAP;\n    listAddNodeTail(server.clients_to_close,c);\n}\n",
        "target": 0
    },
    {
        "id": 2488,
        "func": "WebContext::WebContext(WebContextProxyClient* client,\n                       QObject* handle)\n    : client_(client),\n      construct_props_(new ConstructProperties()),\n      weak_factory_(this) {\n  DCHECK(client);\n  DCHECK(handle);\n\n  setHandle(handle);\n\n  delegate_ = new BrowserContextDelegate(weak_factory_.GetWeakPtr());\n\n  static_assert(\n      CookiePolicyAllowAll == static_cast<CookiePolicy>(\n        net::StaticCookiePolicy::ALLOW_ALL_COOKIES),\n      \"CookiePolicy and net::StaticCookiePolicy::Type values don't match: \"\n      \"CookiePolicyAllowAll\");\n  static_assert(\n      CookiePolicyBlockAll == static_cast<CookiePolicy>(\n        net::StaticCookiePolicy::BLOCK_ALL_COOKIES),\n      \"CookiePolicy and net::StaticCookiePolicy::Type values don't match: \"\n      \"CookiePolicyBlockAll\");\n  static_assert(\n      CookiePolicyBlockThirdParty == static_cast<CookiePolicy>(\n        net::StaticCookiePolicy::BLOCK_ALL_THIRD_PARTY_COOKIES),\n      \"CookiePolicy and net::StaticCookiePolicy::Type values don't match: \"\n      \"CookiePolicyBlockThirdParty\");\n\n  static_assert(\n      SessionCookieModeEphemeral == static_cast<SessionCookieMode>(\n        content::CookieStoreConfig::EPHEMERAL_SESSION_COOKIES),\n      \"SessionCookieMode and net::CookieStoreConfig::SessionCookieMode values \"\n      \"don't match: SessionCookieModeEphemeral\");\n  static_assert(\n      SessionCookieModePersistent == static_cast<SessionCookieMode>(\n        content::CookieStoreConfig::PERSISTANT_SESSION_COOKIES),\n      \"SessionCookieMode and net::CookieStoreConfig::SessionCookieMode values \"\n      \"don't match: SessionCookieModePersistent\");\n  static_assert(\n      SessionCookieModeRestored == static_cast<SessionCookieMode>(\n        content::CookieStoreConfig::RESTORED_SESSION_COOKIES),\n      \"SessionCookieMode and net::CookieStoreConfig::SessionCookieMode values \"\n      \"don't match: SessionCookieModeRestored\");\n}\n",
        "target": 0
    },
    {
        "id": 2489,
        "func": "static void GetRedirectChain(WebDataSource* ds, std::vector<GURL>* result) {\n  WebVector<WebURL> urls;\n  ds->redirectChain(urls);\n  result->reserve(urls.size());\n  for (size_t i = 0; i < urls.size(); ++i)\n    result->push_back(urls[i]);\n}\n",
        "target": 0
    },
    {
        "id": 2490,
        "func": "static void encode_locku(struct xdr_stream *xdr, const struct nfs_locku_args *args, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 12+NFS4_STATEID_SIZE+16);\n\t*p++ = cpu_to_be32(OP_LOCKU);\n\t*p++ = cpu_to_be32(nfs4_lock_type(args->fl, 0));\n\t*p++ = cpu_to_be32(args->seqid->sequence->counter);\n\tp = xdr_encode_opaque_fixed(p, args->stateid->data, NFS4_STATEID_SIZE);\n\tp = xdr_encode_hyper(p, args->fl->fl_start);\n\txdr_encode_hyper(p, nfs4_lock_length(args->fl));\n\thdr->nops++;\n\thdr->replen += decode_locku_maxsz;\n}",
        "target": 0
    },
    {
        "id": 2491,
        "func": " void XMLHttpRequest::didFailRedirectCheck()\n {\n    networkError();\n }\n",
        "target": 1
    },
    {
        "id": 2492,
        "func": "    QuotaManagedDataDeletionHelper::DecrementTaskCountOnIO() {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  DCHECK_GT(task_count_, 0);\n  --task_count_;\n  if (task_count_)\n    return;\n\n  std::move(callback_).Run();\n  delete this;\n}\n",
        "target": 0
    },
    {
        "id": 2493,
        "func": "SplashCoord Splash::getLineDashPhase() {\n  return state->lineDashPhase;\n}\n",
        "target": 0
    },
    {
        "id": 2494,
        "func": " static inline bool hasOneChild(ContainerNode* node)\n {\n     Node* firstChild = node->firstChild();\n    return firstChild && !firstChild->nextSibling();\n}\n",
        "target": 0
    },
    {
        "id": 2495,
        "func": "static void ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeSetter(\n    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Isolate* isolate = info.GetIsolate();\n  ALLOW_UNUSED_LOCAL(isolate);\n\n  v8::Local<v8::Object> holder = info.Holder();\n  ALLOW_UNUSED_LOCAL(holder);\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  ExceptionState exception_state(isolate, ExceptionState::kSetterContext, \"TestObject\", \"activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute\");\n\n  int32_t cpp_value = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), v8_value, exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->setActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute(cpp_value);\n}\n",
        "target": 0
    },
    {
        "id": 2496,
        "func": "void LockContentsView::RemoveUser(bool is_primary) {\n  if (Shell::Get()->login_screen_controller()->IsAuthenticating())\n    return;\n\n  LoginBigUserView* to_remove =\n      is_primary ? primary_big_view_ : opt_secondary_big_view_;\n  DCHECK(to_remove->GetCurrentUser()->can_remove);\n  AccountId user = to_remove->GetCurrentUser()->basic_user_info->account_id;\n\n  Shell::Get()->login_screen_controller()->RemoveUser(user);\n\n  std::vector<mojom::LoginUserInfoPtr> new_users;\n  if (!is_primary)\n    new_users.push_back(primary_big_view_->GetCurrentUser()->Clone());\n  if (is_primary && opt_secondary_big_view_)\n    new_users.push_back(opt_secondary_big_view_->GetCurrentUser()->Clone());\n  if (users_list_) {\n    for (int i = 0; i < users_list_->user_count(); ++i) {\n      new_users.push_back(\n          users_list_->user_view_at(i)->current_user()->Clone());\n    }\n  }\n  data_dispatcher_->NotifyUsers(new_users);\n}\n",
        "target": 0
    },
    {
        "id": 2497,
        "func": "static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\t*newoffs = -1;\n\t\treturn -1;\n\t}\n        ret = php_stream_seek(ts->innerstream, offset, whence);\n        *newoffs = php_stream_tell(ts->innerstream);\n        stream->eof = ts->innerstream->eof;\n        return ret;\n }\n",
        "target": 1
    },
    {
        "id": 2498,
        "func": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n\n  gnutls_datum_t psession;\n  int ret;\n\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n\n  psession.data = session_data;\n\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n       gnutls_assert ();\n       return ret;\n     }\n  *session_data_size = psession.size;\n \n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n \n   if (session_data != NULL)\n     memcpy (session_data, psession.data, psession.size);\n\n  ret = 0;\n\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}\n",
        "target": 1
    },
    {
        "id": 2499,
        "func": "  GenerationElementData(autofill::PasswordForm form,\n                        autofill::FormSignature form_signature,\n                        autofill::FieldSignature field_signature,\n                        uint32_t max_password_length)\n      : form(std::move(form)),\n        form_signature(form_signature),\n        field_signature(field_signature),\n        max_password_length(max_password_length) {}\n",
        "target": 1
    },
    {
        "id": 2500,
        "func": "xsltCopyOfComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemCopyOfPtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemCopyOfPtr) xsltNewStylePreComp(style, XSLT_FUNC_COPYOF);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_COPYOF);\n#endif\n\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n\n    comp->select = xsltGetCNsProp(style, inst, (const xmlChar *)\"select\",\n\t                        XSLT_NAMESPACE);\n    if (comp->select == NULL) {\n\txsltTransformError(NULL, style, inst,\n\t     \"xsl:copy-of : select is missing\\n\");\n\tif (style != NULL) style->errors++;\n\treturn;\n    }\n    comp->comp = xsltXPathCompile(style, comp->select);\n    if (comp->comp == NULL) {\n\txsltTransformError(NULL, style, inst,\n\t     \"xsl:copy-of : could not compile select expression '%s'\\n\",\n\t                 comp->select);\n\tif (style != NULL) style->errors++;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2501,
        "func": "u32 h264bsdStoreSeqParamSet(storage_t *pStorage, seqParamSet_t *pSeqParamSet)\n{\n\n/* Variables */\n\n    u32 id;\n\n/* Code */\n\n    ASSERT(pStorage);\n    ASSERT(pSeqParamSet);\n    ASSERT(pSeqParamSet->seqParameterSetId < MAX_NUM_SEQ_PARAM_SETS);\n\n    id = pSeqParamSet->seqParameterSetId;\n\n /* seq parameter set with id not used before -> allocate memory */\n if (pStorage->sps[id] == NULL)\n {\n        ALLOCATE(pStorage->sps[id], 1, seqParamSet_t);\n if (pStorage->sps[id] == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n }\n /* sequence parameter set with id equal to id of active sps */\n else if (id == pStorage->activeSpsId)\n {\n /* if seq parameter set contents changes\n         *    -> overwrite and re-activate when next IDR picture decoded\n         *    ids of active param sets set to invalid values to force\n         *    re-activation. Memories allocated for old sps freed\n         * otherwise free memeries allocated for just decoded sps and\n         * continue */\n if (h264bsdCompareSeqParamSets(pSeqParamSet, pStorage->activeSps) != 0)\n {\n            FREE(pStorage->sps[id]->offsetForRefFrame);\n            FREE(pStorage->sps[id]->vuiParameters);\n            pStorage->activeSpsId = MAX_NUM_SEQ_PARAM_SETS + 1;\n            pStorage->activePpsId = MAX_NUM_PIC_PARAM_SETS + 1;\n            pStorage->activeSps = NULL;\n            pStorage->activePps = NULL;\n }\n else\n {\n            FREE(pSeqParamSet->offsetForRefFrame);\n            FREE(pSeqParamSet->vuiParameters);\n return(HANTRO_OK);\n }\n }\n /* overwrite seq param set other than active one -> free memories\n     * allocated for old param set */\n else\n {\n        FREE(pStorage->sps[id]->offsetForRefFrame);\n        FREE(pStorage->sps[id]->vuiParameters);\n }\n\n *pStorage->sps[id] = *pSeqParamSet;\n\n return(HANTRO_OK);\n\n}\n",
        "target": 0
    },
    {
        "id": 2502,
        "func": "void snro_del(GF_Box *s)\n{\n\tGF_SeqOffHintEntryBox *snro = (GF_SeqOffHintEntryBox *)s;\n\tgf_free(snro);\n}",
        "target": 0
    },
    {
        "id": 2503,
        "func": "static int tcp_v4_md5_hash_hdr(char *md5_hash, struct tcp_md5sig_key *key,\n\t\t\t       __be32 daddr, __be32 saddr, struct tcphdr *th)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct hash_desc *desc;\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\tdesc = &hp->md5_desc;\n\n\tif (crypto_hash_init(desc))\n\t\tgoto clear_hash;\n\tif (tcp_v4_md5_hash_pseudoheader(hp, daddr, saddr, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_header(hp, th))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tif (crypto_hash_final(desc, md5_hash))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 2504,
        "func": "static int em_push(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct segmented_address addr;\n\n\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP], -ctxt->op_bytes);\n\taddr.ea = register_address(ctxt, ctxt->regs[VCPU_REGS_RSP]);\n\taddr.seg = VCPU_SREG_SS;\n\n\t/* Disable writeback. */\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, addr, &ctxt->src.val, ctxt->op_bytes);\n}",
        "target": 0
    },
    {
        "id": 2505,
        "func": "std::unique_ptr<TracedValue> InspectorXhrLoadEvent::Data(\n    ExecutionContext* context,\n    XMLHttpRequest* request) {\n  std::unique_ptr<TracedValue> value = TracedValue::Create();\n  value->SetString(\"url\", request->Url().GetString());\n  if (LocalFrame* frame = FrameForExecutionContext(context))\n    value->SetString(\"frame\", ToHexString(frame));\n  SetCallStack(value.get());\n  return value;\n}\n",
        "target": 0
    },
    {
        "id": 2506,
        "func": "static int asepcos_list_files(sc_card_t *card, u8 *buf, size_t blen)\n{\n\tint       r, rv = 0, dfFID, efFID;\n\tsc_path_t bpath, tpath;\n\tsc_file_t *tfile = NULL;\n\n\t/* 1. get currently selected DF */\n\tr = asepcos_get_current_df_path(card, &bpath);\n\tif (r != SC_SUCCESS)\n\t\treturn r;\n\t/* 2. re-select DF to get the FID of the child EFs/DFs */\n\tr = sc_select_file(card, &bpath, &tfile);\n\tif (r != SC_SUCCESS)\n\t\treturn r;\n\tif (tfile->prop_attr_len != 6 || tfile->prop_attr == NULL) {\n\t\tsc_file_free(tfile);\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"unable to parse proprietary FCI attributes\");\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tdfFID = (tfile->prop_attr[2] << 8) | tfile->prop_attr[3];\n\tefFID = (tfile->prop_attr[4] << 8) | tfile->prop_attr[5];\n\tsc_file_free(tfile);\n\t/* 3. select every child DF to get the FID of the next child DF */\n\twhile (dfFID != 0) {\n\t\t/* put DF FID on the list */\n\t\tif (blen < 2)\n\t\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t\t*buf++ = (dfFID >> 8) & 0xff;\n\t\t*buf++ = dfFID & 0xff;\n\t\trv   += 2;\n\t\tblen -= 2;\n\t\t/* select DF to get next DF FID */\n\t\ttpath = bpath;\n\t\tr = sc_append_file_id(&tpath, dfFID);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tr = sc_select_file(card, &tpath, &tfile);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tif (tfile->prop_attr_len != 6 || tfile->prop_attr == NULL)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tdfFID = (tfile->prop_attr[0] << 8) | tfile->prop_attr[1];\n\t\tsc_file_free(tfile);\n\t}\n\t/* 4. select every child EF ... */\n\twhile (efFID != 0) {\n\t\t/* put DF FID on the list */\n\t\tif (blen < 2)\n\t\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t\t*buf++ = (efFID >> 8) & 0xff;\n\t\t*buf++ = efFID & 0xff;\n\t\trv   += 2;\n\t\tblen -= 2;\n\t\t/* select EF to get next EF FID */\n\t\ttpath = bpath;\n\t\tr = sc_append_file_id(&tpath, efFID);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tr = sc_select_file(card, &tpath, &tfile);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tif (tfile->prop_attr_len < 2 || tfile->prop_attr == NULL)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tefFID = (tfile->prop_attr[0] << 8) | tfile->prop_attr[1];\n\t\tsc_file_free(tfile);\n\t}\n\n\treturn rv;\n}\n",
        "target": 0
    },
    {
        "id": 2507,
        "func": "void LockScreenMediaControlsView::MediaSessionPositionChanged(\n    const base::Optional<media_session::MediaPosition>& position) {\n  if (hide_controls_timer_->IsRunning())\n    return;\n\n  position_ = position;\n\n  if (!position.has_value()) {\n    if (progress_->GetVisible()) {\n      progress_->SetVisible(false);\n      Layout();\n    }\n    return;\n  }\n\n  progress_->UpdateProgress(*position);\n\n  if (!progress_->GetVisible()) {\n    progress_->SetVisible(true);\n    Layout();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2508,
        "func": "static inline void format_ipmb_msg(struct ipmi_smi_msg   *smi_msg,\n\t\t\t\t   struct kernel_ipmi_msg *msg,\n\t\t\t\t   struct ipmi_ipmb_addr *ipmb_addr,\n\t\t\t\t   long                  msgid,\n\t\t\t\t   unsigned char         ipmb_seq,\n\t\t\t\t   int                   broadcast,\n\t\t\t\t   unsigned char         source_address,\n\t\t\t\t   unsigned char         source_lun)\n{\n\tint i = broadcast;\n\n\t/* Format the IPMB header data. */\n\tsmi_msg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\n\tsmi_msg->data[1] = IPMI_SEND_MSG_CMD;\n\tsmi_msg->data[2] = ipmb_addr->channel;\n\tif (broadcast)\n\t\tsmi_msg->data[3] = 0;\n\tsmi_msg->data[i+3] = ipmb_addr->slave_addr;\n\tsmi_msg->data[i+4] = (msg->netfn << 2) | (ipmb_addr->lun & 0x3);\n\tsmi_msg->data[i+5] = ipmb_checksum(&smi_msg->data[i + 3], 2);\n\tsmi_msg->data[i+6] = source_address;\n\tsmi_msg->data[i+7] = (ipmb_seq << 2) | source_lun;\n\tsmi_msg->data[i+8] = msg->cmd;\n\n\t/* Now tack on the data to the message. */\n\tif (msg->data_len > 0)\n\t\tmemcpy(&smi_msg->data[i + 9], msg->data, msg->data_len);\n\tsmi_msg->data_size = msg->data_len + 9;\n\n\t/* Now calculate the checksum and tack it on. */\n\tsmi_msg->data[i+smi_msg->data_size]\n\t\t= ipmb_checksum(&smi_msg->data[i + 6], smi_msg->data_size - 6);\n\n\t/*\n\t * Add on the checksum size and the offset from the\n\t * broadcast.\n\t */\n\tsmi_msg->data_size += 1 + i;\n\n\tsmi_msg->msgid = msgid;\n}",
        "target": 0
    },
    {
        "id": 2509,
        "func": "static int loop_lookup(struct loop_device **l, int i)\n{\n\tstruct loop_device *lo;\n\tint ret = -ENODEV;\n\n\tif (i < 0) {\n\t\tint err;\n\n\t\terr = idr_for_each(&loop_index_idr, &find_free_cb, &lo);\n\t\tif (err == 1) {\n\t\t\t*l = lo;\n\t\t\tret = lo->lo_number;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* lookup and return a specific i */\n\tlo = idr_find(&loop_index_idr, i);\n\tif (lo) {\n\t\t*l = lo;\n\t\tret = lo->lo_number;\n\t}\nout:\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 2510,
        "func": " const char* GetSRTDownloadURL() {\n  if (base::StartsWith(base::FieldTrialList::FindFullName(kSRTPromptTrial),\n                       kSRTCanaryGroup, base::CompareCase::SENSITIVE)) {\n     return kCanarySRTDownloadURL;\n  }\n   return kMainSRTDownloadURL;\n }\n",
        "target": 0
    },
    {
        "id": 2511,
        "func": "format_PUSH_MPLS(const struct ofpact_push_mpls *a, struct ds *s)\n{\n    ds_put_format(s, \"%spush_mpls:%s0x%04\"PRIx16,\n                  colors.param, colors.end, ntohs(a->ethertype));\n}\n",
        "target": 0
    },
    {
        "id": 2512,
        "func": "int vm_insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page)\n{\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\tif (!page_count(page))\n\t\treturn -EINVAL;\n\tvma->vm_flags |= VM_INSERTPAGE;\n\treturn insert_page(vma, addr, page, vma->vm_page_prot);\n}\n",
        "target": 0
    },
    {
        "id": 2513,
        "func": "static void perf_event_output(struct perf_event *event, int nmi,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_event_header header;\n\n\t/* protect the callchain buffers */\n\trcu_read_lock();\n\n\tperf_prepare_sample(&header, data, event, regs);\n\n\tif (perf_output_begin(&handle, event, header.size, nmi, 1))\n\t\tgoto exit;\n\n\tperf_output_sample(&handle, &header, data, event);\n\n\tperf_output_end(&handle);\n\nexit:\n\trcu_read_unlock();\n}",
        "target": 1
    },
    {
        "id": 2514,
        "func": "void RendererSchedulerImpl::OnVirtualTimeAdvanced() {\n  for (auto& observer : main_thread_only().virtual_time_observers) {\n    observer.OnVirtualTimeAdvanced(virtual_time_domain_->Now() -\n                                   main_thread_only().initial_virtual_time);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2515,
        "func": " Response StorageHandler::Disable() {\n  if (cache_storage_observer_) {\n    BrowserThread::DeleteSoon(BrowserThread::IO, FROM_HERE,\n                              cache_storage_observer_.release());\n  }\n  if (indexed_db_observer_) {\n    scoped_refptr<base::SequencedTaskRunner> observer_task_runner =\n        indexed_db_observer_->TaskRunner();\n    observer_task_runner->DeleteSoon(FROM_HERE,\n                                     std::move(indexed_db_observer_));\n  }\n\n  return Response::OK();\n}\n",
        "target": 0
    },
    {
        "id": 2516,
        "func": "transaction_id_pick(struct evdns_base *base) {\n\tASSERT_LOCKED(base);\n\tfor (;;) {\n\t\tu16 trans_id;\n\t\tevutil_secure_rng_get_bytes(&trans_id, sizeof(trans_id));\n\n\t\tif (trans_id == 0xffff) continue;\n\t\t/* now check to see if that id is already inflight */\n\t\tif (request_find_from_trans_id(base, trans_id) == NULL)\n\t\t\treturn trans_id;\n\t}\n}",
        "target": 0
    },
    {
        "id": 2517,
        "func": "static void hci_sock_cmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct sk_buff *skb)\n{\n\t__u32 mask = hci_pi(sk)->cmsg_mask;\n\n\tif (mask & HCI_CMSG_DIR) {\n\t\tint incoming = bt_cb(skb)->incoming;\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_DIR, sizeof(incoming),\n\t\t\t &incoming);\n\t}\n\n\tif (mask & HCI_CMSG_TSTAMP) {\n#ifdef CONFIG_COMPAT\n\t\tstruct compat_timeval ctv;\n#endif\n\t\tstruct timeval tv;\n\t\tvoid *data;\n\t\tint len;\n\n\t\tskb_get_timestamp(skb, &tv);\n\n\t\tdata = &tv;\n\t\tlen = sizeof(tv);\n#ifdef CONFIG_COMPAT\n\t\tif (!COMPAT_USE_64BIT_TIME &&\n\t\t    (msg->msg_flags & MSG_CMSG_COMPAT)) {\n\t\t\tctv.tv_sec = tv.tv_sec;\n\t\t\tctv.tv_usec = tv.tv_usec;\n\t\t\tdata = &ctv;\n\t\t\tlen = sizeof(ctv);\n\t\t}\n#endif\n\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_TSTAMP, len, data);\n\t}\n}",
        "target": 0
    },
    {
        "id": 2518,
        "func": "static int asn1_encode_path(sc_context_t *ctx, const sc_path_t *path,\n\t\t\t    u8 **buf, size_t *bufsize, int depth, unsigned int parent_flags)\n{\n\tint r;\n \tstruct sc_asn1_entry asn1_path[5];\n\tsc_path_t tpath = *path;\n\n\tsc_copy_asn1_entry(c_asn1_path, asn1_path);\n\tsc_format_asn1_entry(asn1_path + 0, (void *) &tpath.value, (void *) &tpath.len, 1);\n\n\tasn1_path[0].flags |= parent_flags;\n\tif (path->count > 0) {\n\t\tsc_format_asn1_entry(asn1_path + 1, (void *) &tpath.index, NULL, 1);\n\t\tsc_format_asn1_entry(asn1_path + 2, (void *) &tpath.count, NULL, 1);\n\t}\n\tr = asn1_encode(ctx, asn1_path, buf, bufsize, depth + 1);\n\treturn r;\n}",
        "target": 0
    },
    {
        "id": 2519,
        "func": "static void get_prop_set(unsigned long prop_set,\n\t\t\t const struct tee_props **props,\n\t\t\t size_t *size,\n\t\t\t const struct tee_props **vendor_props,\n\t\t\t size_t *vendor_size)\n{\n\tif ((TEE_PropSetHandle)prop_set == TEE_PROPSET_CURRENT_CLIENT) {\n\t\t*props = tee_propset_client;\n\t\t*size = ARRAY_SIZE(tee_propset_client);\n\t\t*vendor_props = vendor_props_client.props;\n\t\t*vendor_size = vendor_props_client.len;\n\t} else if ((TEE_PropSetHandle)prop_set == TEE_PROPSET_CURRENT_TA) {\n\t\t*props = tee_propset_ta;\n\t\t*size = ARRAY_SIZE(tee_propset_ta);\n\t\t*vendor_props = vendor_props_ta.props;\n\t\t*vendor_size = vendor_props_ta.len;\n\t} else if ((TEE_PropSetHandle)prop_set ==\n\t\t   TEE_PROPSET_TEE_IMPLEMENTATION) {\n\t\t*props = tee_propset_tee;\n\t\t*size = ARRAY_SIZE(tee_propset_tee);\n\t\t*vendor_props = vendor_props_tee.props;\n\t\t*vendor_size = vendor_props_tee.len;\n\t} else {\n\t\t*props = NULL;\n\t\t*size = 0;\n\t\t*vendor_props = NULL;\n\t\t*vendor_size = 0;\n\t}\n}",
        "target": 0
    },
    {
        "id": 2520,
        "func": "int TabStrip::GenerateIdealBoundsForMiniTabs(int* first_non_mini_index) {\n  int next_x = 0;\n  int mini_width = Tab::GetMiniWidth();\n  int tab_height = Tab::GetStandardSize().height();\n  int index = 0;\n  for (; index < tab_count() && tab_at(index)->data().mini; ++index) {\n    set_ideal_bounds(index,\n                     gfx::Rect(next_x, 0, mini_width, tab_height));\n    next_x += mini_width + tab_h_offset();\n  }\n  if (index > 0 && index < tab_count())\n    next_x += kMiniToNonMiniGap;\n  if (first_non_mini_index)\n    *first_non_mini_index = index;\n  return next_x;\n}\n",
        "target": 0
    },
    {
        "id": 2521,
        "func": "void lodepng_chunk_type(char type[5], const unsigned char* chunk)\n{\n  unsigned i;\n  for(i = 0; i < 4; i++) type[i] = (char)chunk[4 + i];\n  type[4] = 0; /*null termination char*/\n}\n",
        "target": 0
    },
    {
        "id": 2522,
        "func": "void BluetoothAdapter::AddPairingDelegate(\n    BluetoothDevice::PairingDelegate* pairing_delegate,\n    PairingDelegatePriority priority) {\n  RemovePairingDelegate(pairing_delegate);\n\n  auto iter = pairing_delegates_.begin();\n  while (iter != pairing_delegates_.end() && iter->second >= priority)\n    ++iter;\n\n  pairing_delegates_.insert(iter, std::make_pair(pairing_delegate, priority));\n}\n",
        "target": 0
    },
    {
        "id": 2523,
        "func": "struct posix_acl *get_acl(struct inode *inode, int type)\n{\n\tvoid *sentinel;\n\tstruct posix_acl **p;\n\tstruct posix_acl *acl;\n\n\t/*\n\t * The sentinel is used to detect when another operation like\n\t * set_cached_acl() or forget_cached_acl() races with get_acl().\n\t * It is guaranteed that is_uncached_acl(sentinel) is true.\n\t */\n\n\tacl = get_cached_acl(inode, type);\n\tif (!is_uncached_acl(acl))\n\t\treturn acl;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn NULL;\n\n\tsentinel = uncached_acl_sentinel(current);\n\tp = acl_by_type(inode, type);\n\n\t/*\n\t * If the ACL isn't being read yet, set our sentinel.  Otherwise, the\n\t * current value of the ACL will not be ACL_NOT_CACHED and so our own\n\t * sentinel will not be set; another task will update the cache.  We\n\t * could wait for that other task to complete its job, but it's easier\n\t * to just call ->get_acl to fetch the ACL ourself.  (This is going to\n\t * be an unlikely race.)\n\t */\n\tif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\n\t\t/* fall through */ ;\n\n\t/*\n\t * Normally, the ACL returned by ->get_acl will be cached.\n\t * A filesystem can prevent that by calling\n\t * forget_cached_acl(inode, type) in ->get_acl.\n\t *\n\t * If the filesystem doesn't have a get_acl() function at all, we'll\n\t * just create the negative cache entry.\n\t */\n\tif (!inode->i_op->get_acl) {\n\t\tset_cached_acl(inode, type, NULL);\n\t\treturn NULL;\n\t}\n\tacl = inode->i_op->get_acl(inode, type);\n\n\tif (IS_ERR(acl)) {\n\t\t/*\n\t\t * Remove our sentinel so that we don't block future attempts\n\t\t * to cache the ACL.\n\t\t */\n\t\tcmpxchg(p, sentinel, ACL_NOT_CACHED);\n\t\treturn acl;\n\t}\n\n\t/*\n\t * Cache the result, but only if our sentinel is still in place.\n\t */\n\tposix_acl_dup(acl);\n\tif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\n\t\tposix_acl_release(acl);\n\treturn acl;\n}",
        "target": 0
    },
    {
        "id": 2524,
        "func": "static PHP_MINFO_FUNCTION(pcre)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_row(2, \"PCRE (Perl Compatible Regular Expressions) Support\", \"enabled\" );\n\tphp_info_print_table_row(2, \"PCRE Library Version\", pcre_version() );\n\tphp_info_print_table_end();\n\n\tDISPLAY_INI_ENTRIES();\n}\n",
        "target": 0
    },
    {
        "id": 2525,
        "func": "PHP_METHOD(Phar, mapPhar)\n{\n\tchar *alias = NULL, *error;\n\tsize_t alias_len = 0;\n\tzend_long dataoffset = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|s!l\", &alias, &alias_len, &dataoffset) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize();\n\n\tRETVAL_BOOL(phar_open_executed_filename(alias, alias_len, &error) == SUCCESS);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"%s\", error);\n\t\tefree(error);\n\t}\n} /* }}} */\n\n/* {{{ proto mixed Phar::loadPhar(string filename [, string alias])\n",
        "target": 0
    },
    {
        "id": 2526,
        "func": "int vm_sockets_get_local_cid(void)\n{\n\treturn transport->get_local_cid();\n}",
        "target": 0
    },
    {
        "id": 2527,
        "func": "void usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,\n\t\t\t   struct scatterlist *sg, int n_hw_ents)\n{\n\tstruct usb_bus\t\t*bus;\n\tstruct device\t\t*controller;\n\n\tif (!dev\n\t\t\t|| !(bus = dev->bus)\n\t\t\t|| !(controller = bus->sysdev)\n\t\t\t|| !controller->dma_mask)\n\t\treturn;\n\n\tdma_sync_sg_for_cpu(controller, sg, n_hw_ents,\n\t\t\t    is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n}",
        "target": 0
    },
    {
        "id": 2528,
        "func": "static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)\n{\n    ExceptionCode ignoredExceptionCode;\n    RefPtr<Node> nextChild;\n    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {\n        nextChild = child->nextSibling();\n        element->removeChild(child.get(), ignoredExceptionCode);\n        ASSERT(!ignoredExceptionCode);\n        fragment->insertBefore(child, element, ignoredExceptionCode);\n        ASSERT(!ignoredExceptionCode);\n    }\n    fragment->removeChild(element, ignoredExceptionCode);\n    ASSERT(!ignoredExceptionCode);\n}\n",
        "target": 1
    },
    {
        "id": 2529,
        "func": "static void cdxl_decode_ham6(CDXLVideoContext *c, AVFrame *frame)\n{\n    AVCodecContext *avctx = c->avctx;\n    uint32_t new_palette[16], r, g, b;\n    uint8_t *ptr, *out, index, op;\n    int x, y;\n\n    ptr = c->new_video;\n    out = frame->data[0];\n\n    import_palette(c, new_palette);\n    import_format(c, avctx->width, c->new_video);\n\n    for (y = 0; y < avctx->height; y++) {\n        r = new_palette[0] & 0xFF0000;\n        g = new_palette[0] & 0xFF00;\n        b = new_palette[0] & 0xFF;\n        for (x = 0; x < avctx->width; x++) {\n            index  = *ptr++;\n            op     = index >> 4;\n            index &= 15;\n            switch (op) {\n            case 0:\n                r = new_palette[index] & 0xFF0000;\n                g = new_palette[index] & 0xFF00;\n                b = new_palette[index] & 0xFF;\n                break;\n            case 1:\n                b = index * 0x11;\n                break;\n            case 2:\n                r = index * 0x11 << 16;\n                break;\n            case 3:\n                g = index * 0x11 << 8;\n                break;\n            }\n            AV_WL24(out + x * 3, r | g | b);\n        }\n        out += frame->linesize[0];\n    }\n}",
        "target": 0
    },
    {
        "id": 2530,
        "func": "static void put_ctx(struct perf_event_context *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tif (ctx->parent_ctx)\n\t\t\tput_ctx(ctx->parent_ctx);\n\t\tif (ctx->task)\n\t\t\tput_task_struct(ctx->task);\n\t\tcall_rcu(&ctx->rcu_head, free_ctx);\n\t}\n}",
        "target": 0
    },
    {
        "id": 2531,
        "func": "static struct dentry *lookup_real(struct inode *dir, struct dentry *dentry,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct dentry *old;\n\n\t/* Don't create child dentry for a dead directory. */\n\tif (unlikely(IS_DEADDIR(dir))) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\told = dir->i_op->lookup(dir, dentry, flags);\n\tif (unlikely(old)) {\n\t\tdput(dentry);\n\t\tdentry = old;\n\t}\n\treturn dentry;\n}",
        "target": 0
    },
    {
        "id": 2532,
        "func": "AP_DECLARE(void) ap_register_errorlog_handler(apr_pool_t *p, char *tag,\n                                              ap_errorlog_handler_fn_t *handler,\n                                              int flags)\n{\n    ap_errorlog_handler *log_struct = apr_palloc(p, sizeof(*log_struct));\n    log_struct->func = handler;\n    log_struct->flags = flags;\n\n    apr_hash_set(errorlog_hash, tag, 1, (const void *)log_struct);\n}\n",
        "target": 0
    },
    {
        "id": 2533,
        "func": "static void migration_end(void)\n{\n    if (migration_bitmap) {\n        memory_global_dirty_log_stop();\n        g_free(migration_bitmap);\n        migration_bitmap = NULL;\n    }\n\n    XBZRLE_cache_lock();\n    if (XBZRLE.cache) {\n        cache_fini(XBZRLE.cache);\n        g_free(XBZRLE.encoded_buf);\n        g_free(XBZRLE.current_buf);\n        XBZRLE.cache = NULL;\n        XBZRLE.encoded_buf = NULL;\n        XBZRLE.current_buf = NULL;\n    }\n    XBZRLE_cache_unlock();\n}\n",
        "target": 0
    },
    {
        "id": 2534,
        "func": "armpmu_read(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\t/* Don't read disabled counters! */\n\tif (hwc->idx < 0)\n\t\treturn;\n\n\tarmpmu_event_update(event, hwc, hwc->idx);\n}",
        "target": 0
    },
    {
        "id": 2535,
        "func": "void qeth_clear_recovery_task(struct qeth_card *card)\n{\n\tcard->recovery_task = NULL;\n}",
        "target": 0
    },
    {
        "id": 2536,
        "func": "   void RunInvAccuracyCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 1000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       double out_r[kNumCoeffs];\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n        src[j] = rnd.Rand8();\n        dst[j] = rnd.Rand8();\n        in[j] = src[j] - dst[j];\n       }\n \n       reference_16x16_dct_2d(in, out_r);\n       for (int j = 0; j < kNumCoeffs; ++j)\n        coeff[j] = round(out_r[j]);\n \n      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, 16));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         const uint32_t diff = dst[j] - src[j];\n         const uint32_t error = diff * diff;\n         EXPECT_GE(1u, error)\n             << \"Error: 16x16 IDCT has error \" << error\n << \" at index \" << j;\n\n       }\n     }\n   }\n",
        "target": 1
    },
    {
        "id": 2537,
        "func": "int rfcomm_dev_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)\n{\n\tBT_DBG(\"cmd %d arg %p\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase RFCOMMCREATEDEV:\n\t\treturn rfcomm_create_dev(sk, arg);\n\n\tcase RFCOMMRELEASEDEV:\n\t\treturn rfcomm_release_dev(arg);\n\n\tcase RFCOMMGETDEVLIST:\n\t\treturn rfcomm_get_dev_list(arg);\n\n\tcase RFCOMMGETDEVINFO:\n\t\treturn rfcomm_get_dev_info(arg);\n\t}\n\n\treturn -EINVAL;\n}",
        "target": 0
    },
    {
        "id": 2538,
        "func": "void V8TestObject::ReflectedIdAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_reflectedId_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  test_object_v8_internal::ReflectedIdAttributeSetter(v8_value, info);\n}\n",
        "target": 0
    },
    {
        "id": 2539,
        "func": "inline Range::Range(PassRefPtr<Document> ownerDocument, PassRefPtr<Node> startContainer, int startOffset, PassRefPtr<Node> endContainer, int endOffset)\n    : m_ownerDocument(ownerDocument)\n    , m_start(m_ownerDocument)\n    , m_end(m_ownerDocument)\n{\n#ifndef NDEBUG\n    rangeCounter.increment();\n#endif\n\n    m_ownerDocument->attachRange(this);\n\n    setStart(startContainer, startOffset);\n    setEnd(endContainer, endOffset);\n}\n",
        "target": 0
    },
    {
        "id": 2540,
        "func": "  MockOfflinePageModel* model() const { return model_; }\n",
        "target": 0
    },
    {
        "id": 2541,
        "func": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tsmp_wmb(); /* See comment in __pte_alloc */\n\n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (pud_present(*pud))\t\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n\telse\n\t\tpud_populate(mm, pud, new);\n#else\n\tif (pgd_present(*pud))\t\t/* Another has populated it */\n\t\tpmd_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pud, new);\n#endif /* __ARCH_HAS_4LEVEL_HACK */\n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 2542,
        "func": "IW_IMPL(int) iw_parse_int(const char *s)\n{\n\tdouble result;\n\tint charsread;\n\tiw_parse_number_internal(s, &result, &charsread);\n\treturn iw_round_to_int(result);\n}",
        "target": 0
    },
    {
        "id": 2543,
        "func": "v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n{\n    if (!enabled()) {\n        NOTREACHED();\n        return v8::Undefined(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> entriesValue = callDebuggerMethod(\"getCollectionEntries\", 1, argv).ToLocalChecked();\n    v8::Local<v8::Value> copied;\n    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::Undefined(m_isolate);\n    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n         return v8::Undefined(m_isolate);\n    return copied;\n }\n",
        "target": 0
    },
    {
        "id": 2544,
        "func": "_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}",
        "target": 1
    },
    {
        "id": 2545,
        "func": "int dtls1_shutdown(SSL *s)\n{\n    int ret;\n#ifndef OPENSSL_NO_SCTP\n    BIO *wbio;\n\n    wbio = SSL_get_wbio(s);\n    if (wbio != NULL && BIO_dgram_is_sctp(wbio) &&\n        !(s->shutdown & SSL_SENT_SHUTDOWN)) {\n        ret = BIO_dgram_sctp_wait_for_dry(wbio);\n        if (ret < 0)\n            return -1;\n\n        if (ret == 0)\n            BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN, 1,\n                     NULL);\n    }\n#endif\n    ret = ssl3_shutdown(s);\n#ifndef OPENSSL_NO_SCTP\n    BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN, 0, NULL);\n#endif\n    return ret;\n}\n",
        "target": 0
    },
    {
        "id": 2546,
        "func": " const SeekHead* Segment::GetSeekHead() const { return m_pSeekHead; }\n",
        "target": 0
    },
    {
        "id": 2547,
        "func": "void RenderFrameHost::AllowInjectingJavaScript() {\n  g_allow_injecting_javascript = true;\n}\n",
        "target": 0
    },
    {
        "id": 2548,
        "func": "static int parse_options(char *options, struct super_block *sb,\n\t\t\t unsigned long *journal_devnum,\n\t\t\t unsigned int *journal_ioprio,\n\t\t\t int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tif (handle_mount_opt(sb, p, token, args, journal_devnum,\n\t\t\t\t     journal_ioprio, is_remount) < 0)\n\t\t\treturn 0;\n\t}\n#ifdef CONFIG_QUOTA\n\t/*\n\t * We do the test below only for project quotas. 'usrquota' and\n\t * 'grpquota' mount options are allowed even without quota feature\n\t * to support legacy quotas in quota files.\n\t */\n\tif (test_opt(sb, PRJQUOTA) && !ext4_has_feature_project(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Project quota feature not enabled. \"\n\t\t\t \"Cannot enable project quota enforcement.\");\n\t\treturn 0;\n\t}\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sb, USRQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sb, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR, \"old and new quota \"\n\t\t\t\t\t\"format mixing\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text4_msg(sb, KERN_ERR, \"journaled quota format \"\n\t\t\t\t\t\"not specified\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\tint blocksize =\n\t\t\tBLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\t\tif (blocksize < PAGE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"dioread_nolock if block size != PAGE_SIZE\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA &&\n\t    test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\text4_msg(sb, KERN_ERR, \"can't mount with journal_async_commit \"\n\t\t\t \"in data=ordered mode\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 2549,
        "func": "void Pack<WebGLImageConversion::kDataFormatR16F,\n          WebGLImageConversion::kAlphaDoNothing,\n          float,\n          uint16_t>(const float* source,\n                    uint16_t* destination,\n                    unsigned pixels_per_row) {\n  for (unsigned i = 0; i < pixels_per_row; ++i) {\n    destination[0] = ConvertFloatToHalfFloat(source[0]);\n    source += 4;\n    destination += 1;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2550,
        "func": "void ShowBalloon(const Extension* extension, Profile* profile) {\n  string16 message = l10n_util::GetStringFUTF16(\n      extension->is_app() ?  IDS_BACKGROUND_CRASHED_APP_BALLOON_MESSAGE :\n      IDS_BACKGROUND_CRASHED_EXTENSION_BALLOON_MESSAGE,\n      UTF8ToUTF16(extension->name()));\n  string16 content_url = DesktopNotificationService::CreateDataUrl(\n      extension->GetIconURL(Extension::EXTENSION_ICON_SMALLISH,\n                            ExtensionIconSet::MATCH_BIGGER),\n      string16(), message, WebKit::WebTextDirectionDefault);\n  Notification notification(\n      extension->url(), GURL(content_url), string16(), string16(),\n      new CrashNotificationDelegate(profile, extension));\n  g_browser_process->notification_ui_manager()->Add(notification, profile);\n}\n",
        "target": 0
    },
    {
        "id": 2551,
        "func": "static int em_popa(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RDI;\n\n\twhile (reg >= VCPU_REGS_RAX) {\n\t\tif (reg == VCPU_REGS_RSP) {\n\t\t\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP],\n\t\t\t\t\t\t\tctxt->op_bytes);\n\t\t\t--reg;\n\t\t}\n\n\t\trc = emulate_pop(ctxt, &ctxt->regs[reg], ctxt->op_bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tbreak;\n\t\t--reg;\n\t}\n\treturn rc;\n}",
        "target": 0
    },
    {
        "id": 2552,
        "func": "bool HTMLMediaElement::LoadIsDeferred() const {\n  return deferred_load_state_ != kNotDeferred;\n}\n",
        "target": 0
    },
    {
        "id": 2553,
        "func": "static void HTMLSRC_apply_markup(HTStructured * context, HTlexeme lexeme, int start,\n\t\t\t\t int tag_charset)\n{\n    HT_tagspec *ts = *((start ? lexeme_start : lexeme_end) + lexeme);\n\n    while (ts) {\n#ifdef USE_COLOR_STYLE\n\tif (ts->start) {\n\t    current_tag_style = ts->style;\n\t    force_current_tag_style = TRUE;\n\t    forced_classname = ts->class_name;\n\t    force_classname = TRUE;\n\t}\n#endif\n\tCTRACE((tfp, ts->start ? \"SRCSTART %d\\n\" : \"SRCSTOP %d\\n\", (int) lexeme));\n\tif (ts->start)\n\t    HTML_start_element(context,\n\t\t\t       (int) ts->element,\n\t\t\t       ts->present,\n\t\t\t       (STRING2PTR) ts->value,\n\t\t\t       tag_charset,\n\t\t\t       NULL);\n\telse\n\t    HTML_end_element(context,\n\t\t\t     (int) ts->element,\n\t\t\t     NULL);\n\tts = ts->next;\n    }\n}",
        "target": 0
    },
    {
        "id": 2554,
        "func": "void rng_backend_request_entropy(RngBackend *s, size_t size,\n                                 EntropyReceiveFunc *receive_entropy,\n                                  void *opaque)\n {\n     RngBackendClass *k = RNG_BACKEND_GET_CLASS(s);\n    RngRequest *req;\n \n     if (k->request_entropy) {\n        req = g_malloc(sizeof(*req));\n\n        req->offset = 0;\n        req->size = size;\n        req->receive_entropy = receive_entropy;\n        req->opaque = opaque;\n        req->data = g_malloc(req->size);\n\n        k->request_entropy(s, req);\n\n        s->requests = g_slist_append(s->requests, req);\n     }\n }\n",
        "target": 0
    },
    {
        "id": 2555,
        "func": "static void fsl_emb_pmu_del(struct perf_event *event, int flags)\n{\n\tstruct cpu_hw_events *cpuhw;\n\tint i = event->hw.idx;\n\n\tperf_pmu_disable(event->pmu);\n\tif (i < 0)\n\t\tgoto out;\n\n\tfsl_emb_pmu_read(event);\n\n\tcpuhw = &get_cpu_var(cpu_hw_events);\n\n\tWARN_ON(event != cpuhw->event[event->hw.idx]);\n\n\twrite_pmlca(i, 0);\n\twrite_pmlcb(i, 0);\n\twrite_pmc(i, 0);\n\n\tcpuhw->event[i] = NULL;\n\tevent->hw.idx = -1;\n\n\t/*\n\t * TODO: if at least one restricted event exists, and we\n\t * just freed up a non-restricted-capable counter, and\n\t * there is a restricted-capable counter occupied by\n\t * a non-restricted event, migrate that event to the\n\t * vacated counter.\n\t */\n\n\tcpuhw->n_events--;\n\n out:\n\tperf_pmu_enable(event->pmu);\n\tput_cpu_var(cpu_hw_events);\n}",
        "target": 0
    },
    {
        "id": 2556,
        "func": " void HostNPScriptObject::OnClientAuthenticated(const std::string& jid) {\n  if (MessageLoop::current() != host_context_.main_message_loop()) {\n    host_context_.main_message_loop()->PostTask(FROM_HERE, base::Bind(\n        &HostNPScriptObject::OnClientAuthenticated,\n        base::Unretained(this), jid));\n    return;\n  }\n \n   if (state_ == kDisconnecting) {\n    return;\n  }\n\n  client_username_ = jid;\n  size_t pos = client_username_.find('/');\n  if (pos != std::string::npos)\n    client_username_.replace(pos, std::string::npos, \"\");\n  LOG(INFO) << \"Client \" << client_username_ << \" connected.\";\n  SetState(kConnected);\n }\n",
        "target": 0
    },
    {
        "id": 2557,
        "func": "static int check_map_prog_compatibility(struct bpf_verifier_env *env,\n\t\t\t\t\tstruct bpf_map *map,\n\t\t\t\t\tstruct bpf_prog *prog)\n\n{\n\t/* Make sure that BPF_PROG_TYPE_PERF_EVENT programs only use\n\t * preallocated hash maps, since doing memory allocation\n\t * in overflow_handler can crash depending on where nmi got\n\t * triggered.\n\t */\n\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT) {\n\t\tif (!check_map_prealloc(map)) {\n\t\t\tverbose(env, \"perf_event programs can only use preallocated hash map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (map->inner_map_meta &&\n\t\t    !check_map_prealloc(map->inner_map_meta)) {\n\t\t\tverbose(env, \"perf_event programs can only use preallocated inner hash map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2558,
        "func": "void HTMLMediaElement::configureTextTrackDisplay() {\n  DCHECK(m_textTracks);\n  BLINK_MEDIA_LOG << \"configureTextTrackDisplay(\" << (void*)this << \")\";\n\n  if (m_processingPreferenceChange)\n    return;\n\n  bool haveVisibleTextTrack = m_textTracks->hasShowingTracks();\n  m_textTracksVisible = haveVisibleTextTrack;\n\n  if (!haveVisibleTextTrack && !mediaControls())\n    return;\n\n  cueTimeline().updateActiveCues(currentTime());\n\n  updateTextTrackDisplay();\n}\n",
        "target": 0
    },
    {
        "id": 2559,
        "func": "mm_freelist(struct mm_master *mmalloc, struct mmtree *head)\n{\n\tstruct mm_share *mms, *next;\n\n\tfor (mms = RB_ROOT(head); mms; mms = next) {\n\t\tnext = RB_NEXT(mmtree, head, mms);\n\t\tRB_REMOVE(mmtree, head, mms);\n\t\tif (mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mmalloc, mms);\n\t}\n}",
        "target": 1
    },
    {
        "id": 2560,
        "func": "base::MessageLoopProxy* ProxyChannelDelegate::GetIPCMessageLoop() {\n  return RenderThread::Get()->GetIOMessageLoopProxy().get();\n}\n",
        "target": 1
    },
    {
        "id": 2561,
        "func": "OMX_ERRORTYPE SoftAACEncoder::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_encoder.aac\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPortFormat:\n {\n\n             const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n if ((formatParams->nPortIndex == 0\n && formatParams->eEncoding != OMX_AUDIO_CodingPCM)\n || (formatParams->nPortIndex == 1\n && formatParams->eEncoding != OMX_AUDIO_CodingAAC)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mBitRate = aacParams->nBitRate;\n            mNumChannels = aacParams->nChannels;\n            mSampleRate = aacParams->nSampleRate;\n\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            mNumChannels = pcmParams->nChannels;\n            mSampleRate = pcmParams->nSamplingRate;\n\n if (setAudioParams() != OK) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n",
        "target": 1
    },
    {
        "id": 2562,
        "func": " virtual status_t setListener(const sp<IDrmClient>& listener) {\n Parcel data, reply;\n        data.writeInterfaceToken(IDrm::getInterfaceDescriptor());\n        data.writeStrongBinder(IInterface::asBinder(listener));\n status_t status = remote()->transact(SET_LISTENER, data, &reply);\n if (status != OK) {\n return status;\n }\n return reply.readInt32();\n }\n",
        "target": 0
    },
    {
        "id": 2563,
        "func": "static int shared_policy_replace(struct shared_policy *sp, unsigned long start,\n\t\t\t\t unsigned long end, struct sp_node *new)\n{\n\tstruct sp_node *n;\n\tstruct sp_node *n_new = NULL;\n\tstruct mempolicy *mpol_new = NULL;\n\tint ret = 0;\n\nrestart:\n\twrite_lock(&sp->lock);\n\tn = sp_lookup(sp, start, end);\n\t/* Take care of old policies in the same range. */\n\twhile (n && n->start < end) {\n\t\tstruct rb_node *next = rb_next(&n->nd);\n\t\tif (n->start >= start) {\n\t\t\tif (n->end <= end)\n\t\t\t\tsp_delete(sp, n);\n\t\t\telse\n\t\t\t\tn->start = end;\n\t\t} else {\n\t\t\t/* Old policy spanning whole new range. */\n\t\t\tif (n->end > end) {\n\t\t\t\tif (!n_new)\n\t\t\t\t\tgoto alloc_new;\n\n\t\t\t\t*mpol_new = *n->policy;\n\t\t\t\tatomic_set(&mpol_new->refcnt, 1);\n\t\t\t\tsp_node_init(n_new, end, n->end, mpol_new);\n\t\t\t\tn->end = start;\n\t\t\t\tsp_insert(sp, n_new);\n\t\t\t\tn_new = NULL;\n\t\t\t\tmpol_new = NULL;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tn->end = start;\n\t\t}\n\t\tif (!next)\n\t\t\tbreak;\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t}\n\tif (new)\n\t\tsp_insert(sp, new);\n\twrite_unlock(&sp->lock);\n\tret = 0;\n\nerr_out:\n\tif (mpol_new)\n\t\tmpol_put(mpol_new);\n\tif (n_new)\n\t\tkmem_cache_free(sn_cache, n_new);\n\n\treturn ret;\n\nalloc_new:\n\twrite_unlock(&sp->lock);\n\tret = -ENOMEM;\n\tn_new = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n_new)\n\t\tgoto err_out;\n\tmpol_new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!mpol_new)\n\t\tgoto err_out;\n\tgoto restart;\n}",
        "target": 0
    },
    {
        "id": 2564,
        "func": "static void ccid3_hc_rx_get_info(struct sock *sk, struct tcp_info *info)\n{\n\tinfo->tcpi_ca_state = ccid3_hc_rx_sk(sk)->rx_state;\n\tinfo->tcpi_options  |= TCPI_OPT_TIMESTAMPS;\n\tinfo->tcpi_rcv_rtt  = ccid3_hc_rx_sk(sk)->rx_rtt;\n}",
        "target": 0
    },
    {
        "id": 2565,
        "func": "static int irda_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_irda *addr = (struct sockaddr_irda *) uaddr;\n\tstruct irda_sock *self = irda_sk(sk);\n\tint err;\n\n\tpr_debug(\"%s(%p)\\n\", __func__, self);\n\n\tif (addr_len != sizeof(struct sockaddr_irda))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n#ifdef CONFIG_IRDA_ULTRA\n\t/* Special care for Ultra sockets */\n\tif ((sk->sk_type == SOCK_DGRAM) &&\n\t    (sk->sk_protocol == IRDAPROTO_ULTRA)) {\n\t\tself->pid = addr->sir_lsap_sel;\n\t\terr = -EOPNOTSUPP;\n\t\tif (self->pid & 0x80) {\n\t\t\tpr_debug(\"%s(), extension in PID not supp!\\n\",\n\t\t\t\t __func__);\n\t\t\tgoto out;\n\t\t}\n\t\terr = irda_open_lsap(self, self->pid);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\t/* Pretend we are connected */\n\t\tsock->state = SS_CONNECTED;\n\t\tsk->sk_state   = TCP_ESTABLISHED;\n\t\terr = 0;\n\n\t\tgoto out;\n\t}\n#endif /* CONFIG_IRDA_ULTRA */\n\n\tself->ias_obj = irias_new_object(addr->sir_name, jiffies);\n\terr = -ENOMEM;\n\tif (self->ias_obj == NULL)\n\t\tgoto out;\n\n\terr = irda_open_tsap(self, addr->sir_lsap_sel, addr->sir_name);\n\tif (err < 0) {\n\t\tirias_delete_object(self->ias_obj);\n\t\tself->ias_obj = NULL;\n\t\tgoto out;\n\t}\n\n\t/*  Register with LM-IAS */\n\tirias_add_integer_attrib(self->ias_obj, \"IrDA:TinyTP:LsapSel\",\n\t\t\t\t self->stsap_sel, IAS_KERNEL_ATTR);\n\tirias_insert_object(self->ias_obj);\n\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 2566,
        "func": "xmlSAXParseMemoryWithData(xmlSAXHandlerPtr sax, const char *buffer,\n\t          int size, int recovery, void *data) {\n    xmlDocPtr ret;\n    xmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n\n    ctxt = xmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL) return(NULL);\n    if (sax != NULL) {\n\tif (ctxt->sax != NULL)\n\t    xmlFree(ctxt->sax);\n        ctxt->sax = sax;\n    }\n    xmlDetectSAX2(ctxt);\n    if (data!=NULL) {\n\tctxt->_private=data;\n    }\n\n    ctxt->recovery = recovery;\n\n    xmlParseDocument(ctxt);\n\n    if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;\n    else {\n       ret = NULL;\n       xmlFreeDoc(ctxt->myDoc);\n       ctxt->myDoc = NULL;\n    }\n    if (sax != NULL) \n\tctxt->sax = NULL;\n    xmlFreeParserCtxt(ctxt);\n\n    return(ret);\n}\n",
        "target": 0
    },
    {
        "id": 2567,
        "func": "void br_multicast_stop(struct net_bridge *br)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *p, *n;\n\tu32 ver;\n\tint i;\n\n\tdel_timer_sync(&br->multicast_router_timer);\n\tdel_timer_sync(&br->multicast_querier_timer);\n\tdel_timer_sync(&br->multicast_query_timer);\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (!mdb)\n\t\tgoto out;\n\n\tbr->mdb = NULL;\n\n\tver = mdb->ver;\n\tfor (i = 0; i < mdb->max; i++) {\n\t\thlist_for_each_entry_safe(mp, p, n, &mdb->mhash[i],\n\t\t\t\t\t  hlist[ver]) {\n\t\t\tdel_timer(&mp->timer);\n\t\t\tdel_timer(&mp->query_timer);\n\t\t\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\t\t}\n\t}\n\n\tif (mdb->old) {\n\t\tspin_unlock_bh(&br->multicast_lock);\n\t\trcu_barrier_bh();\n\t\tspin_lock_bh(&br->multicast_lock);\n\t\tWARN_ON(mdb->old);\n\t}\n\n\tmdb->old = mdb;\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\tspin_unlock_bh(&br->multicast_lock);\n}",
        "target": 0
    },
    {
        "id": 2568,
        "func": "void NotCalled(mojo::ScopedSharedBufferHandle shared_buffer,\n               mojo::ScopedHandle socket_handle) {\n  EXPECT_TRUE(false) << \"The StreamCreated callback was called despite the \"\n                        \"test expecting it not to.\";\n}\n",
        "target": 0
    },
    {
        "id": 2569,
        "func": "RenderFrameImpl::JavaScriptIsolatedWorldRequest::JavaScriptIsolatedWorldRequest(\n    int id,\n    bool notify_result,\n    int routing_id,\n    base::WeakPtr<RenderFrameImpl> render_frame_impl)\n    : id_(id),\n      notify_result_(notify_result),\n      routing_id_(routing_id),\n      render_frame_impl_(render_frame_impl) {\n}\n",
        "target": 0
    },
    {
        "id": 2570,
        "func": "uint32_t GraphicsContext3DPrivate::copyToGraphicsSurface()\n{\n    if (!m_graphicsSurface)\n        return 0;\n\n    blitMultisampleFramebufferAndRestoreContext();\n    m_graphicsSurface->copyFromTexture(m_context->m_texture, IntRect(0, 0, m_context->m_currentWidth, m_context->m_currentHeight));\n    return m_graphicsSurface->frontBuffer();\n}\n",
        "target": 0
    },
    {
        "id": 2571,
        "func": "static bool fm10k_set_qos_queues(struct fm10k_intfc *interface)\n{\n\tstruct net_device *dev = interface->netdev;\n\tstruct fm10k_ring_feature *f;\n\tint rss_i, i;\n\tint pcs;\n\n\t/* Map queue offset and counts onto allocated tx queues */\n\tpcs = netdev_get_num_tc(dev);\n\n\tif (pcs <= 1)\n\t\treturn false;\n\n\t/* set QoS mask and indices */\n\tf = &interface->ring_feature[RING_F_QOS];\n\tf->indices = pcs;\n\tf->mask = BIT(fls(pcs - 1)) - 1;\n\n\t/* determine the upper limit for our current DCB mode */\n\trss_i = interface->hw.mac.max_queues / pcs;\n\trss_i = BIT(fls(rss_i) - 1);\n\n\t/* set RSS mask and indices */\n\tf = &interface->ring_feature[RING_F_RSS];\n\trss_i = min_t(u16, rss_i, f->limit);\n\tf->indices = rss_i;\n\tf->mask = BIT(fls(rss_i - 1)) - 1;\n\n\t/* configure pause class to queue mapping */\n\tfor (i = 0; i < pcs; i++)\n\t\tnetdev_set_tc_queue(dev, i, rss_i, rss_i * i);\n\n\tinterface->num_rx_queues = rss_i * pcs;\n\tinterface->num_tx_queues = rss_i * pcs;\n\n\treturn true;\n}",
        "target": 0
    },
    {
        "id": 2572,
        "func": "void WebContentsImpl::Delete() {\n  RenderFrameHost* focused_frame = GetFocusedFrame();\n  if (!focused_frame)\n    return;\n\n  focused_frame->Send(new InputMsg_Delete(focused_frame->GetRoutingID()));\n  RecordAction(base::UserMetricsAction(\"DeleteSelection\"));\n}\n",
        "target": 0
    },
    {
        "id": 2573,
        "func": "  explicit TouchSelectionControllerClientTestWrapper(\n      ui::TouchSelectionControllerClient* client)\n      : expected_event_(ui::SELECTION_HANDLES_SHOWN), client_(client) {}\n",
        "target": 0
    },
    {
        "id": 2574,
        "func": "void *videobuf_to_vmalloc (struct videobuf_buffer *buf)\n{\n\tstruct videbuf_vmalloc_memory *mem=buf->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\treturn mem->vmalloc;\n}",
        "target": 0
    },
    {
        "id": 2575,
        "func": "IntRect InlineTextBox::selectionRect(int tx, int ty, int startPos, int endPos)\n{\n    int sPos = max(startPos - m_start, 0);\n    int ePos = min(endPos - m_start, (int)m_len);\n    \n    if (sPos > ePos)\n        return IntRect();\n\n    RenderText* textObj = textRenderer();\n    int selTop = selectionTop();\n    int selHeight = selectionHeight();\n    RenderStyle* styleToUse = textObj->style(m_firstLine);\n    const Font& f = styleToUse->font();\n\n    const UChar* characters = textObj->text()->characters() + m_start;\n    int len = m_len;\n    BufferForAppendingHyphen charactersWithHyphen;\n    if (ePos == len && hasHyphen()) {\n        adjustCharactersAndLengthForHyphen(charactersWithHyphen, styleToUse, characters, len);\n        ePos = len;\n     }\n \n     IntRect r = enclosingIntRect(f.selectionRectForText(TextRun(characters, len, textObj->allowTabs(), textPos(), m_toAdd, !isLeftToRightDirection(), m_dirOverride),\n                                                        IntPoint(tx + m_x, ty + selTop), selHeight, sPos, ePos));\n    if (r.x() > tx + m_x + m_logicalWidth)\n        r.setWidth(0);\n    else if (r.right() - 1 > tx + m_x + m_logicalWidth)\n        r.setWidth(tx + m_x + m_logicalWidth - r.x());\n    return r;\n }\n",
        "target": 1
    },
    {
        "id": 2576,
        "func": "void h2o_http2_conn_register_stream(h2o_http2_conn_t *conn, h2o_http2_stream_t *stream)\n{\n    khiter_t iter;\n    int r;\n\n    if (!h2o_http2_stream_is_push(stream->stream_id) && conn->pull_stream_ids.max_open < stream->stream_id)\n        conn->pull_stream_ids.max_open = stream->stream_id;\n\n    iter = kh_put(h2o_http2_stream_t, conn->streams, stream->stream_id, &r);\n    assert(iter != kh_end(conn->streams));\n    kh_val(conn->streams, iter) = stream;\n}\n",
        "target": 0
    },
    {
        "id": 2577,
        "func": "WarmupURLFetcher::WarmupURLFetcher(\n    CreateCustomProxyConfigCallback create_custom_proxy_config_callback,\n    WarmupURLFetcherCallback callback,\n    GetHttpRttCallback get_http_rtt_callback,\n    scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner,\n    const std::string& user_agent)\n    : is_fetch_in_flight_(false),\n      previous_attempt_counts_(0),\n      create_custom_proxy_config_callback_(create_custom_proxy_config_callback),\n      callback_(callback),\n      get_http_rtt_callback_(get_http_rtt_callback),\n       user_agent_(user_agent),\n       ui_task_runner_(ui_task_runner) {\n   DCHECK(create_custom_proxy_config_callback);\n }\n",
        "target": 1
    },
    {
        "id": 2578,
        "func": "    ShouldCancelAndIgnore(NavigationHandle* handle) {\n  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;\n}\n",
        "target": 1
    },
    {
        "id": 2579,
        "func": "ssh_packet_stop_discard(struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\n\tif (state->packet_discard_mac) {\n\t\tchar buf[1024];\n\t\tsize_t dlen = PACKET_MAX_SIZE;\n\n\t\tif (dlen > state->packet_discard_mac_already)\n\t\t\tdlen -= state->packet_discard_mac_already;\n\t\tmemset(buf, 'a', sizeof(buf));\n\t\twhile (sshbuf_len(state->incoming_packet) < dlen)\n\t\t\tif ((r = sshbuf_put(state->incoming_packet, buf,\n\t\t\t    sizeof(buf))) != 0)\n\t\t\t\treturn r;\n\t\t(void) mac_compute(state->packet_discard_mac,\n\t\t    state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->incoming_packet), dlen,\n\t\t    NULL, 0);\n\t}\n\tlogit(\"Finished discarding for %.200s port %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\treturn SSH_ERR_MAC_INVALID;\n}",
        "target": 0
    },
    {
        "id": 2580,
        "func": "String base64Encode(const char* data, unsigned length, Base64EncodePolicy policy)\n{\n    Vector<char> result;\n    base64Encode(data, length, result, policy);\n    return String(result.data(), result.size());\n}\n",
        "target": 0
    },
    {
        "id": 2581,
        "func": "void ResourcePrefetchPredictor::DeleteAllUrls() {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  if (initialization_state_ != INITIALIZED) {\n    delete_all_data_requested_ = true;\n    return;\n  }\n\n  host_redirect_data_->DeleteAllData();\n  origin_data_->DeleteAllData();\n}\n",
        "target": 0
    },
    {
        "id": 2582,
        "func": "void QuotaManager::GetUsageInfo(const GetUsageInfoCallback& callback) {\n  LazyInitialize();\n  GetUsageInfoTask* get_usage_info = new GetUsageInfoTask(this, callback);\n  get_usage_info->Start();\n}\n",
        "target": 0
    },
    {
        "id": 2583,
        "func": "Node* StyledMarkupAccumulator::serializeNodes(Node* startNode, Node* pastEnd)\n{\n    if (!m_highestNodeToBeSerialized) {\n        Node* lastClosed = traverseNodesForSerialization(startNode, pastEnd, DoNotEmitString);\n        m_highestNodeToBeSerialized = lastClosed;\n    }\n\n    if (m_highestNodeToBeSerialized && m_highestNodeToBeSerialized->parentNode())\n        m_wrappingStyle = EditingStyle::wrappingStyleForSerialization(m_highestNodeToBeSerialized->parentNode(), shouldAnnotate());\n\n    return traverseNodesForSerialization(startNode, pastEnd, EmitString);\n}\n",
        "target": 0
    },
    {
        "id": 2584,
        "func": "static void hns_gmac_config_an_mode(void *mac_drv, u8 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_bit(drv, GMAC_TRANSMIT_CONTROL_REG,\n\t\t\t GMAC_TX_AN_EN_B, !!newval);\n}",
        "target": 0
    },
    {
        "id": 2585,
        "func": "static TEE_Result get_prop_client_id(struct tee_ta_session *sess __unused,\n\t\t\t\t     void *buf, size_t *blen)\n{\n\tif (*blen < sizeof(TEE_Identity)) {\n\t\t*blen = sizeof(TEE_Identity);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(TEE_Identity);\n\treturn tee_svc_copy_to_user(buf, &sess->clnt_id, sizeof(TEE_Identity));\n}",
        "target": 0
    },
    {
        "id": 2586,
        "func": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\t/* Decode instruction info and find the field to read */\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\t/* Read the field, zero-extended to a u64 field_value */\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\t/*\n\t * Now copy part of this value to register or memory, as requested.\n\t * Note that the number of bits actually copied is 32 or 64 depending\n\t * on the guest's mode (32 or 64 bit), not on the given field's length.\n\t */\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\t/* _system ok, as nested_vmx_check_permission verified cpl=0 */\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
        "target": 0
    },
    {
        "id": 2587,
        "func": "local int nprocs(int n)\n{\n#  ifdef _SC_NPROCESSORS_ONLN\n    n = (int)sysconf(_SC_NPROCESSORS_ONLN);\n#  else\n#    ifdef _SC_NPROC_ONLN\n    n = (int)sysconf(_SC_NPROC_ONLN);\n#    else\n#      ifdef __hpux\n    struct pst_dynamic psd;\n\n    if (pstat_getdynamic(&psd, sizeof(psd), (size_t)1, 0) != -1)\n        n = psd.psd_proc_cnt;\n#      endif\n#    endif\n#  endif\n    return n;\n}",
        "target": 0
    },
    {
        "id": 2588,
        "func": "int bpf_obj_pin_user(u32 ufd, const char __user *pathname)\n{\n\tstruct filename *pname;\n\tenum bpf_type type;\n\tvoid *raw;\n\tint ret;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_fd_probe_obj(ufd, &type);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tret = bpf_obj_do_pin(pname, raw, type);\n\tif (ret != 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 2589,
        "func": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n\n        /* Reenable all timers that depend on unit activation time */\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n\n        if (t->stamp_path) {\n                struct stat st;\n\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        /* The timer has never run before,\n                         * make sure a stamp file exists.\n                         */\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n        }\n\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}",
        "target": 1
    },
    {
        "id": 2590,
        "func": "static bool ldm_parse_guid (const u8 *src, u8 *dest)\n{\n\tstatic const int size[] = { 4, 2, 2, 2, 6 };\n\tint i, j, v;\n\n\tif (src[8]  != '-' || src[13] != '-' ||\n\t    src[18] != '-' || src[23] != '-')\n\t\treturn false;\n\n\tfor (j = 0; j < 5; j++, src++)\n\t\tfor (i = 0; i < size[j]; i++, src+=2, *dest++ = v)\n\t\t\tif ((v = ldm_parse_hexbyte (src)) < 0)\n\t\t\t\treturn false;\n\n\treturn true;\n}",
        "target": 0
    },
    {
        "id": 2591,
        "func": "static size_t mptsas_config_pack_ext(uint8_t **data, const char *fmt, ...)\n{\n    va_list ap;\n    size_t ret;\n\n    va_start(ap, fmt);\n    ret = vpack(data, fmt, ap);\n    va_end(ap);\n\n    if (data) {\n        assert(ret < 65536 && (ret % 4) == 0);\n        stw_le_p(*data + 4, ret / 4);\n    }\n    return ret;\n}\n",
        "target": 0
    },
    {
        "id": 2592,
        "func": "GF_Box *stsd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleDescriptionBox, GF_ISOM_BOX_TYPE_STSD);\n\ttmp->other_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}",
        "target": 0
    },
    {
        "id": 2593,
        "func": "MagickExport void SetCustomStreamData(CustomStreamInfo *custom_stream,\n  void *data)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->data=data;\n}\n",
        "target": 0
    },
    {
        "id": 2594,
        "func": "void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tfx_free(vcpu);\n\tkvm_x86_ops->vcpu_free(vcpu);\n}",
        "target": 0
    },
    {
        "id": 2595,
        "func": "status_t SampleIterator::findChunkRange(uint32_t sampleIndex) {\n    CHECK(sampleIndex >= mFirstChunkSampleIndex);\n\n while (sampleIndex >= mStopChunkSampleIndex) {\n if (mSampleToChunkIndex == mTable->mNumSampleToChunkOffsets) {\n return ERROR_OUT_OF_RANGE;\n }\n\n        mFirstChunkSampleIndex = mStopChunkSampleIndex;\n\n const SampleTable::SampleToChunkEntry *entry =\n &mTable->mSampleToChunkEntries[mSampleToChunkIndex];\n\n        mFirstChunk = entry->startChunk;\n        mSamplesPerChunk = entry->samplesPerChunk;\n        mChunkDesc = entry->chunkDesc;\n\n if (mSampleToChunkIndex + 1 < mTable->mNumSampleToChunkOffsets) {\n            mStopChunk = entry[1].startChunk;\n\n            mStopChunkSampleIndex =\n                mFirstChunkSampleIndex\n + (mStopChunk - mFirstChunk) * mSamplesPerChunk;\n } else {\n            mStopChunk = 0xffffffff;\n            mStopChunkSampleIndex = 0xffffffff;\n }\n\n ++mSampleToChunkIndex;\n }\n\n return OK;\n}\n",
        "target": 0
    },
    {
        "id": 2596,
        "func": "DownloadUrlParameters::DownloadUrlParameters(\n    const GURL& url,\n    int render_process_host_id,\n    int render_view_host_routing_id,\n    int render_frame_host_routing_id,\n    const net::NetworkTrafficAnnotationTag& traffic_annotation)\n    : content_initiated_(false),\n      use_if_range_(true),\n      method_(\"GET\"),\n      post_id_(-1),\n      prefer_cache_(false),\n      referrer_policy_(\n          net::URLRequest::\n              CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE),\n       render_process_host_id_(render_process_host_id),\n       render_view_host_routing_id_(render_view_host_routing_id),\n       render_frame_host_routing_id_(render_frame_host_routing_id),\n       url_(url),\n       do_not_prompt_for_login_(false),\n       follow_cross_origin_redirects_(true),\n      fetch_error_body_(false),\n      transient_(false),\n      traffic_annotation_(traffic_annotation),\n      download_source_(DownloadSource::UNKNOWN) {}\n",
        "target": 1
    },
    {
        "id": 2597,
        "func": "void NavigationControllerImpl::GoToIndex(int index) {\n  TRACE_EVENT0(\"browser,navigation,benchmark\",\n               \"NavigationControllerImpl::GoToIndex\");\n  if (index < 0 || index >= static_cast<int>(entries_.size())) {\n    NOTREACHED();\n    return;\n  }\n\n  if (transient_entry_index_ != -1) {\n    if (index == transient_entry_index_) {\n      return;\n    }\n    if (index > transient_entry_index_) {\n      index--;\n    }\n  }\n\n  DiscardNonCommittedEntries();\n\n  DCHECK_EQ(nullptr, pending_entry_);\n  DCHECK_EQ(-1, pending_entry_index_);\n  pending_entry_ = entries_[index].get();\n  pending_entry_index_ = index;\n  pending_entry_->SetTransitionType(ui::PageTransitionFromInt(\n      pending_entry_->GetTransitionType() | ui::PAGE_TRANSITION_FORWARD_BACK));\n  NavigateToPendingEntry(ReloadType::NONE);\n}\n",
        "target": 0
    },
    {
        "id": 2598,
        "func": "size_t jsvGetLinesInString(JsVar *v) {\n  size_t lines = 1;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, v, 0);\n  while (jsvStringIteratorHasChar(&it)) {\n    if (jsvStringIteratorGetChar(&it)=='\\n') lines++;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n  return lines;\n}\n",
        "target": 0
    },
    {
        "id": 2599,
        "func": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionIntMethod(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n    ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n\n    JSC::JSValue result = jsNumber(impl->intMethod());\n    return JSValue::encode(result);\n}\n",
        "target": 0
    },
    {
        "id": 2600,
        "func": "int i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa)\n\t{\n\treturn ASN1_i2d_bio_of(DSA,i2d_DSA_PUBKEY,bp,dsa);\n\t}\n",
        "target": 0
    },
    {
        "id": 2601,
        "func": "static void smp_update_key_mask(tSMP_CB* p_cb, uint8_t key_type, bool recv) {\n  SMP_TRACE_DEBUG(\n \"%s before update role=%d recv=%d local_i_key = %02x, local_r_key = %02x\",\n      __func__, p_cb->role, recv, p_cb->local_i_key, p_cb->local_r_key);\n\n if (((p_cb->le_secure_connections_mode_is_used) || (p_cb->smp_over_br)) &&\n ((key_type == SMP_SEC_KEY_TYPE_ENC) ||\n (key_type == SMP_SEC_KEY_TYPE_LK))) {\n /* in LE SC mode LTK, CSRK and BR/EDR LK are derived locally instead of\n    ** being exchanged with the peer */\n    p_cb->local_i_key &= ~key_type;\n    p_cb->local_r_key &= ~key_type;\n } else if (p_cb->role == HCI_ROLE_SLAVE) {\n if (recv)\n      p_cb->local_i_key &= ~key_type;\n else\n      p_cb->local_r_key &= ~key_type;\n } else {\n if (recv)\n      p_cb->local_r_key &= ~key_type;\n else\n      p_cb->local_i_key &= ~key_type;\n }\n\n  SMP_TRACE_DEBUG(\"updated local_i_key = %02x, local_r_key = %02x\",\n                  p_cb->local_i_key, p_cb->local_r_key);\n}\n",
        "target": 0
    },
    {
        "id": 2602,
        "func": "base::string16 GetHelpUrlWithBoard(const std::string& original_url) {\n  return base::ASCIIToUTF16(original_url +\n                            \"&b=\" + base::SysInfo::GetLsbReleaseBoard());\n}\n",
        "target": 0
    },
    {
        "id": 2603,
        "func": "MagickExport const ModuleInfo **GetModuleInfoList(const char *pattern,\n  size_t *number_modules,ExceptionInfo *exception)\n{\n  const ModuleInfo\n    **modules;\n\n  register const ModuleInfo\n    *p;\n\n  register ssize_t\n    i;\n\n  /*\n    Allocate module list.\n  */\n  assert(pattern != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",pattern);\n  assert(number_modules != (size_t *) NULL);\n  *number_modules=0;\n  p=GetModuleInfo(\"*\",exception);\n  if (p == (const ModuleInfo *) NULL)\n    return((const ModuleInfo **) NULL);\n  modules=(const ModuleInfo **) AcquireQuantumMemory((size_t)\n    GetNumberOfNodesInSplayTree(module_list)+1UL,sizeof(*modules));\n  if (modules == (const ModuleInfo **) NULL)\n    return((const ModuleInfo **) NULL);\n  /*\n    Generate module list.\n  */\n  LockSemaphoreInfo(module_semaphore);\n  ResetSplayTreeIterator(module_list);\n  p=(const ModuleInfo *) GetNextValueInSplayTree(module_list);\n  for (i=0; p != (const ModuleInfo *) NULL; )\n  {\n    if ((p->stealth == MagickFalse) &&\n        (GlobExpression(p->tag,pattern,MagickFalse) != MagickFalse))\n      modules[i++]=p;\n    p=(const ModuleInfo *) GetNextValueInSplayTree(module_list);\n  }\n  UnlockSemaphoreInfo(module_semaphore);\n  qsort((void *) modules,(size_t) i,sizeof(*modules),ModuleInfoCompare);\n  modules[i]=(ModuleInfo *) NULL;\n  *number_modules=(size_t) i;\n  return(modules);\n}\n",
        "target": 0
    },
    {
        "id": 2604,
        "func": "static void optionsObjectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    if (UNLIKELY(info.Length() < 1)) {\n        throwTypeError(ExceptionMessages::failedToExecute(\"optionsObject\", \"TestObject\", ExceptionMessages::notEnoughArguments(1, info.Length())), info.GetIsolate());\n        return;\n    }\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_VOID(Dictionary, oo, Dictionary(info[0], info.GetIsolate()));\n    if (!oo.isUndefinedOrNull() && !oo.isObject()) {\n        throwTypeError(ExceptionMessages::failedToExecute(\"optionsObject\", \"TestObject\", \"parameter 1 ('oo') is not an object.\"), info.GetIsolate());\n        return;\n    }\n    V8TRYCATCH_VOID(Dictionary, ooo, Dictionary(info[1], info.GetIsolate()));\n    if (!ooo.isUndefinedOrNull() && !ooo.isObject()) {\n        throwTypeError(ExceptionMessages::failedToExecute(\"optionsObject\", \"TestObject\", \"parameter 2 ('ooo') is not an object.\"), info.GetIsolate());\n        return;\n    }\n    imp->optionsObject(oo, ooo);\n}\n",
        "target": 0
    },
    {
        "id": 2605,
        "func": "std::string SafeBrowsingPrivateEventRouter::GetProfileUserName() {\n  return identity_manager_ && identity_manager_->HasPrimaryAccount()\n             ? identity_manager_->GetPrimaryAccountInfo().email\n             : std::string();\n}\n",
        "target": 0
    },
    {
        "id": 2606,
        "func": "    void finishCurrentOverlapTestingContext()\n    {\n        m_overlapStack[m_overlapStack.size() - 2].unite(m_overlapStack.last());\n        m_overlapStack.removeLast();\n    }\n",
        "target": 0
    },
    {
        "id": 2607,
        "func": "static BOOL update_send_cache_bitmap_v2(rdpContext* context,\n                                        CACHE_BITMAP_V2_ORDER* cache_bitmap_v2)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap_v2->compressed ?\n\t            ORDER_TYPE_BITMAP_COMPRESSED_V2 : ORDER_TYPE_BITMAP_UNCOMPRESSED_V2;\n\n\tif (context->settings->NoBitmapCompressionHeader)\n\t\tcache_bitmap_v2->flags |= CBR2_NO_BITMAP_COMPRESSION_HDR;\n\n\tupdate_check_flush(context,\n\t                   headerLength + update_approximate_cache_bitmap_v2_order(cache_bitmap_v2,\n\t                           cache_bitmap_v2->compressed, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v2_order(s, cache_bitmap_v2,\n\t                                        cache_bitmap_v2->compressed, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD |\n\t                   ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags); /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType); /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}",
        "target": 0
    },
    {
        "id": 2608,
        "func": "void RenderFrameHostImpl::InsertVisualStateCallback(\n    const VisualStateCallback& callback) {\n  static uint64_t next_id = 1;\n  uint64_t key = next_id++;\n  Send(new FrameMsg_VisualStateRequest(routing_id_, key));\n  visual_state_callbacks_.insert(std::make_pair(key, callback));\n}\n",
        "target": 0
    },
    {
        "id": 2609,
        "func": "void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}\n\t}\n\tif (!node) {\n\t\t*ch = 0;\n\t\treturn;\n//\t\tCom_Error(ERR_DROP, \"Illegal tree!\");\n\t}\n\t*ch = node->symbol;\n\t*offset = bloc;\n}",
        "target": 1
    },
    {
        "id": 2610,
        "func": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_apic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}",
        "target": 0
    },
    {
        "id": 2611,
        "func": "bool HTMLMediaElement::SupportsFocus() const {\n  if (ownerDocument()->IsMediaDocument())\n    return false;\n\n  return ShouldShowControls() || HTMLElement::SupportsFocus();\n}\n",
        "target": 0
    },
    {
        "id": 2612,
        "func": "void MostVisitedSitesBridge::RecordOpenedMostVisitedItem(\n    JNIEnv* env,\n    const JavaParamRef<jobject>& obj,\n    jint index,\n    jint tile_type,\n    jint source) {\n  ntp_tiles::metrics::RecordTileClick(\n      index, static_cast<NTPTileSource>(source),\n      static_cast<MostVisitedTileType>(tile_type));\n}\n",
        "target": 0
    },
    {
        "id": 2613,
        "func": "static u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.last_tsc_nsec,\n\t\t\t\t      vcpu->kvm->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->kvm->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.last_tsc_write;\n\treturn tsc;\n}",
        "target": 0
    },
    {
        "id": 2614,
        "func": "bool ID3::Iterator::done() const {\n return mFrameData == NULL;\n}\n",
        "target": 0
    },
    {
        "id": 2615,
        "func": "int usb_deauthorize_device(struct usb_device *usb_dev)\n{\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 0)\n\t\tgoto out_unauthorized;\n\n\tusb_dev->authorized = 0;\n\tusb_set_configuration(usb_dev, -1);\n\nout_unauthorized:\n\tusb_unlock_device(usb_dev);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2616,
        "func": "bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(\n    const GURL& document_url,\n    std::string* error) {\n  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {\n    if (error)\n      *error = errors::kCannotScriptGallery;\n     return true;\n   }\n \n  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {\n     if (error)\n       *error = errors::kCannotScriptNtp;\n     return true;\n  }\n\n  return false;\n}\n",
        "target": 1
    },
    {
        "id": 2617,
        "func": "int av_codec_is_decoder(const AVCodec *codec)\n{\n    return codec && (codec->decode || codec->send_packet);\n}",
        "target": 0
    },
    {
        "id": 2618,
        "func": "invoke_NPN_GetValue(PluginInstance *plugin, NPNVariable variable, void *value)\n{\n  npw_return_val_if_fail(rpc_method_invoke_possible(g_rpc_connection),\n\t\t\t\t\t\t NPERR_GENERIC_ERROR);\n\n  int error = rpc_method_invoke(g_rpc_connection,\n\t\t\t\t\t\t\t\tRPC_METHOD_NPN_GET_VALUE,\n\t\t\t\t\t\t\t\tRPC_TYPE_NPW_PLUGIN_INSTANCE, plugin,\n\t\t\t\t\t\t\t\tRPC_TYPE_UINT32, variable,\n\t\t\t\t\t\t\t\tRPC_TYPE_INVALID);\n\n  if (error != RPC_ERROR_NO_ERROR) {\n\tnpw_perror(\"NPN_GetValue() invoke\", error);\n\treturn NPERR_GENERIC_ERROR;\n  }\n\n  int32_t ret;\n  switch (rpc_type_of_NPNVariable(variable)) {\n  case RPC_TYPE_UINT32:\n\t{\n\t  uint32_t n = 0;\n\t  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_UINT32, &n, RPC_TYPE_INVALID);\n\t  if (error != RPC_ERROR_NO_ERROR) {\n\t\tnpw_perror(\"NPN_GetValue() wait for reply\", error);\n\t\tret = NPERR_GENERIC_ERROR;\n\t  }\n\t  D(bug(\"-> value: %u\\n\", n));\n\t  *((unsigned int *)value) = n;\n\t  break;\n\t}\n  case RPC_TYPE_BOOLEAN:\n\t{\n\t  uint32_t b = 0;\n\t  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_BOOLEAN, &b, RPC_TYPE_INVALID);\n\t  if (error != RPC_ERROR_NO_ERROR) {\n\t\tnpw_perror(\"NPN_GetValue() wait for reply\", error);\n\t\tret = NPERR_GENERIC_ERROR;\n\t  }\n\t  D(bug(\"-> value: %s\\n\", b ? \"true\" : \"false\"));\n\t  *((NPBool *)value) = b ? TRUE : FALSE;\n\t  break;\n\t}\n  case RPC_TYPE_NP_OBJECT:\n\t{\n\t  NPObject *npobj = NULL;\n\t  error = rpc_method_wait_for_reply(g_rpc_connection, RPC_TYPE_INT32, &ret, RPC_TYPE_NP_OBJECT, &npobj, RPC_TYPE_INVALID);\n\t  if (error != RPC_ERROR_NO_ERROR) {\n\t\tnpw_perror(\"NPN_GetValue() wait for reply\", error);\n\t\tret = NPERR_GENERIC_ERROR;\n\t  }\n\t  D(bug(\"-> value: <object %p>\\n\", npobj));\n\t  *((NPObject **)value) = npobj;\n\t  break;\n\t}\n  }\n\n  return ret;\n}",
        "target": 0
    },
    {
        "id": 2619,
        "func": "static struct ext4_li_request *ext4_li_request_new(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t start)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr;\n\n\telr = kzalloc(sizeof(*elr), GFP_KERNEL);\n\tif (!elr)\n\t\treturn NULL;\n\n\telr->lr_super = sb;\n\telr->lr_sbi = sbi;\n\telr->lr_next_group = start;\n\n\t/*\n\t * Randomize first schedule time of the request to\n\t * spread the inode table initialization requests\n\t * better.\n\t */\n\telr->lr_next_sched = jiffies + (prandom_u32() %\n\t\t\t\t(EXT4_DEF_LI_MAX_START_DELAY * HZ));\n\treturn elr;\n}",
        "target": 0
    },
    {
        "id": 2620,
        "func": "DEFUN(svI, SAVE_IMAGE, \"Save inline image\")\n{\n    CurrentKeyData = NULL;\t/* not allowed in w3m-control: */\n    do_download = TRUE;\n    followI();\n    do_download = FALSE;\n}",
        "target": 0
    },
    {
        "id": 2621,
        "func": "static ssize_t WriteCALSRecord(Image *image,const char *data)\n{\n  char\n    pad[128];\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  i=0;\n  count=0;\n  if (data != (const char *) NULL)\n    {\n      p=data;\n      for (i=0; (i < 128) && (p[i] != '\\0'); i++);\n      count=WriteBlob(image,(size_t) i,(const unsigned char *) data);\n    }\n  if (i < 128)\n    {\n      i=128-i;\n      (void) ResetMagickMemory(pad,' ',(size_t) i);\n      count=WriteBlob(image,(size_t) i,(const unsigned char *) pad);\n    }\n  return(count);\n}\n",
        "target": 0
    },
    {
        "id": 2622,
        "func": "ScopedRenderTo::ScopedRenderTo(Framebuffer* framebuffer)\n    : framebuffer_(framebuffer) {\n  if (framebuffer)\n    framebuffer_->OnWillRenderTo();\n}\n",
        "target": 0
    },
    {
        "id": 2623,
        "func": "spurious_fault(unsigned long error_code, unsigned long address)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret;\n\n\t/* Reserved-bit violation or user access to kernel space? */\n\tif (error_code & (PF_USER | PF_RSVD))\n\t\treturn 0;\n\n\tpgd = init_mm.pgd + pgd_index(address);\n\tif (!pgd_present(*pgd))\n\t\treturn 0;\n\n\tpud = pud_offset(pgd, address);\n\tif (!pud_present(*pud))\n\t\treturn 0;\n\n\tif (pud_large(*pud))\n\t\treturn spurious_fault_check(error_code, (pte_t *) pud);\n\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn 0;\n\n\tif (pmd_large(*pmd))\n\t\treturn spurious_fault_check(error_code, (pte_t *) pmd);\n\n\t/*\n\t * Note: don't use pte_present() here, since it returns true\n\t * if the _PAGE_PROTNONE bit is set.  However, this aliases the\n\t * _PAGE_GLOBAL bit, which for kernel pages give false positives\n\t * when CONFIG_DEBUG_PAGEALLOC is used.\n\t */\n\tpte = pte_offset_kernel(pmd, address);\n\tif (!(pte_flags(*pte) & _PAGE_PRESENT))\n\t\treturn 0;\n\n\tret = spurious_fault_check(error_code, pte);\n\tif (!ret)\n\t\treturn 0;\n\n\t/*\n\t * Make sure we have permissions in PMD.\n\t * If not, then there's a bug in the page tables:\n\t */\n\tret = spurious_fault_check(error_code, (pte_t *) pmd);\n\tWARN_ONCE(!ret, \"PMD has incorrect permission bits\\n\");\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 2624,
        "func": "long mkvparser::UnserializeInt(\n    IMkvReader* pReader,\n    long long pos,\n    long size,\n    long long& result)\n{\n    assert(pReader);\n    assert(pos >= 0);\n    assert(size > 0);\n    assert(size <= 8);\n \n    {\n        signed char b;\n \n        const long status = pReader->Read(pos, 1, (unsigned char*)&b);\n \n        if (status < 0)\n            return status;\n \n        result = b;\n \n        ++pos;\n    }\n \n    for (long i = 1; i < size; ++i)\n    {\n        unsigned char b;\n        const long status = pReader->Read(pos, 1, &b);\n        if (status < 0)\n            return status;\n        result <<= 8;\n        result |= b;\n        ++pos;\n    }\n    return 0;  //success\n}\n",
        "target": 1
    },
    {
        "id": 2625,
        "func": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\n\tpn = ppp_pernet(net);\n\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = get_net(net);\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif /* CONFIG_PPP_MULTILINK */\n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2626,
        "func": "parse_set_vlan_vid(char *arg, struct ofpbuf *ofpacts, bool push_vlan_if_needed)\n{\n    struct ofpact_vlan_vid *vlan_vid;\n    uint16_t vid;\n    char *error;\n\n    error = str_to_u16(arg, \"VLAN VID\", &vid);\n    if (error) {\n        return error;\n    }\n\n    if (vid & ~VLAN_VID_MASK) {\n        return xasprintf(\"%s: not a valid VLAN VID\", arg);\n    }\n    vlan_vid = ofpact_put_SET_VLAN_VID(ofpacts);\n    vlan_vid->vlan_vid = vid;\n    vlan_vid->push_vlan_if_needed = push_vlan_if_needed;\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 2627,
        "func": "static uint64_t cirrus_vga_mem_read(void *opaque,\n                                    hwaddr addr,\n                                    uint32_t size)\n{\n    CirrusVGAState *s = opaque;\n    unsigned bank_index;\n    unsigned bank_offset;\n    uint32_t val;\n\n    if ((s->vga.sr[0x07] & 0x01) == 0) {\n        return vga_mem_readb(&s->vga, addr);\n    }\n\n    if (addr < 0x10000) {\n\t/* XXX handle bitblt */\n\t/* video memory */\n\tbank_index = addr >> 15;\n\tbank_offset = addr & 0x7fff;\n\tif (bank_offset < s->cirrus_bank_limit[bank_index]) {\n\t    bank_offset += s->cirrus_bank_base[bank_index];\n\t    if ((s->vga.gr[0x0B] & 0x14) == 0x14) {\n\t\tbank_offset <<= 4;\n\t    } else if (s->vga.gr[0x0B] & 0x02) {\n\t\tbank_offset <<= 3;\n\t    }\n\t    bank_offset &= s->cirrus_addr_mask;\n\t    val = *(s->vga.vram_ptr + bank_offset);\n\t} else\n\t    val = 0xff;\n    } else if (addr >= 0x18000 && addr < 0x18100) {\n\t/* memory-mapped I/O */\n\tval = 0xff;\n\tif ((s->vga.sr[0x17] & 0x44) == 0x04) {\n\t    val = cirrus_mmio_blt_read(s, addr & 0xff);\n\t}\n    } else {\n\tval = 0xff;\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: mem_readb \" TARGET_FMT_plx \"\\n\", addr);\n#endif\n    }\n    return val;\n}\n",
        "target": 0
    },
    {
        "id": 2628,
        "func": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n if (err != NO_ERROR) return 0;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n if (!h) {\n return 0;\n }\n\n \n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) err = BAD_VALUE;\n     }\n     err = read(h->data + numFds, sizeof(int)*numInts);\n     if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}\n",
        "target": 1
    },
    {
        "id": 2629,
        "func": "ofputil_check_group_mod(const struct ofputil_group_mod *gm)\n{\n    switch (gm->type) {\n    case OFPGT11_INDIRECT:\n        if (gm->command != OFPGC11_DELETE\n            && !ovs_list_is_singleton(&gm->buckets) ) {\n            return OFPERR_OFPGMFC_INVALID_GROUP;\n        }\n        break;\n    case OFPGT11_ALL:\n    case OFPGT11_SELECT:\n    case OFPGT11_FF:\n        break;\n    default:\n        return OFPERR_OFPGMFC_BAD_TYPE;\n    }\n\n    switch (gm->command) {\n    case OFPGC11_ADD:\n    case OFPGC11_MODIFY:\n    case OFPGC11_ADD_OR_MOD:\n    case OFPGC11_DELETE:\n    case OFPGC15_INSERT_BUCKET:\n        break;\n    case OFPGC15_REMOVE_BUCKET:\n        if (!ovs_list_is_empty(&gm->buckets)) {\n            return OFPERR_OFPGMFC_BAD_BUCKET;\n        }\n        break;\n    default:\n        return OFPERR_OFPGMFC_BAD_COMMAND;\n    }\n\n    struct ofputil_bucket *bucket;\n    LIST_FOR_EACH (bucket, list_node, &gm->buckets) {\n        if (bucket->weight && gm->type != OFPGT11_SELECT) {\n            return OFPERR_OFPGMFC_INVALID_GROUP;\n        }\n\n        switch (gm->type) {\n        case OFPGT11_ALL:\n        case OFPGT11_INDIRECT:\n            if (ofputil_bucket_has_liveness(bucket)) {\n                return OFPERR_OFPGMFC_WATCH_UNSUPPORTED;\n            }\n            break;\n        case OFPGT11_SELECT:\n            break;\n        case OFPGT11_FF:\n            if (!ofputil_bucket_has_liveness(bucket)) {\n                return OFPERR_OFPGMFC_INVALID_GROUP;\n            }\n            break;\n        default:\n            /* Returning BAD TYPE to be consistent\n             * though gm->type has been checked already. */\n            return OFPERR_OFPGMFC_BAD_TYPE;\n        }\n    }\n\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 2630,
        "func": "int csum_len_for_type(int cst)\n{\n        switch (cst) {\n          case CSUM_NONE:\n                return 1;\n         case CSUM_MD4_ARCHAIC:\n                return 2;\n          case CSUM_MD4:\n          case CSUM_MD4_OLD:\n\t  case CSUM_MD4_BUSTED:\n\t\treturn MD4_DIGEST_LEN;\n\t  case CSUM_MD5:\n\t\treturn MD5_DIGEST_LEN;\n\t}\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 2631,
        "func": "void Browser::ShowContentSettingsPage(ContentSettingsType content_type) {\n  ShowOptionsTab(\n      chrome::kContentSettingsExceptionsSubPage + std::string(kHashMark) +\n      ContentSettingsHandler::ContentSettingsTypeToGroupName(content_type));\n}\n",
        "target": 0
    },
    {
        "id": 2632,
        "func": "smb2_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t *of = NULL;\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\n\t/*\n\t * SMB2 Flush request\n\t */\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t/* w */\n\t    &reserved1,\t\t\t/* w */\n\t    &reserved2,\t\t\t/* l */\n\t    &smb2fid.persistent,\t/* q */\n\t    &smb2fid.temporal);\t\t/* q */\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\tof = sr->fid_ofile;\n\n\t/*\n\t * XXX - todo:\n\t * Flush named pipe should drain writes.\n\t */\n\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\n\t/*\n\t * SMB2 Flush reply\n\t */\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t/* StructSize */\t/* w */\n\t    0); /* reserved */\t\t/* w */\n\n\treturn (SDRC_SUCCESS);\n}",
        "target": 1
    },
    {
        "id": 2633,
        "func": "\nstatic int nl80211_dump_survey(struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb)\n{\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tint survey_idx = cb->args[1];\n\tint res;\n\n\tres = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (res)\n\t\treturn res;\n\n\tif (!dev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tres = dev->ops->dump_survey(&dev->wiphy, netdev, survey_idx,\n\t\t\t\t\t    &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).pid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\tnetdev,\n\t\t\t\t&survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n\n out:\n\tcb->args[1] = survey_idx;\n\tres = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn res;",
        "target": 0
    },
    {
        "id": 2634,
        "func": "header_put_marker (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_marker */",
        "target": 1
    },
    {
        "id": 2635,
        "func": "file_completion_cb (const char *buf, linenoiseCompletions *lc) \n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *basec, *basen, *dirc, *dirn;\n\tint baselen, dirlen;\n\tchar *fullpath;\n\tstruct stat filestat;\n\n\tbasec = strdup(buf);\n\tdirc = strdup(buf);\n\tdirn = dirname(dirc);\n\tdirlen = strlen(dirn);\n\tbasen = basename(basec);\n\tbaselen = strlen(basen);\n\tdirp = opendir(dirn);\n\n\tif (dirp) {\n\t\twhile ((dp = readdir(dirp)) != NULL) {\n\t\t\tif (strncmp(basen, dp->d_name, baselen) == 0) {\n\t\t\t\t/* add 2 extra bytes for possible / in middle & at end */\n\t\t\t\tfullpath = (char *) malloc(strlen(dp->d_name) + dirlen + 3);\n\t\t\t\tstrcpy(fullpath, dirn);\n\t\t\t\tif (fullpath[dirlen-1] != '/')\n\t\t\t\t\tstrcat(fullpath, \"/\");\n\t\t\t\tstrcat(fullpath, dp->d_name);\n\t\t\t\tif (stat(fullpath, &filestat) == 0) {\n\t\t\t\t\tif (S_ISDIR(filestat.st_mode)) {\n\t\t\t\t\t\tstrcat(fullpath, \"/\");\n\t\t\t\t\t}\n\t\t\t\t\tlinenoiseAddCompletion(lc,fullpath);\n\t\t\t\t}\n\t\t\t\tfree(fullpath);\n\t\t\t}\n\t\t}\n\n\t\tclosedir(dirp);\n\t}\n\tfree(basec);\n\tfree(dirc);\n}",
        "target": 0
    },
    {
        "id": 2636,
        "func": "static int lxc_cgroup_create_legacy(struct cgroup_process_info *base_info, const char *name, pid_t pid)\n{\n\tstruct cgroup_process_info *info_ptr;\n\tint r;\n\n\tfor (info_ptr = base_info; info_ptr; info_ptr = info_ptr->next) {\n\t\tif (!lxc_string_in_array(\"ns\", (const char **)info_ptr->hierarchy->subsystems))\n\t\t\tcontinue;\n\t\t/*\n\t\t * For any path which has ns cgroup mounted, handler->pid is already\n\t\t * moved into a container called '%d % (handler->pid)'.  Rename it to\n\t\t * the cgroup name and record that.\n\t\t */\n\t\tchar *tmp = cgroup_rename_nsgroup((const char *)info_ptr->designated_mount_point->mount_point,\n\t\t\t\tinfo_ptr->cgroup_path, pid, name);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tfree(info_ptr->cgroup_path);\n\t\tinfo_ptr->cgroup_path = tmp;\n\t\tr = lxc_grow_array((void ***)&info_ptr->created_paths, &info_ptr->created_paths_capacity, info_ptr->created_paths_count + 1, 8);\n\t\tif (r < 0)\n\t\t\treturn -1;\n\t\ttmp = strdup(tmp);\n\t\tif (!tmp)\n\t\t\treturn -1;\n\t\tinfo_ptr->created_paths[info_ptr->created_paths_count++] = tmp;\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2637,
        "func": "static int sctp_getsockopt_pr_supported(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (asoc) {\n\t\tparams.assoc_value = asoc->prsctp_enable;\n\t} else if (!params.assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tparams.assoc_value = sp->ep->prsctp_enable;\n\t} else {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}",
        "target": 0
    },
    {
        "id": 2638,
        "func": "void Document::TraceWrappers(const ScriptWrappableVisitor* visitor) const {\n  visitor->TraceWrappers(imports_controller_);\n  visitor->TraceWrappers(parser_);\n  visitor->TraceWrappers(implementation_);\n  visitor->TraceWrappers(style_sheet_list_);\n  visitor->TraceWrappers(style_engine_);\n  visitor->TraceWrappers(script_runner_);\n  visitor->TraceWrappers(scripted_animation_controller_);\n  visitor->TraceWrappers(scripted_idle_task_controller_);\n  ContainerNode::TraceWrappers(visitor);\n  Supplementable<Document>::TraceWrappers(visitor);\n}\n",
        "target": 0
    },
    {
        "id": 2639,
        "func": "void Browser::NewIncognitoWindow() {\n  UserMetrics::RecordAction(UserMetricsAction(\"NewIncognitoWindow\"), profile_);\n  Browser::OpenEmptyWindow(profile_->GetOffTheRecordProfile());\n}\n",
        "target": 0
    },
    {
        "id": 2640,
        "func": " GLHelper* CmdBufferImageTransportFactory::GetGLHelper() {\n   if (!gl_helper_.get())\n     gl_helper_.reset(new GLHelper(GetContext3D(), NULL));\n\n  return gl_helper_.get();\n}\n",
        "target": 0
    },
    {
        "id": 2641,
        "func": " int trace_list_functions(void *buff, size_t buff_size, size_t *needed)\n {\n\tstruct trace_output_hdr *output_hdr = NULL;\n\tvoid *end, *ptr = buff;\n\tsize_t func;\n\tsize_t upto;\n\n\tend = buff ? buff + buff_size : NULL;\n\n\t/* Place some header information */\n\tif (ptr + sizeof(struct trace_output_hdr) < end)\n\t\toutput_hdr = ptr;\n\tptr += sizeof(struct trace_output_hdr);\n\n\t/* Add information about each function */\n\tfor (func = upto = 0; func < hdr->func_count; func++) {\n\t\tsize_t calls = hdr->call_accum[func];\n\n\t\tif (!calls)\n\t\t\tcontinue;\n\n\t\tif (ptr + sizeof(struct trace_output_func) < end) {\n\t\t\tstruct trace_output_func *stats = ptr;\n\n\t\t\tstats->offset = func * FUNC_SITE_SIZE;\n\t\t\tstats->call_count = calls;\n\t\t\tupto++;\n\t\t}\n\t\tptr += sizeof(struct trace_output_func);\n\t}\n\n\t/* Update the header */\n\tif (output_hdr) {\n\t\toutput_hdr->rec_count = upto;\n\t\toutput_hdr->type = TRACE_CHUNK_FUNCS;\n\t}\n\n\t/* Work out how must of the buffer we used */\n\t*needed = ptr - buff;\n\tif (ptr > end)\n\t\treturn -ENOSPC;\n\n \treturn 0;\n }\n",
        "target": 0
    },
    {
        "id": 2642,
        "func": "XineramaXvPutImage(ClientPtr client)\n{\n    REQUEST(xvPutImageReq);\n    PanoramiXRes *draw, *gc, *port;\n    Bool isRoot;\n    int result, i, x, y;\n\n    REQUEST_AT_LEAST_SIZE(xvPutImageReq);\n\n    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                      XRC_DRAWABLE, client, DixWriteAccess);\n    if (result != Success)\n        return (result == BadValue) ? BadDrawable : result;\n\n    result = dixLookupResourceByType((void **) &gc, stuff->gc,\n                                     XRT_GC, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    result = dixLookupResourceByType((void **) &port, stuff->port,\n                                     XvXRTPort, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;\n\n    x = stuff->drw_x;\n    y = stuff->drw_y;\n\n    FOR_NSCREENS_BACKWARD(i) {\n        if (port->info[i].id) {\n            stuff->drawable = draw->info[i].id;\n            stuff->port = port->info[i].id;\n            stuff->gc = gc->info[i].id;\n            stuff->drw_x = x;\n            stuff->drw_y = y;\n            if (isRoot) {\n                stuff->drw_x -= screenInfo.screens[i]->x;\n                stuff->drw_y -= screenInfo.screens[i]->y;\n            }\n\n            result = ProcXvPutImage(client);\n        }\n    }\n    return result;\n}\n",
        "target": 0
    },
    {
        "id": 2643,
        "func": "static void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\tevents->exception.injected =\n\t\tvcpu->arch.exception.pending &&\n\t\t!kvm_exception_is_soft(vcpu->arch.exception.nr);\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.pad = 0;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow =\n\t\tkvm_x86_ops->get_interrupt_shadow(vcpu,\n\t\t\tKVM_X86_SHADOW_INT_MOV_SS | KVM_X86_SHADOW_INT_STI);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = kvm_x86_ops->get_nmi_mask(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = vcpu->arch.sipi_vector;\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW);\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}\n",
        "target": 0
    },
    {
        "id": 2644,
        "func": "static int unsupported_release_interface(int sub_api, struct libusb_device_handle *dev_handle, int iface) {\n\tPRINT_UNSUPPORTED_API(release_interface);\n}\n",
        "target": 0
    },
    {
        "id": 2645,
        "func": "am_file_data_t *am_file_data_copy(apr_pool_t *pool,\n                                  am_file_data_t *src_file_data)\n{\n    am_file_data_t *dst_file_data = NULL;\n\n    if ((dst_file_data = am_file_data_new(pool, src_file_data->path)) == NULL) {\n        return NULL;\n    }\n\n    dst_file_data->path = apr_pstrdup(pool, src_file_data->path);\n    dst_file_data->stat_time = src_file_data->stat_time;\n    dst_file_data->finfo = src_file_data->finfo;\n    dst_file_data->contents = apr_pstrdup(pool, src_file_data->contents);\n    dst_file_data->read_time = src_file_data->read_time;\n    dst_file_data->rv = src_file_data->rv;\n    dst_file_data->strerror = apr_pstrdup(pool, src_file_data->strerror);\n    dst_file_data->generated = src_file_data->generated;\n\n    return dst_file_data;\n}",
        "target": 0
    },
    {
        "id": 2646,
        "func": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}",
        "target": 1
    },
    {
        "id": 2647,
        "func": "static void bmpw_convert_row_16_32(struct iwbmpwcontext *wctx, const iw_byte *srcrow,\n\tiw_byte *dstrow, int width)\n{\n\tint i,k;\n\tunsigned int v;\n\tint num_src_samples;\n\tunsigned int src_sample[4];\n\n\tfor(k=0;k<4;k++) src_sample[k]=0;\n\n\tnum_src_samples = iw_imgtype_num_channels(wctx->img->imgtype);\n\n\tfor(i=0;i<width;i++) {\n\n\t\t// Read the source samples into a convenient format.\n\t\tfor(k=0;k<num_src_samples;k++) {\n\t\t\tif(wctx->img->bit_depth==16) {\n\t\t\t\tsrc_sample[k] = (srcrow[num_src_samples*2*i + k*2]<<8) | srcrow[num_src_samples*2*i + k*2 +1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsrc_sample[k] = srcrow[num_src_samples*i + k];\n\t\t\t}\n\t\t}\n\n\t\t// Pack the pixels' bits into a single int.\n\t\tswitch(wctx->img->imgtype) {\n\t\tcase IW_IMGTYPE_GRAY:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[2];\n\t\t\tbreak;\n\t\tcase IW_IMGTYPE_RGBA:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[1] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[2] << wctx->bf_amt_to_shift[2];\n\t\t\tv |= src_sample[3] << wctx->bf_amt_to_shift[3];\n\t\t\tbreak;\n\t\tcase IW_IMGTYPE_GRAYA:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[2];\n\t\t\tv |= src_sample[1] << wctx->bf_amt_to_shift[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[1] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[2] << wctx->bf_amt_to_shift[2];\n\t\t}\n\n\t\t// Split the int into bytes, and write it to the target image.\n\t\tif(wctx->bitcount==32) {\n\t\t\tdstrow[i*4+0] = (iw_byte)(v&0xff);\n\t\t\tdstrow[i*4+1] = (iw_byte)((v&0x0000ff00)>>8);\n\t\t\tdstrow[i*4+2] = (iw_byte)((v&0x00ff0000)>>16);\n\t\t\tdstrow[i*4+3] = (iw_byte)((v&0xff000000)>>24);\n\t\t}\n\t\telse {\n\t\t\tdstrow[i*2+0] = (iw_byte)(v&0xff);\n\t\t\tdstrow[i*2+1] = (iw_byte)(v>>8);\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 2648,
        "func": "XRenderPictFormat* GetRenderVisualFormat(Display* dpy, Visual* visual) {\n  DCHECK(QueryRenderSupport(dpy));\n\n  CachedPictFormats* formats = get_cached_pict_formats();\n\n  for (CachedPictFormats::const_iterator i = formats->begin();\n       i != formats->end(); ++i) {\n    if (i->equals(dpy, visual))\n      return i->format;\n  }\n\n  XRenderPictFormat* pictformat = XRenderFindVisualFormat(dpy, visual);\n  CHECK(pictformat) << \"XRENDER does not support default visual\";\n\n  CachedPictFormat cached_value;\n  cached_value.visual = visual;\n  cached_value.display = dpy;\n  cached_value.format = pictformat;\n  formats->push_front(cached_value);\n\n  if (formats->size() == kMaxCacheSize) {\n    formats->pop_back();\n    NOTREACHED();\n  }\n\n  return pictformat;\n}\n",
        "target": 0
    },
    {
        "id": 2649,
        "func": "bool PaletteDelegateChromeOS::HasNoteApp() {\n   return chromeos::IsNoteTakingAppAvailable(GetProfile());\n }\n",
        "target": 0
    },
    {
        "id": 2650,
        "func": "static int cdrom_is_mrw(struct cdrom_device_info *cdi, int *write)\n{\n\tstruct packet_command cgc;\n\tstruct mrw_feature_desc *mfd;\n\tunsigned char buffer[16];\n\tint ret;\n\n\t*write = 0;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[3] = CDF_MRW;\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tmfd = (struct mrw_feature_desc *)&buffer[sizeof(struct feature_header)];\n\tif (be16_to_cpu(mfd->feature_code) != CDF_MRW)\n\t\treturn 1;\n\t*write = mfd->write;\n\n\tif ((ret = cdrom_mrw_probe_pc(cdi))) {\n\t\t*write = 0;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2651,
        "func": "  virtual void SetImePropertyActivated(const std::string& key,\n                                       bool activated) {\n    if (!initialized_successfully_)\n       return;\n \n     DCHECK(!key.empty());\n    chromeos::SetImePropertyActivated(\n        input_method_status_connection_, key.c_str(), activated);\n   }\n",
        "target": 1
    },
    {
        "id": 2652,
        "func": "s64 vsock_stream_has_space(struct vsock_sock *vsk)\n{\n\treturn transport->stream_has_space(vsk);\n}",
        "target": 0
    },
    {
        "id": 2653,
        "func": "void WebContentsImpl::NotifyNavigationStateChanged(\n    InvalidateTypes changed_flags) {\n  if (changed_flags & INVALIDATE_TYPE_TAB) {\n    media_web_contents_observer_->MaybeUpdateAudibleState();\n  }\n\n  if (delegate_)\n    delegate_->NavigationStateChanged(this, changed_flags);\n\n  if (GetOuterWebContents())\n    GetOuterWebContents()->NotifyNavigationStateChanged(changed_flags);\n}\n",
        "target": 0
    },
    {
        "id": 2654,
        "func": "static void printbits(unsigned long val, struct regbit *bits)\n{\n\tconst char *sep = \"\";\n\n\tprintk(\"<\");\n\tfor (; bits->bit; ++bits)\n\t\tif (val & bits->bit) {\n\t\t\tprintk(\"%s%s\", sep, bits->name);\n\t\t\tsep = \",\";\n\t\t}\n\tprintk(\">\");\n}",
        "target": 0
    },
    {
        "id": 2655,
        "func": "monitor_sync(struct monitor *pmonitor)\n{\n\tif (options.compression) {\n\t\t/* The member allocation is not visible, so sync it */\n\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n\t}\n}",
        "target": 1
    },
    {
        "id": 2656,
        "func": "void AppCacheUpdateJob::Cancel() {\n  internal_state_ = CANCELLED;\n\n  LogHistogramStats(CANCELLED_ERROR, GURL());\n\n  if (manifest_fetcher_) {\n    delete manifest_fetcher_;\n    manifest_fetcher_ = NULL;\n  }\n\n  for (PendingUrlFetches::iterator it = pending_url_fetches_.begin();\n       it != pending_url_fetches_.end(); ++it) {\n    delete it->second;\n  }\n  pending_url_fetches_.clear();\n\n  for (PendingUrlFetches::iterator it = master_entry_fetches_.begin();\n       it != master_entry_fetches_.end(); ++it) {\n    delete it->second;\n  }\n  master_entry_fetches_.clear();\n\n  ClearPendingMasterEntries();\n  DiscardInprogressCache();\n\n  if (manifest_response_writer_)\n    manifest_response_writer_.reset();\n\n  storage_->CancelDelegateCallbacks(this);\n}\n",
        "target": 0
    },
    {
        "id": 2657,
        "func": "mojom::AppPtr AppControllerImpl::CreateAppPtr(const apps::AppUpdate& update) {\n   auto app = chromeos::kiosk_next_home::mojom::App::New();\n   app->app_id = update.AppId();\n   app->type = update.AppType();\n  app->display_name = update.Name();\n  app->readiness = update.Readiness();\n\n  if (app->type == apps::mojom::AppType::kArc) {\n    app->android_package_name = MaybeGetAndroidPackageName(app->app_id);\n  }\n   return app;\n }\n",
        "target": 1
    },
    {
        "id": 2658,
        "func": "static bool ExecuteCut(LocalFrame& frame,\n                       Event*,\n                       EditorCommandSource source,\n                       const String&) {\n  if (!CanWriteClipboard(frame, source))\n    return false;\n  frame.GetEditor().Cut(source);\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2659,
        "func": "void kvm_vcpu_kick(struct kvm_vcpu *vcpu)\n{\n\tint me;\n\tint cpu = vcpu->cpu;\n\n\tif (kvm_vcpu_wake_up(vcpu))\n\t\treturn;\n\n\tme = get_cpu();\n\tif (cpu != me && (unsigned)cpu < nr_cpu_ids && cpu_online(cpu))\n\t\tif (kvm_arch_vcpu_should_kick(vcpu))\n\t\t\tsmp_send_reschedule(cpu);\n\tput_cpu();\n}",
        "target": 0
    },
    {
        "id": 2660,
        "func": "static int ext4_setup_super(struct super_block *sb, struct ext4_super_block *es,\n\t\t\t    int read_only)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_MAX_SUPP_REV) {\n\t\text4_msg(sb, KERN_ERR, \"revision level too high, \"\n\t\t\t \"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\tgoto done;\n\tif (!(sbi->s_mount_state & EXT4_VALID_FS))\n\t\text4_msg(sb, KERN_WARNING, \"warning: mounting unchecked fs, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (sbi->s_mount_state & EXT4_ERROR_FS)\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: mounting fs with errors, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) > 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: maximal mount count reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: checktime reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\tif (!sbi->s_journal)\n\t\tes->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\tif (!(__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT4_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text4_update_dynamic_rev(sb);\n\tif (sbi->s_journal)\n\t\text4_set_feature_journal_needs_recovery(sb);\n\n\text4_commit_super(sb, 1);\ndone:\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_INFO \"[EXT4 FS bs=%lu, gc=%u, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04x, mo2=%04x]\\n\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT4_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt, sbi->s_mount_opt2);\n\n\tcleancache_init_fs(sb);\n\treturn res;\n}",
        "target": 0
    },
    {
        "id": 2661,
        "func": "static int tm_cgpr32_get(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     void *kbuf, void __user *ubuf)\n{\n\treturn gpr32_get_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.ckpt_regs.gpr[0]);\n}",
        "target": 0
    },
    {
        "id": 2662,
        "func": "static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n\t\tunsigned long arg)\n{\n\tstruct sem_undo *un;\n\tstruct sem_array *sma;\n\tstruct sem* curr;\n\tint err;\n\tint nsems;\n\tstruct list_head tasks;\n\tint val;\n#if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\n\t/* big-endian 64bit */\n\tval = arg >> 32;\n#else\n\t/* 32bit or little-endian 64bit */\n\tval = arg;\n#endif\n\n\tsma = sem_lock_check(ns, semid);\n\tif (IS_ERR(sma))\n\t\treturn PTR_ERR(sma);\n\n\tINIT_LIST_HEAD(&tasks);\n\tnsems = sma->sem_nsems;\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO))\n\t\tgoto out_unlock;\n\n\terr = security_sem_semctl(sma, SETVAL);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = -EINVAL;\n\tif(semnum < 0 || semnum >= nsems)\n\t\tgoto out_unlock;\n\n\tcurr = &sma->sem_base[semnum];\n\n\terr = -ERANGE;\n\tif (val > SEMVMX || val < 0)\n\t\tgoto out_unlock;\n\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry(un, &sma->list_id, list_id)\n\t\tun->semadj[semnum] = 0;\n\n\tcurr->semval = val;\n\tcurr->sempid = task_tgid_vnr(current);\n\tsma->sem_ctime = get_seconds();\n\t/* maybe some queued-up processes were waiting for this */\n\tdo_smart_update(sma, NULL, 0, 0, &tasks);\n\terr = 0;\nout_unlock:\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 2663,
        "func": "bool OmniboxEditModel::CurrentTextIsURL() const {\n  if (controller_->GetToolbarModel()->WouldReplaceURL())\n    return false;\n\n  if (!user_input_in_progress_)\n    return true;\n\n  return !AutocompleteMatch::IsSearchType(CurrentMatch(NULL).type);\n}\n",
        "target": 0
    },
    {
        "id": 2664,
        "func": "void WebBluetoothServiceImpl::OnStartDiscoverySession(\n    blink::mojom::WebBluetoothScanClientAssociatedPtr client,\n    blink::mojom::WebBluetoothRequestLEScanOptionsPtr options,\n    std::unique_ptr<device::BluetoothDiscoverySession> session) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  DCHECK(!discovery_session_);\n\n  discovery_session_ = std::move(session);\n\n  if (AreScanFiltersAllowed(options->filters)) {\n    auto scanning_client = std::make_unique<ScanningClient>(\n        std::move(client), std::move(options), std::move(discovery_callback_),\n        nullptr);\n    scanning_client->RunRequestScanningStartCallback(\n        blink::mojom::WebBluetoothResult::SUCCESS);\n    scanning_client->set_allow_send_event(true);\n    scanning_clients_.push_back(std::move(scanning_client));\n    return;\n  }\n\n  device_scanning_prompt_controller_ =\n      std::make_unique<BluetoothDeviceScanningPromptController>(\n          this, render_frame_host_);\n\n  scanning_clients_.push_back(std::make_unique<ScanningClient>(\n      std::move(client), std::move(options), std::move(discovery_callback_),\n      device_scanning_prompt_controller_.get()));\n  device_scanning_prompt_controller_->ShowPermissionPrompt();\n}\n",
        "target": 0
    },
    {
        "id": 2665,
        "func": "static void __wake_userfault(struct userfaultfd_ctx *ctx,\n\t\t\t     struct userfaultfd_wake_range *range)\n{\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t/* wake all in the range and autoremove */\n\tif (waitqueue_active(&ctx->fault_pending_wqh))\n\t\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL,\n\t\t\t\t     range);\n\tif (waitqueue_active(&ctx->fault_wqh))\n\t\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n}",
        "target": 0
    },
    {
        "id": 2666,
        "func": " void MediaElementAudioSourceHandler::SetFormat(size_t number_of_channels,\n                                                float source_sample_rate) {\n   if (number_of_channels != source_number_of_channels_ ||\n       source_sample_rate != source_sample_rate_) {\n     if (!number_of_channels ||\n        number_of_channels > BaseAudioContext::MaxNumberOfChannels() ||\n        !AudioUtilities::IsValidAudioBufferSampleRate(source_sample_rate)) {\n      DLOG(ERROR) << \"setFormat(\" << number_of_channels << \", \"\n                  << source_sample_rate << \") - unhandled format change\";\n       Locker<MediaElementAudioSourceHandler> locker(*this);\n       source_number_of_channels_ = 0;\n       source_sample_rate_ = 0;\n       return;\n     }\n \n     Locker<MediaElementAudioSourceHandler> locker(*this);\n \n     source_number_of_channels_ = number_of_channels;\n     source_sample_rate_ = source_sample_rate;\n \n    if (source_sample_rate != Context()->sampleRate()) {\n      double scale_factor = source_sample_rate / Context()->sampleRate();\n      multi_channel_resampler_ = std::make_unique<MultiChannelResampler>(\n          scale_factor, number_of_channels);\n    } else {\n      multi_channel_resampler_.reset();\n    }\n\n    {\n      BaseAudioContext::GraphAutoLocker context_locker(Context());\n\n      Output(0).SetNumberOfChannels(number_of_channels);\n    }\n   }\n }\n",
        "target": 1
    },
    {
        "id": 2667,
        "func": "DOMWrapperMap<void>& getActiveDOMObjectMap(v8::Isolate* isolate)\n{\n    return DOMData::getCurrentStore(isolate).activeDomObjectMap();\n}\n",
        "target": 0
    },
    {
        "id": 2668,
        "func": "status_t Camera3Device::createDefaultRequest(int templateId,\n\n         CameraMetadata *request) {\n     ATRACE_CALL();\n     ALOGV(\"%s: for template %d\", __FUNCTION__, templateId);\n     Mutex::Autolock il(mInterfaceLock);\n     Mutex::Autolock l(mLock);\n \n switch (mStatus) {\n case STATUS_ERROR:\n            CLOGE(\"Device has encountered a serious error\");\n return INVALID_OPERATION;\n case STATUS_UNINITIALIZED:\n            CLOGE(\"Device is not initialized!\");\n return INVALID_OPERATION;\n case STATUS_UNCONFIGURED:\n case STATUS_CONFIGURED:\n case STATUS_ACTIVE:\n break;\n default:\n            SET_ERR_L(\"Unexpected status: %d\", mStatus);\n return INVALID_OPERATION;\n }\n\n if (!mRequestTemplateCache[templateId].isEmpty()) {\n *request = mRequestTemplateCache[templateId];\n return OK;\n }\n\n const camera_metadata_t *rawRequest;\n    ATRACE_BEGIN(\"camera3->construct_default_request_settings\");\n    rawRequest = mHal3Device->ops->construct_default_request_settings(\n        mHal3Device, templateId);\n    ATRACE_END();\n if (rawRequest == NULL) {\n        ALOGI(\"%s: template %d is not supported on this camera device\",\n              __FUNCTION__, templateId);\n return BAD_VALUE;\n }\n *request = rawRequest;\n    mRequestTemplateCache[templateId] = rawRequest;\n\n return OK;\n}\n",
        "target": 1
    },
    {
        "id": 2669,
        "func": "bool Textfield::HasTextBeingDragged() const {\n  return initiating_drag_;\n}\n",
        "target": 0
    },
    {
        "id": 2670,
        "func": "void HostNPScriptObject::LocalizeStrings(NPObject* localize_func) {\n  DCHECK(plugin_message_loop_proxy_->BelongsToCurrentThread());\n\n  UiStrings ui_strings;\n  string16 direction;\n  LocalizeString(localize_func, \"@@bidi_dir\", &direction);\n  ui_strings.direction = UTF16ToUTF8(direction) == \"rtl\" ?\n      remoting::UiStrings::RTL : remoting::UiStrings::LTR;\n  LocalizeString(localize_func, /*i18n-content*/\"PRODUCT_NAME\",\n                 &ui_strings.product_name);\n  LocalizeString(localize_func, /*i18n-content*/\"DISCONNECT_OTHER_BUTTON\",\n                 &ui_strings.disconnect_button_text);\n  LocalizeString(localize_func,\n#if defined(OS_WIN)\n      /*i18n-content*/\"DISCONNECT_BUTTON_PLUS_SHORTCUT_WINDOWS\",\n#elif defined(OS_MACOSX)\n      /*i18n-content*/\"DISCONNECT_BUTTON_PLUS_SHORTCUT_MAC_OS_X\",\n#else\n      /*i18n-content*/\"DISCONNECT_BUTTON_PLUS_SHORTCUT_LINUX\",\n#endif\n      &ui_strings.disconnect_button_text_plus_shortcut);\n  LocalizeString(localize_func, /*i18n-content*/\"CONTINUE_PROMPT\",\n                 &ui_strings.continue_prompt);\n  LocalizeString(localize_func, /*i18n-content*/\"CONTINUE_BUTTON\",\n                 &ui_strings.continue_button_text);\n  LocalizeString(localize_func, /*i18n-content*/\"STOP_SHARING_BUTTON\",\n                 &ui_strings.stop_sharing_button_text);\n  LocalizeString(localize_func, /*i18n-content*/\"MESSAGE_SHARED\",\n                 &ui_strings.disconnect_message);\n\n  base::AutoLock auto_lock(ui_strings_lock_);\n  ui_strings_ = ui_strings;\n}\n",
        "target": 0
    },
    {
        "id": 2671,
        "func": "bool ContentBrowserClient::AllowSaveLocalState(ResourceContext* context) {\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2672,
        "func": "void V8TestObject::ActivityLoggingGetterForIsolatedWorldsPerWorldBindingsLongAttributeAttributeSetterCallbackForMainWorld(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_activityLoggingGetterForIsolatedWorldsPerWorldBindingsLongAttribute_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  test_object_v8_internal::ActivityLoggingGetterForIsolatedWorldsPerWorldBindingsLongAttributeAttributeSetterForMainWorld(v8_value, info);\n}\n",
        "target": 0
    },
    {
        "id": 2673,
        "func": "void DataObjectImpl::OnDownloadCompleted(const base::FilePath& file_path) {\n  DataObjectImpl::StoredData::iterator iter = contents_.begin();\n  for (; iter != contents_.end(); ++iter) {\n    if ((*iter)->format_etc.cfFormat == CF_HDROP) {\n      if ((*iter)->owns_medium) {\n        ReleaseStgMedium((*iter)->medium);\n        delete (*iter)->medium;\n      }\n\n      (*iter)->owns_medium = true;\n      (*iter)->medium = GetStorageForFileName(file_path);\n\n      break;\n    }\n  }\n  DCHECK(iter != contents_.end());\n}\n",
        "target": 0
    },
    {
        "id": 2674,
        "func": "void EC_GROUP_clear_free(EC_GROUP *group)\n\t{\n\tif (!group) return;\n\n\tif (group->meth->group_clear_finish != 0)\n\t\tgroup->meth->group_clear_finish(group);\n\telse if (group->meth->group_finish != 0)\n\t\tgroup->meth->group_finish(group);\n\n\tEC_EX_DATA_clear_free_all_data(&group->extra_data);\n\n\tif (group->generator != NULL)\n \n        EC_EX_DATA_clear_free_all_data(&group->extra_data);\n \n       if (group->mont_data)\n               BN_MONT_CTX_free(group->mont_data);\n\n        if (group->generator != NULL)\n                EC_POINT_clear_free(group->generator);\n        BN_clear_free(&group->order);\n\n\tOPENSSL_cleanse(group, sizeof *group);\n\tOPENSSL_free(group);\n\t}\n",
        "target": 0
    },
    {
        "id": 2675,
        "func": "void WebView::setParentWindow(HWND parentWindow)\n{\n    if (m_window) {\n        if (::GetParent(m_window) == parentWindow)\n            return;\n        if (parentWindow)\n            ::SetParent(m_window, parentWindow);\n        else if (!m_isBeingDestroyed) {\n            ::SetParent(m_window, HWND_MESSAGE);\n        }\n    }\n\n    windowAncestryDidChange();\n}\n",
        "target": 0
    },
    {
        "id": 2676,
        "func": "handle_t *__ext4_journal_start_sb(struct super_block *sb, unsigned int line,\n\t\t\t\t  int type, int blocks, int rsv_blocks)\n{\n\tjournal_t *journal;\n\tint err;\n\n\ttrace_ext4_journal_start(sb, blocks, rsv_blocks, _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\tif (!journal)\n\t\treturn ext4_get_nojournal();\n\treturn jbd2__journal_start(journal, blocks, rsv_blocks, GFP_NOFS,\n\t\t\t\t   type, line);\n}",
        "target": 0
    },
    {
        "id": 2677,
        "func": "bool AutofillPopupBaseView::OnMouseDragged(const ui::MouseEvent& event) {\n  if (HitTestPoint(event.location())) {\n    SetSelection(event.location());\n\n    return true;\n  }\n\n  ClearSelection();\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 2678,
        "func": "CastSelectDefaultView::CastSelectDefaultView(\n    SystemTrayItem* owner,\n    CastConfigDelegate* cast_config_delegate,\n    bool show_more)\n    : TrayItemMore(owner, show_more),\n      cast_config_delegate_(cast_config_delegate) {\n  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n  SetImage(rb.GetImageNamed(IDR_AURA_UBER_TRAY_CAST).ToImageSkia());\n\n  SetLabel(rb.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_NO_DEVICE));\n  UpdateLabel();\n}\n",
        "target": 0
    },
    {
        "id": 2679,
        "func": "void RenderWidgetHostImpl::ForwardInputEvent(const WebInputEvent& input_event,\n                                             int event_size,\n                                             bool is_keyboard_shortcut) {\n  TRACE_EVENT0(\"renderer_host\", \"RenderWidgetHostImpl::ForwardInputEvent\");\n\n  if (!process_->HasConnection())\n    return;\n\n  DCHECK(!process_->IgnoreInputEvents());\n\n  if (overscroll_controller_.get() &&\n      !overscroll_controller_->WillDispatchEvent(input_event)) {\n    if (input_event.type == WebKit::WebInputEvent::MouseWheel) {\n      mouse_wheel_pending_ = false;\n    } else if (WebInputEvent::isGestureEventType(input_event.type) &&\n               gesture_event_filter_->HasQueuedGestureEvents()) {\n      gesture_event_filter_->ProcessGestureAck(true, input_event.type);\n    } else if (WebInputEvent::isTouchEventType(input_event.type)) {\n      touch_event_queue_->ProcessTouchAck(INPUT_EVENT_ACK_STATE_NOT_CONSUMED);\n    }\n    return;\n  }\n\n  in_process_event_types_.push(input_event.type);\n\n  if (input_event.type != WebInputEvent::MouseWheel) {\n    for (size_t i = 0; i < coalesced_mouse_wheel_events_.size(); ++i) {\n      SendInputEvent(coalesced_mouse_wheel_events_[i],\n                     sizeof(WebMouseWheelEvent), false);\n    }\n    coalesced_mouse_wheel_events_.clear();\n  }\n\n  SendInputEvent(input_event, event_size, is_keyboard_shortcut);\n\n  next_mouse_move_.reset();\n\n  StartHangMonitorTimeout(\n      TimeDelta::FromMilliseconds(hung_renderer_delay_ms_));\n}\n",
        "target": 0
    },
    {
        "id": 2680,
        "func": "void WebGL2RenderingContextBase::texSubImage3D(\n    ExecutionContext* execution_context,\n    GLenum target,\n    GLint level,\n    GLint xoffset,\n    GLint yoffset,\n    GLint zoffset,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    GLenum format,\n    GLenum type,\n    HTMLCanvasElement* canvas,\n    ExceptionState& exception_state) {\n  if (isContextLost())\n    return;\n  if (bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texSubImage3D\",\n                      \"a buffer is bound to PIXEL_UNPACK_BUFFER\");\n    return;\n  }\n\n  TexImageHelperHTMLCanvasElement(execution_context->GetSecurityOrigin(),\n                                  kTexSubImage3D, target, level, 0, format,\n                                  type, xoffset, yoffset, zoffset, canvas,\n                                  GetTextureSourceSubRectangle(width, height),\n                                  depth, unpack_image_height_, exception_state);\n}\n",
        "target": 0
    },
    {
        "id": 2681,
        "func": "static inline void report_user_fault(struct pt_regs *regs, long int_code,\n\t\t\t\t     int signr, unsigned long address)\n{\n\tif ((task_pid_nr(current) > 1) && !show_unhandled_signals)\n\t\treturn;\n\tif (!unhandled_signal(current, signr))\n\t\treturn;\n\tif (!printk_ratelimit())\n\t\treturn;\n\tprintk(\"User process fault: interruption code 0x%lX \", int_code);\n\tprint_vma_addr(KERN_CONT \"in \", regs->psw.addr & PSW_ADDR_INSN);\n\tprintk(\"\\n\");\n\tprintk(\"failing address: %lX\\n\", address);\n\tshow_regs(regs);\n}",
        "target": 0
    },
    {
        "id": 2682,
        "func": "void Browser::TabDetachedAtImpl(TabContentsWrapper* contents, int index,\n                                DetachType type) {\n  if (type == DETACH_TYPE_DETACH) {\n    if (contents == GetSelectedTabContentsWrapper())\n      window_->GetLocationBar()->SaveStateToContents(contents->tab_contents());\n\n    if (!tab_handler_->GetTabStripModel()->closing_all())\n      SyncHistoryWithTabs(0);\n  }\n\n  contents->tab_contents()->set_delegate(NULL);\n  RemoveScheduledUpdatesFor(contents->tab_contents());\n\n  if (find_bar_controller_.get() &&\n      index == tab_handler_->GetTabStripModel()->selected_index()) {\n     find_bar_controller_->ChangeTabContents(NULL);\n   }\n \n   registrar_.Remove(this, NotificationType::TAB_CONTENTS_DISCONNECTED,\n                     Source<TabContentsWrapper>(contents));\n }\n",
        "target": 1
    },
    {
        "id": 2683,
        "func": "GURL RenderFrameImpl::GetLoadingUrl() const {\n  WebDocumentLoader* document_loader = frame_->GetDocumentLoader();\n\n  GURL overriden_url;\n  if (MaybeGetOverriddenURL(document_loader, &overriden_url))\n    return overriden_url;\n\n  return document_loader->GetUrl();\n}\n",
        "target": 0
    },
    {
        "id": 2684,
        "func": "void WT_Interpolate (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_PCM *pOutputBuffer;\n    EAS_I32 phaseInc;\n    EAS_I32 phaseFrac;\n    EAS_I32 acc0;\n const EAS_SAMPLE *pSamples;\n const EAS_SAMPLE *loopEnd;\n    EAS_I32 samp1;\n    EAS_I32 samp2;\n    EAS_I32 numSamples;\n\n \n     /* initialize some local variables */\n     numSamples = pWTIntFrame->numSamples;\n     pOutputBuffer = pWTIntFrame->pAudioBuffer;\n \n     loopEnd = (const EAS_SAMPLE*) pWTVoice->loopEnd + 1;\n    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;\n /*lint -e{713} truncation is OK */\n    phaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->frame.phaseIncrement;\n\n /* fetch adjacent samples */\n#if defined(_8_BIT_SAMPLES)\n /*lint -e{701} <avoid multiply for performance>*/\n    samp1 = pSamples[0] << 8;\n /*lint -e{701} <avoid multiply for performance>*/\n    samp2 = pSamples[1] << 8;\n#else\n    samp1 = pSamples[0];\n    samp2 = pSamples[1];\n#endif\n\n while (numSamples--) {\n\n /* linear interpolation */\n        acc0 = samp2 - samp1;\n        acc0 = acc0 * phaseFrac;\n /*lint -e{704} <avoid divide>*/\n        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);\n\n /* save new output sample in buffer */\n /*lint -e{704} <avoid divide>*/\n *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);\n\n /* increment phase */\n        phaseFrac += phaseInc;\n /*lint -e{704} <avoid divide>*/\n        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;\n\n /* next sample */\n if (acc0 > 0) {\n\n /* advance sample pointer */\n            pSamples += acc0;\n            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);\n\n /* check for loop end */\n            acc0 = (EAS_I32) (pSamples - loopEnd);\n if (acc0 >= 0)\n                pSamples = (const EAS_SAMPLE*) pWTVoice->loopStart + acc0;\n\n /* fetch new samples */\n#if defined(_8_BIT_SAMPLES)\n /*lint -e{701} <avoid multiply for performance>*/\n            samp1 = pSamples[0] << 8;\n /*lint -e{701} <avoid multiply for performance>*/\n            samp2 = pSamples[1] << 8;\n#else\n            samp1 = pSamples[0];\n            samp2 = pSamples[1];\n#endif\n }\n }\n\n /* save pointer and phase */\n    pWTVoice->phaseAccum = (EAS_U32) pSamples;\n    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;\n}\n",
        "target": 1
    },
    {
        "id": 2685,
        "func": "void metx_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tif (ptr->config) gf_isom_box_del((GF_Box *)ptr->config);\n\tgf_free(ptr);\n}",
        "target": 0
    },
    {
        "id": 2686,
        "func": "void GpuDataManager::AddGpuInfoUpdateCallback(Callback0::Type* callback) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  gpu_info_update_callbacks_.insert(callback);\n}\n",
        "target": 0
    },
    {
        "id": 2687,
        "func": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
        "target": 1
    },
    {
        "id": 2688,
        "func": "psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\n\tmaxlen = strlen ((char*) psf->header) ;\n\tstart\t= ((char*) psf->header) + maxlen ;\n\tmaxlen\t= sizeof (psf->header) - maxlen ;\n\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\n\t/* Make sure the string is properly terminated. */\n\tstart [maxlen - 1] = 0 ;\n\n\tpsf->headindex = strlen ((char*) psf->header) ;\n\n\treturn ;\n} /* psf_asciiheader_printf */",
        "target": 1
    },
    {
        "id": 2689,
        "func": "static void kvm_track_tsc_matching(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\tbool vcpus_matched;\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\t atomic_read(&vcpu->kvm->online_vcpus));\n\n\t/*\n\t * Once the masterclock is enabled, always perform request in\n\t * order to update it.\n\t *\n\t * In order to enable masterclock, the host clocksource must be TSC\n\t * and the vcpus need to have matched TSCs.  When that happens,\n\t * perform request to enable masterclock.\n\t */\n\tif (ka->use_master_clock ||\n\t    (gtod->clock.vclock_mode == VCLOCK_TSC && vcpus_matched))\n\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\ttrace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,\n\t\t\t    atomic_read(&vcpu->kvm->online_vcpus),\n\t\t            ka->use_master_clock, gtod->clock.vclock_mode);\n#endif\n}",
        "target": 0
    },
    {
        "id": 2690,
        "func": "int phar_open_or_create_zip(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar;\n\tint ret = phar_create_or_parse_filename(fname, fname_len, alias, alias_len, is_data, options, &phar, error TSRMLS_CC);\n\n\tif (FAILURE == ret) {\n\t\treturn FAILURE;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = phar;\n\t}\n\n\tphar->is_data = is_data;\n\n\tif (phar->is_zip) {\n\t\treturn ret;\n\t}\n\n\tif (phar->is_brandnew) {\n\t\tphar->internal_file_start = 0;\n\t\tphar->is_zip = 1;\n\t\tphar->is_tar = 0;\n\t\treturn SUCCESS;\n\t}\n\n\t/* we've reached here - the phar exists and is a regular phar */\n\tif (error) {\n\t\tspprintf(error, 4096, \"phar zip error: phar \\\"%s\\\" already exists as a regular phar and must be deleted from disk prior to creating as a zip-based phar\", fname);\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 2691,
        "func": "void InputHandler::selectionChanged()\n{\n    if (!m_webPage->m_mainFrame)\n        return;\n\n    if (!isActiveTextEdit())\n        return;\n\n    if (processingChange())\n        return;\n\n    if (m_shouldEnsureFocusTextElementVisibleOnSelectionChanged) {\n        ensureFocusTextElementVisible(EdgeIfNeeded);\n        m_shouldEnsureFocusTextElementVisibleOnSelectionChanged = false;\n    }\n\n    ASSERT(m_currentFocusElement->document() && m_currentFocusElement->document()->frame());\n\n    if (m_receivedBackspaceKeyDown)\n        return;\n\n    int newSelectionStart = selectionStart();\n    int newSelectionEnd = selectionEnd();\n\n    InputLog(LogLevelInfo, \"InputHandler::selectionChanged selectionStart=%u, selectionEnd=%u\", newSelectionStart, newSelectionEnd);\n\n    m_webPage->m_client->inputSelectionChanged(newSelectionStart, newSelectionEnd);\n\n    removeAttributedTextMarker();\n}\n",
        "target": 0
    },
    {
        "id": 2692,
        "func": "void TabCountChangeObserver::TabDetachedAt(TabContents* contents,\nvoid TabCountChangeObserver::TabDetachedAt(WebContents* contents,\n                                            int index) {\n   CheckTabCount();\n }\n",
        "target": 0
    },
    {
        "id": 2693,
        "func": "void Part::slotPasteFilesDone(KJob *job)\n{\n    if (job->error() && job->error() != KJob::KilledJobError) {\n        KMessageBox::error(widget(), job->errorString());\n    }\n    m_cutIndexes.clear();\n    m_model->filesToMove.clear();\n    m_model->filesToCopy.clear();\n}\n",
        "target": 0
    },
    {
        "id": 2694,
        "func": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\n\t*prev = NULL;\t/* tell sys_madvise we drop mmap_sem */\n\n\tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n\t\treturn -EINVAL;\n\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\n\t/* filesystem's fallocate may need to take i_mutex */\n\tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}",
        "target": 1
    },
    {
        "id": 2695,
        "func": "void mem_cgroup_commit_charge_swapin(struct page *page,\n\t\t\t\t     struct mem_cgroup *memcg)\n{\n\t__mem_cgroup_commit_charge_swapin(page, memcg,\n\t\t\t\t\t  MEM_CGROUP_CHARGE_TYPE_MAPPED);\n}\n",
        "target": 0
    },
    {
        "id": 2696,
        "func": "static void tg3_napi_fini(struct tg3 *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->irq_cnt; i++)\n\t\tnetif_napi_del(&tp->napi[i].napi);\n}",
        "target": 0
    },
    {
        "id": 2697,
        "func": "OmniboxPopupViewGtk::OmniboxPopupViewGtk(const gfx::Font& font,\n                                          OmniboxView* omnibox_view,\n                                          AutocompleteEditModel* edit_model,\n                                          GtkWidget* location_bar)\n    : model_(new AutocompletePopupModel(this, edit_model)),\n       omnibox_view_(omnibox_view),\n       location_bar_(location_bar),\n       window_(gtk_window_new(GTK_WINDOW_POPUP)),\n      layout_(NULL),\n      theme_service_(ThemeServiceGtk::GetFrom(edit_model->profile())),\n      font_(font.DeriveFont(kEditFontAdjust)),\n      ignore_mouse_drag_(false),\n      opened_(false) {\n  gtk_widget_set_can_focus(window_, FALSE);\n  gtk_window_set_resizable(GTK_WINDOW(window_), FALSE);\n  gtk_widget_set_app_paintable(window_, TRUE);\n  gtk_widget_set_double_buffered(window_, TRUE);\n\n  layout_ = gtk_widget_create_pango_layout(window_, NULL);\n  pango_layout_set_auto_dir(layout_, FALSE);\n  pango_layout_set_ellipsize(layout_, PANGO_ELLIPSIZE_END);\n\n  gtk_widget_add_events(window_, GDK_BUTTON_MOTION_MASK |\n                                  GDK_POINTER_MOTION_MASK |\n                                  GDK_BUTTON_PRESS_MASK |\n                                  GDK_BUTTON_RELEASE_MASK);\n  g_signal_connect(window_, \"motion-notify-event\",\n                   G_CALLBACK(HandleMotionThunk), this);\n  g_signal_connect(window_, \"button-press-event\",\n                   G_CALLBACK(HandleButtonPressThunk), this);\n  g_signal_connect(window_, \"button-release-event\",\n                   G_CALLBACK(HandleButtonReleaseThunk), this);\n  g_signal_connect(window_, \"expose-event\",\n                   G_CALLBACK(HandleExposeThunk), this);\n \n   registrar_.Add(this,\n                  chrome::NOTIFICATION_BROWSER_THEME_CHANGED,\n                 content::Source<ThemeService>(theme_service_));\n  theme_service_->InitThemesFor(this);\n\n }\n",
        "target": 1
    },
    {
        "id": 2698,
        "func": "  void Reset() {\n    events_.clear();\n    tap_ = false;\n    tap_down_ = false;\n    tap_cancel_ = false;\n    begin_ = false;\n    end_ = false;\n    scroll_begin_ = false;\n    scroll_update_ = false;\n    scroll_end_ = false;\n    pinch_begin_ = false;\n    pinch_update_ = false;\n    pinch_end_ = false;\n    long_press_ = false;\n    fling_ = false;\n    two_finger_tap_ = false;\n    show_press_ = false;\n    swipe_left_ = false;\n    swipe_right_ = false;\n    swipe_up_ = false;\n    swipe_down_ = false;\n\n    scroll_begin_position_.SetPoint(0, 0);\n    tap_location_.SetPoint(0, 0);\n    gesture_end_location_.SetPoint(0, 0);\n\n    scroll_x_ = 0;\n    scroll_y_ = 0;\n    scroll_velocity_x_ = 0;\n    scroll_velocity_y_ = 0;\n    velocity_x_ = 0;\n    velocity_y_ = 0;\n    scroll_x_hint_ = 0;\n    scroll_y_hint_ = 0;\n     tap_count_ = 0;\n     scale_ = 0;\n     flags_ = 0;\n   }\n",
        "target": 1
    },
    {
        "id": 2699,
        "func": "  void TestWeirdType(const V8ValueConverterImpl& converter,\n                     v8::Local<v8::Value> val,\n                     base::Value::Type expected_type,\n                     std::unique_ptr<base::Value> expected_value) {\n    v8::Local<v8::Context> context =\n        v8::Local<v8::Context>::New(isolate_, context_);\n    std::unique_ptr<base::Value> raw(converter.FromV8Value(val, context));\n\n    if (expected_value) {\n      ASSERT_TRUE(raw.get());\n      EXPECT_TRUE(expected_value->Equals(raw.get()));\n      EXPECT_EQ(expected_type, raw->GetType());\n    } else {\n      EXPECT_FALSE(raw.get());\n    }\n\n    v8::Local<v8::Object> object(v8::Object::New(isolate_));\n    object->Set(v8::String::NewFromUtf8(isolate_, \"test\"), val);\n    std::unique_ptr<base::DictionaryValue> dictionary(\n        static_cast<base::DictionaryValue*>(\n            converter.FromV8Value(object, context)));\n    ASSERT_TRUE(dictionary.get());\n\n    if (expected_value) {\n      base::Value* temp = NULL;\n      ASSERT_TRUE(dictionary->Get(\"test\", &temp));\n      EXPECT_EQ(expected_type, temp->GetType());\n      EXPECT_TRUE(expected_value->Equals(temp));\n    } else {\n      EXPECT_FALSE(dictionary->HasKey(\"test\"));\n    }\n\n    v8::Local<v8::Array> array(v8::Array::New(isolate_));\n    array->Set(0, val);\n    std::unique_ptr<base::ListValue> list(\n        static_cast<base::ListValue*>(converter.FromV8Value(array, context)));\n    ASSERT_TRUE(list.get());\n    if (expected_value) {\n      base::Value* temp = NULL;\n      ASSERT_TRUE(list->Get(0, &temp));\n      EXPECT_EQ(expected_type, temp->GetType());\n      EXPECT_TRUE(expected_value->Equals(temp));\n    } else {\n      base::Value* temp = NULL;\n      ASSERT_TRUE(list->Get(0, &temp));\n      EXPECT_EQ(base::Value::TYPE_NULL, temp->GetType());\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 2700,
        "func": " PassRefPtr<RenderStyle> HTMLInputElement::customStyleForRenderer()\n {\n    return m_inputTypeView->customStyleForRenderer(originalStyleForRenderer());\n}\n",
        "target": 0
    },
    {
        "id": 2701,
        "func": "void llc_sap_rtn_pdu(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tstruct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);\n\n\tswitch (LLC_U_PDU_RSP(pdu)) {\n\tcase LLC_1_PDU_CMD_TEST:\n\t\tev->prim = LLC_TEST_PRIM;\tbreak;\n\tcase LLC_1_PDU_CMD_XID:\n\t\tev->prim = LLC_XID_PRIM;\tbreak;\n\tcase LLC_1_PDU_CMD_UI:\n\t\tev->prim = LLC_DATAUNIT_PRIM;\tbreak;\n\t}\n\tev->ind_cfm_flag = LLC_IND;\n}",
        "target": 0
    },
    {
        "id": 2702,
        "func": "void ExternalProtocolHandler::LaunchUrlWithDelegate(\n    const GURL& url,\n    int render_process_host_id,\n    int render_view_routing_id,\n    ui::PageTransition page_transition,\n    bool has_user_gesture,\n    Delegate* delegate) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n \n   std::string escaped_url_string = net::EscapeExternalHandlerValue(url.spec());\n   GURL escaped_url(escaped_url_string);\n \n  content::WebContents* web_contents = tab_util::GetWebContentsByID(\n      render_process_host_id, render_view_routing_id);\n  Profile* profile = nullptr;\n  if (web_contents)  // Maybe NULL during testing.\n    profile = Profile::FromBrowserContext(web_contents->GetBrowserContext());\n  BlockState block_state =\n      GetBlockStateWithDelegate(escaped_url.scheme(), delegate, profile);\n  if (block_state == BLOCK) {\n    if (delegate)\n      delegate->BlockRequest();\n    return;\n  }\n\n  g_accept_requests = false;\n\n   shell_integration::DefaultWebClientWorkerCallback callback = base::Bind(\n      &OnDefaultProtocolClientWorkerFinished, url, render_process_host_id,\n      render_view_routing_id, block_state == UNKNOWN, page_transition,\n      has_user_gesture, delegate);\n \n  CreateShellWorker(callback, escaped_url.scheme(), delegate)\n      ->StartCheckIsDefault();\n}\n",
        "target": 1
    },
    {
        "id": 2703,
        "func": "ResourceMultiBufferDataProvider::ResourceMultiBufferDataProvider(\n    UrlData* url_data,\n    MultiBufferBlockId pos,\n    bool is_client_audio_element)\n    : pos_(pos),\n      url_data_(url_data),\n      retries_(0),\n      cors_mode_(url_data->cors_mode()),\n      origin_(url_data->url().GetOrigin()),\n      is_client_audio_element_(is_client_audio_element),\n      weak_factory_(this) {\n  DCHECK(url_data_) << \" pos = \" << pos;\n  DCHECK_GE(pos, 0);\n}\n",
        "target": 0
    },
    {
        "id": 2704,
        "func": "VariationsSeedStore::VariationsSeedStore(PrefService* local_state)\n    : local_state_(local_state), seed_has_country_code_(false) {\n}\n",
        "target": 0
    },
    {
        "id": 2705,
        "func": "void DevToolsAgentHost::DetachAllClients() {\n  if (!g_devtools_instances.IsCreated())\n    return;\n\n   DevToolsMap copy = g_devtools_instances.Get();\n   for (DevToolsMap::iterator it(copy.begin()); it != copy.end(); ++it) {\n     DevToolsAgentHostImpl* agent_host = it->second;\n    agent_host->ForceDetachAllClients();\n   }\n }\n",
        "target": 1
    },
    {
        "id": 2706,
        "func": "static void pty_line_name(struct tty_driver *driver, int index, char *p)\n{\n\tint i = index + driver->name_base;\n\t/* ->name is initialized to \"ttyp\", but \"tty\" is expected */\n\tsprintf(p, \"%s%c%x\",\n\t\tdriver->subtype == PTY_TYPE_SLAVE ? \"tty\" : driver->name,\n\t\tptychar[i >> 4 & 0xf], i & 0xf);\n}",
        "target": 0
    },
    {
        "id": 2707,
        "func": "PHP_FUNCTION(highlight_file)\n{\n\tchar *filename;\n\tint filename_len, ret;\n\tzend_syntax_highlighter_ini syntax_highlighter_ini;\n\tzend_bool i = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|b\", &filename, &filename_len, &i) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_check_open_basedir(filename TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (i) {\n\t\tphp_output_start_default(TSRMLS_C);\n\t}\n\n\tphp_get_highlight_struct(&syntax_highlighter_ini);\n\n\tret = highlight_file(filename, &syntax_highlighter_ini TSRMLS_CC);\n\n\tif (ret == FAILURE) {\n\t\tif (i) {\n\t\t\tphp_output_end(TSRMLS_C);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tif (i) {\n\t\tphp_output_get_contents(return_value TSRMLS_CC);\n\t\tphp_output_discard(TSRMLS_C);\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 2708,
        "func": "static int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppm->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppm->ind)) {\n\t\tgoto error;\n\t}\n\n\tppm->len = ms->len - 1;\n\tif (ppm->len > 0) {\n\t\tif (!(ppm->data = jas_malloc(ppm->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (JAS_CAST(jas_uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppm->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppm_destroyparms(ms);\n\treturn -1;\n}",
        "target": 0
    },
    {
        "id": 2709,
        "func": "_rsvg_io_get_file_path (const gchar * filename,\n                        const gchar * base_uri)\n{\n    gchar *absolute_filename;\n\n    if (g_file_test (filename, G_FILE_TEST_EXISTS) || g_path_is_absolute (filename)) {\n        absolute_filename = g_strdup (filename);\n    } else {\n        gchar *tmpcdir;\n        gchar *base_filename;\n\n        if (base_uri) {\n            base_filename = g_filename_from_uri (base_uri, NULL, NULL);\n            if (base_filename != NULL) {\n                tmpcdir = g_path_get_dirname (base_filename);\n                g_free (base_filename);\n            } else \n                return NULL;\n        } else\n            tmpcdir = g_get_current_dir ();\n\n        absolute_filename = g_build_filename (tmpcdir, filename, NULL);\n        g_free (tmpcdir);\n    }\n\n    return absolute_filename;\n}",
        "target": 1
    },
    {
        "id": 2710,
        "func": "static inline enum direction decode_direction(unsigned int insn)\n{\n\tunsigned long tmp = (insn >> 21) & 1;\n\n\tif(!tmp)\n\t\treturn load;\n\telse {\n\t\tif(((insn>>19)&0x3f) == 15)\n\t\t\treturn both;\n\t\telse\n\t\t\treturn store;\n\t}\n}",
        "target": 0
    },
    {
        "id": 2711,
        "func": "queue_fake_message (FlatpakProxyClient *client, GDBusMessage *message, ExpectedReplyType reply_type)\n{\n  Buffer *buffer;\n\n  client->last_serial++;\n  client->serial_offset++;\n  g_dbus_message_set_serial (message, client->last_serial);\n  buffer = message_to_buffer (message);\n  g_object_unref (message);\n\n  queue_outgoing_buffer (&client->bus_side, buffer);\n  queue_expected_reply (&client->client_side, client->last_serial, reply_type);\n}",
        "target": 0
    },
    {
        "id": 2712,
        "func": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tint bitmap_pos;\n\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\n\tif (bitmap_pos < 0) {\n\t\tchar *name = path_name(path, last);\n\t\tbitmap_pos = ext_index_add_object(object, name);\n\t\tfree(name);\n\t}\n\n\tbitmap_set(base, bitmap_pos);\n}",
        "target": 1
    },
    {
        "id": 2713,
        "func": "static int do_devconfig_ioctl(struct comedi_device *dev,\n\t\t\t      struct comedi_devconfig __user *arg)\n{\n\tstruct comedi_devconfig it;\n\tint ret;\n\tunsigned char *aux_data = NULL;\n\tint aux_len;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (arg == NULL) {\n\t\tif (is_device_busy(dev))\n\t\t\treturn -EBUSY;\n\t\tif (dev->attached) {\n\t\t\tstruct module *driver_module = dev->driver->module;\n\t\t\tcomedi_device_detach(dev);\n\t\t\tmodule_put(driver_module);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (copy_from_user(&it, arg, sizeof(struct comedi_devconfig)))\n\t\treturn -EFAULT;\n\n\tit.board_name[COMEDI_NAMELEN - 1] = 0;\n\n\tif (comedi_aux_data(it.options, 0) &&\n\t    it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {\n\t\tint bit_shift;\n\t\taux_len = it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH];\n\t\tif (aux_len < 0)\n\t\t\treturn -EFAULT;\n\n\t\taux_data = vmalloc(aux_len);\n\t\tif (!aux_data)\n\t\t\treturn -ENOMEM;\n\n\t\tif (copy_from_user(aux_data,\n\t\t\t\t   comedi_aux_data(it.options, 0), aux_len)) {\n\t\t\tvfree(aux_data);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tit.options[COMEDI_DEVCONF_AUX_DATA_LO] =\n\t\t    (unsigned long)aux_data;\n\t\tif (sizeof(void *) > sizeof(int)) {\n\t\t\tbit_shift = sizeof(int) * 8;\n\t\t\tit.options[COMEDI_DEVCONF_AUX_DATA_HI] =\n\t\t\t    ((unsigned long)aux_data) >> bit_shift;\n\t\t} else\n\t\t\tit.options[COMEDI_DEVCONF_AUX_DATA_HI] = 0;\n\t}\n\n\tret = comedi_device_attach(dev, &it);\n\tif (ret == 0) {\n\t\tif (!try_module_get(dev->driver->module)) {\n\t\t\tcomedi_device_detach(dev);\n\t\t\treturn -ENOSYS;\n\t\t}\n\t}\n\n\tif (aux_data)\n\t\tvfree(aux_data);\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 2714,
        "func": " void BluetoothOptionsHandler::GenerateFakeDeviceList() {\n  GenerateFakeDiscoveredDevice(\n     \"Fake Wireless Keyboard\",\n     \"01-02-03-04-05-06\",\n     \"input-keyboard\",\n     true,\n    true);\n  GenerateFakeDiscoveredDevice(\n     \"Fake Wireless Mouse\",\n     \"02-03-04-05-06-01\",\n     \"input-mouse\",\n     true,\n    false);\n  GenerateFakeDiscoveredDevice(\n     \"Fake Wireless Headset\",\n     \"03-04-05-06-01-02\",\n     \"headset\",\n     false,\n    false);\n  GenerateFakePairing(\n     \"Fake Connecting Keyboard\",\n     \"04-05-06-01-02-03\",\n     \"input-keyboard\",\n     \"bluetoothRemotePasskey\");\n  GenerateFakePairing(\n     \"Fake Connecting Phone\",\n     \"05-06-01-02-03-04\",\n     \"phone\",\n     \"bluetoothConfirmPasskey\");\n  GenerateFakePairing(\n     \"Fake Connecting Headset\",\n     \"06-01-02-03-04-05\",\n     \"headset\",\n     \"bluetoothEnterPasskey\");\n \n   web_ui_->CallJavascriptFunction(\n       \"options.SystemOptions.notifyBluetoothSearchComplete\");\n }\n",
        "target": 1
    },
    {
        "id": 2715,
        "func": "xmlXPathNewFloat(double val) {\n    xmlXPathObjectPtr ret;\n\n    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n    if (ret == NULL) {\n        xmlXPathErrMemory(NULL, \"creating float object\\n\");\n\treturn(NULL);\n    }\n    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n    ret->type = XPATH_NUMBER;\n    ret->floatval = val;\n#ifdef XP_DEBUG_OBJ_USAGE\n    xmlXPathDebugObjUsageRequested(NULL, XPATH_NUMBER);\n#endif\n    return(ret);\n}\n",
        "target": 0
    },
    {
        "id": 2716,
        "func": "status_t Camera3Device::deleteReprocessStream(int id) {\n    ATRACE_CALL();\n (void)id;\n\n    CLOGE(\"Unimplemented\");\n return INVALID_OPERATION;\n}\n",
        "target": 0
    },
    {
        "id": 2717,
        "func": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}",
        "target": 1
    },
    {
        "id": 2718,
        "func": "void EventBindings::MatchAgainstEventFilter(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  v8::Isolate* isolate = args.GetIsolate();\n  typedef std::set<EventFilter::MatcherID> MatcherIDs;\n  EventFilter& event_filter = g_event_filter.Get();\n  std::string event_name = *v8::String::Utf8Value(args[0]);\n  EventFilteringInfo info =\n      ParseFromObject(args[1]->ToObject(isolate), isolate);\n  MatcherIDs matched_event_filters = event_filter.MatchEvent(\n      event_name, info, context()->GetRenderFrame()->GetRoutingID());\n  v8::Local<v8::Array> array(\n      v8::Array::New(isolate, matched_event_filters.size()));\n  int i = 0;\n  for (MatcherIDs::iterator it = matched_event_filters.begin();\n       it != matched_event_filters.end();\n       ++it) {\n    array->Set(v8::Integer::New(isolate, i++), v8::Integer::New(isolate, *it));\n  }\n  args.GetReturnValue().Set(array);\n}\n",
        "target": 0
    },
    {
        "id": 2719,
        "func": "void VRDisplay::ProcessScheduledWindowAnimations(double timestamp) {\n  TRACE_EVENT1(\"gpu\", \"VRDisplay::window.rAF\", \"frame\", vr_frame_id_);\n  auto doc = navigator_vr_->GetDocument();\n  if (!doc)\n    return;\n   auto page = doc->GetPage();\n   if (!page)\n     return;\n   page->Animator().ServiceScriptedAnimations(timestamp);\n }\n",
        "target": 1
    },
    {
        "id": 2720,
        "func": "int migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2721,
        "func": "PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->decodetile != NULL);\n\n \tif ((*sp->decodetile)(tif, op0, occ0, s)) {\n \t\ttmsize_t rowsize = sp->rowsize;\n \t\tassert(rowsize > 0);\n\t\tassert((occ0%rowsize)==0);\n \t\tassert(sp->decodepfunc != NULL);\n \t\twhile (occ0 > 0) {\n\t\t\t(*sp->decodepfunc)(tif, op0, rowsize);\n \t\t\tocc0 -= rowsize;\n \t\t\top0 += rowsize;\n \t\t}\n\t\treturn 1;\n\t} else\n \t\treturn 0;\n }\n",
        "target": 1
    },
    {
        "id": 2722,
        "func": "void Document::updateLayout()\n{\n    ASSERT(isMainThread());\n\n    ScriptForbiddenScope forbidScript;\n\n    RefPtrWillBeRawPtr<FrameView> frameView = view();\n    if (frameView && frameView->isInPerformLayout()) {\n        ASSERT_NOT_REACHED();\n        return;\n    }\n\n    if (HTMLFrameOwnerElement* owner = ownerElement())\n        owner->document().updateLayout();\n\n    updateLayoutTreeIfNeeded();\n\n    if (!isActive())\n        return;\n\n    if (frameView->needsLayout())\n        frameView->layout();\n\n    if (lifecycle().state() < DocumentLifecycle::LayoutClean)\n        lifecycle().advanceTo(DocumentLifecycle::LayoutClean);\n}\n",
        "target": 0
    },
    {
        "id": 2723,
        "func": "bool IsValidPVRTCSize(GLint level, GLsizei size) {\n  return GLES2Util::IsPOT(size);\n}\n",
        "target": 0
    },
    {
        "id": 2724,
        "func": "static void freq_to_fnum    (int freq, int *block, int *fnum)\n{\n\tint f, octave;\n\n\t/*\n\t * Converts the note frequency to block and fnum values for the FM chip\n\t */\n\t/*\n\t * First try to compute the block -value (octave) where the note belongs\n\t */\n\n\tf = freq;\n\n\toctave = 5;\n\n\tif (f == 0)\n\t\toctave = 0;\n\telse if (f < 261)\n\t{\n\t\twhile (f < 261)\n\t\t{\n\t\t\toctave--;\n\t\t\tf <<= 1;\n\t\t}\n\t}\n\telse if (f > 493)\n\t{\n\t\twhile (f > 493)\n\t\t{\n\t\t\t octave++;\n\t\t\t f >>= 1;\n\t\t}\n\t}\n\n\tif (octave > 7)\n\t\toctave = 7;\n\n\t*fnum = freq * (1 << (20 - octave)) / 49716;\n\t*block = octave;\n}",
        "target": 0
    },
    {
        "id": 2725,
        "func": "spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}",
        "target": 1
    },
    {
        "id": 2726,
        "func": "bool BackgroundLoaderOffliner::HandleTimeout(int64_t request_id) {\n  if (pending_request_) {\n    DCHECK(request_id == pending_request_->request_id());\n    if (is_low_bar_met_ && (pending_request_->started_attempt_count() + 1 >=\n                                policy_->GetMaxStartedTries() ||\n                            pending_request_->completed_attempt_count() + 1 >=\n                                policy_->GetMaxCompletedTries())) {\n      if (save_state_ == NONE) {\n        did_snapshot_on_last_retry_ = true;\n        StartSnapshot();\n      }\n      return true;\n    }\n  }\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 2727,
        "func": "v8::Handle<v8::Value> V8DOMWrapper::convertDOMImplementationToV8Object(DOMImplementation* impl)\n{\n    v8::Handle<v8::Object> result = instantiateV8Object(V8ClassIndex::DOMIMPLEMENTATION, V8ClassIndex::DOMIMPLEMENTATION, impl);\n    if (result.IsEmpty()) {\n        return v8::Null();\n    }\n    return result;\n}\n",
        "target": 0
    },
    {
        "id": 2728,
        "func": "void HWNDMessageHandler::OnSize(UINT param, const CSize& size) {\n  RedrawWindow(hwnd(), NULL, NULL, RDW_INVALIDATE | RDW_ALLCHILDREN);\n  ResetWindowRegion(false, true);\n\n#if defined(USE_AURA)\n  if (scroll_styles_set_) {\n     ShowScrollBar(hwnd(), SB_BOTH, FALSE);\n     base::MessageLoop::current()->PostTask(\n        FROM_HERE,\n        base::Bind(&AddScrollStylesToWindow, hwnd()));\n#endif\n   }\n }\n",
        "target": 1
    },
    {
        "id": 2729,
        "func": "show_wbxml_string_table (proto_tree *tree, tvbuff_t *tvb, guint32 str_tbl,\n\t\t\t guint32 str_tbl_len)\n{\n\tguint32 off = str_tbl;\n\tguint32 len = 0;\n\tguint32 end = str_tbl + str_tbl_len;\n\n\tproto_tree_add_text (tree, tvb, off, end,\n\t\t\t     \"Start  | Length | String\");\n\twhile (off < end) {\n\t\tlen = tvb_strsize (tvb, off);\n\t\tproto_tree_add_text (tree, tvb, off, len,\n\t\t\t\t     \"%6d | %6d | '%s'\",\n\t\t\t\t     off - str_tbl, len,\n\t\t\t\t     tvb_format_text (tvb, off, len-1));\n\t\toff += len;\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 2730,
        "func": "static void callbackFunctionReturnValueMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    v8SetReturnValue(info, imp->callbackFunctionReturnValue().v8Value());\n}\n",
        "target": 0
    },
    {
        "id": 2731,
        "func": "num_rend_services(void)\n{\n  if (!rend_service_list)\n    return 0;\n  return smartlist_len(rend_service_list);\n}",
        "target": 0
    },
    {
        "id": 2732,
        "func": "int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n const VpxInterface *decoder = NULL;\n VpxVideoReader *reader = NULL;\n const VpxVideoInfo *info = NULL;\n int n = 0;\n int m = 0;\n int is_range = 0;\n char *nptr = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 4)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing.\", argv[2]);\n\n  n = strtol(argv[3], &nptr, 0);\n  m = strtol(nptr + 1, NULL, 0);\n  is_range = (*nptr == '-');\n if (!n || !m || (*nptr != '-' && *nptr != '/'))\n    die(\"Couldn't parse pattern %s.\\n\", argv[3]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n     die_codec(&codec, \"Failed to initialize decoder.\");\n \n   while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n int skip;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))\n      die_codec(&codec, \"Failed to decode frame.\");\n\n ++frame_cnt;\n\n    skip = (is_range && frame_cnt >= n && frame_cnt <= m) ||\n (!is_range && m - (frame_cnt - 1) % m <= n);\n\n if (!skip) {\n      putc('.', stdout);\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL)\n        vpx_img_write(img, outfile);\n } else {\n      putc('X', stdout);\n }\n\n    fflush(stdout);\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  printf(\"Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\\n\",\n         info->frame_width, info->frame_height, argv[2]);\n\n  vpx_video_reader_close(reader);\n  fclose(outfile);\n\n return EXIT_SUCCESS;\n}\n",
        "target": 1
    },
    {
        "id": 2733,
        "func": "static void dispatchNVWriteItem(Parcel &p, RequestInfo *pRI) {\n    RIL_NV_WriteItem nvwi;\n int32_t  t;\n status_t status;\n\n    memset(&nvwi, 0, sizeof(nvwi));\n\n    status = p.readInt32(&t);\n    nvwi.itemID = (RIL_NV_Item) t;\n\n    nvwi.value = strdupReadString(p);\n\n if (status != NO_ERROR || nvwi.value == NULL) {\n goto invalid;\n }\n\n    startRequest;\n    appendPrintBuf(\"%snvwi.itemID=%d, value=%s, \", printBuf, nvwi.itemID,\n            nvwi.value);\n    closeRequest;\n\n    printRequest(pRI->token, pRI->pCI->requestNumber);\n\n    CALL_ONREQUEST(pRI->pCI->requestNumber, &nvwi, sizeof(nvwi), pRI, pRI->socket_id);\n\n#ifdef MEMSET_FREED\n    memsetString(nvwi.value);\n#endif\n\n    free(nvwi.value);\n\n#ifdef MEMSET_FREED\n    memset(&nvwi, 0, sizeof(nvwi));\n#endif\n\n return;\n\ninvalid:\n    invalidCommandBlock(pRI);\n return;\n}\n",
        "target": 0
    },
    {
        "id": 2734,
        "func": "static void cmd_namespace(char* tag)\n{\n    int sawone[3] = {0, 0, 0};\n    char* pattern;\n\n    if (SLEEZY_NAMESPACE) {\n        if (strlen(imapd_userid) + 5 >= MAX_MAILBOX_BUFFER)\n            sawone[NAMESPACE_INBOX] = 0;\n        else {\n            char *inbox = mboxname_user_mbox(imapd_userid, NULL);\n            sawone[NAMESPACE_INBOX] =\n                !mboxlist_lookup(inbox, NULL, NULL);\n            free(inbox);\n        }\n        sawone[NAMESPACE_USER] = imapd_userisadmin ? 1 : imapd_namespace.accessible[NAMESPACE_USER];\n        sawone[NAMESPACE_SHARED] = imapd_userisadmin ? 1 : imapd_namespace.accessible[NAMESPACE_SHARED];\n    } else {\n        pattern = xstrdup(\"%\");\n        /* now find all the exciting toplevel namespaces -\n         * we're using internal names here\n         */\n        mboxlist_findall(NULL, pattern, imapd_userisadmin, imapd_userid,\n                         imapd_authstate, namespacedata, (void*) sawone);\n        free(pattern);\n    }\n\n    prot_printf(imapd_out, \"* NAMESPACE\");\n    if (sawone[NAMESPACE_INBOX]) {\n        prot_printf(imapd_out, \" ((\\\"%s\\\" \\\"%c\\\"))\",\n                    imapd_namespace.prefix[NAMESPACE_INBOX],\n                    imapd_namespace.hier_sep);\n    } else {\n        prot_printf(imapd_out, \" NIL\");\n    }\n    if (sawone[NAMESPACE_USER]) {\n        prot_printf(imapd_out, \" ((\\\"%s\\\" \\\"%c\\\"))\",\n                    imapd_namespace.prefix[NAMESPACE_USER],\n                    imapd_namespace.hier_sep);\n    } else {\n        prot_printf(imapd_out, \" NIL\");\n    }\n    if (sawone[NAMESPACE_SHARED]) {\n        prot_printf(imapd_out, \" ((\\\"%s\\\" \\\"%c\\\"))\",\n                    imapd_namespace.prefix[NAMESPACE_SHARED],\n                    imapd_namespace.hier_sep);\n    } else {\n        prot_printf(imapd_out, \" NIL\");\n    }\n    prot_printf(imapd_out, \"\\r\\n\");\n\n    imapd_check(NULL, 0);\n\n    prot_printf(imapd_out, \"%s OK %s\\r\\n\", tag,\n                error_message(IMAP_OK_COMPLETED));\n}\n",
        "target": 0
    },
    {
        "id": 2735,
        "func": "void fix_bad(DOS_FS * fs)\n{\n    uint32_t i;\n\n    if (verbose)\n\tprintf(\"Checking for bad clusters.\\n\");\n    for (i = 2; i < fs->clusters + 2; i++) {\n\tFAT_ENTRY curEntry;\n\tget_fat(&curEntry, fs->fat, i, fs);\n\n\tif (!get_owner(fs, i) && !FAT_IS_BAD(fs, curEntry.value))\n\t    if (!fs_test(cluster_start(fs, i), fs->cluster_size)) {\n\t\tprintf(\"Cluster %lu is unreadable.\\n\", (unsigned long)i);\n\t\tset_fat(fs, i, -2);\n\t    }\n    }\n}",
        "target": 0
    },
    {
        "id": 2736,
        "func": "status_t MediaMetadataRetriever::setDataSource(\n const sp<IMediaHTTPService> &httpService,\n const char *srcUrl,\n const KeyedVector<String8, String8> *headers)\n{\n    ALOGV(\"setDataSource\");\n Mutex::Autolock _l(mLock);\n if (mRetriever == 0) {\n        ALOGE(\"retriever is not initialized\");\n return INVALID_OPERATION;\n }\n if (srcUrl == NULL) {\n        ALOGE(\"data source is a null pointer\");\n return UNKNOWN_ERROR;\n }\n    ALOGV(\"data source (%s)\", srcUrl);\n return mRetriever->setDataSource(httpService, srcUrl, headers);\n}\n",
        "target": 0
    },
    {
        "id": 2737,
        "func": "void RenderThreadImpl::HistogramCustomizer::RenderViewNavigatedToHost(\n    const std::string& host, size_t view_count) {\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kDisableHistogramCustomizer)) {\n    return;\n  }\n  if (view_count == 1)\n    SetCommonHost(host);\n  else if (host != common_host_)\n    SetCommonHost(std::string());\n}\n",
        "target": 0
    },
    {
        "id": 2738,
        "func": "static void predictor_decode_mono_3950(APEContext *ctx, int count)\n{\n    APEPredictor *p = &ctx->predictor;\n    int32_t *decoded0 = ctx->decoded[0];\n    int32_t predictionA, currentA, A, sign;\n\n    ape_apply_filters(ctx, ctx->decoded[0], NULL, count);\n\n    currentA = p->lastA[0];\n\n    while (count--) {\n        A = *decoded0;\n\n        p->buf[YDELAYA] = currentA;\n        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n\n        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +\n                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +\n                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n\n        currentA = A + (predictionA >> 10);\n\n        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n\n        sign = APESIGN(A);\n        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n\n        p->buf++;\n\n        /* Have we filled the history buffer? */\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n            memmove(p->historybuffer, p->buf,\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n            p->buf = p->historybuffer;\n        }\n\n        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);\n        *(decoded0++) = p->filterA[0];\n    }\n\n    p->lastA[0] = currentA;\n}",
        "target": 0
    },
    {
        "id": 2739,
        "func": "static void ehci_update_frindex(EHCIState *ehci, int uframes)\n{\n    if (!ehci_enabled(ehci) && ehci->pstate == EST_INACTIVE) {\n        return;\n    }\n\n    /* Generate FLR interrupt if frame index rolls over 0x2000 */\n    if ((ehci->frindex % 0x2000) + uframes >= 0x2000) {\n        ehci_raise_irq(ehci, USBSTS_FLR);\n    }\n\n    /* How many times will frindex roll over 0x4000 with this frame count?\n     * usbsts_frindex is decremented by 0x4000 on rollover until it reaches 0\n     */\n    int rollovers = (ehci->frindex + uframes) / 0x4000;\n    if (rollovers > 0) {\n        if (ehci->usbsts_frindex >= (rollovers * 0x4000)) {\n            ehci->usbsts_frindex -= 0x4000 * rollovers;\n        } else {\n            ehci->usbsts_frindex = 0;\n        }\n    }\n\n    ehci->frindex = (ehci->frindex + uframes) % 0x4000;\n}\n",
        "target": 0
    },
    {
        "id": 2740,
        "func": "static void pit_load_count(struct kvm *kvm, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &kvm->arch.vpit->pit_state;\n\n\tWARN_ON(!mutex_is_locked(&ps->lock));\n\n\tpr_debug(\"load_count val is %d, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(kvm, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(kvm, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(kvm->arch.vpit);\n\t}\n}",
        "target": 0
    },
    {
        "id": 2741,
        "func": "bool DesktopWindowTreeHostX11::IsVisibleOnAllWorkspaces() const {\n  return GetWorkspace() == base::NumberToString(kAllDesktops);\n}\n",
        "target": 0
    },
    {
        "id": 2742,
        "func": "ctrl_body_print(netdissect_options *ndo,\n                uint16_t fc, const u_char *p)\n{\n\tND_PRINT((ndo, \"%s\", tok2str(ctrl_str, \"Unknown Ctrl Subtype\", FC_SUBTYPE(fc))));\n\tswitch (FC_SUBTYPE(fc)) {\n\tcase CTRL_CONTROL_WRAPPER:\n\t\t/* XXX - requires special handling */\n\t\tbreak;\n\tcase CTRL_BAR:\n\t\tif (!ND_TTEST2(*p, CTRL_BAR_HDRLEN))\n\t\t\treturn 0;\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \" RA:%s TA:%s CTL(%x) SEQ(%u) \",\n\t\t\t    etheraddr_string(ndo, ((const struct ctrl_bar_hdr_t *)p)->ra),\n\t\t\t    etheraddr_string(ndo, ((const struct ctrl_bar_hdr_t *)p)->ta),\n\t\t\t    EXTRACT_LE_16BITS(&(((const struct ctrl_bar_hdr_t *)p)->ctl)),\n\t\t\t    EXTRACT_LE_16BITS(&(((const struct ctrl_bar_hdr_t *)p)->seq))));\n\t\tbreak;\n\tcase CTRL_BA:\n\t\tif (!ND_TTEST2(*p, CTRL_BA_HDRLEN))\n\t\t\treturn 0;\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \" RA:%s \",\n\t\t\t    etheraddr_string(ndo, ((const struct ctrl_ba_hdr_t *)p)->ra)));\n\t\tbreak;\n\tcase CTRL_PS_POLL:\n\t\tif (!ND_TTEST2(*p, CTRL_PS_POLL_HDRLEN))\n\t\t\treturn 0;\n\t\tND_PRINT((ndo, \" AID(%x)\",\n\t\t    EXTRACT_LE_16BITS(&(((const struct ctrl_ps_poll_hdr_t *)p)->aid))));\n\t\tbreak;\n\tcase CTRL_RTS:\n\t\tif (!ND_TTEST2(*p, CTRL_RTS_HDRLEN))\n\t\t\treturn 0;\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \" TA:%s \",\n\t\t\t    etheraddr_string(ndo, ((const struct ctrl_rts_hdr_t *)p)->ta)));\n\t\tbreak;\n\tcase CTRL_CTS:\n\t\tif (!ND_TTEST2(*p, CTRL_CTS_HDRLEN))\n\t\t\treturn 0;\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \" RA:%s \",\n\t\t\t    etheraddr_string(ndo, ((const struct ctrl_cts_hdr_t *)p)->ra)));\n\t\tbreak;\n\tcase CTRL_ACK:\n\t\tif (!ND_TTEST2(*p, CTRL_ACK_HDRLEN))\n\t\t\treturn 0;\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \" RA:%s \",\n\t\t\t    etheraddr_string(ndo, ((const struct ctrl_ack_hdr_t *)p)->ra)));\n\t\tbreak;\n\tcase CTRL_CF_END:\n\t\tif (!ND_TTEST2(*p, CTRL_END_HDRLEN))\n\t\t\treturn 0;\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \" RA:%s \",\n\t\t\t    etheraddr_string(ndo, ((const struct ctrl_end_hdr_t *)p)->ra)));\n\t\tbreak;\n\tcase CTRL_END_ACK:\n\t\tif (!ND_TTEST2(*p, CTRL_END_ACK_HDRLEN))\n\t\t\treturn 0;\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \" RA:%s \",\n\t\t\t    etheraddr_string(ndo, ((const struct ctrl_end_ack_hdr_t *)p)->ra)));\n\t\tbreak;\n\t}\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 2743,
        "func": "xfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
        "target": 0
    },
    {
        "id": 2744,
        "func": "  AccessType GetExtensionAccess(const Extension* extension,\n                                const GURL& url,\n                                 int tab_id) {\n     bool allowed_script = IsAllowedScript(extension, url, tab_id);\n     bool allowed_capture = extension->permissions_data()->CanCaptureVisiblePage(\n        url, tab_id, nullptr);\n \n     if (allowed_script && allowed_capture)\n       return ALLOWED_SCRIPT_AND_CAPTURE;\n    if (allowed_script)\n      return ALLOWED_SCRIPT_ONLY;\n    if (allowed_capture)\n      return ALLOWED_CAPTURE_ONLY;\n    return DISALLOWED;\n  }\n",
        "target": 1
    },
    {
        "id": 2745,
        "func": "WM_SYMBOL const char *WildMidi_GetString(uint16_t info) {\n    static char WM_Version[] = \"WildMidi Processing Library \" PACKAGE_VERSION;\n    switch (info) {\n    case WM_GS_VERSION:\n        return WM_Version;\n    }\n    return NULL;\n}",
        "target": 0
    },
    {
        "id": 2746,
        "func": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\n\tif (ndp_msg_type_info(msg_type)->addrto_validate)\n\t\treturn ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);\n\telse\n\t\treturn true;\n}",
        "target": 0
    },
    {
        "id": 2747,
        "func": "ConfirmEmailDialogDelegate::ConfirmEmailDialogDelegate(\n    content::WebContents* contents,\n    const std::string& last_email,\n    const std::string& email,\n    Callback callback)\n  : TabModalConfirmDialogDelegate(contents),\n    last_email_(last_email),\n    email_(email),\n    callback_(callback) {\n}\n",
        "target": 0
    },
    {
        "id": 2748,
        "func": "void GLES2Implementation::MultiDrawElementsInstancedWEBGL(\n    GLenum mode,\n    const GLsizei* counts,\n    GLenum type,\n    const GLsizei* offsets,\n    const GLsizei* instance_counts,\n    GLsizei drawcount) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] glMultiDrawElementsInstancedWEBGL(\"\n                     << GLES2Util::GetStringDrawMode(mode) << \", \" << counts\n                     << \", \" << GLES2Util::GetStringIndexType(type) << \", \"\n                     << offsets << \", \" << instance_counts << \", \" << drawcount\n                     << \")\");\n  if (drawcount < 0) {\n    SetGLError(GL_INVALID_VALUE, \"glMultiDrawElementsInstancedWEBGL\",\n               \"drawcount < 0\");\n    return;\n  }\n  if (drawcount == 0) {\n    return;\n  }\n  if (vertex_array_object_manager_->bound_element_array_buffer() == 0) {\n    SetGLError(GL_INVALID_OPERATION, \"glMultiDrawElementsInstancedWEBGL\",\n               \"No element array buffer\");\n    return;\n  }\n  if (vertex_array_object_manager_->SupportsClientSideBuffers()) {\n    SetGLError(GL_INVALID_OPERATION, \"glMultiDrawElementsInstancedWEBGL\",\n               \"Missing array buffer for vertex attribute\");\n    return;\n  }\n  MultiDrawElementsInstancedWEBGLHelper(mode, counts, type, offsets,\n                                        instance_counts, drawcount);\n  CheckGLError();\n}\n",
        "target": 0
    },
    {
        "id": 2749,
        "func": "static void sync_lockstate_on_connect(btif_hh_device_t *p_dev)\n{\n int keylockstates;\n\n    BTIF_TRACE_EVENT(\"%s: Syncing keyboard lock states after \"\\\n \"reconnect...\",__FUNCTION__);\n /*If the device is connected, update keyboard state */\n    update_keyboard_lockstates(p_dev);\n\n /*Check if the lockstate of caps,scroll,num is set.\n     If so, send a report to the kernel\n    so the lockstate is in sync */\n    keylockstates = get_keylockstates();\n if (keylockstates)\n {\n\n         BTIF_TRACE_DEBUG(\"%s: Sending hid report to kernel \"\\\n             \"indicating lock key state 0x%x\",__FUNCTION__,\n             keylockstates);\n        usleep(200000);\n         toggle_os_keylockstates(p_dev->fd, keylockstates);\n     }\n     else\n {\n        BTIF_TRACE_DEBUG(\"%s: NOT sending hid report to kernel \"\\\n \"indicating lock key state 0x%x\",__FUNCTION__,\n            keylockstates);\n }\n}\n",
        "target": 1
    },
    {
        "id": 2750,
        "func": "static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}",
        "target": 1
    },
    {
        "id": 2751,
        "func": "void RenderView::OnViewContextSwapBuffersComplete() {\n  RenderWidget::OnSwapBuffersComplete();\n}\n",
        "target": 0
    },
    {
        "id": 2752,
        "func": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\t/* first let's check the buffer parameter's */\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\n\t/* now codec parameters */\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 2753,
        "func": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,value);\n\t\t\treturn(err);\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 2754,
        "func": "static void tun_flow_init(struct tun_struct *tun)\n{\n\tint i;\n\n\tfor (i = 0; i < TUN_NUM_FLOW_ENTRIES; i++)\n\t\tINIT_HLIST_HEAD(&tun->flows[i]);\n\n\ttun->ageing_time = TUN_FLOW_EXPIRE;\n\tsetup_timer(&tun->flow_gc_timer, tun_flow_cleanup, (unsigned long)tun);\n\tmod_timer(&tun->flow_gc_timer,\n\t\t  round_jiffies_up(jiffies + tun->ageing_time));\n}",
        "target": 0
    },
    {
        "id": 2755,
        "func": "JSC::JSValue toJS(JSC::ExecState* exec, JSDOMGlobalObject* globalObject, TestEventTarget* impl)\n{\n    return wrap<JSTestEventTarget>(exec, globalObject, impl);\n}\n",
        "target": 0
    },
    {
        "id": 2756,
        "func": "bool RenderFrameHostManager::CreateSpeculativeRenderFrameHost(\n    SiteInstance* old_instance,\n    SiteInstance* new_instance) {\n  CHECK(new_instance);\n  CHECK_NE(old_instance, new_instance);\n\n  if (!new_instance->GetProcess()->Init())\n    return false;\n\n  CreateProxiesForNewRenderFrameHost(old_instance, new_instance);\n\n  speculative_render_frame_host_ =\n      CreateRenderFrame(new_instance, delegate_->IsHidden(), nullptr);\n\n  if (speculative_render_frame_host_) {\n    speculative_render_frame_host_->render_view_host()\n        ->DispatchRenderViewCreated();\n  }\n\n  return !!speculative_render_frame_host_;\n}\n",
        "target": 0
    },
    {
        "id": 2757,
        "func": "static inline int ipv6_addr_orchid(const struct in6_addr *a)\n{\n\treturn (a->s6_addr32[0] & htonl(0xfffffff0)) == htonl(0x20010010);\n}",
        "target": 0
    },
    {
        "id": 2758,
        "func": " bool MatchFilter::MatchesCookie(\n     const net::CookieMonster::CookieListPair& cookie_pair) {\n   const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;\n  if (!MatchesString(keys::kNameKey, cookie.Name()))\n      return false;\n  if (!MatchesDomain(cookie_pair.first))\n      return false;\n  if (!MatchesString(keys::kPathKey, cookie.Path()))\n      return false;\n  if (!MatchesBoolean(keys::kSecureKey, cookie.IsSecure()))\n      return false;\n  if (!MatchesBoolean(keys::kSessionKey, !cookie.DoesExpire()))\n      return false;\n  return true;\n }\n",
        "target": 1
    },
    {
        "id": 2759,
        "func": "rdp_connect(char *server, uint32 flags, char *domain, char *password,\n\t    char *command, char *directory, RD_BOOL reconnect)\n{\n\tRD_BOOL deactivated = False;\n\tuint32 ext_disc_reason = 0;\n\n\tif (!sec_connect(server, g_username, domain, password, reconnect))\n\t\treturn False;\n\n\trdp_send_client_info_pdu(flags, domain, g_username, password, command, directory);\n\n\t/* run RDP loop until first licence demand active PDU */\n\twhile (!g_rdp_shareid)\n\t{\n\t\tif (g_network_error)\n\t\t\treturn False;\n\n\t\tif (!rdp_loop(&deactivated, &ext_disc_reason))\n\t\t\treturn False;\n\n\t\tif (g_redirect)\n\t\t\treturn True;\n\t}\n\treturn True;\n}",
        "target": 0
    },
    {
        "id": 2760,
        "func": "ChromotingHost::ChromotingHost(ChromotingHostContext* context,\n                               MutableHostConfig* config,\n                               DesktopEnvironment* environment,\n                               AccessVerifier* access_verifier,\n                               bool allow_nat_traversal)\n    : context_(context),\n      desktop_environment_(environment),\n       config_(config),\n       access_verifier_(access_verifier),\n       allow_nat_traversal_(allow_nat_traversal),\n      state_(kInitial),\n       stopping_recorders_(0),\n       protocol_config_(protocol::CandidateSessionConfig::CreateDefault()),\n       is_curtained_(false),\n       is_it2me_(false) {\n  DCHECK(desktop_environment_);\n  desktop_environment_->set_host(this);\n}\n",
        "target": 1
    },
    {
        "id": 2761,
        "func": "static struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 2762,
        "func": "static int vsock_listen(struct socket *sock, int backlog)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\n\tsk = sock->sk;\n\n\tlock_sock(sk);\n\n\tif (sock->type != SOCK_STREAM) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (sock->state != SS_UNCONNECTED) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tvsk = vsock_sk(sk);\n\n\tif (!vsock_addr_bound(&vsk->local_addr)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_state = SS_LISTEN;\n\n\terr = 0;\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 2763,
        "func": "ResourceDispatcherHostRequestInfo* ResourceDispatcherHost::InfoForRequest(\n    URLRequest* request) {\n  const URLRequest* const_request = request;\n  return const_cast<ResourceDispatcherHostRequestInfo*>(\n      InfoForRequest(const_request));\n}\n",
        "target": 0
    },
    {
        "id": 2764,
        "func": "static int proc_control_compat(struct usb_dev_state *ps,\n\t\t\t\tstruct usbdevfs_ctrltransfer32 __user *p32)\n{\n\tstruct usbdevfs_ctrltransfer __user *p;\n\t__u32 udata;\n\tp = compat_alloc_user_space(sizeof(*p));\n\tif (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||\n\t    get_user(udata, &p32->data) ||\n\t    put_user(compat_ptr(udata), &p->data))\n\t\treturn -EFAULT;\n\treturn proc_control(ps, p);\n}",
        "target": 0
    },
    {
        "id": 2765,
        "func": "\nstatic inline void deliver_ptype_list_skb(struct sk_buff *skb,\n\t\t\t\t\t  struct packet_type **pt,\n\t\t\t\t\t  struct net_device *orig_dev,\n\t\t\t\t\t  __be16 type,\n\t\t\t\t\t  struct list_head *ptype_list)\n{\n\tstruct packet_type *ptype, *pt_prev = *pt;\n\n\tlist_for_each_entry_rcu(ptype, ptype_list, list) {\n\t\tif (ptype->type != type)\n\t\t\tcontinue;\n\t\tif (pt_prev)\n\t\t\tdeliver_skb(skb, pt_prev, orig_dev);\n\t\tpt_prev = ptype;\n\t}\n\t*pt = pt_prev;",
        "target": 0
    },
    {
        "id": 2766,
        "func": "bool ChromeContentRendererClient::OverrideCreatePlugin(\n    content::RenderView* render_view,\n    WebFrame* frame,\n    const WebPluginParams& params,\n    WebPlugin** plugin) {\n  ChromeViewHostMsg_GetPluginInfo_Status status;\n  webkit::WebPluginInfo plugin_info;\n  std::string actual_mime_type;\n  render_view->Send(new ChromeViewHostMsg_GetPluginInfo(\n      render_view->GetRoutingID(), GURL(params.url),\n      frame->top()->document().url(), params.mimeType.utf8(),\n      &status, &plugin_info, &actual_mime_type));\n  *plugin = CreatePlugin(render_view, frame, params,\n                         status, plugin_info, actual_mime_type);\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2767,
        "func": "inline bool IsSchemeFirstChar(unsigned char c) {\n  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n",
        "target": 0
    },
    {
        "id": 2768,
        "func": "static const char *set_signature_flag(cmd_parms *cmd, void *d_,\n                                      const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"On\") == 0) {\n        d->server_signature = srv_sig_on;\n    }\n    else if (ap_cstr_casecmp(arg, \"Off\") == 0) {\n        d->server_signature = srv_sig_off;\n    }\n    else if (ap_cstr_casecmp(arg, \"EMail\") == 0) {\n        d->server_signature = srv_sig_withmail;\n    }\n    else {\n        return \"ServerSignature: use one of: off | on | email\";\n    }\n\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 2769,
        "func": "psf_fseek (SF_PRIVATE *psf, sf_count_t offset, int whence)\n{\tsf_count_t new_position ;\n\tLONG lDistanceToMove, lDistanceToMoveHigh ;\n\tDWORD dwMoveMethod ;\n\tDWORD dwResult, dwError ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.seek (offset, whence, psf->vio_user_data) ;\n\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\t\toffset += psf->fileoffset ;\n\t\t\t\tdwMoveMethod = FILE_BEGIN ;\n\t\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\t\t\tdwMoveMethod = FILE_END ;\n\t\t\t\tbreak ;\n\n\t\tdefault :\n\t\t\t\tdwMoveMethod = FILE_CURRENT ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tlDistanceToMove = (DWORD) (offset & 0xFFFFFFFF) ;\n\tlDistanceToMoveHigh = (DWORD) ((offset >> 32) & 0xFFFFFFFF) ;\n\n\tdwResult = SetFilePointer (psf->file.handle, lDistanceToMove, &lDistanceToMoveHigh, dwMoveMethod) ;\n\n\tif (dwResult == 0xFFFFFFFF)\n\t\tdwError = GetLastError () ;\n\telse\n\t\tdwError = NO_ERROR ;\n\n\tif (dwError != NO_ERROR)\n\t{\tpsf_log_syserr (psf, dwError) ;\n\t\treturn -1 ;\n\t\t} ;\n\n\tnew_position = (dwResult + ((__int64) lDistanceToMoveHigh << 32)) - psf->fileoffset ;\n\n\treturn new_position ;\n} /* psf_fseek */",
        "target": 0
    },
    {
        "id": 2770,
        "func": " SPL_METHOD(DirectoryIterator, valid)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tRETURN_BOOL(intern->u.dir.entry.d_name[0] != '\\0');\n}\n",
        "target": 1
    },
    {
        "id": 2771,
        "func": " NotificationsNativeHandler::NotificationsNativeHandler(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n      \"GetNotificationImageSizes\",\n       base::Bind(&NotificationsNativeHandler::GetNotificationImageSizes,\n                  base::Unretained(this)));\n }\n",
        "target": 1
    },
    {
        "id": 2772,
        "func": "static inline void chroma_4mv_motion_lowres(MpegEncContext *s,\n                                            uint8_t *dest_cb, uint8_t *dest_cr,\n                                            uint8_t **ref_picture,\n                                            h264_chroma_mc_func * pix_op,\n                                            int mx, int my)\n{\n    const int lowres     = s->avctx->lowres;\n    const int op_index   = FFMIN(lowres, 3);\n    const int block_s    = 8 >> lowres;\n    const int s_mask     = (2 << lowres) - 1;\n    const int h_edge_pos = s->h_edge_pos >> lowres + 1;\n    const int v_edge_pos = s->v_edge_pos >> lowres + 1;\n    int emu = 0, src_x, src_y, sx, sy;\n    ptrdiff_t offset;\n    uint8_t *ptr;\n\n    if (s->quarter_sample) {\n        mx /= 2;\n        my /= 2;\n    }\n\n    /* In case of 8X8, we construct a single chroma motion vector\n       with a special rounding */\n    mx = ff_h263_round_chroma(mx);\n    my = ff_h263_round_chroma(my);\n\n    sx = mx & s_mask;\n    sy = my & s_mask;\n    src_x = s->mb_x * block_s + (mx >> lowres + 1);\n    src_y = s->mb_y * block_s + (my >> lowres + 1);\n\n    offset = src_y * s->uvlinesize + src_x;\n    ptr = ref_picture[1] + offset;\n    if ((unsigned) src_x > FFMAX(h_edge_pos - (!!sx) - block_s, 0) ||\n        (unsigned) src_y > FFMAX(v_edge_pos - (!!sy) - block_s, 0)) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 s->uvlinesize, s->uvlinesize,\n                                 9, 9,\n                                 src_x, src_y, h_edge_pos, v_edge_pos);\n        ptr = s->sc.edge_emu_buffer;\n        emu = 1;\n    }\n    sx = (sx << 2) >> lowres;\n    sy = (sy << 2) >> lowres;\n    pix_op[op_index](dest_cb, ptr, s->uvlinesize, block_s, sx, sy);\n\n    ptr = ref_picture[2] + offset;\n    if (emu) {\n        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, ptr,\n                                 s->uvlinesize, s->uvlinesize,\n                                 9, 9,\n                                 src_x, src_y, h_edge_pos, v_edge_pos);\n        ptr = s->sc.edge_emu_buffer;\n    }\n    pix_op[op_index](dest_cr, ptr, s->uvlinesize, block_s, sx, sy);\n}",
        "target": 0
    },
    {
        "id": 2773,
        "func": "    ~ProcessingChangeGuard()\n    {\n        m_inputHandler->setProcessingChange(m_savedProcessingChange);\n    }\n",
        "target": 0
    },
    {
        "id": 2774,
        "func": "void PictureLayerImplTest::TestQuadsForSolidColor(bool test_for_solid) {\n  base::TimeTicks time_ticks;\n  time_ticks += base::TimeDelta::FromMilliseconds(1);\n  host_impl_.SetCurrentBeginFrameArgs(\n      CreateBeginFrameArgsForTesting(BEGINFRAME_FROM_HERE, time_ticks));\n\n  gfx::Size tile_size(100, 100);\n  gfx::Size layer_bounds(200, 200);\n  gfx::Rect layer_rect(layer_bounds);\n\n  FakeContentLayerClient client;\n  scoped_refptr<PictureLayer> layer = PictureLayer::Create(&client);\n  FakeLayerTreeHostClient host_client(FakeLayerTreeHostClient::DIRECT_3D);\n  scoped_ptr<FakeLayerTreeHost> host = FakeLayerTreeHost::Create(&host_client);\n  host->SetRootLayer(layer);\n  RecordingSource* recording_source = layer->GetRecordingSourceForTesting();\n\n  int frame_number = 0;\n\n  client.set_fill_with_nonsolid_color(!test_for_solid);\n\n  Region invalidation(layer_rect);\n  recording_source->UpdateAndExpandInvalidation(\n      &client, &invalidation, false, layer_bounds, layer_rect, frame_number++,\n      Picture::RECORD_NORMALLY);\n\n  scoped_refptr<RasterSource> pending_raster_source =\n      recording_source->CreateRasterSource();\n\n  SetupPendingTreeWithFixedTileSize(pending_raster_source, tile_size, Region());\n  ActivateTree();\n\n  if (test_for_solid) {\n    EXPECT_EQ(0u, active_layer_->tilings()->num_tilings());\n  } else {\n    ASSERT_TRUE(active_layer_->tilings());\n    ASSERT_GT(active_layer_->tilings()->num_tilings(), 0u);\n    std::vector<Tile*> tiles =\n        active_layer_->tilings()->tiling_at(0)->AllTilesForTesting();\n    EXPECT_FALSE(tiles.empty());\n    host_impl_.tile_manager()->InitializeTilesWithResourcesForTesting(tiles);\n  }\n\n  scoped_ptr<RenderPass> render_pass = RenderPass::Create();\n  AppendQuadsData data;\n  active_layer_->WillDraw(DRAW_MODE_SOFTWARE, nullptr);\n  active_layer_->AppendQuads(render_pass.get(), Occlusion(), &data);\n  active_layer_->DidDraw(nullptr);\n\n  DrawQuad::Material expected = test_for_solid\n                                    ? DrawQuad::Material::SOLID_COLOR\n                                    : DrawQuad::Material::TILED_CONTENT;\n  EXPECT_EQ(expected, render_pass->quad_list.front()->material);\n}\n",
        "target": 0
    },
    {
        "id": 2775,
        "func": "static void __rpc_atrun(struct rpc_task *task)\n{\n\ttask->tk_status = 0;\n}",
        "target": 0
    },
    {
        "id": 2776,
        "func": "  void OnMalwareDetailsDone() {\n    EXPECT_TRUE(BrowserThread::CurrentlyOn(BrowserThread::UI));\n    MessageLoopForUI::current()->Quit();\n  }\n",
        "target": 0
    },
    {
        "id": 2777,
        "func": "static ALWAYS_INLINE double MAXD(double a, double b)\n{\n\tif (a > b)\n\t\treturn a;\n\treturn b;\n}\n",
        "target": 0
    },
    {
        "id": 2778,
        "func": "static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct perf_event *event = file->private_data;\n\tvoid (*func)(struct perf_event *);\n\tu32 flags = arg;\n\n\tswitch (cmd) {\n\tcase PERF_EVENT_IOC_ENABLE:\n\t\tfunc = perf_event_enable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_DISABLE:\n\t\tfunc = perf_event_disable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_RESET:\n\t\tfunc = perf_event_reset;\n\t\tbreak;\n\n\tcase PERF_EVENT_IOC_REFRESH:\n\t\treturn perf_event_refresh(event, arg);\n\n\tcase PERF_EVENT_IOC_PERIOD:\n\t\treturn perf_event_period(event, (u64 __user *)arg);\n\n\tcase PERF_EVENT_IOC_ID:\n\t{\n\t\tu64 id = primary_event_id(event);\n\n\t\tif (copy_to_user((void __user *)arg, &id, sizeof(id)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_OUTPUT:\n\t{\n\t\tint ret;\n\t\tif (arg != -1) {\n\t\t\tstruct perf_event *output_event;\n\t\t\tstruct fd output;\n\t\t\tret = perf_fget_light(arg, &output);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\toutput_event = output.file->private_data;\n\t\t\tret = perf_event_set_output(event, output_event);\n\t\t\tfdput(output);\n\t\t} else {\n\t\t\tret = perf_event_set_output(event, NULL);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_FILTER:\n\t\treturn perf_event_set_filter(event, (void __user *)arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (flags & PERF_IOC_FLAG_GROUP)\n\t\tperf_event_for_each(event, func);\n\telse\n\t\tperf_event_for_each_child(event, func);\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 2779,
        "func": "void DisplaySourceCustomBindings::Invalidate() {\n  session_map_.clear();\n  weak_factory_.InvalidateWeakPtrs();\n  ObjectBackedNativeHandler::Invalidate();\n}\n",
        "target": 0
    },
    {
        "id": 2780,
        "func": "void ResourceDispatcherHost::OnResponseStarted(URLRequest* request) {\n  RESOURCE_LOG(\"OnResponseStarted: \" << request->url().spec());\n  ResourceDispatcherHostRequestInfo* info = InfoForRequest(request);\n  if (PauseRequestIfNeeded(info)) {\n    RESOURCE_LOG(\"OnResponseStarted pausing: \" << request->url().spec());\n    return;\n  }\n\n  if (request->status().is_success()) {\n    info->set_waiting_for_upload_progress_ack(false);\n    MaybeUpdateUploadProgress(info, request);\n\n    if (!CompleteResponseStarted(request)) {\n      CancelRequest(info->child_id(), info->request_id(), false);\n    } else {\n      if (PauseRequestIfNeeded(info)) {\n        RESOURCE_LOG(\"OnResponseStarted pausing2: \" << request->url().spec());\n        return;\n      }\n\n      StartReading(request);\n    }\n  } else {\n    OnResponseCompleted(request);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2781,
        "func": "SYSCALL_DEFINE0(sched_yield)\n{\n\tstruct rq *rq = this_rq_lock();\n\n\tschedstat_inc(rq, yld_count);\n\tcurrent->sched_class->yield_task(rq);\n\n\t/*\n\t * Since we are going to call schedule() anyway, there's\n\t * no need to preempt or enable interrupts:\n\t */\n\t__release(rq->lock);\n\tspin_release(&rq->lock.dep_map, 1, _THIS_IP_);\n\tdo_raw_spin_unlock(&rq->lock);\n\tsched_preempt_enable_no_resched();\n\n\tschedule();\n\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 2782,
        "func": "get_ofp14_async_config_prop_by_prop_type(uint64_t prop_type)\n{\n    FOR_EACH_ASYNC_PROP (ap) {\n        if (prop_type == ap->prop_type) {\n            return ap;\n        }\n    }\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 2783,
        "func": "bool SessionModelAssociator::AssociateModels(SyncError* error) {\n  DCHECK(CalledOnValidThread());\n\n  DCHECK(synced_session_tracker_.empty());\n  DCHECK_EQ(0U, tab_pool_.capacity());\n\n  local_session_syncid_ = sync_api::kInvalidId;\n\n  {\n    sync_api::WriteTransaction trans(FROM_HERE, sync_service_->GetUserShare());\n\n    sync_api::ReadNode root(&trans);\n    if (!root.InitByTagLookup(kSessionsTag)) {\n      error->Reset(FROM_HERE, kNoSessionsFolderError, model_type());\n      return false;\n    }\n\n    if (current_machine_tag_.empty()) {\n      InitializeCurrentMachineTag(&trans);\n      InitializeCurrentSessionName();\n    }\n    synced_session_tracker_.SetLocalSessionTag(current_machine_tag_);\n    if (!UpdateAssociationsFromSyncModel(root, &trans)) {\n      error->Reset(FROM_HERE,\n                   \"Failed to update associations from sync\",\n                   model_type());\n      return false;\n    }\n\n    if (local_session_syncid_ == sync_api::kInvalidId) {\n      sync_api::WriteNode write_node(&trans);\n      if (!write_node.InitUniqueByCreation(syncable::SESSIONS, root,\n          current_machine_tag_)) {\n        error->Reset(FROM_HERE,\n                     \"Failed to create sessions header sync node.\",\n                     model_type());\n        return false;\n      }\n      write_node.SetTitle(UTF8ToWide(current_machine_tag_));\n      local_session_syncid_ = write_node.GetId();\n    }\n  }\n\n  UpdateSyncModelDataFromClient();\n\n  VLOG(1) << \"Session models associated.\";\n\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2784,
        "func": "static void ion_vm_close(struct vm_area_struct *vma)\n{\n\tstruct ion_buffer *buffer = vma->vm_private_data;\n\tstruct ion_vma_list *vma_list, *tmp;\n\n\tpr_debug(\"%s\\n\", __func__);\n\tmutex_lock(&buffer->lock);\n\tlist_for_each_entry_safe(vma_list, tmp, &buffer->vmas, list) {\n\t\tif (vma_list->vma != vma)\n\t\t\tcontinue;\n\t\tlist_del(&vma_list->list);\n\t\tkfree(vma_list);\n\t\tpr_debug(\"%s: deleting %p\\n\", __func__, vma);\n\t\tbreak;\n\t}\n\tmutex_unlock(&buffer->lock);\n}",
        "target": 0
    },
    {
        "id": 2785,
        "func": "bool CanvasSurfaceLayerBridge::createSurfaceLayer(int canvasWidth, int canvasHeight)\n{\n     if (!m_client->syncGetSurfaceId(&m_surfaceId))\n         return false;\n \n    m_client->asyncRequestSurfaceCreation(m_surfaceId);\n     cc::SurfaceLayer::SatisfyCallback satisfyCallback = convertToBaseCallback(WTF::bind(&CanvasSurfaceLayerBridge::satisfyCallback, WTF::unretained(this)));\n     cc::SurfaceLayer::RequireCallback requireCallback = convertToBaseCallback(WTF::bind(&CanvasSurfaceLayerBridge::requireCallback, WTF::unretained(this)));\n     m_surfaceLayer = cc::SurfaceLayer::Create(std::move(satisfyCallback), std::move(requireCallback));\n    m_surfaceLayer->SetSurfaceId(m_surfaceId, 1.f, gfx::Size(canvasWidth, canvasHeight));\n\n    m_webLayer = wrapUnique(Platform::current()->compositorSupport()->createLayerFromCCLayer(m_surfaceLayer.get()));\n    GraphicsLayer::registerContentsLayer(m_webLayer.get());\n    return true;\n}\n",
        "target": 1
    },
    {
        "id": 2786,
        "func": "static int session_release_effect(struct session_s *session,\n struct effect_s *fx)\n{\n    ALOGW_IF(effect_release(fx) != 0, \" session_release_effect() failed for id %d\", fx->id);\n\n    session->created_msk &= ~(1<<fx->id);\n if (session->created_msk == 0)\n {\n        ALOGV(\"session_release_effect() last effect: removing session\");\n        list_remove(&session->node);\n        free(session);\n }\n\n return 0;\n}\n",
        "target": 0
    },
    {
        "id": 2787,
        "func": "exsltDateCurrent (void)\n{\n    struct tm localTm, gmTm;\n    time_t secs;\n    int local_s, gm_s;\n    exsltDateValPtr ret;\n\n    ret = exsltDateCreateDate(XS_DATETIME);\n    if (ret == NULL)\n        return NULL;\n\n    /* get current time */\n    secs    = time(NULL);\n#if HAVE_LOCALTIME_R\n    localtime_r(&secs, &localTm);\n#else\n    localTm = *localtime(&secs);\n#endif\n\n    /* get real year, not years since 1900 */\n    ret->value.date.year = localTm.tm_year + 1900;\n\n    ret->value.date.mon  = localTm.tm_mon + 1;\n    ret->value.date.day  = localTm.tm_mday;\n    ret->value.date.hour = localTm.tm_hour;\n    ret->value.date.min  = localTm.tm_min;\n\n    /* floating point seconds */\n    ret->value.date.sec  = (double) localTm.tm_sec;\n\n    /* determine the time zone offset from local to gm time */\n#if HAVE_GMTIME_R\n    gmtime_r(&secs, &gmTm);\n#else\n    gmTm = *gmtime(&secs);\n#endif\n    ret->value.date.tz_flag = 0;\n#if 0\n    ret->value.date.tzo = (((ret->value.date.day * 1440) +\n                            (ret->value.date.hour * 60) +\n                             ret->value.date.min) -\n                           ((gmTm.tm_mday * 1440) + (gmTm.tm_hour * 60) +\n                             gmTm.tm_min));\n#endif\n    local_s = localTm.tm_hour * SECS_PER_HOUR +\n        localTm.tm_min * SECS_PER_MIN +\n        localTm.tm_sec;\n\n    gm_s = gmTm.tm_hour * SECS_PER_HOUR +\n        gmTm.tm_min * SECS_PER_MIN +\n        gmTm.tm_sec;\n\n    if (localTm.tm_year < gmTm.tm_year) {\n\tret->value.date.tzo = -((SECS_PER_DAY - local_s) + gm_s)/60;\n    } else if (localTm.tm_year > gmTm.tm_year) {\n\tret->value.date.tzo = ((SECS_PER_DAY - gm_s) + local_s)/60;\n    } else if (localTm.tm_mon < gmTm.tm_mon) {\n\tret->value.date.tzo = -((SECS_PER_DAY - local_s) + gm_s)/60;\n    } else if (localTm.tm_mon > gmTm.tm_mon) {\n\tret->value.date.tzo = ((SECS_PER_DAY - gm_s) + local_s)/60;\n    } else if (localTm.tm_mday < gmTm.tm_mday) {\n\tret->value.date.tzo = -((SECS_PER_DAY - local_s) + gm_s)/60;\n    } else if (localTm.tm_mday > gmTm.tm_mday) {\n\tret->value.date.tzo = ((SECS_PER_DAY - gm_s) + local_s)/60;\n    } else  {\n\tret->value.date.tzo = (local_s - gm_s)/60;\n    }\n\n    return ret;\n}\n",
        "target": 0
    },
    {
        "id": 2788,
        "func": "struct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}",
        "target": 0
    },
    {
        "id": 2789,
        "func": "buffer_write(struct display *dp, struct buffer *buffer, png_bytep data,\n png_size_t size)\n /* Generic write function used both from the write callback provided to\n    * libpng and from the generic read code.\n    */\n{\n /* Write the data into the buffer, adding buffers as required */\n struct buffer_list *last = buffer->last;\n size_t end_count = buffer->end_count;\n\n while (size > 0)\n {\n size_t avail;\n\n if (end_count >= sizeof last->buffer)\n {\n if (last->next == NULL)\n {\n            last = buffer_extend(last);\n\n if (last == NULL)\n               display_log(dp, APP_ERROR, \"out of memory saving file\");\n }\n\n else\n            last = last->next;\n\n         buffer->last = last; /* avoid the need to rewrite every time */\n         end_count = 0;\n }\n\n      avail = (sizeof last->buffer) - end_count;\n if (avail > size)\n         avail = size;\n\n      memcpy(last->buffer + end_count, data, avail);\n      end_count += avail;\n      size -= avail;\n      data += avail;\n }\n\n   buffer->end_count = end_count;\n}\n",
        "target": 0
    },
    {
        "id": 2790,
        "func": "static int snd_msnd_write_cfg_mem(int cfg, int num, int mem)\n{\n\tu16 wmem;\n\n\tmem >>= 8;\n\twmem = (u16)(mem & 0xfff);\n\tif (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_MEMBASEHI, HIBYTE(wmem)))\n\t\treturn -EIO;\n\tif (snd_msnd_write_cfg(cfg, IREG_MEMBASELO, LOBYTE(wmem)))\n\t\treturn -EIO;\n\tif (wmem && snd_msnd_write_cfg(cfg, IREG_MEMCONTROL,\n\t\t\t\t       MEMTYPE_HIADDR | MEMTYPE_16BIT))\n\t\treturn -EIO;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2791,
        "func": "static int syslog_action_restricted(int type)\n{\n\tif (dmesg_restrict)\n\t\treturn 1;\n\t/* Unless restricted, we allow \"read all\" and \"get buffer size\" for everybody */\n\treturn type != SYSLOG_ACTION_READ_ALL && type != SYSLOG_ACTION_SIZE_BUFFER;\n}\n",
        "target": 0
    },
    {
        "id": 2792,
        "func": "INST_HANDLER (cbi) {\t// CBI A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRStrBuf *io_port;\n\n\top->family = R_ANAL_OP_FAMILY_IO;\n\top->type2 = 1;\n\top->val = a;\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"0xff,%d,1,<<,^,%s,&,\", b, io_port);\n\tr_strbuf_free (io_port);\n\n\t// write result to port a\n\tio_port = __generic_io_dest (a, 1, cpu);\n\tESIL_A (\"%s,\", r_strbuf_get (io_port));\n\tr_strbuf_free (io_port);\n}",
        "target": 0
    },
    {
        "id": 2793,
        "func": "print_trans(netdissect_options *ndo,\n            const u_char *words, const u_char *data1, const u_char *buf, const u_char *maxbuf)\n{\n    u_int bcc;\n    const char *f1, *f2, *f3, *f4;\n    const u_char *data, *param;\n    const u_char *w = words + 1;\n    int datalen, paramlen;\n\n    if (request) {\n\tND_TCHECK2(w[12 * 2], 2);\n\tparamlen = EXTRACT_LE_16BITS(w + 9 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 10 * 2);\n\tdatalen = EXTRACT_LE_16BITS(w + 11 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 12 * 2);\n\tf1 = \"TotParamCnt=[d] \\nTotDataCnt=[d] \\nMaxParmCnt=[d] \\nMaxDataCnt=[d]\\nMaxSCnt=[d] \\nTransFlags=[w] \\nRes1=[w] \\nRes2=[w] \\nRes3=[w]\\nParamCnt=[d] \\nParamOff=[d] \\nDataCnt=[d] \\nDataOff=[d] \\nSUCnt=[d]\\n\";\n\tf2 = \"|Name=[S]\\n\";\n\tf3 = \"|Param \";\n\tf4 = \"|Data \";\n    } else {\n\tND_TCHECK2(w[7 * 2], 2);\n\tparamlen = EXTRACT_LE_16BITS(w + 3 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 4 * 2);\n\tdatalen = EXTRACT_LE_16BITS(w + 6 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 7 * 2);\n\tf1 = \"TotParamCnt=[d] \\nTotDataCnt=[d] \\nRes1=[d]\\nParamCnt=[d] \\nParamOff=[d] \\nRes2=[d] \\nDataCnt=[d] \\nDataOff=[d] \\nRes3=[d]\\nLsetup=[d]\\n\";\n\tf2 = \"|Unknown \";\n\tf3 = \"|Param \";\n\tf4 = \"|Data \";\n    }\n\n    smb_fdata(ndo, words + 1, f1, min(words + 1 + 2 * words[0], maxbuf),\n        unicodestr);\n\n    ND_TCHECK2(*data1, 2);\n    bcc = EXTRACT_LE_16BITS(data1);\n     ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n     if (bcc > 0) {\n \tsmb_fdata(ndo, data1 + 2, f2, maxbuf - (paramlen + datalen), unicodestr);\n\tif (strcmp((const char *)(data1 + 2), \"\\\\MAILSLOT\\\\BROWSE\") == 0) {\n \t    print_browse(ndo, param, paramlen, data, datalen);\n \t    return;\n \t}\n \n\tif (strcmp((const char *)(data1 + 2), \"\\\\PIPE\\\\LANMAN\") == 0) {\n \t    print_ipc(ndo, param, paramlen, data, datalen);\n \t    return;\n \t}\n \n \tif (paramlen)\n \t    smb_fdata(ndo, param, f3, min(param + paramlen, maxbuf), unicodestr);\n\tif (datalen)\n\t    smb_fdata(ndo, data, f4, min(data + datalen, maxbuf), unicodestr);\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n",
        "target": 1
    },
    {
        "id": 2794,
        "func": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}",
        "target": 1
    },
    {
        "id": 2795,
        "func": "static u64 mask_for_index(int idx)\n{\n\treturn event_encoding(sparc_pmu->event_mask, idx);\n}",
        "target": 0
    },
    {
        "id": 2796,
        "func": "int FLTIsComparisonFilterType(const char *pszValue)\n{\n  if (pszValue) {\n    if (FLTIsBinaryComparisonFilterType(pszValue) ||\n        strcasecmp(pszValue, \"PropertyIsLike\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsBetween\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsNull\") == 0 ||\n        strcasecmp(pszValue, \"PropertyIsNil\") == 0)\n      return MS_TRUE;\n  }\n\n  return MS_FALSE;\n}",
        "target": 0
    },
    {
        "id": 2797,
        "func": "  Factory(const std::string& name,\n          HistogramBase::Sample minimum,\n          HistogramBase::Sample maximum,\n          uint32_t bucket_count,\n          int32_t flags)\n    : Factory(name, HISTOGRAM, minimum, maximum, bucket_count, flags) {}\n",
        "target": 0
    },
    {
        "id": 2798,
        "func": "  bool changed_auto_hide_state() const { return changed_auto_hide_state_; }\n",
        "target": 0
    },
    {
        "id": 2799,
        "func": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}",
        "target": 1
    },
    {
        "id": 2800,
        "func": "int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)\n{\n    return get_audio_frame_duration(avctx->codec_id, avctx->sample_rate,\n                                    avctx->channels, avctx->block_align,\n                                    avctx->codec_tag, avctx->bits_per_coded_sample,\n                                    avctx->bit_rate, avctx->extradata, avctx->frame_size,\n                                    frame_bytes);\n}",
        "target": 0
    },
    {
        "id": 2801,
        "func": "void InputMethodIBus::SendFakeProcessKeyEvent(bool pressed) const {\n  DispatchFabricatedKeyEventPostIME(pressed ? ET_KEY_PRESSED : ET_KEY_RELEASED,\n                                    VKEY_PROCESSKEY,\n                                    0);\n}\n",
        "target": 0
    },
    {
        "id": 2802,
        "func": "static int sctp_cmd_process_sack(sctp_cmd_seq_t *cmds,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t struct sctp_chunk *chunk)\n{\n\tint err = 0;\n\n\tif (sctp_outq_sack(&asoc->outqueue, chunk)) {\n\t\tstruct net *net = sock_net(asoc->base.sk);\n\n\t\t/* There are no more TSNs awaiting SACK.  */\n\t\terr = sctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t\t\t SCTP_ST_OTHER(SCTP_EVENT_NO_PENDING_TSN),\n\t\t\t\t asoc->state, asoc->ep, asoc, NULL,\n\t\t\t\t GFP_ATOMIC);\n\t}\n\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 2803,
        "func": "void GLES2Implementation::AllocateShadowCopiesForReadback() {\n  for (auto buffer : readback_buffer_shadow_tracker_->GetUnfencedBufferList()) {\n    if (!buffer) {\n      continue;\n    }\n    int32_t shm_id = 0;\n    uint32_t shm_offset = 0;\n    bool already_allocated = false;\n    uint32_t size = buffer->Alloc(&shm_id, &shm_offset, &already_allocated);\n    if (already_allocated) {\n      SendErrorMessage(\n          \"performance warning: READ-usage buffer was written, then \"\n          \"fenced, but written again before being read back. This discarded \"\n          \"the shadow copy that was created to accelerate readback.\",\n          0);\n    }\n    helper_->SetReadbackBufferShadowAllocationINTERNAL(buffer->id(), shm_id,\n                                                       shm_offset, size);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2804,
        "func": "static inline void gen_string_movl_A0_ESI(DisasContext *s)\n{\n    gen_lea_v_seg(s, s->aflag, cpu_regs[R_ESI], R_DS, s->override);\n}\n",
        "target": 0
    },
    {
        "id": 2805,
        "func": "void WebMediaPlayerImpl::OnWebLayerUpdated() {}\n",
        "target": 0
    },
    {
        "id": 2806,
        "func": "bool LayoutSVGTransformableContainer::calculateLocalTransform()\n {\n     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());\n     ASSERT(element);\n\n    SVGUseElement* useElement = nullptr;\n    if (isSVGUseElement(*element)) {\n        useElement = toSVGUseElement(element);\n    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {\n        SVGElement* correspondingElement = element->correspondingElement();\n        if (isSVGUseElement(correspondingElement))\n            useElement = toSVGUseElement(correspondingElement);\n    }\n\n    if (useElement) {\n        SVGLengthContext lengthContext(useElement);\n         FloatSize translation(\n             useElement->x()->currentValue()->value(lengthContext),\n             useElement->y()->currentValue()->value(lengthContext));\n         if (translation != m_additionalTranslation)\n            m_needsTransformUpdate = true;\n         m_additionalTranslation = translation;\n     }\n \n     if (!m_needsTransformUpdate)\n        return false;\n \n     m_localTransform = element->calculateAnimatedLocalTransform();\n     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());\n     m_needsTransformUpdate = false;\n    return true;\n }\n",
        "target": 1
    },
    {
        "id": 2807,
        "func": "void AXObject::selectionChanged() {\n  if (AXObject* parent = parentObjectIfExists())\n    parent->selectionChanged();\n}\n",
        "target": 0
    },
    {
        "id": 2808,
        "func": "void FileSystemManagerImpl::ReadMetadata(const GURL& path,\n                                         ReadMetadataCallback callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  FileSystemURL url(context_->CrackURL(path));\n  base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url);\n  if (opt_error) {\n    std::move(callback).Run(base::File::Info(), opt_error.value());\n    return;\n  }\n  if (!security_policy_->CanReadFileSystemFile(process_id_, url)) {\n    std::move(callback).Run(base::File::Info(),\n                            base::File::FILE_ERROR_SECURITY);\n    return;\n  }\n\n  operation_runner()->GetMetadata(\n      url,\n      FileSystemOperation::GET_METADATA_FIELD_IS_DIRECTORY |\n          FileSystemOperation::GET_METADATA_FIELD_SIZE |\n          FileSystemOperation::GET_METADATA_FIELD_LAST_MODIFIED,\n      base::BindRepeating(&FileSystemManagerImpl::DidGetMetadata, GetWeakPtr(),\n                          base::Passed(&callback)));\n}\n",
        "target": 0
    },
    {
        "id": 2809,
        "func": "perf_output_sample_ustack(struct perf_output_handle *handle, u64 dump_size,\n\t\t\t  struct pt_regs *regs)\n{\n\t/* Case of a kernel thread, nothing to dump */\n\tif (!regs) {\n\t\tu64 size = 0;\n\t\tperf_output_put(handle, size);\n\t} else {\n\t\tunsigned long sp;\n\t\tunsigned int rem;\n\t\tu64 dyn_size;\n\n\t\t/*\n\t\t * We dump:\n\t\t * static size\n\t\t *   - the size requested by user or the best one we can fit\n\t\t *     in to the sample max size\n\t\t * data\n\t\t *   - user stack dump data\n\t\t * dynamic size\n\t\t *   - the actual dumped size\n\t\t */\n\n\t\t/* Static size. */\n\t\tperf_output_put(handle, dump_size);\n\n\t\t/* Data. */\n\t\tsp = perf_user_stack_pointer(regs);\n\t\trem = __output_copy_user(handle, (void *) sp, dump_size);\n\t\tdyn_size = dump_size - rem;\n\n\t\tperf_output_skip(handle, rem);\n\n\t\t/* Dynamic size. */\n\t\tperf_output_put(handle, dyn_size);\n\t}\n}",
        "target": 0
    },
    {
        "id": 2810,
        "func": "void RenderFrameHostImpl::OnStreamHandleConsumed(const GURL& stream_url) {\n  if (stream_handle_ && stream_handle_->GetURL() == stream_url)\n    stream_handle_.reset();\n}\n",
        "target": 0
    },
    {
        "id": 2811,
        "func": "void XSSAuditor::initForFragment()\n{\n    ASSERT(isMainThread());\n    ASSERT(m_state == Uninitialized);\n    m_state = FilteringTokens;\n    ASSERT(!m_isEnabled);\n}\n",
        "target": 0
    },
    {
        "id": 2812,
        "func": "static const char *set_max_reversals(cmd_parms *cmd, void *conf_, const char *arg)\n{\n    core_dir_config *conf = conf_;\n    int val = 0;\n\n    if (!ap_cstr_casecmp(arg, \"none\")) {\n        val = AP_MAXRANGES_NORANGES;\n    }\n    else if (!ap_cstr_casecmp(arg, \"default\")) {\n        val = AP_MAXRANGES_DEFAULT;\n    }\n    else if (!ap_cstr_casecmp(arg, \"unlimited\")) {\n        val = AP_MAXRANGES_UNLIMITED;\n    }\n    else {\n        val = atoi(arg);\n        if (val <= 0)\n            return \"MaxRangeReversals requires 'none', 'default', 'unlimited' or \"\n            \"a positive integer\";\n    }\n\n    conf->max_reversals = val;\n\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 2813,
        "func": "  void WriteFakeData(uint8* audio_data, size_t length) {\n    Type* output = reinterpret_cast<Type*>(audio_data);\n    for (size_t i = 0; i < length; i++) {\n      output[i] = i % 5 + 10;\n    }\n  }\n",
        "target": 1
    },
    {
        "id": 2814,
        "func": "void TabAppendedNotificationObserver::ObserveTab(\n    NavigationController* controller) {\n  if (!automation_ || !reply_message_.get())\n    return;\n\n  if (automation_->GetIndexForNavigationController(controller, parent_) ==\n      TabStripModel::kNoTab) {\n    return;\n  }\n\n  new NavigationNotificationObserver(controller, automation_,\n                                     reply_message_.release(),\n                                     1, false, use_json_interface_);\n}\n",
        "target": 0
    },
    {
        "id": 2815,
        "func": "  virtual ~RemoveTabAnimation() {}\n",
        "target": 0
    },
    {
        "id": 2816,
        "func": "void ChromeClientImpl::DispatchViewportPropertiesDidChange(\n    const ViewportDescription& description) const {\n  web_view_->UpdatePageDefinedViewportConstraints(description);\n}\n",
        "target": 0
    },
    {
        "id": 2817,
        "func": "const GURL& DownloadItemImpl::GetReferrerUrl() const {\n  return request_info_.referrer_url;\n}\n",
        "target": 0
    },
    {
        "id": 2818,
        "func": "void AutofillDialogViews::SuggestionView::SetLabelText(\n    const base::string16& text) {\n  base::string16 line_return(base::ASCIIToUTF16(\"\\n\"));\n  size_t position = text.find(line_return);\n  if (position == base::string16::npos) {\n    label_->SetText(text);\n    label_line_2_->SetVisible(false);\n  } else {\n    label_->SetText(text.substr(0, position));\n    label_line_2_->SetText(text.substr(position + line_return.length()));\n    label_line_2_->SetVisible(true);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2819,
        "func": "static unsigned int get_rr_interval_fair(struct rq *rq, struct task_struct *task)\n{\n\tstruct sched_entity *se = &task->se;\n\tunsigned int rr_interval = 0;\n\n\t/*\n\t * Time slice is 0 for SCHED_OTHER tasks that are on an otherwise\n\t * idle runqueue:\n\t */\n\tif (rq->cfs.load.weight)\n\t\trr_interval = NS_TO_JIFFIES(sched_slice(cfs_rq_of(se), se));\n\n\treturn rr_interval;\n}",
        "target": 0
    },
    {
        "id": 2820,
        "func": "gfx::NativeWindow PanelBrowserView::GetNativePanelHandle() {\n  return GetNativeHandle();\n}\n",
        "target": 0
    },
    {
        "id": 2821,
        "func": "int RenderFrameImpl::GetRoutingID() {\n  return routing_id_;\n}\n",
        "target": 0
    },
    {
        "id": 2822,
        "func": "MemStream::MemStream(char *bufA, Guint startA, Guint lengthA, Object *dictA):\n    BaseStream(dictA, lengthA) {\n  buf = bufA;\n  start = startA;\n  length = lengthA;\n  bufEnd = buf + start + length;\n  bufPtr = buf + start;\n  needFree = gFalse;\n}\n",
        "target": 0
    },
    {
        "id": 2823,
        "func": "const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha256(void)\n{\n    return ((OPENSSL_ia32cap_P[1] & AESNI_CAPABLE) &&\n            aesni_cbc_sha256_enc(NULL, NULL, 0, NULL, NULL, NULL, NULL) ?\n            &aesni_128_cbc_hmac_sha256_cipher : NULL);\n}\n",
        "target": 0
    },
    {
        "id": 2824,
        "func": "static int do_recv_NPIdentifier(rpc_message_t *message, void *p_value)\n{\n  int error;\n  uint32_t id;\n\n  if ((error = rpc_message_recv_uint32(message, &id)) < 0)\n\treturn error;\n\n  NPIdentifier ident = NULL;\n  if (id) {\n#ifdef BUILD_WRAPPER\n\tident = id_lookup(id);\n#endif\n#ifdef BUILD_VIEWER\n\tident = (void *)(uintptr_t)id;\n#endif\n\tassert(ident != NULL);\n  }\n  *((NPIdentifier *)p_value) = ident;\n  return RPC_ERROR_NO_ERROR;\n}",
        "target": 0
    },
    {
        "id": 2825,
        "func": "   void DoTest(ExternalProtocolHandler::BlockState block_state,\n               shell_integration::DefaultWebClientState os_state,\n               Action expected_action) {\n    GURL url(\"mailto:test@test.com\");\n     EXPECT_FALSE(delegate_.has_prompted());\n     EXPECT_FALSE(delegate_.has_launched());\n     EXPECT_FALSE(delegate_.has_blocked());\n\n    delegate_.set_block_state(block_state);\n    delegate_.set_os_state(os_state);\n    ExternalProtocolHandler::LaunchUrlWithDelegate(\n        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);\n    content::RunAllTasksUntilIdle();\n\n    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());\n    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());\n    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());\n  }\n",
        "target": 1
    },
    {
        "id": 2826,
        "func": "int Label::GetBaseline() {\n  return GetInsets().top() + font_.GetBaseline();\n}\n",
        "target": 0
    },
    {
        "id": 2827,
        "func": "void SetLocation(PP_Resource resource, const PP_Rect* location) {\n  scoped_refptr<PPB_Widget_Impl> widget(\n      Resource::GetAs<PPB_Widget_Impl>(resource));\n  if (widget)\n    widget->SetLocation(location);\n}\n",
        "target": 0
    },
    {
        "id": 2828,
        "func": "static int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 2829,
        "func": "int __weak ftrace_arch_code_modify_prepare(void)\n{\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2830,
        "func": "int kvm_highest_pending_irq(struct kvm_vcpu *vcpu)\n{\n    struct vpd *vpd = to_host(vcpu->kvm, vcpu->arch.vpd);\n\n    if (vpd->irr[0] & (1UL << NMI_VECTOR))\n\t\treturn NMI_VECTOR;\n    if (vpd->irr[0] & (1UL << ExtINT_VECTOR))\n\t\treturn ExtINT_VECTOR;\n\n    return find_highest_bits((int *)&vpd->irr[0]);\n}\n",
        "target": 0
    },
    {
        "id": 2831,
        "func": "ssize_t tpm_show_owned(struct device * dev, struct device_attribute * attr,\n\t\t\tchar *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(dev, TPM_CAP_PROP_OWNER, &cap,\n\t\t\t \"attempting to determine the owner state\");\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, \"%d\\n\", cap.owned);\n\treturn rc;\n}",
        "target": 0
    },
    {
        "id": 2832,
        "func": "static void sixel_node_del(sixel_output_t *const context, sixel_node_t *np)\n{\n    sixel_node_t *tp;\n\n    if ((tp = context->node_top) == np) {\n        context->node_top = np->next;\n    }\n\n    else {\n        while (tp->next != NULL) {\n            if (tp->next == np) {\n                tp->next = np->next;\n                break;\n            }\n            tp = tp->next;\n        }\n    }\n\n    np->next = context->node_free;\n    context->node_free = np;\n}\n",
        "target": 0
    },
    {
        "id": 2833,
        "func": "static int ip_vs_genl_new_daemon(struct net *net, struct nlattr **attrs)\n{\n\tif (!(attrs[IPVS_DAEMON_ATTR_STATE] &&\n\t      attrs[IPVS_DAEMON_ATTR_MCAST_IFN] &&\n\t      attrs[IPVS_DAEMON_ATTR_SYNC_ID]))\n\t\treturn -EINVAL;\n\n\treturn start_sync_thread(net,\n\t\t\t\t nla_get_u32(attrs[IPVS_DAEMON_ATTR_STATE]),\n\t\t\t\t nla_data(attrs[IPVS_DAEMON_ATTR_MCAST_IFN]),\n\t\t\t\t nla_get_u32(attrs[IPVS_DAEMON_ATTR_SYNC_ID]));\n}",
        "target": 0
    },
    {
        "id": 2834,
        "func": "static void userns_put(void *ns)\n{\n\tput_user_ns(ns);\n}",
        "target": 0
    },
    {
        "id": 2835,
        "func": "void jslGetTokenString(char *str, size_t len) {\n  if (lex->tk == LEX_ID) {\n    strncpy(str, \"ID:\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n  } else if (lex->tk == LEX_STR) {\n    strncpy(str, \"String:'\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n    strncat(str, \"'\", len);\n  } else\n    jslTokenAsString(lex->tk, str, len);\n}",
        "target": 1
    },
    {
        "id": 2836,
        "func": "int wc_ecc_shared_secret(ecc_key* private_key, ecc_key* public_key, byte* out,\n                      word32* outlen)\n{\n   int err;\n\n   if (private_key == NULL || public_key == NULL || out == NULL ||\n                                                            outlen == NULL) {\n       return BAD_FUNC_ARG;\n   }\n\n#ifdef WOLF_CRYPTO_DEV\n    if (private_key->devId != INVALID_DEVID) {\n        err = wc_CryptoDev_Ecdh(private_key, public_key, out, outlen);\n        if (err != NOT_COMPILED_IN)\n            return err;\n    }\n#endif\n\n   /* type valid? */\n   if (private_key->type != ECC_PRIVATEKEY &&\n           private_key->type != ECC_PRIVATEKEY_ONLY) {\n      return ECC_BAD_ARG_E;\n   }\n\n   /* Verify domain params supplied */\n   if (wc_ecc_is_valid_idx(private_key->idx) == 0 ||\n       wc_ecc_is_valid_idx(public_key->idx)  == 0) {\n      return ECC_BAD_ARG_E;\n   }\n\n   /* Verify curve id matches */\n   if (private_key->dp->id != public_key->dp->id) {\n      return ECC_BAD_ARG_E;\n   }\n\n#ifdef WOLFSSL_ATECC508A\n   err = atcatls_ecdh(private_key->slot, public_key->pubkey_raw, out);\n   if (err != ATCA_SUCCESS) {\n      err = BAD_COND_E;\n   }\n   *outlen = private_key->dp->size;\n#else\n   err = wc_ecc_shared_secret_ex(private_key, &public_key->pubkey, out, outlen);\n#endif /* WOLFSSL_ATECC508A */\n\n   return err;\n}",
        "target": 0
    },
    {
        "id": 2837,
        "func": "static int phar_zip_changed_apply(zval *zv, void *arg) /* {{{ */\n{\n\treturn phar_zip_changed_apply_int(Z_PTR_P(zv), arg);\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 2838,
        "func": "device_partition_table_create_authorized_cb (Daemon *daemon,\n                                             Device *device,\n                                             DBusGMethodInvocation *context,\n                                             const gchar *action_id,\n                                             guint num_user_data,\n                                             gpointer *user_data_elements)\n{\n  const char *scheme = user_data_elements[0];\n  char **options = user_data_elements[1];\n  int n;\n  int m;\n  char *argv[128];\n  GError *error;\n\n  error = NULL;\n\n  if (device_local_is_busy (device, TRUE, &error))\n    {\n      dbus_g_method_return_error (context, error);\n      g_error_free (error);\n      goto out;\n    }\n\n  if (strlen (scheme) == 0)\n    {\n      throw_error (context, ERROR_FAILED, \"type not specified\");\n      goto out;\n    }\n\n  n = 0;\n  argv[n++] = \"udisks-helper-create-partition-table\";\n  if (device->priv->device_is_linux_dmmp)\n    argv[n++] = (gchar *) get_dmmp_device_node (device);\n  else\n    argv[n++] = device->priv->device_file;\n  argv[n++] = (char *) scheme;\n  for (m = 0; options[m] != NULL; m++)\n    {\n      if (n >= (int) sizeof(argv) - 1)\n        {\n          throw_error (context, ERROR_FAILED, \"Too many options\");\n          goto out;\n        }\n      /* the helper will validate each option */\n      argv[n++] = (char *) options[m];\n    }\n  argv[n++] = NULL;\n\n  if (!job_new (context,\n                \"PartitionTableCreate\",\n                TRUE,\n                device,\n                argv,\n                NULL,\n                partition_table_create_completed_cb,\n                FALSE,\n                partition_table_create_data_new (context, device, scheme),\n                (GDestroyNotify) partition_table_create_data_unref))\n    {\n      goto out;\n    }\n\n out:\n  ;\n}\n",
        "target": 0
    },
    {
        "id": 2839,
        "func": "void Com_Quit_f( void ) {\n\tchar *p = Cmd_Args( );\n\tif ( !com_errorEntered ) {\n\t\tVM_Forced_Unload_Start();\n\t\tSV_Shutdown(p[0] ? p : \"Server quit\");\n\t\tCL_Shutdown(p[0] ? p : \"Client quit\", qtrue, qtrue);\n\t\tVM_Forced_Unload_Done();\n\t\tCom_Shutdown();\n\t\tFS_Shutdown( qtrue );\n\t}\n\tSys_Quit();\n}\n",
        "target": 0
    },
    {
        "id": 2840,
        "func": "static void php_x509_free(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tX509 *x509 = (X509 *)rsrc->ptr;\n\tX509_free(x509);\n}\n",
        "target": 0
    },
    {
        "id": 2841,
        "func": "  virtual ~AsyncUploadTokenCompletionObserver() {\n  }\n",
        "target": 0
    },
    {
        "id": 2842,
        "func": "  SitePerProcessProgrammaticScrollTest()\n      : kInfinity(1000000U), kPositiveXYPlane(0, 0, kInfinity, kInfinity) {}\n",
        "target": 0
    },
    {
        "id": 2843,
        "func": "int svc_rdma_xdr_encode_error(struct svcxprt_rdma *xprt,\n\t\t\t      struct rpcrdma_msg *rmsgp,\n\t\t\t      enum rpcrdma_errcode err, __be32 *va)\n{\n\t__be32 *startp = va;\n\t*va++ = rmsgp->rm_xid;\n\t*va++ = rmsgp->rm_vers;\n\t*va++ = xprt->sc_fc_credits;\n\t*va++ = rdma_error;\n\t*va++ = cpu_to_be32(err);\n\tif (err == ERR_VERS) {\n\t\t*va++ = rpcrdma_version;\n\t\t*va++ = rpcrdma_version;\n\t}\n\treturn (int)((unsigned long)va - (unsigned long)startp);\n}\n",
        "target": 1
    },
    {
        "id": 2844,
        "func": "status_t Camera2Client::updateProcessorStream(sp<ProcessorT> processor,\n Parameters params) {\n status_t res;\n\n ProcessorT *processorPtr = processor.get();\n    res = (processorPtr->*updateStreamF)(params);\n\n /**\n     * Can't update the stream if it's busy?\n     *\n     * Then we need to stop the device (by temporarily clearing the request\n     * queue) and then try again. Resume streaming once we're done.\n     */\n if (res == -EBUSY) {\n        ALOGV(\"%s: Camera %d: Pausing to update stream\", __FUNCTION__,\n                mCameraId);\n        res = mStreamingProcessor->togglePauseStream(/*pause*/true);\n if (res != OK) {\n            ALOGE(\"%s: Camera %d: Can't pause streaming: %s (%d)\",\n                    __FUNCTION__, mCameraId, strerror(-res), res);\n }\n\n        res = mDevice->waitUntilDrained();\n if (res != OK) {\n            ALOGE(\"%s: Camera %d: Waiting to stop streaming failed: %s (%d)\",\n                    __FUNCTION__, mCameraId, strerror(-res), res);\n }\n\n        res = (processorPtr->*updateStreamF)(params);\n if (res != OK) {\n            ALOGE(\"%s: Camera %d: Failed to update processing stream \"\n \" despite having halted streaming first: %s (%d)\",\n                  __FUNCTION__, mCameraId, strerror(-res), res);\n }\n\n        res = mStreamingProcessor->togglePauseStream(/*pause*/false);\n if (res != OK) {\n            ALOGE(\"%s: Camera %d: Can't unpause streaming: %s (%d)\",\n                    __FUNCTION__, mCameraId, strerror(-res), res);\n }\n }\n\n return res;\n}\n",
        "target": 0
    },
    {
        "id": 2845,
        "func": "std::string TestURLLoader::ReadEntireFile(pp::FileIO* file_io,\n                                          std::string* data) {\n  TestCompletionCallback callback(instance_->pp_instance(), callback_type());\n  char buf[256];\n  int64_t offset = 0;\n\n  for (;;) {\n    callback.WaitForResult(file_io->Read(offset, buf, sizeof(buf),\n                           callback.GetCallback()));\n    if (callback.result() < 0)\n      return ReportError(\"FileIO::Read\", callback.result());\n    if (callback.result() == 0)\n      break;\n    offset += callback.result();\n    data->append(buf, callback.result());\n  }\n\n  PASS();\n}\n",
        "target": 0
    },
    {
        "id": 2846,
        "func": "int ssl3_do_uncompress(SSL *ssl)\n\t{\n#ifndef OPENSSL_NO_COMP\n\tint i;\n\tSSL3_RECORD *rr;\n\n\trr= &(ssl->s3->rrec);\n\ti=COMP_expand_block(ssl->expand,rr->comp,\n\t\tSSL3_RT_MAX_PLAIN_LENGTH,rr->data,(int)rr->length);\n\tif (i < 0)\n\t\treturn(0);\n\telse\n\t\trr->length=i;\n\trr->data=rr->comp;\n#endif\n\treturn(1);\n\t}\n",
        "target": 0
    },
    {
        "id": 2847,
        "func": "PictureLayerImpl::PictureLayerImpl(LayerTreeImpl* tree_impl,\n                                   int id,\n                                   bool is_mask)\n     : LayerImpl(tree_impl, id),\n       twin_layer_(nullptr),\n       tilings_(CreatePictureLayerTilingSet()),\n      raster_source_(PicturePileImpl::Create()),\n       ideal_page_scale_(0.f),\n       ideal_device_scale_(0.f),\n       ideal_source_scale_(0.f),\n      ideal_contents_scale_(0.f),\n      raster_page_scale_(0.f),\n      raster_device_scale_(0.f),\n      raster_source_scale_(0.f),\n      raster_contents_scale_(0.f),\n      low_res_raster_contents_scale_(0.f),\n      raster_source_scale_is_fixed_(false),\n      was_screen_space_transform_animating_(false),\n      needs_post_commit_initialization_(true),\n      should_update_tile_priorities_(false),\n      only_used_low_res_last_append_quads_(false),\n      is_mask_(is_mask),\n      nearest_neighbor_(false) {\n  layer_tree_impl()->RegisterPictureLayerImpl(this);\n}\n",
        "target": 1
    },
    {
        "id": 2848,
        "func": "print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n\n   ND_TCHECK2(data[0],length);\n\n   switch(attr_code)\n   {\n      case TUNNEL_PASS:\n           if (length < 3)\n              goto trunc;\n           if (*data && (*data <=0x1F) )\n              ND_PRINT((ndo, \"Tag[%u] \", *data));\n           else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n           if (*data <= 0x1F)\n           {\n              if (length < 1)\n                 goto trunc;\n              if (*data)\n                ND_PRINT((ndo, \"Tag[%u] \", *data));\n              else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n           }\n        break;\n      case EGRESS_VLAN_NAME:\n           if (length < 1)\n              goto trunc;\n           ND_PRINT((ndo, \"%s (0x%02x) \",\n                  tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                  *data));\n           data++;\n           length--;\n        break;\n   }\n\n   for (i=0; i < length && *data; i++, data++)\n       ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n\n   return;\n\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}",
        "target": 0
    },
    {
        "id": 2849,
        "func": "void GLES2DecoderImpl::DoGetFramebufferAttachmentParameteriv(\n    GLenum target, GLenum attachment, GLenum pname, GLint* params) {\n  FramebufferManager::FramebufferInfo* framebuffer_info =\n      GetFramebufferInfoForTarget(target);\n  if (!framebuffer_info) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glFramebufferAttachmentParameteriv\", \"no framebuffer bound\");\n    return;\n  }\n  glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params);\n  if (pname == GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) {\n    GLint type = 0;\n    GLuint client_id = 0;\n    glGetFramebufferAttachmentParameterivEXT(\n        target, attachment, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, &type);\n    switch (type) {\n      case GL_RENDERBUFFER: {\n        renderbuffer_manager()->GetClientId(*params, &client_id);\n        break;\n      }\n      case GL_TEXTURE: {\n        texture_manager()->GetClientId(*params, &client_id);\n        break;\n      }\n      default:\n        break;\n    }\n    *params = client_id;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2850,
        "func": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\t/* don't alter vm_end if the coredump is running */\n\tif (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}",
        "target": 0
    },
    {
        "id": 2851,
        "func": "static void activityLoggingForIsolatedWorldsPerWorldBindingsVoidMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    V8PerContextData* contextData = V8PerContextData::from(info.GetIsolate()->GetCurrentContext());\n    if (contextData && contextData->activityLogger()) {\n        Vector<v8::Handle<v8::Value> > loggerArgs = toNativeArguments<v8::Handle<v8::Value> >(info, 0);\n        contextData->activityLogger()->log(\"TestObjectPython.activityLoggingForIsolatedWorldsPerWorldBindingsVoidMethod\", info.Length(), loggerArgs.data(), \"Method\");\n    }\n    TestObjectPythonV8Internal::activityLoggingForIsolatedWorldsPerWorldBindingsVoidMethodMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 2852,
        "func": "static bool flush_incoming_que_on_wr_signal(rfc_slot_t *slot) {\n while (!list_is_empty(slot->incoming_queue)) {\n    BT_HDR *p_buf = list_front(slot->incoming_queue);\n switch (send_data_to_app(slot->fd, p_buf)) {\n case SENT_NONE:\n case SENT_PARTIAL:\n        btsock_thread_add_fd(pth, slot->fd, BTSOCK_RFCOMM, SOCK_THREAD_FD_WR, slot->id);\n return true;\n\n case SENT_ALL:\n        list_remove(slot->incoming_queue, p_buf);\n break;\n\n case SENT_FAILED:\n        list_remove(slot->incoming_queue, p_buf);\n return false;\n }\n }\n\n  APPL_TRACE_DEBUG(\"enable data flow, rfc_handle:0x%x, rfc_port_handle:0x%x, user_id:%d\",\n      slot->rfc_handle, slot->rfc_port_handle, slot->id);\n extern int PORT_FlowControl_MaxCredit(uint16_t handle, bool enable);\n  PORT_FlowControl_MaxCredit(slot->rfc_port_handle, true);\n return true;\n}\n",
        "target": 0
    },
    {
        "id": 2853,
        "func": "int WebContentsImpl::CreateOpenerRenderViews(SiteInstance* instance) {\n  int opener_route_id = MSG_ROUTING_NONE;\n\n  if (opener_)\n    opener_route_id = opener_->CreateOpenerRenderViews(instance);\n\n  if (GetRenderManager()->current_host()->GetSiteInstance() == instance)\n    return GetRenderManager()->current_host()->GetRoutingID();\n\n  if (GetRenderManager()->pending_render_view_host() &&\n      GetRenderManager()->pending_render_view_host()->GetSiteInstance() ==\n          instance)\n    return GetRenderManager()->pending_render_view_host()->GetRoutingID();\n\n  RenderViewHostImpl* rvh = GetRenderManager()->GetSwappedOutRenderViewHost(\n      instance);\n  if (rvh)\n    return rvh->GetRoutingID();\n\n  return GetRenderManager()->CreateRenderFrame(instance, opener_route_id,\n                                               true, true);\n}\n",
        "target": 0
    },
    {
        "id": 2854,
        "func": "SMB2_tdis(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb2_tree_disconnect_req *req; /* response is trivial */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"Tree Disconnect\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\n\t\treturn 0;\n\n\trc = small_smb2_init(SMB2_TREE_DISCONNECT, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\trc = SendReceiveNoRsp(xid, ses, (char *)req, flags);\n\tcifs_small_buf_release(req);\n\tif (rc)\n\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_DISCONNECT_HE);\n\n\treturn rc;\n}",
        "target": 0
    },
    {
        "id": 2855,
        "func": "static inline void fsnotify_link(struct inode *dir, struct inode *inode, struct dentry *new_dentry)\n{\n\tfsnotify_link_count(inode);\n\taudit_inode_child(dir, new_dentry, AUDIT_TYPE_CHILD_CREATE);\n\n\tfsnotify(dir, FS_CREATE, inode, FSNOTIFY_EVENT_INODE, new_dentry->d_name.name, 0);\n}",
        "target": 0
    },
    {
        "id": 2856,
        "func": "void RenderView::didReceiveDocumentData(\n    WebFrame* frame, const char* data, size_t data_len,\n    bool& prevent_default) {\n  NavigationState* navigation_state =\n      NavigationState::FromDataSource(frame->dataSource());\n  if (!navigation_state->postpone_loading_data())\n    return;\n\n  prevent_default = true;\n\n  navigation_state->append_postponed_data(data, data_len);\n  if (navigation_state->postponed_data().size() >= 512) {\n    navigation_state->set_postpone_loading_data(false);\n    frame->commitDocumentData(navigation_state->postponed_data().data(),\n                              navigation_state->postponed_data().size());\n    navigation_state->clear_postponed_data();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2857,
        "func": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\n\t/* don't change ip_summed == CHECKSUM_PARTIAL, as that\n\t   will cause bad checksum on forwarded packets */\n\tif (skb->ip_summed == CHECKSUM_NONE &&\n\t    rcv->features & NETIF_F_RXCSUM)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tlength = skb->len;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\n\tu64_stats_update_begin(&stats->syncp);\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\tu64_stats_update_end(&stats->syncp);\n\n\tu64_stats_update_begin(&rcv_stats->syncp);\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\tu64_stats_update_end(&rcv_stats->syncp);\n\n\treturn NETDEV_TX_OK;\n\nrx_drop:\n\tu64_stats_update_begin(&rcv_stats->syncp);\n\trcv_stats->rx_dropped++;\n\tu64_stats_update_end(&rcv_stats->syncp);\n\treturn NETDEV_TX_OK;\n}",
        "target": 0
    },
    {
        "id": 2858,
        "func": "static int ext4_ext_dirty(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path)\n{\n\tint err;\n\tif (path->p_bh) {\n\t\t/* path points to block */\n\t\terr = ext4_handle_dirty_metadata(handle, inode, path->p_bh);\n\t} else {\n\t\t/* path points to leaf/index in inode body */\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t}\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 2859,
        "func": "void usb_release_bos_descriptor(struct usb_device *dev)\n{\n\tif (dev->bos) {\n\t\tkfree(dev->bos->desc);\n\t\tkfree(dev->bos);\n\t\tdev->bos = NULL;\n\t}\n}",
        "target": 0
    },
    {
        "id": 2860,
        "func": "static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_spu_palette __user *up)\n{\n\tstruct video_spu_palette __user *up_native;\n\tcompat_uptr_t palp;\n\tint length, err;\n\n\terr  = get_user(palp, &up->palette);\n\terr |= get_user(length, &up->length);\n\n\tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n\terr  = put_user(compat_ptr(palp), &up_native->palette);\n\terr |= put_user(length, &up_native->length);\n\tif (err)\n\t\treturn -EFAULT;\n\n\terr = sys_ioctl(fd, cmd, (unsigned long) up_native);\n\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 2861,
        "func": "void WebRuntimeFeatures::EnableWebGPU(bool enable) {\n  RuntimeEnabledFeatures::SetWebGPUEnabled(enable);\n}\n",
        "target": 0
    },
    {
        "id": 2862,
        "func": "void HTMLMediaElement::StartPlayerLoad() {\n  DCHECK(!web_media_player_);\n\n  WebMediaPlayerSource source;\n  if (src_object_) {\n    source = WebMediaPlayerSource(WebMediaStream(src_object_));\n  } else {\n    KURL request_url = current_src_;\n    if (!request_url.User().IsEmpty())\n      request_url.SetUser(String());\n    if (!request_url.Pass().IsEmpty())\n      request_url.SetPass(String());\n\n    KURL kurl(request_url);\n    source = WebMediaPlayerSource(WebURL(kurl));\n  }\n\n  LocalFrame* frame = GetDocument().GetFrame();\n  if (!frame) {\n    MediaLoadingFailed(\n        WebMediaPlayer::kNetworkStateFormatError,\n        BuildElementErrorMessage(\"Player load failure: document has no frame\"));\n    return;\n  }\n\n  web_media_player_ = frame->Client()->CreateWebMediaPlayer(\n      *this, source, this,\n      frame->GetPage()->GetChromeClient().GetWebLayerTreeView(frame));\n\n  if (!web_media_player_) {\n    MediaLoadingFailed(WebMediaPlayer::kNetworkStateFormatError,\n                       BuildElementErrorMessage(\n                           \"Player load failure: error creating media player\"));\n    return;\n  }\n\n  if (GetLayoutObject())\n    GetLayoutObject()->SetShouldDoFullPaintInvalidation();\n  audio_source_provider_.Wrap(web_media_player_->GetAudioSourceProvider());\n  web_media_player_->SetVolume(EffectiveMediaVolume());\n\n  web_media_player_->SetPoster(PosterImageURL());\n\n  const auto preload = EffectivePreloadType();\n  web_media_player_->SetPreload(preload);\n\n  web_media_player_->RequestRemotePlaybackDisabled(\n      FastHasAttribute(kDisableremoteplaybackAttr));\n\n  auto load_timing = web_media_player_->Load(GetLoadType(), source, CorsMode());\n  if (load_timing == WebMediaPlayer::LoadTiming::kDeferred) {\n    SetShouldDelayLoadEvent(false);\n  }\n\n  if (IsFullscreen())\n    web_media_player_->EnteredFullscreen();\n\n  web_media_player_->BecameDominantVisibleContent(mostly_filling_viewport_);\n}\n",
        "target": 0
    },
    {
        "id": 2863,
        "func": "    ChromeContentBrowserClient::GetSpeechRecognitionManagerDelegate() {\n#if defined(ENABLE_INPUT_SPEECH)\n  return new speech::ChromeSpeechRecognitionManagerDelegate();\n#else\n  return NULL;\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 2864,
        "func": "  ui::ClipboardType GetAndResetCopiedToClipboard() {\n    ui::ClipboardType clipboard_type = copied_to_clipboard_;\n    copied_to_clipboard_ = ui::CLIPBOARD_TYPE_LAST;\n    return clipboard_type;\n  }\n",
        "target": 0
    },
    {
        "id": 2865,
        "func": "rc_free_icc_profile(gs_memory_t * mem, void *ptr_in, client_name_t cname)\n{\n    cmm_profile_t *profile = (cmm_profile_t *)ptr_in;\n    gs_memory_t *mem_nongc =  profile->memory;\n\n    if_debug2m(gs_debug_flag_icc, mem,\n               \"[icc] rc decrement profile = 0x%p rc = %ld\\n\",\n               ptr_in, profile->rc.ref_count);\n    if (profile->rc.ref_count <= 1 ) {\n        /* Clear out the buffer if it is full */\n        if (profile->buffer != NULL) {\n            gs_free_object(mem_nongc, profile->buffer, \"rc_free_icc_profile(buffer)\");\n            profile->buffer = NULL;\n        }\n        if_debug0m(gs_debug_flag_icc, mem, \"[icc] profile freed\\n\");\n        /* Release this handle if it has been set */\n        if (profile->profile_handle != NULL) {\n            profile->release(profile->profile_handle);\n            profile->profile_handle = NULL;\n        }\n        /* Release the name if it has been set */\n        if (profile->name != NULL) {\n            gs_free_object(mem_nongc, profile->name,\"rc_free_icc_profile(name)\");\n            profile->name = NULL;\n            profile->name_length = 0;\n        }\n        profile->hash_is_valid = 0;\n        if (profile->lock != NULL) {\n            gx_monitor_free(profile->lock);\n            profile->lock = NULL;\n        }\n        /* If we had a DeviceN profile with names deallocate that now */\n        if (profile->spotnames != NULL) {\n            /* Free the linked list in this object */\n            gsicc_free_spotnames(profile->spotnames, mem_nongc);\n            /* Free the main object */\n            gs_free_object(mem_nongc, profile->spotnames, \"rc_free_icc_profile(spotnames)\");\n        }\n        /* If we allocated a buffer to hold the v2 profile then free that */\n        if (profile->v2_data != NULL) {\n            gs_free_object(mem_nongc, profile->v2_data, \"rc_free_icc_profile(v2_data)\");\n        }\n        gs_free_object(mem_nongc, profile, \"rc_free_icc_profile\");\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2866,
        "func": "int kvm_io_bus_read(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,\n\t\t    int len, void *val)\n{\n\tint idx;\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\n\tbus = srcu_dereference(kvm->buses[bus_idx], &kvm->srcu);\n\tidx = kvm_io_bus_get_first_dev(bus, addr, len);\n\tif (idx < 0)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (idx < bus->dev_count &&\n\t\tkvm_io_bus_sort_cmp(&range, &bus->range[idx]) == 0) {\n\t\tif (!kvm_iodevice_read(bus->range[idx].dev, addr, len, val))\n\t\t\treturn 0;\n\t\tidx++;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n",
        "target": 0
    },
    {
        "id": 2867,
        "func": "void AppCacheHost::MarkAsForeignEntry(const GURL& document_url,\n                                       int64 cache_document_was_loaded_from) {\n   storage()->MarkEntryAsForeign(\n       main_resource_was_namespace_entry_ ? namespace_entry_url_ : document_url,\n       cache_document_was_loaded_from);\n   SelectCache(document_url, kAppCacheNoCacheId, GURL());\n }\n",
        "target": 1
    },
    {
        "id": 2868,
        "func": " Response StorageHandler::UntrackCacheStorageForOrigin(\n     const std::string& origin) {\n  if (!process_)\n     return Response::InternalError();\n \n   GURL origin_url(origin);\n  if (!origin_url.is_valid())\n    return Response::InvalidParams(origin + \" is not a valid URL\");\n\n  BrowserThread::PostTask(\n      BrowserThread::IO, FROM_HERE,\n      base::BindOnce(&CacheStorageObserver::UntrackOriginOnIOThread,\n                     base::Unretained(GetCacheStorageObserver()),\n                     url::Origin::Create(origin_url)));\n  return Response::OK();\n }\n",
        "target": 1
    },
    {
        "id": 2869,
        "func": "  DevtoolsInterceptionWithAuthProxyTest()\n      : proxy_server_(net::SpawnedTestServer::TYPE_BASIC_AUTH_PROXY,\n                      base::FilePath(FILE_PATH_LITERAL(\"headless/test/data\"))) {\n  }\n",
        "target": 0
    },
    {
        "id": 2870,
        "func": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\n\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"rng\");\n\n\trrng.seedsize = alg->cra_rng.seedsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "target": 1
    },
    {
        "id": 2871,
        "func": "static void propagate_entity_cfs_rq(struct sched_entity *se) { }",
        "target": 0
    },
    {
        "id": 2872,
        "func": "static int vmload_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct page *page;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tnested_vmcb = nested_svm_map(svm, svm->vmcb->save.rax, &page);\n\tif (!nested_vmcb)\n\t\treturn 1;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(nested_vmcb, svm->vmcb);\n\tnested_svm_unmap(page);\n\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 2873,
        "func": "void PwnMessageHelper::LockMouse(RenderProcessHost* process,\n                                 int routing_id,\n                                 bool user_gesture,\n                                 bool privileged) {\n  IPC::IpcSecurityTestUtil::PwnMessageReceived(\n      process->GetChannel(),\n      ViewHostMsg_LockMouse(routing_id, user_gesture, privileged));\n}\n",
        "target": 0
    },
    {
        "id": 2874,
        "func": "CPError CPB_GetCommandLineArgumentsCommon(const char* url,\n                                          std::string* arguments) {\n  const CommandLine cmd = *CommandLine::ForCurrentProcess();\n  std::wstring arguments_w;\n\n  std::wstring user_data_dir = cmd.GetSwitchValue(switches::kUserDataDir);\n  if (!user_data_dir.empty()) {\n    if (file_util::AbsolutePath(&user_data_dir) &&\n        file_util::PathExists(FilePath::FromWStringHack(user_data_dir))) {\n      arguments_w += std::wstring(L\"--\") + ASCIIToWide(switches::kUserDataDir) +\n                     L\"=\\\"\" + user_data_dir + L\"\\\" \";\n    }\n  }\n\n#if defined (OS_CHROMEOS)\n  std::wstring profile = cmd.GetSwitchValue(switches::kProfile);\n  if (!profile.empty()) {\n    arguments_w += std::wstring(L\"--\") + ASCIIToWide(switches::kProfile) +\n                   L\"=\\\"\" + profile + L\"\\\" \";\n  }\n#endif\n\n   std::string url_string(url);\n  ReplaceSubstringsAfterOffset(&url_string, 0, \"\\\"\", \"\\\\\\\"\");\n  ReplaceSubstringsAfterOffset(&url_string, 0, \"%\", \"%%\");\n  ReplaceSubstringsAfterOffset(&url_string, 0, \";\", \"\");\n  ReplaceSubstringsAfterOffset(&url_string, 0, \"$\", \"\");\n   std::wstring url_w = UTF8ToWide(url_string);\n   arguments_w += std::wstring(L\"--\") + ASCIIToWide(switches::kApp) +\n      L\"=\\\"\" + url_w + L\"\\\"\";\n\n  *arguments = WideToUTF8(arguments_w);\n\n  return CPERR_SUCCESS;\n}\n",
        "target": 1
    },
    {
        "id": 2875,
        "func": "void EnumFonts(FPDF_SYSFONTINFO* sysfontinfo, void* mapper) {\n  FPDF_AddInstalledFont(mapper, \"Arial\", FXFONT_DEFAULT_CHARSET);\n\n  const FPDF_CharsetFontMap* font_map = FPDF_GetDefaultTTFMap();\n  for (; font_map->charset != -1; ++font_map) {\n    FPDF_AddInstalledFont(mapper, font_map->fontname, font_map->charset);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2876,
        "func": "SPL_METHOD(SplFileInfo, getPathInfo)\n{\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tzend_class_entry *ce = intern->info_class;\n \tzend_error_handling error_handling;\n \tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tint path_len;\n\t\tchar *path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\t\tif (path) {\n\t\t\tchar *dpath = estrndup(path, path_len);\n\t\t\tpath_len = php_dirname(dpath, path_len);\n\t\t\tspl_filesystem_object_create_info(intern, dpath, path_len, 1, ce, return_value TSRMLS_CC);\n\t\t\tefree(dpath);\n\t\t}\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n",
        "target": 1
    },
    {
        "id": 2877,
        "func": "  static void WaitForFirstSharedWorkerOnIOThread(\n      scoped_refptr<WorkerData> worker_data) {\n    std::vector<WorkerService::WorkerInfo> worker_info =\n        WorkerService::GetInstance()->GetWorkers();\n    if (!worker_info.empty()) {\n      worker_data->worker_process_id = worker_info[0].process_id;\n      worker_data->worker_route_id = worker_info[0].route_id;\n      BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n          MessageLoop::QuitClosure());\n      return;\n    }\n\n    WorkerService::GetInstance()->AddObserver(\n        new WorkerCreationObserver(worker_data.get()));\n  }\n",
        "target": 0
    },
    {
        "id": 2878,
        "func": "void ContentSecurityPolicy::reportInvalidPluginTypes(const String& pluginType) {\n  String message;\n  if (pluginType.isNull())\n    message =\n        \"'plugin-types' Content Security Policy directive is empty; all \"\n        \"plugins will be blocked.\\n\";\n  else if (pluginType == \"'none'\")\n    message =\n        \"Invalid plugin type in 'plugin-types' Content Security Policy \"\n        \"directive: '\" +\n        pluginType +\n        \"'. Did you mean to set the object-src directive to 'none'?\\n\";\n  else\n    message =\n        \"Invalid plugin type in 'plugin-types' Content Security Policy \"\n        \"directive: '\" +\n        pluginType + \"'.\\n\";\n  logToConsole(message);\n}\n",
        "target": 0
    },
    {
        "id": 2879,
        "func": "void Document::enqueueResizeEvent()\n{\n    Event* event = Event::create(EventTypeNames::resize);\n    event->setTarget(domWindow());\n    ensureScriptedAnimationController().enqueuePerFrameEvent(event);\n}\n",
        "target": 0
    },
    {
        "id": 2880,
        "func": "PHP_FUNCTION(mdecrypt_generic)\n{\n\tzval *mcryptind;\n\tchar *data;\n\tint data_len;\n \tphp_mcrypt *pm;\n \tchar* data_s;\n \tint block_size, data_size;\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &mcryptind, &data, &data_len) == FAILURE) {\n \t\treturn;\n \t}\n \tZEND_FETCH_RESOURCE(pm, php_mcrypt * , &mcryptind, -1, \"MCrypt\", le_mcrypt);\n \tPHP_MCRYPT_INIT_CHECK\n \n\tif (data_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"An empty string was passed\");\n\t\tRETURN_FALSE\n\t}\n\n\t/* Check blocksize */\n \tif (mcrypt_enc_is_block_mode(pm->td) == 1) { /* It's a block algorithm */\n \t\tblock_size = mcrypt_enc_get_block_size(pm->td);\n \t\tdata_size = (((data_len - 1) / block_size) + 1) * block_size;\n \t\tdata_s = emalloc(data_size + 1);\n \t\tmemset(data_s, 0, data_size);\n \t\tmemcpy(data_s, data, data_len);\n\t} else { /* It's not a block algorithm */\n\t\tdata_size = data_len;\n\t\tdata_s = emalloc(data_size + 1);\n \t\tmemset(data_s, 0, data_size);\n \t\tmemcpy(data_s, data, data_len);\n \t}\n \tmdecrypt_generic(pm->td, data_s, data_size);\n \n \tRETVAL_STRINGL(data_s, data_size, 1);\n\tefree(data_s);\n}\n",
        "target": 1
    },
    {
        "id": 2881,
        "func": "static inline size_t utf8_codepoint_len(uint8_t ch)\n{\n return ((0xe5000000 >> ((ch >> 3) & 0x1e)) & 3) + 1;\n}\n",
        "target": 0
    },
    {
        "id": 2882,
        "func": "content::WebContents* TranslateInfoBarDelegate::GetWebContents() {\n   return InfoBarService::WebContentsFromInfoBar(infobar());\n }\n",
        "target": 0
    },
    {
        "id": 2883,
        "func": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Receive client pre-shared key identity name\n     */\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n\n    if( n < 1 || n > 65535 || *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        /* Identity is not a big secret since clients send it in the clear,\n         * but treat it carefully anyway, just in case */\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n\n    *p += n;\n\n    return( 0 );\n}",
        "target": 1
    },
    {
        "id": 2884,
        "func": "base::WaitableEvent* ProxyChannelDelegate::GetShutdownEvent() {\n  return &shutdown_event_;\n}\n",
        "target": 1
    },
    {
        "id": 2885,
        "func": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
        "target": 1
    },
    {
        "id": 2886,
        "func": "DebuggerDetachFunction::~DebuggerDetachFunction() {\n}\n",
        "target": 0
    },
    {
        "id": 2887,
        "func": "find_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}\n",
        "target": 0
    },
    {
        "id": 2888,
        "func": " static uint32_t readU32(const uint8_t* data, size_t offset) {\n    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];\n }\n",
        "target": 1
    },
    {
        "id": 2889,
        "func": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tstrlcpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "target": 1
    },
    {
        "id": 2890,
        "func": "static void uv__chld(uv_signal_t* handle, int signum) {\n  uv_process_t* process;\n  uv_loop_t* loop;\n  int exit_status;\n  int term_signal;\n  unsigned int i;\n  int status;\n  pid_t pid;\n  QUEUE pending;\n  QUEUE* h;\n  QUEUE* q;\n\n  assert(signum == SIGCHLD);\n\n  QUEUE_INIT(&pending);\n  loop = handle->loop;\n\n  for (i = 0; i < ARRAY_SIZE(loop->process_handles); i++) {\n    h = loop->process_handles + i;\n    q = QUEUE_HEAD(h);\n\n    while (q != h) {\n      process = QUEUE_DATA(q, uv_process_t, queue);\n      q = QUEUE_NEXT(q);\n\n      do\n        pid = waitpid(process->pid, &status, WNOHANG);\n      while (pid == -1 && errno == EINTR);\n\n      if (pid == 0)\n        continue;\n\n      if (pid == -1) {\n        if (errno != ECHILD)\n          abort();\n        continue;\n      }\n\n      process->status = status;\n      QUEUE_REMOVE(&process->queue);\n      QUEUE_INSERT_TAIL(&pending, &process->queue);\n    }\n\n    while (!QUEUE_EMPTY(&pending)) {\n      q = QUEUE_HEAD(&pending);\n      QUEUE_REMOVE(q);\n      QUEUE_INIT(q);\n\n      process = QUEUE_DATA(q, uv_process_t, queue);\n      uv__handle_stop(process);\n\n      if (process->exit_cb == NULL)\n        continue;\n\n      exit_status = 0;\n      if (WIFEXITED(process->status))\n        exit_status = WEXITSTATUS(process->status);\n\n      term_signal = 0;\n      if (WIFSIGNALED(process->status))\n        term_signal = WTERMSIG(process->status);\n\n      process->exit_cb(process, exit_status, term_signal);\n    }\n  }\n}",
        "target": 0
    },
    {
        "id": 2891,
        "func": "xps_parse_matrix_transform(xps_document *doc, fz_xml *root, fz_matrix *matrix)\n{\n\tchar *transform;\n\n\t*matrix = fz_identity;\n\n\tif (!strcmp(fz_xml_tag(root), \"MatrixTransform\"))\n\t{\n\t\ttransform = fz_xml_att(root, \"Matrix\");\n\t\tif (transform)\n\t\t\txps_parse_render_transform(doc, transform, matrix);\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 2892,
        "func": "void AutofillManager::OnFocusOnFormFieldImpl(const FormData& form,\n                                             const FormFieldData& field,\n                                             const gfx::RectF& bounding_box) {\n  if (!external_delegate_->HasActiveScreenReader())\n    return;\n\n  std::vector<Suggestion> suggestions;\n  SuggestionsContext context;\n  GetAvailableSuggestions(form, field, &suggestions, &context);\n\n  external_delegate_->OnAutofillAvailabilityEvent(\n      context.suppress_reason == SuppressReason::kNotSuppressed &&\n      !suggestions.empty());\n}\n",
        "target": 0
    },
    {
        "id": 2893,
        "func": "void ImageBitmapFactories::ImageBitmapLoader::didFinishLoading()\n{\n    if (!m_loader.arrayBufferResult()) {\n        rejectPromise();\n        return;\n    }\n    RefPtr<SharedBuffer> sharedBuffer = SharedBuffer::create((char*)m_loader.arrayBufferResult()->data(), m_loader.arrayBufferResult()->byteLength());\n\n    OwnPtr<ImageSource> source = adoptPtr(new ImageSource());\n    source->setData(sharedBuffer.get(), true);\n    RefPtr<NativeImageSkia> imageSkia = source->createFrameAtIndex(0);\n    if (!imageSkia) {\n        rejectPromise();\n        return;\n    }\n\n    RefPtr<Image> image = BitmapImage::create(imageSkia);\n    if (!image->width() || !image->height()) {\n        rejectPromise();\n        return;\n    }\n    if (!m_cropRect.width() && !m_cropRect.height()) {\n        m_cropRect = IntRect(IntPoint(), image->size());\n    }\n\n    RefPtrWillBeRawPtr<ImageBitmap> imageBitmap = ImageBitmap::create(image.get(), m_cropRect);\n    ScriptScope scope(m_scriptState);\n    m_resolver->resolve(imageBitmap.release());\n    m_factory->didFinishLoading(this);\n}\n",
        "target": 0
    },
    {
        "id": 2894,
        "func": "static void async_removepending(struct async *as)\n{\n\tstruct usb_dev_state *ps = as->ps;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ps->lock, flags);\n\tlist_del_init(&as->asynclist);\n\tspin_unlock_irqrestore(&ps->lock, flags);\n}",
        "target": 0
    },
    {
        "id": 2895,
        "func": "static v8::Handle<v8::Value> intMethodWithArgsCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.intMethodWithArgs\");\n     if (args.Length() < 3)\n        return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));\n    EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined))) : 0);\n    return v8::Integer::New(imp->intMethodWithArgs(intArg, strArg, objArg));\n}\n",
        "target": 0
    },
    {
        "id": 2896,
        "func": "bool VaapiWrapper::IsJpegDecodeSupported() {\n  return profile_infos_.Get().IsProfileSupported(kDecode,\n                                                 VAProfileJPEGBaseline);\n}\n",
        "target": 0
    },
    {
        "id": 2897,
        "func": "HarfBuzzShaper::HarfBuzzShaper(const Font* font, const TextRun& run, const GlyphData* emphasisData,\n    HashSet<const SimpleFontData*>* fallbackFonts, FloatRect* bounds)\n    : Shaper(font, run, emphasisData, fallbackFonts, bounds)\n    , m_normalizedBufferLength(0)\n    , m_wordSpacingAdjustment(font->fontDescription().wordSpacing())\n    , m_letterSpacing(font->fontDescription().letterSpacing())\n     , m_expansionOpportunityCount(0)\n     , m_fromIndex(0)\n     , m_toIndex(m_run.length())\n {\n     m_normalizedBuffer = adoptArrayPtr(new UChar[m_run.length() + 1]);\n     normalizeCharacters(m_run, m_run.length(), m_normalizedBuffer.get(), &m_normalizedBufferLength);\n    setExpansion(m_run.expansion());\n    setFontFeatures();\n}\n",
        "target": 1
    },
    {
        "id": 2898,
        "func": "void SyncManager::SyncInternal::SetExtraChangeRecordData(int64 id,\n    syncable::ModelType type, ChangeReorderBuffer* buffer,\n    Cryptographer* cryptographer, const syncable::EntryKernel& original,\n    bool existed_before, bool exists_now) {\n  if (!exists_now && existed_before) {\n    sync_pb::EntitySpecifics original_specifics(original.ref(SPECIFICS));\n    if (type == syncable::PASSWORDS) {\n      scoped_ptr<sync_pb::PasswordSpecificsData> data(\n          DecryptPasswordSpecifics(original_specifics, cryptographer));\n      if (!data.get()) {\n        NOTREACHED();\n        return;\n      }\n      buffer->SetExtraDataForId(id, new ExtraPasswordChangeRecordData(*data));\n    } else if (original_specifics.has_encrypted()) {\n      const sync_pb::EncryptedData& encrypted = original_specifics.encrypted();\n      if (!cryptographer->Decrypt(encrypted, &original_specifics)) {\n        NOTREACHED();\n        return;\n      }\n    }\n    buffer->SetSpecificsForId(id, original_specifics);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 2899,
        "func": " jbig2_end_of_stripe(Jbig2Ctx *ctx, Jbig2Segment *segment, const uint8_t *segment_data)\n {\n     Jbig2Page page = ctx->pages[ctx->current_page];\n    int end_row;\n \n    end_row = jbig2_get_int32(segment_data);\n     if (end_row < page.end_row) {\n         jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number,\n                     \"end of stripe segment with non-positive end row advance\" \" (new end row %d vs current end row %d)\", end_row, page.end_row);\n    } else {\n        jbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number, \"end of stripe: advancing end row to %d\", end_row);\n    }\n\n    page.end_row = end_row;\n\n    return 0;\n}\n",
        "target": 1
    },
    {
        "id": 2900,
        "func": "throw_error (GDBusMethodInvocation *context,\n             gint                   error_code,\n             const gchar           *format,\n             ...)\n{\n        va_list args;\n        g_autofree gchar *message = NULL;\n\n        va_start (args, format);\n        message = g_strdup_vprintf (format, args);\n        va_end (args);\n\n        g_dbus_method_invocation_return_error (context, ERROR, error_code, \"%s\", message);\n}\n",
        "target": 0
    },
    {
        "id": 2901,
        "func": "Response InspectorHandler::Enable() {\n  if (host_ && !host_->IsRenderFrameLive())\n    frontend_->TargetCrashed();\n  return Response::OK();\n}\n",
        "target": 0
    },
    {
        "id": 2902,
        "func": "bool SiteInstanceImpl::ShouldLockToOrigin(BrowserContext* browser_context,\n                                          GURL site_url) {\n  if (RenderProcessHost::run_renderer_in_process())\n    return false;\n\n  if (!DoesSiteRequireDedicatedProcess(browser_context, site_url))\n    return false;\n\n   if (site_url.SchemeIs(content::kGuestScheme))\n     return false;\n \n  if (site_url.SchemeIs(content::kChromeUIScheme))\n    return false;\n  if (!GetContentClient()->browser()->ShouldLockToOrigin(browser_context,\n                                                         site_url)) {\n    return false;\n  }\n\n  return true;\n}\n",
        "target": 1
    },
    {
        "id": 2903,
        "func": " RenderLayer* InRegionScrollableArea::layer() const\n {\n     ASSERT(!m_isNull);\n    return m_layer;\n}\n",
        "target": 0
    },
    {
        "id": 2904,
        "func": "  virtual void SendHandwritingStroke(const HandwritingStroke& stroke) {\n  virtual void SendHandwritingStroke(\n      const input_method::HandwritingStroke& stroke) {\n     if (!initialized_successfully_)\n       return;\n    ibus_controller_->SendHandwritingStroke(stroke);\n   }\n",
        "target": 0
    },
    {
        "id": 2905,
        "func": "isdn_net_delphone(isdn_net_ioctl_phone * phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint inout = phone->outgoing & 1;\n\tisdn_net_phone *n;\n\tisdn_net_phone *m;\n\n\tif (p) {\n\t\tn = p->local->phone[inout];\n\t\tm = NULL;\n\t\twhile (n) {\n\t\t\tif (!strcmp(n->num, phone->phone)) {\n\t\t\t\tif (p->local->dial == n)\n\t\t\t\t\tp->local->dial = n->next;\n\t\t\t\tif (m)\n\t\t\t\t\tm->next = n->next;\n\t\t\t\telse\n\t\t\t\t\tp->local->phone[inout] = n->next;\n\t\t\t\tkfree(n);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tm = n;\n\t\t\tn = (isdn_net_phone *) n->next;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\treturn -ENODEV;\n}",
        "target": 0
    },
    {
        "id": 2906,
        "func": "static inline u32 ___hsiphash_aligned(const __le32 *data, size_t len,\n\t\t\t\t      const hsiphash_key_t *key)\n{\n\tif (__builtin_constant_p(len) && len == 4)\n\t\treturn hsiphash_1u32(le32_to_cpu(data[0]), key);\n\tif (__builtin_constant_p(len) && len == 8)\n\t\treturn hsiphash_2u32(le32_to_cpu(data[0]), le32_to_cpu(data[1]),\n\t\t\t\t     key);\n\tif (__builtin_constant_p(len) && len == 12)\n\t\treturn hsiphash_3u32(le32_to_cpu(data[0]), le32_to_cpu(data[1]),\n\t\t\t\t     le32_to_cpu(data[2]), key);\n\tif (__builtin_constant_p(len) && len == 16)\n\t\treturn hsiphash_4u32(le32_to_cpu(data[0]), le32_to_cpu(data[1]),\n\t\t\t\t     le32_to_cpu(data[2]), le32_to_cpu(data[3]),\n\t\t\t\t     key);\n\treturn __hsiphash_aligned(data, len, key);\n}",
        "target": 0
    },
    {
        "id": 2907,
        "func": " PHP_FUNCTION(curl_escape)\n {\n \tchar       *str = NULL, *res = NULL;\n\tsize_t     str_len = 0;\n \tzval       *zid;\n \tphp_curl   *ch;\n \n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rs\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((ch = (php_curl*)zend_fetch_resource(Z_RES_P(zid), le_curl_name, le_curl)) == NULL) {\n \t\tRETURN_FALSE;\n \t}\n \n\tif (ZEND_SIZE_T_INT_OVFL(str_len)) {\n\t\tRETURN_FALSE;\n\t}\n\n \tif ((res = curl_easy_escape(ch->cp, str, str_len))) {\n \t\tRETVAL_STRING(res);\n \t\tcurl_free(res);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 2908,
        "func": "static void security_A(BYTE* master_secret, const BYTE* client_random, BYTE* server_random,\n\t\tBYTE* output)\n{\n\tsecurity_premaster_hash(\"A\", 1, master_secret, client_random, server_random, &output[0]);\n\tsecurity_premaster_hash(\"BB\", 2, master_secret, client_random, server_random, &output[16]);\n\tsecurity_premaster_hash(\"CCC\", 3, master_secret, client_random, server_random, &output[32]);\n}",
        "target": 0
    },
    {
        "id": 2909,
        "func": "mwifiex_cmd_uap_sys_config(struct host_cmd_ds_command *cmd, u16 cmd_action,\n\t\t\t   u32 type, void *cmd_buf)\n{\n\tu8 *tlv;\n\tu16 cmd_size, param_size, ie_size;\n\tstruct host_cmd_ds_sys_config *sys_cfg;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_UAP_SYS_CONFIG);\n\tcmd_size = (u16)(sizeof(struct host_cmd_ds_sys_config) + S_DS_GEN);\n\tsys_cfg = (struct host_cmd_ds_sys_config *)&cmd->params.uap_sys_config;\n\tsys_cfg->action = cpu_to_le16(cmd_action);\n\ttlv = sys_cfg->tlv;\n\n\tswitch (type) {\n\tcase UAP_BSS_PARAMS_I:\n\t\tparam_size = cmd_size;\n\t\tif (mwifiex_uap_bss_param_prepare(tlv, cmd_buf, &param_size))\n\t\t\treturn -1;\n\t\tcmd->size = cpu_to_le16(param_size);\n\t\tbreak;\n\tcase UAP_CUSTOM_IE_I:\n\t\tie_size = cmd_size;\n\t\tif (mwifiex_uap_custom_ie_prepare(tlv, cmd_buf, &ie_size))\n\t\t\treturn -1;\n\t\tcmd->size = cpu_to_le16(ie_size);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 2910,
        "func": "Document& Document::TopDocument() const {\n  Document* doc = const_cast<Document*>(this);\n  for (HTMLFrameOwnerElement* element = doc->LocalOwner(); element;\n       element = doc->LocalOwner())\n    doc = &element->GetDocument();\n\n  DCHECK(doc);\n  return *doc;\n}\n",
        "target": 0
    },
    {
        "id": 2911,
        "func": "views::View* AutofillPopupItemView::CreateSubtextLabel() {\n  return nullptr;\n}\n",
        "target": 0
    },
    {
        "id": 2912,
        "func": "\nstatic void napi_reuse_skb(struct napi_struct *napi, struct sk_buff *skb)\n{\n\tif (unlikely(skb->pfmemalloc)) {\n\t\tconsume_skb(skb);\n\t\treturn;\n\t}\n\t__skb_pull(skb, skb_headlen(skb));\n\t/* restore the reserve we had after netdev_alloc_skb_ip_align() */\n\tskb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN - skb_headroom(skb));\n\tskb->vlan_tci = 0;\n\tskb->dev = napi->dev;\n\tskb->skb_iif = 0;\n\tskb->encapsulation = 0;\n\tskb_shinfo(skb)->gso_type = 0;\n\tskb->truesize = SKB_TRUESIZE(skb_end_offset(skb));\n\tsecpath_reset(skb);\n\n\tnapi->skb = skb;",
        "target": 0
    },
    {
        "id": 2913,
        "func": "LoginLibrary* CrosLibrary::GetLoginLibrary() {\n  return login_lib_.GetDefaultImpl(use_stub_impl_);\n}\n",
        "target": 1
    },
    {
        "id": 2914,
        "func": "static void acm_tty_cleanup(struct tty_struct *tty)\n{\n\tstruct acm *acm = tty->driver_data;\n\tdev_dbg(&acm->control->dev, \"%s\\n\", __func__);\n\ttty_port_put(&acm->port);\n}",
        "target": 0
    },
    {
        "id": 2915,
        "func": "H264SwDecRet H264SwDecInit(H264SwDecInst *decInst, u32 noOutputReordering)\n{\n    u32 rv = 0;\n\n decContainer_t *pDecCont;\n\n    DEC_API_TRC(\"H264SwDecInit#\");\n\n /* check that right shift on negative numbers is performed signed */\n /*lint -save -e* following check causes multiple lint messages */\n if ( ((-1)>>1) != (-1) )\n {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: Right shift is not signed\");\n return(H264SWDEC_INITFAIL);\n }\n /*lint -restore */\n\n if (decInst == NULL)\n {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: decInst == NULL\");\n\n         return(H264SWDEC_PARAM_ERR);\n     }\n \n    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t));\n \n     if (pDecCont == NULL)\n     {\n        DEC_API_TRC(\"H264SwDecInit# ERROR: Memory allocation failed\");\n return(H264SWDEC_MEMFAIL);\n }\n\n#ifdef H264DEC_TRACE\n    sprintf(pDecCont->str, \"H264SwDecInit# decInst %p noOutputReordering %d\",\n (void*)decInst, noOutputReordering);\n    DEC_API_TRC(pDecCont->str);\n#endif\n\n    rv = h264bsdInit(&pDecCont->storage, noOutputReordering);\n if (rv != HANTRO_OK)\n {\n        H264SwDecRelease(pDecCont);\n return(H264SWDEC_MEMFAIL);\n }\n\n    pDecCont->decStat  = INITIALIZED;\n    pDecCont->picNumber = 0;\n\n#ifdef H264DEC_TRACE\n    sprintf(pDecCont->str, \"H264SwDecInit# OK: return %p\", (void*)pDecCont);\n    DEC_API_TRC(pDecCont->str);\n#endif\n\n *decInst = (decContainer_t *)pDecCont;\n\n return(H264SWDEC_OK);\n\n}\n",
        "target": 1
    },
    {
        "id": 2916,
        "func": "void RememberValidHandle(const ScriptableHandle* handle) {\n  if (NULL == g_ValidHandles) {\n    g_ValidHandles = new(std::nothrow) std::set<const ScriptableHandle*>;\n    if (NULL == g_ValidHandles) {\n      return;\n    }\n  }\n   g_ValidHandles->insert(handle);\n }\n",
        "target": 0
    },
    {
        "id": 2917,
        "func": " void HttpResponseHeaders::AddHeader(const std::string& header) {\n   DCHECK_EQ('\\0', raw_headers_[raw_headers_.size() - 2]);\n   DCHECK_EQ('\\0', raw_headers_[raw_headers_.size() - 1]);\n  std::string new_raw_headers(raw_headers_, 0, raw_headers_.size() - 1);\n  new_raw_headers.append(header);\n  new_raw_headers.push_back('\\0');\n  new_raw_headers.push_back('\\0');\n\n  raw_headers_.clear();\n  parsed_.clear();\n  Parse(new_raw_headers);\n }\n",
        "target": 1
    },
    {
        "id": 2918,
        "func": "nameNsPop(xmlParserCtxtPtr ctxt)\n{\n const xmlChar *ret;\n\n if (ctxt->nameNr <= 0)\n return (NULL);\n    ctxt->nameNr--;\n if (ctxt->nameNr > 0)\n        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];\n else\n        ctxt->name = NULL;\n    ret = ctxt->nameTab[ctxt->nameNr];\n    ctxt->nameTab[ctxt->nameNr] = NULL;\n return (ret);\n}\n",
        "target": 0
    },
    {
        "id": 2919,
        "func": "  t42_loader_done( T42_Loader  loader )\n  {\n    T42_Parser  parser = &loader->parser;\n\n\n    /* finalize tables */\n    T1_Release_Table( &loader->encoding_table );\n    T1_Release_Table( &loader->charstrings );\n    T1_Release_Table( &loader->glyph_names );\n    T1_Release_Table( &loader->swap_table );\n\n    /* finalize parser */\n    t42_parser_done( parser );\n  }\n",
        "target": 0
    },
    {
        "id": 2920,
        "func": "ssize_t rawexpwrite(off_t a, char *buf, size_t len, CLIENT *client, int fua) {\n\tint fhandle;\n\toff_t foffset;\n\tsize_t maxbytes;\n\tssize_t retval;\n\n\tif(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))\n\t\treturn -1;\n\tif(maxbytes && len > maxbytes)\n\t\tlen = maxbytes;\n\n\tDEBUG(\"(WRITE to fd %d offset %llu len %u fua %d), \", fhandle, (long long unsigned)foffset, (unsigned int)len, fua);\n\n\tmyseek(fhandle, foffset);\n\tretval = write(fhandle, buf, len);\n\tif(client->server->flags & F_SYNC) {\n\t\tfsync(fhandle);\n\t} else if (fua) {\n\n\t  /* This is where we would do the following\n\t   *   #ifdef USE_SYNC_FILE_RANGE\n\t   * However, we don't, for the reasons set out below\n\t   * by Christoph Hellwig <hch@infradead.org>\n\t   *\n\t   * [BEGINS] \n\t   * fdatasync is equivalent to fsync except that it does not flush\n\t   * non-essential metadata (basically just timestamps in practice), but it\n\t   * does flush metadata requried to find the data again, e.g. allocation\n\t   * information and extent maps.  sync_file_range does nothing but flush\n\t   * out pagecache content - it means you basically won't get your data\n\t   * back in case of a crash if you either:\n\t   * \n\t   *  a) have a volatile write cache in your disk (e.g. any normal SATA disk)\n\t   *  b) are using a sparse file on a filesystem\n\t   *  c) are using a fallocate-preallocated file on a filesystem\n\t   *  d) use any file on a COW filesystem like btrfs\n\t   * \n\t   * e.g. it only does anything useful for you if you do not have a volatile\n\t   * write cache, and either use a raw block device node, or just overwrite\n\t   * an already fully allocated (and not preallocated) file on a non-COW\n\t   * filesystem.\n\t   * [ENDS]\n\t   *\n\t   * What we should do is open a second FD with O_DSYNC set, then write to\n\t   * that when appropriate. However, with a Linux client, every REQ_FUA\n\t   * immediately follows a REQ_FLUSH, so fdatasync does not cause performance\n\t   * problems.\n\t   *\n\t   */\n#if 0\n\t\tsync_file_range(fhandle, foffset, len,\n\t\t\t\tSYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE |\n\t\t\t\tSYNC_FILE_RANGE_WAIT_AFTER);\n#else\n\t\tfdatasync(fhandle);\n#endif\n\t}\n\treturn retval;\n}",
        "target": 0
    },
    {
        "id": 2921,
        "func": "static int gfs2_get_flags(struct file *filp, u32 __user *ptr)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint error;\n\tu32 fsflags;\n\n\tgfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);\n\terror = gfs2_glock_nq(&gh);\n\tif (error)\n\t\treturn error;\n\n\tfsflags = fsflags_cvt(gfs2_to_fsflags, ip->i_diskflags);\n\tif (!S_ISDIR(inode->i_mode) && ip->i_diskflags & GFS2_DIF_JDATA)\n\t\tfsflags |= FS_JOURNAL_DATA_FL;\n\tif (put_user(fsflags, ptr))\n\t\terror = -EFAULT;\n\n\tgfs2_glock_dq(&gh);\n\tgfs2_holder_uninit(&gh);\n\treturn error;\n}",
        "target": 0
    },
    {
        "id": 2922,
        "func": "  void TriggerNavigatorGetPasswordCredentialsAndExpectHasResult(\n      content::WebContents* web_contents,\n      bool expect_has_results) {\n    bool result = false;\n    ASSERT_TRUE(content::ExecuteScriptAndExtractBool(\n        web_contents,\n        \"navigator.credentials.get({password: true}).then(c => {\"\n        \"  window.domAutomationController.send(!!c);\"\n        \"});\",\n        &result));\n    ASSERT_EQ(expect_has_results, result);\n  }\n",
        "target": 0
    },
    {
        "id": 2923,
        "func": "static char *MakeNewMapValue(STRING2PTR value, const char *mapstr)\n{\n    char *ptr;\n    char *newtitle = NULL;\n\n    StrAllocCopy(newtitle, \"[\");\n    StrAllocCat(newtitle, mapstr);\t/* ISMAP or USEMAP */\n    if (verbose_img && non_empty(value[HTML_IMG_SRC])) {\n\tStrAllocCat(newtitle, \":\");\n\tptr = strrchr(value[HTML_IMG_SRC], '/');\n\tif (!ptr) {\n\t    StrAllocCat(newtitle, value[HTML_IMG_SRC]);\n\t} else {\n\t    StrAllocCat(newtitle, ptr + 1);\n\t}\n    }\n    StrAllocCat(newtitle, \"]\");\n    return newtitle;\n}",
        "target": 0
    },
    {
        "id": 2924,
        "func": "static void *decode_register(struct x86_emulate_ctxt *ctxt, u8 modrm_reg,\n\t\t\t     int byteop)\n{\n\tvoid *p;\n\tint highbyte_regs = (ctxt->rex_prefix == 0) && byteop;\n\n\tif (highbyte_regs && modrm_reg >= 4 && modrm_reg < 8)\n\t\tp = (unsigned char *)reg_rmw(ctxt, modrm_reg & 3) + 1;\n\telse\n\t\tp = reg_rmw(ctxt, modrm_reg);\n\treturn p;\n}",
        "target": 0
    },
    {
        "id": 2925,
        "func": "base::string16 TemplateURL::GenerateKeyword(const GURL& url) {\n  DCHECK(url.is_valid());\n  base::string16 keyword = url_formatter::StripWWW(\n      url_formatter::IDNToUnicode(url.host()));\n  return keyword.empty() ? base::ASCIIToUTF16(\"www\") : keyword;\n}\n",
        "target": 0
    },
    {
        "id": 2926,
        "func": "void DXVAVideoDecodeAccelerator::Decode(\n    const media::BitstreamBuffer& bitstream_buffer) {\n  DCHECK(CalledOnValidThread());\n\n  RETURN_AND_NOTIFY_ON_FAILURE((state_ == kNormal || state_ == kStopped),\n      \"Invalid state: \" << state_, ILLEGAL_STATE,);\n \n   base::win::ScopedComPtr<IMFSample> sample;\n   sample.Attach(CreateSampleFromInputBuffer(bitstream_buffer,\n                                            renderer_process_,\n                                             input_stream_info_.cbSize,\n                                             input_stream_info_.cbAlignment));\n   RETURN_AND_NOTIFY_ON_FAILURE(sample, \"Failed to create input sample\",\n                               PLATFORM_FAILURE,);\n  if (!inputs_before_decode_) {\n    TRACE_EVENT_BEGIN_ETW(\"DXVAVideoDecodeAccelerator.Decoding\", this, \"\");\n  }\n  inputs_before_decode_++;\n\n  RETURN_AND_NOTIFY_ON_FAILURE(\n      SendMFTMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, 0),\n      \"Failed to create input sample\", PLATFORM_FAILURE,);\n\n  HRESULT hr = decoder_->ProcessInput(0, sample, 0);\n  RETURN_AND_NOTIFY_ON_HR_FAILURE(hr, \"Failed to process input sample\",\n      PLATFORM_FAILURE,);\n\n  RETURN_AND_NOTIFY_ON_FAILURE(\n    SendMFTMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, 0),\n    \"Failed to send eos message to MFT\", PLATFORM_FAILURE,);\n  state_ = kEosDrain;\n\n  last_input_buffer_id_ = bitstream_buffer.id();\n\n  DoDecode();\n\n  RETURN_AND_NOTIFY_ON_FAILURE((state_ == kStopped || state_ == kNormal),\n      \"Failed to process output. Unexpected decoder state: \" << state_,\n      ILLEGAL_STATE,);\n\n  MessageLoop::current()->PostTask(FROM_HERE, base::Bind(\n      &DXVAVideoDecodeAccelerator::NotifyInputBufferRead, this,\n      bitstream_buffer.id()));\n}\n",
        "target": 1
    },
    {
        "id": 2927,
        "func": "static void unfold_ifblk(struct block **blk)\n{\n   struct ifblock *ifblk;\n   struct unfold_elm *ue;\n   u_int32 a = vlabel++; \n   u_int32 b = vlabel++; \n   u_int32 c = vlabel++; \n\n   /*\n    * the virtual labels represent the three points of an if block:\n    *\n    *    if (conds) {\n    * a ->\n    *       ...\n    *       jmp c;\n    * b ->\n    *    } else {\n    *       ...\n    *    }\n    * c ->\n    *\n    * if the conds are true, jump to 'a'\n    * if the conds are false, jump to 'b'\n    * 'c' is used to skip the else if the conds were true\n    */\n\n   /* the progress bar */\n   ef_debug(1, \"#\"); \n   \n   /* cast the if block */\n   ifblk = (*blk)->un.ifb;\n  \n   /* compile the conditions */\n   unfold_conds(ifblk->conds, a, b);\n   \n   /* if the conditions are match, jump here */\n   SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n   ue->label = a;\n   TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n\n   /* check if the block is empty. i.e.  { } */\n   if (ifblk->blk != NULL) {\n      /* recursively compile the main block */\n      unfold_blk(&ifblk->blk);\n   }\n\n   /* \n    * if there is the else block, we have to skip it\n    * if the condition was true\n    */\n   if (ifblk->elseblk != NULL) {\n      SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n      ue->fop.opcode = FOP_JMP;\n      ue->fop.op.jmp = c;\n      TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n   }\n   \n   /* if the conditions are NOT match, jump here (after the block) */\n   SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n   ue->label = b;\n   TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n   \n   /* recursively compile the else block */\n   if (ifblk->elseblk != NULL) {\n      unfold_blk(&ifblk->elseblk);\n      /* this is the label to skip the else if the condition was true */\n      SAFE_CALLOC(ue, 1, sizeof(struct unfold_elm));\n      ue->label = c;\n      TAILQ_INSERT_TAIL(&unfolded_tree, ue, next);\n   }\n\n}",
        "target": 0
    },
    {
        "id": 2928,
        "func": "static void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream,\n\t\t\t\t      int up)\n{\n\tstruct snd_usb_midi *umidi = substream->rmidi->private_data;\n\n\tif (up)\n\t\tset_bit(substream->number, &umidi->input_triggered);\n\telse\n\t\tclear_bit(substream->number, &umidi->input_triggered);\n}",
        "target": 0
    },
    {
        "id": 2929,
        "func": "gpgsm_passwd (void *engine, gpgme_key_t key, unsigned int flags)\n{\n  engine_gpgsm_t gpgsm = engine;\n  gpgme_error_t err;\n  char *line;\n\n  if (!key || !key->subkeys || !key->subkeys->fpr)\n    return gpg_error (GPG_ERR_INV_CERT_OBJ);\n\n  if (asprintf (&line, \"PASSWD -- %s\", key->subkeys->fpr) < 0)\n    return gpg_error_from_syserror ();\n\n  gpgsm_clear_fd (gpgsm, OUTPUT_FD);\n  gpgsm_clear_fd (gpgsm, INPUT_FD);\n  gpgsm_clear_fd (gpgsm, MESSAGE_FD);\n  gpgsm->inline_data = NULL;\n\n  err = start (gpgsm, line);\n  free (line);\n\n  return err;\n}\n",
        "target": 0
    },
    {
        "id": 2930,
        "func": "MagickExport MagickBooleanType SetImageAlpha(Image *image,const Quantum alpha,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  image->alpha_trait=BlendPixelTrait;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (GetPixelReadMask(image,q) != 0)\n        SetPixelAlpha(image,alpha,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}",
        "target": 0
    },
    {
        "id": 2931,
        "func": " static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,\n                               int nb_sectors)\n {\n     return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,\n                                    nb_sectors * BDRV_SECTOR_SIZE);\n }\n",
        "target": 1
    },
    {
        "id": 2932,
        "func": "void Document::RegisterNodeListWithIdNameCache(const LiveNodeListBase* list) {\n  node_lists_.Add(list, kInvalidateOnIdNameAttrChange);\n  LiveNodeListBaseWriteBarrier(this, list);\n}\n",
        "target": 0
    },
    {
        "id": 2933,
        "func": "void CL_PacketEvent( netadr_t from, msg_t *msg ) {\n\tint\t\theaderBytes;\n\n\tclc.lastPacketTime = cls.realtime;\n\n\tif ( msg->cursize >= 4 && *(int *)msg->data == -1 ) {\n\t\tCL_ConnectionlessPacket( from, msg );\n\t\treturn;\n\t}\n\n\tif ( clc.state < CA_CONNECTED ) {\n\t\treturn;\t\t// can't be a valid sequenced packet\n\t}\n\n\tif ( msg->cursize < 4 ) {\n\t\tCom_Printf (\"%s: Runt packet\\n\", NET_AdrToStringwPort( from ));\n\t\treturn;\n\t}\n\n\tif ( !NET_CompareAdr( from, clc.netchan.remoteAddress ) ) {\n\t\tCom_DPrintf (\"%s:sequenced packet without connection\\n\"\n\t\t\t, NET_AdrToStringwPort( from ) );\n\t\treturn;\n\t}\n\n\tif (!CL_Netchan_Process( &clc.netchan, msg) ) {\n\t\treturn;\t\t// out of order, duplicated, etc\n\t}\n\n\theaderBytes = msg->readcount;\n\n\tclc.serverMessageSequence = LittleLong( *(int *)msg->data );\n\n\tclc.lastPacketTime = cls.realtime;\n\tCL_ParseServerMessage( msg );\n\n\tif ( clc.demorecording && !clc.demowaiting ) {\n\t\tCL_WriteDemoMessage( msg, headerBytes );\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 2934,
        "func": "static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\treturn;\n}",
        "target": 0
    },
    {
        "id": 2935,
        "func": "static int em_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 pmc;\n\n\tif (ctxt->ops->read_pmc(ctxt, reg_read(ctxt, VCPU_REGS_RCX), &pmc))\n\t\treturn emulate_gp(ctxt, 0);\n\t*reg_write(ctxt, VCPU_REGS_RAX) = (u32)pmc;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = pmc >> 32;\n\treturn X86EMUL_CONTINUE;\n}",
        "target": 0
    },
    {
        "id": 2936,
        "func": "  void CloseSession() {\n    if (opened_device_label_.empty())\n      return;\n    media_stream_manager_->CancelRequest(opened_device_label_);\n    opened_device_label_.clear();\n    opened_session_id_ = kInvalidMediaCaptureSessionId;\n  }\n",
        "target": 0
    },
    {
        "id": 2937,
        "func": " void HeapObjectHeader::Finalize(Address object, size_t object_size) {\n   HeapAllocHooks::FreeHookIfEnabled(object);\n  const GCInfo* gc_info = GCInfoTable::Get().GCInfoFromIndex(GcInfoIndex());\n   if (gc_info->HasFinalizer())\n     gc_info->finalize_(object);\n \n  ASAN_RETIRE_CONTAINER_ANNOTATION(object, object_size);\n}\n",
        "target": 0
    },
    {
        "id": 2938,
        "func": "static bool IsJSNewline(UChar c) {\n  return (c == '\\n' || c == '\\r' || c == 0x2028 || c == 0x2029);\n}\n",
        "target": 0
    },
    {
        "id": 2939,
        "func": "void LayerTreeHostQt::setVisibleContentsRectForPanning(const IntRect& rect, const FloatPoint& trajectoryVector)\n{\n    m_visibleContentsRect = rect;\n\n    toWebGraphicsLayer(m_nonCompositedContentLayer.get())->setVisibleContentRectTrajectoryVector(trajectoryVector);\n\n    scheduleLayerFlush();\n}\n",
        "target": 0
    },
    {
        "id": 2940,
        "func": "int tls1_process_ticket(SSL *s, unsigned char *session_id, int len,\n\t\t\tconst unsigned char *limit, SSL_SESSION **ret)\n\t{\n\t/* Point after session ID in client hello */\n\tconst unsigned char *p = session_id + len;\n\tunsigned short i;\n\n\t*ret = NULL;\n\ts->tlsext_ticket_expected = 0;\n\n\t/* If tickets disabled behave as if no ticket present\n\t * to permit stateful resumption.\n\t */\n\tif (!tls_use_ticket(s))\n\t\treturn 0;\n\tif ((s->version <= SSL3_VERSION) || !limit)\n\t\treturn 0;\n\tif (p >= limit)\n\t\treturn -1;\n\t/* Skip past DTLS cookie */\n\tif (SSL_IS_DTLS(s))\n\t\t{\n\t\ti = *(p++);\n\t\tp+= i;\n\t\tif (p >= limit)\n\t\t\treturn -1;\n\t\t}\n\t/* Skip past cipher list */\n\tn2s(p, i);\n\tp+= i;\n\tif (p >= limit)\n\t\treturn -1;\n\t/* Skip past compression algorithm list */\n\ti = *(p++);\n\tp += i;\n\tif (p > limit)\n\t\treturn -1;\n\t/* Now at start of extensions */\n\tif ((p + 2) >= limit)\n\t\treturn 0;\n\tn2s(p, i);\n\twhile ((p + 4) <= limit)\n\t\t{\n\t\tunsigned short type, size;\n\t\tn2s(p, type);\n\t\tn2s(p, size);\n\t\tif (p + size > limit)\n\t\t\treturn 0;\n\t\tif (type == TLSEXT_TYPE_session_ticket)\n\t\t\t{\n\t\t\tint r;\n\t\t\tif (size == 0)\n\t\t\t\t{\n\t\t\t\t/* The client will accept a ticket but doesn't\n\t\t\t\t * currently have one. */\n\t\t\t\ts->tlsext_ticket_expected = 1;\n\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\tif (s->tls_session_secret_cb)\n\t\t\t\t{\n\t\t\t\t/* Indicate that the ticket couldn't be\n\t\t\t\t * decrypted rather than generating the session\n\t\t\t\t * from ticket now, trigger abbreviated\n\t\t\t\t * handshake based on external mechanism to\n\t\t\t\t * calculate the master secret later. */\n\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\tr = tls_decrypt_ticket(s, p, size, session_id, len, ret);\n\t\t\tswitch (r)\n\t\t\t\t{\n\t\t\t\tcase 2: /* ticket couldn't be decrypted */\n\t\t\t\t\ts->tlsext_ticket_expected = 1;\n\t\t\t\t\treturn 2;\n\t\t\t\tcase 3: /* ticket was decrypted */\n\t\t\t\t\treturn r;\n\t\t\t\tcase 4: /* ticket decrypted but need to renew */\n\t\t\t\t\ts->tlsext_ticket_expected = 1;\n\t\t\t\t\treturn 3;\n\t\t\t\tdefault: /* fatal error */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\tp += size;\n\t\t}\n\treturn 0;\n\t}\n",
        "target": 0
    },
    {
        "id": 2941,
        "func": " bool AXLayoutObject::supportsARIADragging() const {\n   const AtomicString& grabbed = getAttribute(aria_grabbedAttr);\n  return equalIgnoringCase(grabbed, \"true\") ||\n         equalIgnoringCase(grabbed, \"false\");\n }\n",
        "target": 1
    },
    {
        "id": 2942,
        "func": "static void irda_selective_discovery_indication(discinfo_t *discovery,\n\t\t\t\t\t\tDISCOVERY_MODE mode,\n\t\t\t\t\t\tvoid *priv)\n{\n\tstruct irda_sock *self;\n\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\n\tself = priv;\n\tif (!self) {\n\t\tIRDA_WARNING(\"%s: lost myself!\\n\", __func__);\n\t\treturn;\n\t}\n\n\t/* Pass parameter to the caller */\n\tself->cachedaddr = discovery->daddr;\n\n\t/* Wake up process if its waiting for device to be discovered */\n\twake_up_interruptible(&self->query_wait);\n}",
        "target": 0
    },
    {
        "id": 2943,
        "func": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t/* first fragment, reserve header_len */\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * this fragment is not first, the headers\n\t\t\t * space is regarded as data space.\n\t\t\t */\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}",
        "target": 1
    },
    {
        "id": 2944,
        "func": "apply_numeric_port_hack(int port, struct evutil_addrinfo **ai)\n{\n\t/* Now we run through the list and set the ports on all of the\n\t * results where ports would make sense. */\n\tfor ( ; *ai; ai = &(*ai)->ai_next) {\n\t\tstruct sockaddr *sa = (*ai)->ai_addr;\n\t\tif (sa && sa->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in*)sa;\n\t\t\tsin->sin_port = htons(port);\n\t\t} else if (sa && sa->sa_family == AF_INET6) {\n\t\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6*)sa;\n\t\t\tsin6->sin6_port = htons(port);\n\t\t} else {\n\t\t\t/* A numeric port makes no sense here; remove this one\n\t\t\t * from the list. */\n\t\t\tstruct evutil_addrinfo *victim = *ai;\n\t\t\t*ai = victim->ai_next;\n\t\t\tvictim->ai_next = NULL;\n\t\t\tfreeaddrinfo(victim);\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 2945,
        "func": "void _WM_do_meta_endoftrack(struct _mdi *mdi, struct _event_data *data) {\n/* placeholder function so we can record eot in the event stream\n * for conversion function _WM_Event2Midi */\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n\n    _WM_Release_Allowance(mdi);\n    return;\n}\n",
        "target": 0
    },
    {
        "id": 2946,
        "func": "void AwMainDelegate::PreSandboxStartup() {\n#if defined(ARCH_CPU_ARM_FAMILY)\n  base::CPU cpu_info;\n#endif\n\n  const base::CommandLine& command_line =\n      *base::CommandLine::ForCurrentProcess();\n  std::string process_type =\n      command_line.GetSwitchValueASCII(switches::kProcessType);\n  if (process_type == switches::kRendererProcess) {\n    auto global_descriptors = base::GlobalDescriptors::GetInstance();\n    int pak_fd = global_descriptors->Get(kAndroidWebViewLocalePakDescriptor);\n    base::MemoryMappedFile::Region pak_region =\n        global_descriptors->GetRegion(kAndroidWebViewLocalePakDescriptor);\n    ResourceBundle::InitSharedInstanceWithPakFileRegion(base::File(pak_fd),\n                                                        pak_region);\n    pak_fd = global_descriptors->Get(kAndroidWebViewMainPakDescriptor);\n    pak_region =\n        global_descriptors->GetRegion(kAndroidWebViewMainPakDescriptor);\n    ResourceBundle::GetSharedInstance().AddDataPackFromFileRegion(\n        base::File(pak_fd), pak_region, ui::SCALE_FACTOR_NONE);\n  }\n\n  crash_reporter::EnableMicrodumpCrashReporter();\n}\n",
        "target": 0
    },
    {
        "id": 2947,
        "func": "void RenderProcessHostImpl::OnSavedPageAsMHTML(int job_id, int64 data_size) {\n  MHTMLGenerationManager::GetInstance()->MHTMLGenerated(job_id, data_size);\n}\n",
        "target": 0
    },
    {
        "id": 2948,
        "func": "int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = CPUCLOCK_PID(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (CPUCLOCK_WHICH(new_timer->it_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&new_timer->it.cpu.entry);\n\tnew_timer->it.cpu.incr.sched = 0;\n\tnew_timer->it.cpu.expires.sched = 0;\n\n\tread_lock(&tasklist_lock);\n\tif (CPUCLOCK_PERTHREAD(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = NULL;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !thread_group_leader(p))\n\t\t\t\tp = NULL;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 2949,
        "func": "ReportLedBadType(CompatInfo *info, LedInfo *ledi, const char *field,\n                 const char *wanted)\n{\n    return ReportBadType(info->ctx, \"indicator map\", field,\n                         xkb_atom_text(info->ctx, ledi->led.name),\n                         wanted);\n}",
        "target": 0
    },
    {
        "id": 2950,
        "func": "void RenderLayerCompositor::frameViewDidChangeSize()\n{\n    if (m_containerLayer) {\n        FrameView* frameView = m_renderView->frameView();\n        m_containerLayer->setSize(frameView->unscaledVisibleContentSize());\n\n        frameViewDidScroll();\n        updateOverflowControlsLayers();\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2951,
        "func": "static void clear_node_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tunsigned int long flags;\n\n\tif (PageDirty(page)) {\n\t\tspin_lock_irqsave(&mapping->tree_lock, flags);\n\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\tpage_index(page),\n\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\tspin_unlock_irqrestore(&mapping->tree_lock, flags);\n\n\t\tclear_page_dirty_for_io(page);\n\t\tdec_page_count(F2FS_M_SB(mapping), F2FS_DIRTY_NODES);\n\t}\n\tClearPageUptodate(page);\n}",
        "target": 0
    },
    {
        "id": 2952,
        "func": "int flush_completed_IO(struct inode *inode)\n{\n\text4_io_end_t *io;\n\tint ret = 0;\n\tint ret2 = 0;\n\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n\t\treturn ret;\n\n\tdump_completed_IO(inode);\n\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n\t\t\t\text4_io_end_t, list);\n\t\t/*\n\t\t * Calling ext4_end_io_nolock() to convert completed\n\t\t * IO to written.\n\t\t *\n\t\t * When ext4_sync_file() is called, run_queue() may already\n\t\t * about to flush the work corresponding to this io structure.\n\t\t * It will be upset if it founds the io structure related\n\t\t * to the work-to-be schedule is freed.\n\t\t *\n\t\t * Thus we need to keep the io structure still valid here after\n\t\t * convertion finished. The io structure has a flag to\n\t\t * avoid double converting from both fsync and background work\n\t\t * queue work.\n\t\t */\n\t\tret = ext4_end_io_nolock(io);\n\t\tif (ret < 0)\n\t\t\tret2 = ret;\n\t\telse\n\t\t\tlist_del_init(&io->list);\n\t}\n\treturn (ret2 < 0) ? ret2 : 0;\n}",
        "target": 1
    },
    {
        "id": 2953,
        "func": "static void dump_error_msg(struct nl_msg *msg, FILE *ofd)\n{\n\tstruct nlmsghdr *hdr = nlmsg_hdr(msg);\n\tstruct nlmsgerr *err = nlmsg_data(hdr);\n\n\tfprintf(ofd, \"  [ERRORMSG] %zu octets\\n\", sizeof(*err));\n\n\tif (nlmsg_len(hdr) >= sizeof(*err)) {\n\t\tstruct nl_msg *errmsg;\n\n\t\tfprintf(ofd, \"    .error = %d \\\"%s\\\"\\n\", err->error,\n\t\t\tnl_strerror_l(-err->error));\n\t\tfprintf(ofd, \"  [ORIGINAL MESSAGE] %zu octets\\n\", sizeof(*hdr));\n\n\t\terrmsg = nlmsg_inherit(&err->msg);\n\t\tprint_hdr(ofd, errmsg);\n\t\tnlmsg_free(errmsg);\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 2954,
        "func": "void FrameLoaderClient::dispatchDidReceiveTitle(const String& title)\n{\n    WebKitWebFramePrivate* priv = m_frame->priv;\n    g_free(priv->title);\n    priv->title = g_strdup(title.utf8().data());\n\n    g_signal_emit_by_name(m_frame, \"title-changed\", priv->title);\n    g_object_notify(G_OBJECT(m_frame), \"title\");\n\n    WebKitWebView* webView = getViewFromFrame(m_frame);\n    if (m_frame == webkit_web_view_get_main_frame(webView)) {\n        g_signal_emit_by_name(webView, \"title-changed\", m_frame, title.utf8().data());\n        g_object_notify(G_OBJECT(webView), \"title\");\n    }\n}\n",
        "target": 0
    },
    {
        "id": 2955,
        "func": "static v8::Handle<v8::Value> overloadedMethod1Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.overloadedMethod1\");\n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));\n    imp->overloadedMethod(objArg, strArg);\n    return v8::Handle<v8::Value>();\n}\n",
        "target": 1
    },
    {
        "id": 2956,
        "func": "SYSCALL_DEFINE2(rt_sigpending, sigset_t __user *, set, size_t, sigsetsize)\n{\n\treturn do_sigpending(set, sigsetsize);\n}",
        "target": 0
    },
    {
        "id": 2957,
        "func": "void QuotaManagerTest::GetUsage_WithModifyTestBody(const StorageType type) {\n  const MockOriginData data[] = {\n    { \"http://foo.com/\",   type,  10 },\n    { \"http://foo.com:1/\", type,  20 },\n  };\n  MockStorageClient* client = CreateClient(data, ARRAYSIZE_UNSAFE(data));\n  RegisterClient(client);\n\n  GetUsageAndQuota(GURL(\"http://foo.com/\"), type);\n  MessageLoop::current()->RunAllPending();\n  EXPECT_EQ(kQuotaStatusOk, status());\n  EXPECT_EQ(10 + 20, usage());\n\n  client->ModifyOriginAndNotify(GURL(\"http://foo.com/\"), type, 30);\n  client->ModifyOriginAndNotify(GURL(\"http://foo.com:1/\"), type, -5);\n  client->AddOriginAndNotify(GURL(\"https://foo.com/\"), type, 1);\n\n  GetUsageAndQuota(GURL(\"http://foo.com/\"), type);\n  MessageLoop::current()->RunAllPending();\n  EXPECT_EQ(kQuotaStatusOk, status());\n  EXPECT_EQ(10 + 20 + 30 - 5 + 1, usage());\n  int foo_usage = usage();\n\n  client->AddOriginAndNotify(GURL(\"http://bar.com/\"), type, 40);\n  GetUsageAndQuota(GURL(\"http://bar.com/\"), type);\n  MessageLoop::current()->RunAllPending();\n  EXPECT_EQ(kQuotaStatusOk, status());\n  EXPECT_EQ(40, usage());\n\n  GetGlobalUsage(type);\n  MessageLoop::current()->RunAllPending();\n  EXPECT_EQ(foo_usage + 40, usage());\n  EXPECT_EQ(0, unlimited_usage());\n}\n",
        "target": 0
    },
    {
        "id": 2958,
        "func": "  const net::HttpRequestHeaders& request_headers() const {\n    return request_headers_;\n  }\n",
        "target": 1
    },
    {
        "id": 2959,
        "func": "bool HTMLMediaElement::TextTracksAreReady() const {\n  for (const auto& text_track : text_tracks_when_resource_selection_began_) {\n    if (text_track->GetReadinessState() == TextTrack::kLoading ||\n        text_track->GetReadinessState() == TextTrack::kNotLoaded)\n      return false;\n  }\n\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 2960,
        "func": "void BrowserViewRenderer::UpdateRootLayerState(\n    const gfx::Vector2dF& total_scroll_offset_dip,\n    const gfx::Vector2dF& max_scroll_offset_dip,\n    const gfx::SizeF& scrollable_size_dip,\n    float page_scale_factor,\n    float min_page_scale_factor,\n    float max_page_scale_factor) {\n  TRACE_EVENT_INSTANT1(\n      \"android_webview\",\n      \"BrowserViewRenderer::UpdateRootLayerState\",\n      TRACE_EVENT_SCOPE_THREAD,\n      \"state\",\n      RootLayerStateAsValue(total_scroll_offset_dip, scrollable_size_dip));\n\n  DCHECK_GT(dip_scale_, 0.f);\n\n  max_scroll_offset_dip_ = max_scroll_offset_dip;\n  DCHECK_LE(0.f, max_scroll_offset_dip_.x());\n  DCHECK_LE(0.f, max_scroll_offset_dip_.y());\n\n  page_scale_factor_ = page_scale_factor;\n  DCHECK_GT(page_scale_factor_, 0.f);\n\n  client_->UpdateScrollState(max_scroll_offset(),\n                             scrollable_size_dip,\n                             page_scale_factor,\n                             min_page_scale_factor,\n                             max_page_scale_factor);\n  SetTotalRootLayerScrollOffset(total_scroll_offset_dip);\n}\n",
        "target": 0
    },
    {
        "id": 2961,
        "func": "void Tab::OnMouseEntered(const ui::MouseEvent& event) {\n  mouse_hovered_ = true;\n  tab_style_->ShowHover(TabStyle::ShowHoverStyle::kSubtle);\n  UpdateForegroundColors();\n  Layout();\n  controller_->UpdateHoverCard(this, true);\n}\n",
        "target": 0
    },
    {
        "id": 2962,
        "func": "DEFUN(goLine, GOTO_LINE, \"Go to the specified line\")\n{\n\n    char *str = searchKeyData();\n    if (prec_num)\n\t_goLine(\"^\");\n    else if (str)\n\t_goLine(str);\n    else\n\t/* FIXME: gettextize? */\n\t_goLine(inputStr(\"Goto line: \", \"\"));\n}",
        "target": 0
    },
    {
        "id": 2963,
        "func": "static void tcp_xmit_recovery(struct sock *sk, int rexmit)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (rexmit == REXMIT_NONE)\n\t\treturn;\n\n\tif (unlikely(rexmit == 2)) {\n\t\t__tcp_push_pending_frames(sk, tcp_current_mss(sk),\n\t\t\t\t\t  TCP_NAGLE_OFF);\n\t\tif (after(tp->snd_nxt, tp->high_seq))\n\t\t\treturn;\n\t\ttp->frto = 0;\n\t}\n\ttcp_xmit_retransmit_queue(sk);\n}",
        "target": 0
    },
    {
        "id": 2964,
        "func": "const UChar* WordAwareIterator::characters() const\n{\n    if (!m_buffer.isEmpty())\n        return m_buffer.data();\n    if (m_previousText)\n        return m_previousText;\n    return m_textIterator.characters();\n}\n",
        "target": 0
    },
    {
        "id": 2965,
        "func": "void ExtensionBrowserTest::TearDownOnMainThread() {\n  ExtensionMessageBubbleFactory::set_override_for_tests(\n      ExtensionMessageBubbleFactory::NO_OVERRIDE);\n  extensions::SetExtensionProtocolTestHandler(nullptr);\n}\n",
        "target": 0
    },
    {
        "id": 2966,
        "func": "krb5_gss_inquire_attrs_for_mech(OM_uint32 *minor_status,\n                                gss_const_OID mech,\n                                gss_OID_set *mech_attrs,\n                                gss_OID_set *known_mech_attrs)\n{\n    OM_uint32 major, tmpMinor;\n\n    if (mech_attrs == NULL) {\n        *minor_status = 0;\n        return GSS_S_COMPLETE;\n    }\n\n    major = gss_create_empty_oid_set(minor_status, mech_attrs);\n    if (GSS_ERROR(major))\n        goto cleanup;\n\n#define MA_SUPPORTED(ma)    do {                                        \\\n        major = gss_add_oid_set_member(minor_status, (gss_OID)ma,       \\\n                                       mech_attrs);                     \\\n        if (GSS_ERROR(major))                                           \\\n            goto cleanup;                                               \\\n    } while (0)\n\n    MA_SUPPORTED(GSS_C_MA_MECH_CONCRETE);\n    MA_SUPPORTED(GSS_C_MA_ITOK_FRAMED);\n    MA_SUPPORTED(GSS_C_MA_AUTH_INIT);\n    MA_SUPPORTED(GSS_C_MA_AUTH_TARG);\n    MA_SUPPORTED(GSS_C_MA_DELEG_CRED);\n    MA_SUPPORTED(GSS_C_MA_INTEG_PROT);\n    MA_SUPPORTED(GSS_C_MA_CONF_PROT);\n    MA_SUPPORTED(GSS_C_MA_MIC);\n    MA_SUPPORTED(GSS_C_MA_WRAP);\n    MA_SUPPORTED(GSS_C_MA_PROT_READY);\n    MA_SUPPORTED(GSS_C_MA_REPLAY_DET);\n    MA_SUPPORTED(GSS_C_MA_OOS_DET);\n    MA_SUPPORTED(GSS_C_MA_CBINDINGS);\n    MA_SUPPORTED(GSS_C_MA_CTX_TRANS);\n\n    if (g_OID_equal(mech, gss_mech_iakerb)) {\n        MA_SUPPORTED(GSS_C_MA_AUTH_INIT_INIT);\n    } else if (!g_OID_equal(mech, gss_mech_krb5)) {\n        MA_SUPPORTED(GSS_C_MA_DEPRECATED);\n    }\n\ncleanup:\n    if (GSS_ERROR(major))\n        gss_release_oid_set(&tmpMinor, mech_attrs);\n\n    return major;\n}",
        "target": 0
    },
    {
        "id": 2967,
        "func": "static inline int alloc_fresh_gigantic_page(struct hstate *h,\n\t\t\t\t\tnodemask_t *nodes_allowed) { return 0; }",
        "target": 0
    },
    {
        "id": 2968,
        "func": "Strfgetall(FILE * f)\n{\n    Str s = Strnew();\n    int c;\n    while ((c = fgetc(f)) != EOF) {\n\tStrcat_char(s, c);\n    }\n    return s;\n}\n",
        "target": 0
    },
    {
        "id": 2969,
        "func": "void AutofillPopupBaseView::SetSelection(const gfx::Point& point) {\n  if (delegate_)\n    delegate_->SetSelectionAtPoint(point);\n}\n",
        "target": 0
    },
    {
        "id": 2970,
        "func": "static unsigned int fanout_demux_lb(struct packet_fanout *f,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    unsigned int num)\n{\n\tunsigned int val = atomic_inc_return(&f->rr_cur);\n\n\treturn val % num;\n}",
        "target": 0
    },
    {
        "id": 2971,
        "func": "getCodePage(void)\n{\n    unsigned long CpList[8], CpSize;\n\n    if (!getenv(\"WINDOWID\") && !DosQueryCp(sizeof(CpList), CpList, &CpSize))\n\treturn Sprintf(\"CP%d\", *CpList)->ptr;\n    return NULL;\n}",
        "target": 0
    },
    {
        "id": 2972,
        "func": "static void wq_add(struct mqueue_inode_info *info, int sr,\n\t\t\tstruct ext_wait_queue *ewp)\n{\n\tstruct ext_wait_queue *walk;\n\n\tewp->task = current;\n\n\tlist_for_each_entry(walk, &info->e_wait_q[sr].list, list) {\n\t\tif (walk->task->static_prio <= current->static_prio) {\n\t\t\tlist_add_tail(&ewp->list, &walk->list);\n\t\t\treturn;\n\t\t}\n\t}\n\tlist_add_tail(&ewp->list, &info->e_wait_q[sr].list);\n}",
        "target": 0
    },
    {
        "id": 2973,
        "func": "static void cache_free(Cache* cache)\n{\n    /* shutdown cache in 10 minutes of inactivity */\n    if(!cache->delayed_free_handler)\n        cache->delayed_free_handler = g_timeout_add_seconds(600,\n                                                            delayed_cache_free,\n                                                            cache);\n    DEBUG(\"menu %p cache unused, removing in 600s\", cache);\n}\n",
        "target": 0
    },
    {
        "id": 2974,
        "func": "void padb_del(GF_Box *s)\n{\n\tGF_PaddingBitsBox *ptr = (GF_PaddingBitsBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->padbits) gf_free(ptr->padbits);\n\tgf_free(ptr);\n}",
        "target": 0
    },
    {
        "id": 2975,
        "func": "  static bool ConvertJSONValue(const base::DictionaryValue& value,\n                               ExpectFileTasksMessage* message) {\n    base::JSONValueConverter<ExpectFileTasksMessage> converter;\n    return converter.Convert(value, message);\n  }\n",
        "target": 0
    },
    {
        "id": 2976,
        "func": "static void perf_event_switch_output(struct perf_event *event, void *data)\n{\n\tstruct perf_switch_event *se = data;\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tif (!perf_event_switch_match(event))\n\t\treturn;\n\n\t/* Only CPU-wide events are allowed to see next/prev pid/tid */\n\tif (event->ctx->task) {\n\t\tse->event_id.header.type = PERF_RECORD_SWITCH;\n\t\tse->event_id.header.size = sizeof(se->event_id.header);\n\t} else {\n\t\tse->event_id.header.type = PERF_RECORD_SWITCH_CPU_WIDE;\n\t\tse->event_id.header.size = sizeof(se->event_id);\n\t\tse->event_id.next_prev_pid =\n\t\t\t\t\tperf_event_pid(event, se->next_prev);\n\t\tse->event_id.next_prev_tid =\n\t\t\t\t\tperf_event_tid(event, se->next_prev);\n\t}\n\n\tperf_event_header__init_id(&se->event_id.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event, se->event_id.header.size);\n\tif (ret)\n\t\treturn;\n\n\tif (event->ctx->task)\n\t\tperf_output_put(&handle, se->event_id.header);\n\telse\n\t\tperf_output_put(&handle, se->event_id);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}",
        "target": 0
    },
    {
        "id": 2977,
        "func": "void DidFindRegistrationForDispatchSyncEventOnIO(\n    scoped_refptr<BackgroundSyncContext> sync_context,\n    const std::string& tag,\n    bool last_chance,\n    ServiceWorkerStatusCode status,\n    scoped_refptr<content::ServiceWorkerRegistration> registration) {\n  if (status != SERVICE_WORKER_OK || !registration->active_version())\n    return;\n  BackgroundSyncManager* background_sync_manager =\n      sync_context->background_sync_manager();\n  scoped_refptr<content::ServiceWorkerVersion> version(\n      registration->active_version());\n  background_sync_manager->EmulateDispatchSyncEvent(\n      tag, std::move(version), last_chance,\n      base::BindOnce(&StatusNoOpKeepingRegistration, std::move(registration)));\n}\n",
        "target": 0
    },
    {
        "id": 2978,
        "func": "DefragTimeoutTest(void)\n{\n    int i;\n    int ret = 0;\n\n    /* Setup a small numberr of trackers. */\n    if (ConfSet(\"defrag.trackers\", \"16\") != 1) {\n        printf(\"ConfSet failed: \");\n        goto end;\n    }\n\n    DefragInit();\n\n    /* Load in 16 packets. */\n    for (i = 0; i < 16; i++) {\n        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n        if (p == NULL)\n            goto end;\n\n        Packet *tp = Defrag(NULL, NULL, p, NULL);\n\n        SCFree(p);\n\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n    }\n\n    /* Build a new packet but push the timestamp out by our timeout.\n     * This should force our previous fragments to be timed out. */\n    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n    if (p == NULL)\n        goto end;\n\n    p->ts.tv_sec += (defrag_context->timeout + 1);\n    Packet *tp = Defrag(NULL, NULL, p, NULL);\n\n    if (tp != NULL) {\n        SCFree(tp);\n        goto end;\n    }\n\n    DefragTracker *tracker = DefragLookupTrackerFromHash(p);\n    if (tracker == NULL)\n        goto end;\n\n    if (tracker->id != 99)\n        goto end;\n\n    SCFree(p);\n\n    ret = 1;\nend:\n    DefragDestroy();\n    return ret;\n}",
        "target": 1
    },
    {
        "id": 2979,
        "func": " void UserSelectionScreen::FillMultiProfileUserPrefs(\n    const user_manager::User* user,\n     base::DictionaryValue* user_dict,\n     bool is_signin_to_add) {\n   if (!is_signin_to_add) {\n    user_dict->SetBoolean(kKeyMultiProfilesAllowed, true);\n    return;\n  }\n\n  bool is_user_allowed;\n  ash::mojom::MultiProfileUserBehavior policy;\n  GetMultiProfilePolicy(user, &is_user_allowed, &policy);\n  user_dict->SetBoolean(kKeyMultiProfilesAllowed, is_user_allowed);\n  user_dict->SetInteger(kKeyMultiProfilesPolicy, static_cast<int>(policy));\n}\n",
        "target": 0
    },
    {
        "id": 2980,
        "func": "  void SetAsyncInitExpectation(int result) {\n    init_result_ = result;\n    EXPECT_CALL(*this, Init(_))\n        .WillOnce(DoAll(Invoke(this, &MockUploadElementReader::OnInit),\n                        Return(ERR_IO_PENDING)));\n  }\n",
        "target": 0
    },
    {
        "id": 2981,
        "func": "OMX_ERRORTYPE SoftOpus::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch ((int)index) {\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (strncmp((const char *)roleParams->cRole,\n                         \"audio_decoder.opus\",\n                         OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAndroidOpus:\n {\n\n             const OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *opusParams =\n                 (const OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *)params;\n \n             if (opusParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n",
        "target": 1
    },
    {
        "id": 2982,
        "func": "bool XmlReader::IsClosingElement() {\n  return NodeType() == XML_READER_TYPE_END_ELEMENT;\n}\n",
        "target": 0
    },
    {
        "id": 2983,
        "func": "void webkit_web_view_move_cursor(WebKitWebView* webView, GtkMovementStep step, gint count)\n{\n    g_return_if_fail(WEBKIT_IS_WEB_VIEW(webView));\n    g_return_if_fail(step == GTK_MOVEMENT_VISUAL_POSITIONS ||\n                     step == GTK_MOVEMENT_DISPLAY_LINES ||\n                     step == GTK_MOVEMENT_PAGES ||\n                     step == GTK_MOVEMENT_BUFFER_ENDS);\n    g_return_if_fail(count == 1 || count == -1);\n\n    gboolean handled;\n    g_signal_emit(webView, webkit_web_view_signals[MOVE_CURSOR], 0, step, count, &handled);\n}\n",
        "target": 0
    },
    {
        "id": 2984,
        "func": "static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\n\t\t\t    struct mr6_table **mrt)\n{\n\tint err;\n\tstruct ip6mr_result res;\n\tstruct fib_lookup_arg arg = {\n\t\t.result = &res,\n\t\t.flags = FIB_LOOKUP_NOREF,\n\t};\n\n\terr = fib_rules_lookup(net->ipv6.mr6_rules_ops,\n\t\t\t       flowi6_to_flowi(flp6), 0, &arg);\n\tif (err < 0)\n\t\treturn err;\n\t*mrt = res.mrt;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2985,
        "func": " void DelegatedFrameHost::CopyFromCompositingSurface(\n     const gfx::Rect& src_subrect,\n    const gfx::Size& dst_size,\n     const base::Callback<void(bool, const SkBitmap&)>& callback,\n     const SkColorType color_type) {\n  bool format_support = ((color_type == kRGB_565_SkColorType) ||\n                         (color_type == kN32_SkColorType));\n  DCHECK(format_support);\n  if (!CanCopyToBitmap()) {\n    callback.Run(false, SkBitmap());\n     return;\n   }\n \n  const gfx::Size& dst_size_in_pixel =\n      client_->ConvertViewSizeToPixel(dst_size);\n   scoped_ptr<cc::CopyOutputRequest> request =\n       cc::CopyOutputRequest::CreateRequest(base::Bind(\n           &DelegatedFrameHost::CopyFromCompositingSurfaceHasResult,\n          dst_size_in_pixel,\n           color_type,\n           callback));\n  gfx::Rect src_subrect_in_pixel =\n      ConvertRectToPixel(client_->CurrentDeviceScaleFactor(), src_subrect);\n  request->set_area(src_subrect_in_pixel);\n   client_->RequestCopyOfOutput(request.Pass());\n }\n",
        "target": 1
    },
    {
        "id": 2986,
        "func": "EncodedJSValue JSC_HOST_CALL JSDeprecatedPeerConnectionConstructor::constructJSDeprecatedPeerConnection(ExecState* exec)\n{\n    JSDeprecatedPeerConnectionConstructor* jsConstructor = static_cast<JSDeprecatedPeerConnectionConstructor*>(exec->callee());\n    ScriptExecutionContext* context = jsConstructor->scriptExecutionContext();\n    if (!context)\n         return throwVMError(exec, createReferenceError(exec, \"DeprecatedPeerConnection constructor associated document is unavailable\"));\n \n     if (exec->argumentCount() < 2)\n        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n \n     String serverConfiguration = ustringToString(exec->argument(0).toString(exec)->value(exec));\n     if (exec->hadException())\n        return JSValue::encode(JSValue());\n\n    RefPtr<SignalingCallback> signalingCallback = createFunctionOnlyCallback<JSSignalingCallback>(exec, static_cast<JSDOMGlobalObject*>(exec->lexicalGlobalObject()), exec->argument(1));\n    if (exec->hadException())\n        return JSValue::encode(JSValue());\n\n    RefPtr<DeprecatedPeerConnection> peerConnection = DeprecatedPeerConnection::create(context, serverConfiguration, signalingCallback.release());\n    return JSValue::encode(CREATE_DOM_WRAPPER(exec, jsConstructor->globalObject(), DeprecatedPeerConnection, peerConnection.get()));\n}\n",
        "target": 0
    },
    {
        "id": 2987,
        "func": "static void btrfs_release_delalloc_bytes(struct btrfs_root *root,\n\t\t\t\t\t u64 start, u64 len)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = btrfs_lookup_block_group(root->fs_info, start);\n\tASSERT(cache);\n\n\tspin_lock(&cache->lock);\n\tcache->delalloc_bytes -= len;\n\tspin_unlock(&cache->lock);\n\n\tbtrfs_put_block_group(cache);\n}",
        "target": 0
    },
    {
        "id": 2988,
        "func": "static int decode_rename(struct xdr_stream *xdr, struct nfs4_change_info *old_cinfo,\n\t      struct nfs4_change_info *new_cinfo)\n{\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_RENAME);\n\tif (status)\n\t\tgoto out;\n\tif ((status = decode_change_info(xdr, old_cinfo)))\n\t\tgoto out;\n\tstatus = decode_change_info(xdr, new_cinfo);\nout:\n\treturn status;\n}",
        "target": 0
    },
    {
        "id": 2989,
        "func": "Element* Editor::findEventTargetFromSelection() const {\n  return findEventTargetFrom(\n      frame().selection().computeVisibleSelectionInDOMTreeDeprecated());\n}\n",
        "target": 0
    },
    {
        "id": 2990,
        "func": "std::string OutdatedPluginInfoBarDelegate::GetLearnMoreURL() const {\n  return chrome::kOutdatedPluginLearnMoreURL;\n}\n",
        "target": 0
    },
    {
        "id": 2991,
        "func": "bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *done_key)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\n\tget_random_bytes(buf, nbytes);\n\t*done = true;\n\tspin_unlock_irqrestore(&lock, flags);\n\n\t__net_random_once_disable_jump(done_key);\n\n\treturn true;\n}",
        "target": 1
    },
    {
        "id": 2992,
        "func": "mm_answer_skeyquery(int sock, Buffer *m)\n{\n\tstruct skey skey;\n\tchar challenge[1024];\n\tu_int success;\n\n\tsuccess = _compat_skeychallenge(&skey, authctxt->user, challenge,\n\t    sizeof(challenge)) < 0 ? 0 : 1;\n\n\tbuffer_clear(m);\n\tbuffer_put_int(m, success);\n\tif (success)\n\t\tbuffer_put_cstring(m, challenge);\n\n\tdebug3(\"%s: sending challenge success: %u\", __func__, success);\n\tmm_request_send(sock, MONITOR_ANS_SKEYQUERY, m);\n\n\treturn (0);\n}",
        "target": 0
    },
    {
        "id": 2993,
        "func": "static int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t  u32 kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2994,
        "func": "void __audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tcontext->type = AUDIT_EXECVE;\n\tcontext->execve.argc = bprm->argc;\n}",
        "target": 0
    },
    {
        "id": 2995,
        "func": "status_t ACodec::setMinBufferSize(OMX_U32 portIndex, size_t size) {\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n    def.nPortIndex = portIndex;\n\n status_t err = mOMX->getParameter(\n            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n if (def.nBufferSize >= size) {\n return OK;\n }\n\n    def.nBufferSize = size;\n\n    err = mOMX->setParameter(\n            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n    err = mOMX->getParameter(\n            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n if (def.nBufferSize < size) {\n        ALOGE(\"failed to set min buffer size to %zu (is still %u)\", size, def.nBufferSize);\n return FAILED_TRANSACTION;\n }\n\n return OK;\n}\n",
        "target": 0
    },
    {
        "id": 2996,
        "func": "\t\tvoid CWebServer::RType_GetTransfers(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"GetTransfers\";\n\n\t\t\tuint64_t idx = 0;\n\t\t\tif (request::findValue(&req, \"idx\") != \"\")\n\t\t\t{\n\t\t\t\tidx = std::strtoull(request::findValue(&req, \"idx\").c_str(), nullptr, 10);\n\t\t\t}\n\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_query(\"SELECT Type, SubType FROM DeviceStatus WHERE (ID==%\" PRIu64 \")\",\n\t\t\t\tidx);\n\t\t\tif (!result.empty())\n\t\t\t{\n\t\t\t\tint dType = atoi(result[0][0].c_str());\n\t\t\t\tif (\n\t\t\t\t\t(dType == pTypeTEMP) ||\n\t\t\t\t\t(dType == pTypeTEMP_HUM)\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tresult = m_sql.safe_query(\n\t\t\t\t\t\t\"SELECT ID, Name FROM DeviceStatus WHERE (Type=='%q') AND (ID!=%\" PRIu64 \")\",\n\t\t\t\t\t\tresult[0][0].c_str(), idx);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = m_sql.safe_query(\n\t\t\t\t\t\t\"SELECT ID, Name FROM DeviceStatus WHERE (Type=='%q') AND (SubType=='%q') AND (ID!=%\" PRIu64 \")\",\n\t\t\t\t\t\tresult[0][0].c_str(), result[0][1].c_str(), idx);\n\t\t\t\t}\n\n\t\t\t\tint ii = 0;\n\t\t\t\tfor (const auto & itt : result)\n\t\t\t\t{\n\t\t\t\t\tstd::vector<std::string> sd = itt;\n\n\t\t\t\t\troot[\"result\"][ii][\"idx\"] = sd[0];\n\t\t\t\t\troot[\"result\"][ii][\"Name\"] = sd[1];\n\t\t\t\t\tii++;\n\t\t\t\t}\n\t\t\t}\n\t\t}",
        "target": 0
    },
    {
        "id": 2997,
        "func": "HostPortAllocatorSession::HostPortAllocatorSession(\n    cricket::HttpPortAllocatorBase* allocator,\n    int component,\n    const std::string& ice_username_fragment,\n    const std::string& ice_password,\n    const std::vector<talk_base::SocketAddress>& stun_hosts,\n    const std::vector<std::string>& relay_hosts,\n    const std::string& relay,\n    const scoped_refptr<net::URLRequestContextGetter>& url_context)\n    : HttpPortAllocatorSessionBase(\n        allocator, component, ice_username_fragment, ice_password,\n        stun_hosts, relay_hosts, relay, \"\"),\n      url_context_(url_context) {\n}\n",
        "target": 0
    },
    {
        "id": 2998,
        "func": "static int cqspi_prep(struct spi_nor *nor, enum spi_nor_ops ops)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\n\tmutex_lock(&cqspi->bus_mutex);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 2999,
        "func": "error::Error GLES2DecoderPassthroughImpl::DoBindAttribLocation(\n    GLuint program,\n    GLuint index,\n    const char* name) {\n  api()->glBindAttribLocationFn(GetProgramServiceID(program, resources_), index,\n                                name);\n  return error::kNoError;\n}\n",
        "target": 0
    },
    {
        "id": 3000,
        "func": "static struct nft_trans *nft_trans_alloc(struct nft_ctx *ctx, int msg_type,\n\t\t\t\t\t u32 size)\n{\n\tstruct nft_trans *trans;\n\n\ttrans = kzalloc(sizeof(struct nft_trans) + size, GFP_KERNEL);\n\tif (trans == NULL)\n\t\treturn NULL;\n\n\ttrans->msg_type = msg_type;\n\ttrans->ctx\t= *ctx;\n\n\treturn trans;\n}",
        "target": 0
    },
    {
        "id": 3001,
        "func": "static long sock_prot_memory_allocated(struct proto *proto)\n{\n\treturn proto->memory_allocated != NULL ? proto_memory_allocated(proto) : -1L;\n}",
        "target": 0
    },
    {
        "id": 3002,
        "func": "JSTestEventTarget::JSTestEventTarget(Structure* structure, JSDOMGlobalObject* globalObject, PassRefPtr<TestEventTarget> impl)\n    : JSDOMWrapper(structure, globalObject)\n    , m_impl(impl.leakRef())\n{\n}\n",
        "target": 0
    },
    {
        "id": 3003,
        "func": "GahpClient::condor_job_remove(const char *schedd_name, PROC_ID job_id,\n\t\t\t\t\t\t\t  const char *reason)\n{\n\tstatic const char* command = \"CONDOR_JOB_REMOVE\";\n\n\tif  (server->m_commands_supported->contains_anycase(command)==FALSE) {\n\t\treturn GAHPCLIENT_COMMAND_NOT_SUPPORTED;\n\t}\n\n\tif (!schedd_name) schedd_name=NULLSTRING;\n\tif (!reason) reason=NULLSTRING;\n\tstd::string reqline;\n\tchar *esc1 = strdup( escapeGahpString(schedd_name) );\n\tchar *esc2 = strdup( escapeGahpString(reason) );\n\tint x = sprintf(reqline, \"%s %d.%d %s\", esc1, job_id.cluster, job_id.proc,\n\t\t\t\t\t\t\t esc2);\n\tfree(esc1);\n\tfree(esc2);\n\tASSERT( x > 0 );\n\tconst char *buf = reqline.c_str();\n\n\tif ( !is_pending(command,buf) ) {\n\t\tif ( m_mode == results_only ) {\n\t\t\treturn GAHPCLIENT_COMMAND_NOT_SUBMITTED;\n\t\t}\n\t\tnow_pending(command,buf,deleg_proxy);\n\t}\n\n\t\t\n\tGahp_Args* result = get_pending_result(command,buf);\n\tif ( result ) {\n\t\tif (result->argc != 3) {\n\t\t\tEXCEPT(\"Bad %s Result\",command);\n\t\t}\n\t\tint rc = 1;\n\t\tif ( result->argv[1][0] == 'S' ) {\n\t\t\trc = 0;\n\t\t}\n\t\tif ( strcasecmp(result->argv[2], NULLSTRING) ) {\n\t\t\terror_string = result->argv[2];\n\t\t} else {\n\t\t\terror_string = \"\";\n\t\t}\n\t\tdelete result;\n\t\treturn rc;\n\t}\n\n\tif ( check_pending_timeout(command,buf) ) {\n\t\tsprintf( error_string, \"%s timed out\", command );\n\t\treturn GAHPCLIENT_COMMAND_TIMED_OUT;\n\t}\n\n\treturn GAHPCLIENT_COMMAND_PENDING;\n}\n",
        "target": 0
    },
    {
        "id": 3004,
        "func": "GtkWidget* webkit_web_view_new(void)\n{\n    WebKitWebView* webView = WEBKIT_WEB_VIEW(g_object_new(WEBKIT_TYPE_WEB_VIEW, NULL));\n\n    return GTK_WIDGET(webView);\n}\n",
        "target": 0
    },
    {
        "id": 3005,
        "func": "  tt_cmap10_validate( FT_Byte*      table,\n                      FT_Validator  valid )\n  {\n    FT_Byte*  p = table + 4;\n    FT_ULong  length, count;\n\n\n    if ( table + 20 > valid->limit )\n      FT_INVALID_TOO_SHORT;\n\n    length = TT_NEXT_ULONG( p );\n    p      = table + 16;\n    count  = TT_NEXT_ULONG( p );\n\n    if ( length > (FT_ULong)( valid->limit - table ) ||\n         /* length < 20 + count * 2 ? */\n         length < 20                                 ||\n         ( length - 20 ) / 2 < count                 )\n      FT_INVALID_TOO_SHORT;\n\n    /* check glyph indices */\n    if ( valid->level >= FT_VALIDATE_TIGHT )\n    {\n      FT_UInt  gindex;\n\n\n      for ( ; count > 0; count-- )\n      {\n        gindex = TT_NEXT_USHORT( p );\n        if ( gindex >= TT_VALID_GLYPH_COUNT( valid ) )\n          FT_INVALID_GLYPH_ID;\n      }\n    }\n\n    return FT_Err_Ok;\n  }\n",
        "target": 0
    },
    {
        "id": 3006,
        "func": " */\nu16 __skb_tx_hash(const struct net_device *dev, struct sk_buff *skb,\n\t\t  unsigned int num_tx_queues)\n{\n\tu32 hash;\n\tu16 qoffset = 0;\n\tu16 qcount = num_tx_queues;\n\n\tif (skb_rx_queue_recorded(skb)) {\n\t\thash = skb_get_rx_queue(skb);\n\t\twhile (unlikely(hash >= num_tx_queues))\n\t\t\thash -= num_tx_queues;\n\t\treturn hash;\n\t}\n\n\tif (dev->num_tc) {\n\t\tu8 tc = netdev_get_prio_tc_map(dev, skb->priority);\n\n\t\tqoffset = dev->tc_to_txq[tc].offset;\n\t\tqcount = dev->tc_to_txq[tc].count;\n\t}\n\n\treturn (u16) reciprocal_scale(skb_get_hash(skb), qcount) + qoffset;",
        "target": 0
    },
    {
        "id": 3007,
        "func": "bool SessionModelAssociator::UpdateAssociationsFromSyncModel(\n    const sync_api::ReadNode& root,\n    const sync_api::BaseTransaction* trans) {\n  DCHECK(CalledOnValidThread());\n\n  int64 id = root.GetFirstChildId();\n  while (id != sync_api::kInvalidId) {\n    sync_api::ReadNode sync_node(trans);\n    if (!sync_node.InitByIdLookup(id)) {\n      LOG(ERROR) << \"Failed to fetch sync node for id \" << id;\n      return false;\n    }\n \n     const sync_pb::SessionSpecifics& specifics =\n         sync_node.GetSessionSpecifics();\n    const base::Time& modification_time = sync_node.GetModificationTime();\n     if (specifics.session_tag() != GetCurrentMachineTag()) {\n       if (!AssociateForeignSpecifics(specifics, modification_time)) {\n         return false;\n      }\n    } else if (id != local_session_syncid_) {\n      if (specifics.has_header()) {\n        if (sync_api::kInvalidId != local_session_syncid_)\n          return false;\n\n        local_session_syncid_ = id;\n        if (specifics.header().has_client_name()) {\n          current_session_name_ = specifics.header().client_name();\n        }\n      } else {\n        if (!specifics.has_tab())\n          return false;\n\n        tab_pool_.AddTabNode(id);\n      }\n    }\n\n    id = sync_node.GetSuccessorId();\n  }\n\n  if (!tab_pool_.full())\n    return false;\n\n  return true;\n}\n",
        "target": 1
    },
    {
        "id": 3008,
        "func": "void PresentationConnection::send(DOMArrayBufferView* arrayBufferView,\n                                  ExceptionState& exceptionState) {\n  ASSERT(arrayBufferView);\n  if (!canSendMessage(exceptionState))\n    return;\n\n  m_messages.append(new Message(arrayBufferView->buffer()));\n  handleMessageQueue();\n}\n",
        "target": 0
    },
    {
        "id": 3009,
        "func": "static noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit **inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(BTRFS_I(dir)->root, dentry,\n\t\t\t\t      name, namelen, async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}",
        "target": 1
    },
    {
        "id": 3010,
        "func": "static int check_empty_slot(struct module *module, int slot)\n{\n\treturn !slots[slot] || !*slots[slot];\n}",
        "target": 0
    },
    {
        "id": 3011,
        "func": "void GLES2DecoderImpl::DoCompileShader(GLuint client_id) {\n  TRACE_EVENT0(\"gpu\", \"GLES2DecoderImpl::DoCompileShader\");\n  ShaderManager::ShaderInfo* info = GetShaderInfoNotProgram(\n      client_id, \"glCompileShader\");\n  if (!info) {\n    return;\n  }\n  const char* shader_src = info->source() ? info->source()->c_str() : \"\";\n  ShaderTranslator* translator = NULL;\n  if (use_shader_translator_) {\n    translator = info->shader_type() == GL_VERTEX_SHADER ?\n        vertex_translator_.get() : fragment_translator_.get();\n\n    if (!translator->Translate(shader_src)) {\n      info->SetStatus(false, translator->info_log(), NULL);\n      return;\n    }\n    shader_src = translator->translated_shader();\n    if (!feature_info_->feature_flags().angle_translated_shader_source)\n      info->UpdateTranslatedSource(shader_src);\n  }\n\n  glShaderSource(info->service_id(), 1, &shader_src, NULL);\n  glCompileShader(info->service_id());\n  if (feature_info_->feature_flags().angle_translated_shader_source) {\n    GLint max_len = 0;\n    glGetShaderiv(info->service_id(),\n                  GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE,\n                  &max_len);\n    scoped_array<char> temp(new char[max_len]);\n    GLint len = 0;\n    glGetTranslatedShaderSourceANGLE(\n        info->service_id(), max_len, &len, temp.get());\n    DCHECK(max_len == 0 || len < max_len);\n    DCHECK(len == 0 || temp[len] == '\\0');\n    info->UpdateTranslatedSource(temp.get());\n  }\n\n  GLint status = GL_FALSE;\n  glGetShaderiv(info->service_id(),  GL_COMPILE_STATUS, &status);\n  if (status) {\n    info->SetStatus(true, \"\", translator);\n  } else {\n    LOG_IF(ERROR, use_shader_translator_)\n        << \"Shader translator allowed/produced an invalid shader.\";\n    GLint max_len = 0;\n    glGetShaderiv(info->service_id(), GL_INFO_LOG_LENGTH, &max_len);\n    scoped_array<char> temp(new char[max_len]);\n    GLint len = 0;\n    glGetShaderInfoLog(info->service_id(), max_len, &len, temp.get());\n    DCHECK(max_len == 0 || len < max_len);\n    DCHECK(len == 0 || temp[len] == '\\0');\n    info->SetStatus(false, std::string(temp.get(), len).c_str(), NULL);\n  }\n};\n",
        "target": 0
    },
    {
        "id": 3012,
        "func": "void DocumentLoader::commitLoad(const char* data, int length)\n{\n    RefPtr<Frame> protectFrame(m_frame);\n    RefPtr<DocumentLoader> protectLoader(this);\n\n    commitIfReady();\n    FrameLoader* frameLoader = DocumentLoader::frameLoader();\n    if (!frameLoader)\n        return;\n#if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)\n    if (ArchiveFactory::isArchiveMimeType(response().mimeType()))\n        return;\n#endif\n    frameLoader->client()->committedLoad(this, data, length);\n}\n",
        "target": 0
    },
    {
        "id": 3013,
        "func": "PHP_FUNCTION(gethostbynamel)\n{\n\tchar *hostname;\n\tint hostname_len;\n\tstruct hostent *hp;\n\tstruct in_addr in;\n\tint i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &hostname, &hostname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\thp = gethostbyname(hostname);\n\tif (hp == NULL || hp->h_addr_list == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\tfor (i = 0 ; hp->h_addr_list[i] != 0 ; i++) {\n\t\tin = *(struct in_addr *) hp->h_addr_list[i];\n\t\tadd_next_index_string(return_value, inet_ntoa(in), 1);\n\t}\n}",
        "target": 0
    },
    {
        "id": 3014,
        "func": " void TouchEventConverterEvdev::OnFileCanReadWithoutBlocking(int fd) {\n   input_event inputs[kNumTouchEvdevSlots * 6 + 1];\n   ssize_t read_size = read(fd, inputs, sizeof(inputs));\n   if (read_size < 0) {\n    if (errno == EINTR || errno == EAGAIN)\n      return;\n    if (errno != ENODEV)\n      PLOG(ERROR) << \"error reading device \" << path_.value();\n    Stop();\n    return;\n  }\n\n  if (ignore_events_)\n    return;\n\n  for (unsigned i = 0; i < read_size / sizeof(*inputs); i++) {\n    if (!has_mt_) {\n      EmulateMultitouchEvent(inputs[i]);\n    }\n\n    ProcessMultitouchEvent(inputs[i]);\n  }\n}\n",
        "target": 1
    },
    {
        "id": 3015,
        "func": "int tls12_get_sigid(const EVP_PKEY *pk)\n{\n    return tls12_find_id(EVP_PKEY_id(pk), tls12_sig, OSSL_NELEM(tls12_sig));\n}\n",
        "target": 0
    },
    {
        "id": 3016,
        "func": "OMX_ERRORTYPE  omx_vdec::set_callbacks(OMX_IN OMX_HANDLETYPE        hComp,\n        OMX_IN OMX_CALLBACKTYPE* callbacks,\n        OMX_IN OMX_PTR             appData)\n{\n (void) hComp;\n    m_cb       = *callbacks;\n    DEBUG_PRINT_LOW(\"Callbacks Set %p %p %p\",m_cb.EmptyBufferDone,\\\n            m_cb.EventHandler,m_cb.FillBufferDone);\n    m_app_data =    appData;\n return OMX_ErrorNotImplemented;\n}\n",
        "target": 0
    },
    {
        "id": 3017,
        "func": "char **XListExtensions(\n    register Display *dpy,\n    int *nextensions)\t/* RETURN */\n{\n\txListExtensionsReply rep;\n\tchar **list = NULL;\n\tchar *ch = NULL;\n\tchar *chend;\n\tint count = 0;\n\tregister unsigned i;\n\tregister int length;\n\t_X_UNUSED register xReq *req;\n\tunsigned long rlen = 0;\n\n\tLockDisplay(dpy);\n\tGetEmptyReq (ListExtensions, req);\n\n\tif (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\n\tif (rep.nExtensions) {\n\t    list = Xmalloc (rep.nExtensions * sizeof (char *));\n\t    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t\trlen = rep.length << 2;\n\t\tch = Xmalloc (rlen + 1);\n                /* +1 to leave room for last null-terminator */\n\t    }\n\n\t    if ((!list) || (!ch)) {\n\t\tXfree(list);\n\t\tXfree(ch);\n\t\t_XEatDataWords(dpy, rep.length);\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn (char **) NULL;\n\t    }\n\n\t    _XReadPad (dpy, ch, rlen);\n\t    /*\n \t     * unpack into null terminated strings.\n \t     */\n \t    chend = ch + rlen;\n\t    length = *ch;\n \t    for (i = 0; i < rep.nExtensions; i++) {\n \t\tif (ch + length < chend) {\n \t\t    list[i] = ch+1;  /* skip over length */\n \t\t    ch += length + 1; /* find next length ... */\n\t\t    length = *ch;\n \t\t    *ch = '\\0'; /* and replace with null-termination */\n \t\t    count++;\n \t\t} else\n\t\t    list[i] = NULL;\n\t    }\n\t}\n\n\t*nextensions = count;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (list);\n}\n",
        "target": 1
    },
    {
        "id": 3018,
        "func": "asmlinkage void do_cpu(struct pt_regs *regs)\n{\n\tunsigned int __user *epc;\n\tunsigned long old_epc;\n\tunsigned int opcode;\n\tunsigned int cpid;\n\tint status;\n\tunsigned long __maybe_unused flags;\n\n\tdie_if_kernel(\"do_cpu invoked from kernel context!\", regs);\n\n\tcpid = (regs->cp0_cause >> CAUSEB_CE) & 3;\n\n\tswitch (cpid) {\n\tcase 0:\n\t\tepc = (unsigned int __user *)exception_epc(regs);\n\t\told_epc = regs->cp0_epc;\n\t\topcode = 0;\n\t\tstatus = -1;\n\n\t\tif (unlikely(compute_return_epc(regs) < 0))\n\t\t\treturn;\n\n\t\tif (unlikely(get_user(opcode, epc) < 0))\n\t\t\tstatus = SIGSEGV;\n\n\t\tif (!cpu_has_llsc && status < 0)\n\t\t\tstatus = simulate_llsc(regs, opcode);\n\n\t\tif (status < 0)\n\t\t\tstatus = simulate_rdhwr(regs, opcode);\n\n\t\tif (status < 0)\n\t\t\tstatus = SIGILL;\n\n\t\tif (unlikely(status > 0)) {\n\t\t\tregs->cp0_epc = old_epc;\t/* Undo skip-over.  */\n\t\t\tforce_sig(status, current);\n\t\t}\n\n\t\treturn;\n\n\tcase 1:\n\t\tif (used_math())\t/* Using the FPU again.  */\n\t\t\town_fpu(1);\n\t\telse {\t\t\t/* First time FPU user.  */\n\t\t\tinit_fpu();\n\t\t\tset_used_math();\n\t\t}\n\n\t\tif (!raw_cpu_has_fpu) {\n\t\t\tint sig;\n\t\t\tvoid __user *fault_addr = NULL;\n\t\t\tsig = fpu_emulator_cop1Handler(regs,\n\t\t\t\t\t\t       &current->thread.fpu,\n\t\t\t\t\t\t       0, &fault_addr);\n\t\t\tif (!process_fpemu_return(sig, fault_addr))\n\t\t\t\tmt_ase_fp_affinity();\n\t\t}\n\n\t\treturn;\n\n\tcase 2:\n\t\traw_notifier_call_chain(&cu2_chain, CU2_EXCEPTION, regs);\n\t\treturn;\n\n\tcase 3:\n\t\tbreak;\n\t}\n\n\tforce_sig(SIGILL, current);\n}",
        "target": 0
    },
    {
        "id": 3019,
        "func": "void Document::setReadyState(ReadyState readyState)\n{\n    if (readyState == m_readyState)\n        return;\n\n    switch (readyState) {\n    case Loading:\n        if (!m_documentTiming.domLoading) {\n            m_documentTiming.domLoading = monotonicallyIncreasingTime();\n            if (RuntimeEnabledFeatures::webAnimationsEnabled())\n                m_timeline->setZeroTimeAsPerfTime(m_documentTiming.domLoading);\n        }\n        break;\n    case Interactive:\n        if (!m_documentTiming.domInteractive)\n            m_documentTiming.domInteractive = monotonicallyIncreasingTime();\n        break;\n    case Complete:\n        if (!m_documentTiming.domComplete)\n            m_documentTiming.domComplete = monotonicallyIncreasingTime();\n        break;\n    }\n\n    m_readyState = readyState;\n    dispatchEvent(Event::create(EventTypeNames::readystatechange));\n}\n",
        "target": 0
    },
    {
        "id": 3020,
        "func": "static int __init perf_event_sysfs_init(void)\n{\n\tstruct pmu *pmu;\n\tint ret;\n\n\tmutex_lock(&pmus_lock);\n\n\tret = bus_register(&pmu_bus);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(pmu, &pmus, entry) {\n\t\tif (!pmu->name || pmu->type < 0)\n\t\t\tcontinue;\n\n\t\tret = pmu_dev_alloc(pmu);\n\t\tWARN(ret, \"Failed to register pmu: %s, reason %d\\n\", pmu->name, ret);\n\t}\n\tpmu_bus_running = 1;\n\tret = 0;\n\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 3021,
        "func": "     ~OffScreenRootWindow()\n     {\n         if (!--refCount) {\n#if PLATFORM(QT)\n            delete window;\n            window = 0;\n#elif PLATFORM(EFL)\n             XUnmapWindow(display, window);\n             XDestroyWindow(display, window);\n#endif\n         }\n     }\n",
        "target": 1
    },
    {
        "id": 3022,
        "func": "chunk_new_with_alloc_size(size_t alloc)\n{\n  chunk_t *ch;\n  ch = tor_malloc(alloc);\n  ch->next = NULL;\n  ch->datalen = 0;\n#ifdef DEBUG_CHUNK_ALLOC\n  ch->DBG_alloc = alloc;\n#endif\n  ch->memlen = CHUNK_SIZE_WITH_ALLOC(alloc);\n  total_bytes_allocated_in_chunks += alloc;\n  ch->data = &ch->mem[0];\n  return ch;\n}",
        "target": 1
    },
    {
        "id": 3023,
        "func": "void RenderFrameImpl::PepperCancelComposition(\n    PepperPluginInstanceImpl* instance) {\n  if (instance != focused_pepper_plugin_)\n    return;\n  if (mojom::WidgetInputHandlerHost* host = GetLocalRootRenderWidget()\n                                                ->widget_input_handler_manager()\n                                                ->GetWidgetInputHandlerHost()) {\n    host->ImeCancelComposition();\n  }\n#if defined(OS_MACOSX) || defined(USE_AURA)\n  GetLocalRootRenderWidget()->UpdateCompositionInfo(\n      false /* not an immediate request */);\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 3024,
        "func": "my_object_send_car (MyObject *obj, GValueArray *invals, GValueArray **outvals, GError **error)\n{\n  if (invals->n_values != 3\n      || G_VALUE_TYPE (g_value_array_get_nth (invals, 0)) != G_TYPE_STRING\n      || G_VALUE_TYPE (g_value_array_get_nth (invals, 1)) != G_TYPE_UINT\n      || G_VALUE_TYPE (g_value_array_get_nth (invals, 2)) != G_TYPE_VALUE)\n    {\n      g_set_error (error,\n\t\t   MY_OBJECT_ERROR,\n\t\t   MY_OBJECT_ERROR_FOO,\n\t\t   \"invalid incoming values\");\n      return FALSE;\n    }\n  *outvals = g_value_array_new (2);\n  g_value_array_append (*outvals, NULL);\n  g_value_init (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1), G_TYPE_UINT);\n  g_value_set_uint (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1),\n\t\t    g_value_get_uint (g_value_array_get_nth (invals, 1)) + 1);\n  g_value_array_append (*outvals, NULL);\n  g_value_init (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1), DBUS_TYPE_G_OBJECT_PATH);\n  g_value_set_boxed (g_value_array_get_nth (*outvals, (*outvals)->n_values - 1),\n\t\t     g_strdup (\"/org/freedesktop/DBus/GLib/Tests/MyTestObject2\"));\n  return TRUE;\n}\n",
        "target": 1
    },
    {
        "id": 3025,
        "func": "static void perf_iterate_sb_cpu(perf_iterate_f output, void *data)\n{\n\tstruct pmu_event_list *pel = this_cpu_ptr(&pmu_sb_events);\n\tstruct perf_event *event;\n\n\tlist_for_each_entry_rcu(event, &pel->list, sb_list) {\n\t\t/*\n\t\t * Skip events that are not fully formed yet; ensure that\n\t\t * if we observe event->ctx, both event and ctx will be\n\t\t * complete enough. See perf_install_in_context().\n\t\t */\n\t\tif (!smp_load_acquire(&event->ctx))\n\t\t\tcontinue;\n\n\t\tif (event->state < PERF_EVENT_STATE_INACTIVE)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\t\toutput(event, data);\n\t}\n}",
        "target": 0
    },
    {
        "id": 3026,
        "func": "static int dvb_usbv2_adapter_frontend_exit(struct dvb_usb_adapter *adap)\n{\n\tint ret, i;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\n\tdev_dbg(&d->udev->dev, \"%s: adap=%d\\n\", __func__, adap->id);\n\n\tfor (i = MAX_NO_OF_FE_PER_ADAP - 1; i >= 0; i--) {\n\t\tif (adap->fe[i]) {\n\t\t\tdvb_unregister_frontend(adap->fe[i]);\n\t\t\tdvb_frontend_detach(adap->fe[i]);\n\t\t}\n\t}\n\n\tif (d->props->tuner_detach) {\n\t\tret = d->props->tuner_detach(adap);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&d->udev->dev, \"%s: tuner_detach() failed=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t}\n\t}\n\n\tif (d->props->frontend_detach) {\n\t\tret = d->props->frontend_detach(adap);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&d->udev->dev,\n\t\t\t\t\t\"%s: frontend_detach() failed=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3027,
        "func": "void comps_rtree_print(COMPS_HSList * hl, unsigned  deep) {\n    COMPS_HSListItem * it;\n    for (it = hl->first; it != NULL; it=it->next) {\n        printf(\"%d %s\\n\",deep, (((COMPS_RTreeData*)it->data)->key));\n        comps_rtree_print(((COMPS_RTreeData*)it->data)->subnodes, deep+1);\n    }\n}",
        "target": 0
    },
    {
        "id": 3028,
        "func": "CIFSFindClose(const int xid, struct cifs_tcon *tcon,\n\t      const __u16 searchHandle)\n{\n\tint rc = 0;\n\tFINDCLOSE_REQ *pSMB = NULL;\n\n\tcFYI(1, \"In CIFSSMBFindClose\");\n\trc = small_smb_init(SMB_COM_FIND_CLOSE2, 1, tcon, (void **)&pSMB);\n\n\t/* no sense returning error if session restarted\n\t\tas file handle has been closed */\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = searchHandle;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (struct smb_hdr *) pSMB, 0);\n\tif (rc)\n\t\tcERROR(1, \"Send error in FindClose = %d\", rc);\n\n\tcifs_stats_inc(&tcon->num_fclose);\n\n\t/* Since session is dead, search handle closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
        "target": 0
    },
    {
        "id": 3029,
        "func": "parse_object(JsonLexContext *lex, JsonSemAction *sem)\n{\n\t/*\n\t * an object is a possibly empty sequence of object fields, separated by\n\t * commas and surrounded by curly braces.\n\t */\n\tjson_struct_action ostart = sem->object_start;\n    json_struct_action oend = sem->object_end;\n    JsonTokenType tok;\n \n    if (ostart != NULL)\n        (*ostart) (sem->semstate);\n \n\t * itself. Note that we increment this after we call the semantic routine\n\t * for the object start and restore it before we call the routine for the\n\t * object end.\n\t */\n\tlex->lex_level++;\n\n\t/* we know this will succeeed, just clearing the token */\n\tlex_expect(JSON_PARSE_OBJECT_START, lex, JSON_TOKEN_OBJECT_START);\n\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_STRING:\n\t\t\tparse_object_field(lex, sem);\n\t\t\twhile (lex_accept(lex, JSON_TOKEN_COMMA, NULL))\n\t\t\t\tparse_object_field(lex, sem);\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_OBJECT_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* case of an invalid initial token inside the object */\n\t\t\treport_parse_error(JSON_PARSE_OBJECT_START, lex);\n\t}\n\n\tlex_expect(JSON_PARSE_OBJECT_NEXT, lex, JSON_TOKEN_OBJECT_END);\n\n\tlex->lex_level--;\n\n\tif (oend != NULL)\n\t\t(*oend) (sem->semstate);\n}\n",
        "target": 1
    },
    {
        "id": 3030,
        "func": "void Clipboard::WriteText(const char* text_data, size_t text_len) {\n  char* data = new char[text_len];\n  memcpy(data, text_data, text_len);\n\n  InsertMapping(kMimeTypeText, data, text_len);\n  InsertMapping(\"TEXT\", data, text_len);\n  InsertMapping(\"STRING\", data, text_len);\n  InsertMapping(\"UTF8_STRING\", data, text_len);\n  InsertMapping(\"COMPOUND_TEXT\", data, text_len);\n}\n",
        "target": 0
    },
    {
        "id": 3031,
        "func": "void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\n\tfree(name);\n}",
        "target": 1
    },
    {
        "id": 3032,
        "func": "static int vfat_find(struct inode *dir, struct qstr *qname,\n\t\t     struct fat_slot_info *sinfo)\n{\n\tunsigned int len = vfat_striptail_len(qname);\n\tif (len == 0)\n\t\treturn -ENOENT;\n\treturn fat_search_long(dir, qname->name, len, sinfo);\n}",
        "target": 0
    },
    {
        "id": 3033,
        "func": "NPError WebPluginDelegatePepper::Device3DGetStateContext(\n    NPDeviceContext3D* context,\n    int32 state,\n    int32* value) {\n  return NPERR_GENERIC_ERROR;\n}\n",
        "target": 0
    },
    {
        "id": 3034,
        "func": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\t/* NOTE: BAD_SEQID means the server and client disagree about the\n\t\t * book-keeping w.r.t. state-changing operations\n\t\t * (OPEN/CLOSE/LOCK/LOCKU...)\n\t\t * It is actually a sign of a bug on the client or on the server.\n\t\t *\n\t\t * If we receive a BAD_SEQID error in the particular case of\n\t\t * doing an OPEN, we assume that nfs_increment_open_seqid() will\n\t\t * have unhashed the old state_owner for us, and that we can\n\t\t * therefore safely retry using a new one. We should still warn\n\t\t * the user though...\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * BAD_STATEID on OPEN means that the server cancelled our\n\t\t * state before it received the OPEN_CONFIRM.\n\t\t * Recover by retrying the request as per the discussion\n\t\t * on Page 181 of RFC3530.\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\t/* We must have found a delegation */\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}",
        "target": 1
    },
    {
        "id": 3035,
        "func": "map_possibly_volatile_file_to_real_on_write (GFile              *volatile_file,\n                                             GFileOutputStream  *stream,\n                                             GCancellable       *cancellable,\n                                             GError            **error)\n{\n    GFile *real_file = NULL;\n    GFileInfo *info = NULL;\n\n    info = g_file_output_stream_query_info (stream,\n                                            G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                                            G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE \",\"\n                                            G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                            cancellable,\n                                            error);\n    if (info == NULL)\n    {\n        return NULL;\n    }\n    else\n    {\n        gboolean is_volatile;\n\n        is_volatile = g_file_info_get_attribute_boolean (info,\n                                                         G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE);\n        if (is_volatile)\n        {\n            const gchar *target;\n\n            target = g_file_info_get_symlink_target (info);\n            real_file = g_file_resolve_relative_path (volatile_file, target);\n        }\n    }\n\n    g_object_unref (info);\n\n    if (real_file == NULL)\n    {\n        real_file = g_object_ref (volatile_file);\n    }\n\n    return real_file;\n}",
        "target": 0
    },
    {
        "id": 3036,
        "func": "sp<MetaData> CameraSource::getFormat() {\n return mMeta;\n}\n",
        "target": 0
    },
    {
        "id": 3037,
        "func": "  InputMethodIBus* input_method() const { return input_method_; }\n",
        "target": 0
    },
    {
        "id": 3038,
        "func": "void RenderWidgetHostImpl::AccessibilitySetTextSelection(\n    int object_id, int start_offset, int end_offset) {\n  Send(new AccessibilityMsg_SetTextSelection(\n      GetRoutingID(), object_id, start_offset, end_offset));\n}\n",
        "target": 0
    },
    {
        "id": 3039,
        "func": "static __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}\n",
        "target": 0
    },
    {
        "id": 3040,
        "func": "  FakePacketTransport(quic::QuicAlarmFactory* alarm_factory,\n                      quic::MockClock* clock)\n      : alarm_(alarm_factory->CreateAlarm(new AlarmDelegate(this))),\n        clock_(clock) {}\n",
        "target": 0
    },
    {
        "id": 3041,
        "func": "log2vis_utf8 (PyObject * string, int unicode_length,\n\t      FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tFriBidiChar *logical = NULL; /* input fribidi unicode buffer */\n\tFriBidiChar *visual = NULL;\t /* output fribidi unicode buffer */\n\tchar *visual_utf8 = NULL;    /* output fribidi UTF-8 buffer */\n\tFriBidiStrIndex new_len = 0; /* length of the UTF-8 buffer */\n\tPyObject *result = NULL;\t /* failure */\n\n\t/* Allocate fribidi unicode buffers */\n\n\tlogical = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (logical == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\n\tvisual = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (visual == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Convert to unicode and order visually */\n\tfribidi_set_reorder_nsm(reordernsm);\n\tfribidi_utf8_to_unicode (PyString_AS_STRING (string),\n\t\t\t\t PyString_GET_SIZE (string), logical);\n\n\tif (!fribidi_log2vis (logical, unicode_length, &base_direction, visual,\n\t\t\t      NULL, NULL, NULL))\n\t{\n\t\tPyErr_SetString (PyExc_RuntimeError,\n\t\t\t\t \"fribidi failed to order string\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Cleanup the string if requested */\n\tif (clean)\n\t\tfribidi_remove_bidi_marks (visual, unicode_length, NULL, NULL, NULL);\n\n\t/* Allocate fribidi UTF-8 buffer */\n\n\tvisual_utf8 = PyMem_New(char, (unicode_length * 4)+1);\n\tif (visual_utf8 == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t\"failed to allocate UTF-8 buffer\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Encode the reordered string  and create result string */\n\n\tnew_len = fribidi_unicode_to_utf8 (visual, unicode_length, visual_utf8);\n\n\tresult = PyString_FromStringAndSize (visual_utf8, new_len);\n\tif (result == NULL)\n\t\t/* XXX does it raise any error? */\n\t\tgoto cleanup;\n\n      cleanup:\n\t/* Delete unicode buffers */\n\tPyMem_Del (logical);\n\tPyMem_Del (visual);\n\tPyMem_Del (visual_utf8);\n\n\treturn result;\n}",
        "target": 1
    },
    {
        "id": 3042,
        "func": "void XMLHttpRequest::send(Blob* body, ExceptionState& es)\n{\n    if (!initSend(es))\n        return;\n\n    if (areMethodAndURLValidForSend()) {\n        const String& contentType = getRequestHeader(\"Content-Type\");\n        if (contentType.isEmpty()) {\n            const String& blobType = body->type();\n            if (!blobType.isEmpty() && isValidContentType(blobType))\n                setRequestHeaderInternal(\"Content-Type\", blobType);\n            else {\n                setRequestHeaderInternal(\"Content-Type\", \"\");\n            }\n        }\n\n        m_requestEntityBody = FormData::create();\n        if (body->isFile())\n            m_requestEntityBody->appendFile(toFile(body)->path());\n        else\n            m_requestEntityBody->appendBlob(body->url());\n    }\n\n    createRequest(es);\n}\n",
        "target": 0
    },
    {
        "id": 3043,
        "func": " float AudioParam::finalValue()\n {\n    float value;\n     calculateFinalValues(&value, 1, false);\n     return value;\n }\n",
        "target": 1
    },
    {
        "id": 3044,
        "func": "bool PermissionsData::HasEffectiveAccessToAllHosts() const {\n  base::AutoLock auto_lock(runtime_lock_);\n  return active_permissions_unsafe_->HasEffectiveAccessToAllHosts();\n}\n",
        "target": 0
    },
    {
        "id": 3045,
        "func": " bool RenderWidgetHostViewAndroid::HasAcceleratedSurface(\n     const gfx::Size& desired_size) {\n   NOTREACHED();\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 3046,
        "func": "Node* WebPagePrivate::bestNodeForZoomUnderPoint(const IntPoint& documentPoint)\n{\n    IntRect clickRect(documentPoint.x() - blockClickRadius, documentPoint.y() - blockClickRadius, 2 * blockClickRadius, 2 * blockClickRadius);\n    Node* originalNode = nodeForZoomUnderPoint(documentPoint);\n    if (!originalNode)\n        return 0;\n    Node* node = bestChildNodeForClickRect(originalNode, clickRect);\n    return node ? adjustedBlockZoomNodeForZoomAndExpandingRatioLimits(node) : adjustedBlockZoomNodeForZoomAndExpandingRatioLimits(originalNode);\n}\n",
        "target": 0
    },
    {
        "id": 3047,
        "func": "set_str_utf16be(struct archive_write *a, unsigned char *p, const char *s,\n    size_t l, uint16_t uf, enum vdc vdc)\n{\n\tsize_t size, i;\n\tint onepad;\n\n\tif (s == NULL)\n\t\ts = \"\";\n\tif (l & 0x01) {\n\t\tonepad = 1;\n\t\tl &= ~1;\n\t} else\n\t\tonepad = 0;\n\tif (vdc == VDC_UCS2) {\n\t\tstruct iso9660 *iso9660 = a->format_data;\n\t\tif (archive_strncpy_l(&iso9660->utf16be, s, strlen(s),\n\t\t    iso9660->sconv_to_utf16be) != 0 && errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for UTF-16BE\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tsize = iso9660->utf16be.length;\n\t\tif (size > l)\n\t\t\tsize = l;\n\t\tmemcpy(p, iso9660->utf16be.s, size);\n\t} else {\n\t\tconst uint16_t *u16 = (const uint16_t *)s;\n\n\t\tsize = 0;\n\t\twhile (*u16++)\n\t\t\tsize += 2;\n\t\tif (size > l)\n\t\t\tsize = l;\n\t\tmemcpy(p, s, size);\n\t}\n\tfor (i = 0; i < size; i += 2, p += 2) {\n\t\tif (!joliet_allowed_char(p[0], p[1]))\n\t\t\tarchive_be16enc(p, 0x005F);/* '_' */\n\t}\n\tl -= size;\n\twhile (l > 0) {\n\t\tarchive_be16enc(p, uf);\n\t\tp += 2;\n\t\tl -= 2;\n\t}\n\tif (onepad)\n\t\t*p = 0;\n\treturn (ARCHIVE_OK);\n}\n",
        "target": 0
    },
    {
        "id": 3048,
        "func": "static void init_all_refs_cb(struct all_refs_cb *cb, struct rev_info *revs,\n\tunsigned flags)\n{\n\tcb->all_revs = revs;\n\tcb->all_flags = flags;\n}",
        "target": 0
    },
    {
        "id": 3049,
        "func": "void WebMediaPlayerImpl::Paint(cc::PaintCanvas* canvas,\n                               const blink::WebRect& rect,\n                               cc::PaintFlags& flags,\n                               int already_uploaded_id,\n                               VideoFrameUploadMetadata* out_metadata) {\n  DCHECK(main_task_runner_->BelongsToCurrentThread());\n  TRACE_EVENT0(\"media\", \"WebMediaPlayerImpl:paint\");\n\n  if (cdm_context_ref_)\n    return;\n\n  scoped_refptr<VideoFrame> video_frame = GetCurrentFrameFromCompositor();\n\n  gfx::Rect gfx_rect(rect);\n  Context3D context_3d;\n  if (video_frame.get() && video_frame->HasTextures()) {\n    if (context_provider_) {\n      context_3d = Context3D(context_provider_->ContextGL(),\n                             context_provider_->GrContext());\n    }\n    if (!context_3d.gl)\n      return;  // Unable to get/create a shared main thread context.\n    if (!context_3d.gr_context)\n      return;  // The context has been lost since and can't setup a GrContext.\n  }\n  if (out_metadata && video_frame) {\n    ComputeFrameUploadMetadata(video_frame.get(), already_uploaded_id,\n                               out_metadata);\n    if (out_metadata->skipped) {\n      return;\n    }\n  }\n  video_renderer_.Paint(\n      video_frame, canvas, gfx::RectF(gfx_rect), flags,\n      pipeline_metadata_.video_decoder_config.video_rotation(), context_3d);\n}\n",
        "target": 0
    },
    {
        "id": 3050,
        "func": " std::string MasterPreferences::GetCompressedVariationsSeed() const {\n  return ExtractPrefString(prefs::kVariationsCompressedSeed);\n }\n",
        "target": 1
    },
    {
        "id": 3051,
        "func": "static bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n",
        "target": 0
    },
    {
        "id": 3052,
        "func": "net::HttpAuthHandlerFactory* IOThread::CreateDefaultAuthHandlerFactory(\n    net::HostResolver* resolver) {\n  net::HttpAuthFilterWhitelist* auth_filter_default_credentials = NULL;\n  if (!auth_server_whitelist_.empty()) {\n    auth_filter_default_credentials =\n        new net::HttpAuthFilterWhitelist(auth_server_whitelist_);\n  }\n  net::HttpAuthFilterWhitelist* auth_filter_delegate = NULL;\n  if (!auth_delegate_whitelist_.empty()) {\n    auth_filter_delegate =\n        new net::HttpAuthFilterWhitelist(auth_delegate_whitelist_);\n  }\n  globals_->url_security_manager.reset(\n      net::URLSecurityManager::Create(auth_filter_default_credentials,\n                                      auth_filter_delegate));\n  std::vector<std::string> supported_schemes;\n  base::SplitString(auth_schemes_, ',', &supported_schemes);\n\n  scoped_ptr<net::HttpAuthHandlerRegistryFactory> registry_factory(\n      net::HttpAuthHandlerRegistryFactory::Create(\n          supported_schemes, globals_->url_security_manager.get(),\n          resolver, gssapi_library_name_, negotiate_disable_cname_lookup_,\n          negotiate_enable_port_));\n\n  if (!spdyproxy_auth_origins_.empty()) {\n    registry_factory->RegisterSchemeFactory(\n        \"spdyproxy\",\n        new spdyproxy::HttpAuthHandlerSpdyProxy::Factory(\n            spdyproxy_auth_origins_));\n  }\n\n  return registry_factory.release();\n}\n",
        "target": 0
    },
    {
        "id": 3053,
        "func": "  void ExpectSyncedAndDeleted() {\n    EXPECT_EQ(metahandle_, GetMetahandleOfTag());\n    EXPECT_TRUE(Get(metahandle_, IS_DEL));\n    EXPECT_TRUE(Get(metahandle_, SERVER_IS_DEL));\n    EXPECT_FALSE(Get(metahandle_, IS_UNSYNCED));\n    EXPECT_FALSE(Get(metahandle_, IS_UNAPPLIED_UPDATE));\n    EXPECT_GE(0, Get(metahandle_, BASE_VERSION));\n    EXPECT_GE(0, Get(metahandle_, SERVER_VERSION));\n  }\n",
        "target": 0
    },
    {
        "id": 3054,
        "func": "void TabStripGtk::SetVerticalOffset(int offset) {\n  tab_vertical_offset_ = offset;\n  Layout();\n}\n",
        "target": 0
    },
    {
        "id": 3055,
        "func": "static asocket* create_host_service_socket(const char* name, const char* serial) {\n    asocket* s;\n\n    s = host_service_to_socket(name, serial);\n\n if (s != NULL) {\n        D(\"LS(%d) bound to '%s'\", s->id, name);\n return s;\n }\n\n return s;\n}\n",
        "target": 0
    },
    {
        "id": 3056,
        "func": "void BluetoothDeviceChromeOS::Release() {\n  DCHECK(agent_.get());\n  DCHECK(pairing_delegate_);\n  VLOG(1) << object_path_.value() << \": Release\";\n  pincode_callback_.Reset();\n  passkey_callback_.Reset();\n  confirmation_callback_.Reset();\n  UnregisterAgent();\n}\n",
        "target": 1
    },
    {
        "id": 3057,
        "func": "void PasswordAccessoryControllerImpl::OnAutomaticGenerationStatusChanged(\n    bool available,\n    const base::Optional<\n        autofill::password_generation::PasswordGenerationUIData>& ui_data,\n    const base::WeakPtr<password_manager::PasswordManagerDriver>& driver) {\n  target_frame_driver_ = driver;\n  if (available) {\n    DCHECK(ui_data.has_value());\n    generation_element_data_ = std::make_unique<GenerationElementData>(\n        ui_data.value().password_form,\n        autofill::CalculateFormSignature(\n            ui_data.value().password_form.form_data),\n        autofill::CalculateFieldSignatureByNameAndType(\n            ui_data.value().generation_element, \"password\"),\n        ui_data.value().max_length);\n  } else {\n    generation_element_data_.reset();\n  }\n  GetManualFillingController()->OnAutomaticGenerationStatusChanged(available);\n}\n",
        "target": 1
    },
    {
        "id": 3058,
        "func": "png_handle_IEND(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)\n{\n   png_debug(1, \"in png_handle_IEND\");\n\n   if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT))\n   {\n      png_error(png_ptr, \"No image in file\");\n   }\n\n   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);\n\n   if (length != 0)\n   {\n      png_warning(png_ptr, \"Incorrect IEND chunk length\");\n   }\n   png_crc_finish(png_ptr, length);\n\n   info_ptr = info_ptr; /* Quiet compiler warnings about unused info_ptr */\n}\n",
        "target": 0
    },
    {
        "id": 3059,
        "func": "int find_camera_metadata_ro_entry(const camera_metadata_t *src,\n uint32_t tag,\n camera_metadata_ro_entry_t *entry) {\n return find_camera_metadata_entry((camera_metadata_t*)src, tag,\n (camera_metadata_entry_t*)entry);\n}\n",
        "target": 0
    },
    {
        "id": 3060,
        "func": "bool SiteInstanceImpl::DoesSiteRequireDedicatedProcess(\n    BrowserContext* browser_context,\n    const GURL& url) {\n   if (SiteIsolationPolicy::UseDedicatedProcessesForAllSites())\n     return true;\n \n  // Always require a dedicated process for isolated origins.\n  GURL site_url = SiteInstance::GetSiteForURL(browser_context, url);\n  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();\n  if (policy->IsIsolatedOrigin(url::Origin::Create(site_url)))\n    return true;\n\n  if (site_url.SchemeIs(kChromeErrorScheme))\n     return true;\n \n  // Isolate kChromeUIScheme pages from one another and from other kinds of\n  // schemes.\n  if (site_url.SchemeIs(content::kChromeUIScheme))\n     return true;\n \n  if (GetContentClient()->browser()->DoesSiteRequireDedicatedProcess(\n          browser_context, site_url)) {\n    return true;\n  }\n\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 3061,
        "func": "BaseMultipleFieldsDateAndTimeInputType::~BaseMultipleFieldsDateAndTimeInputType()\n{\n    if (m_spinButtonElement)\n        m_spinButtonElement->removeSpinButtonOwner();\n    if (m_clearButton)\n        m_clearButton->removeClearButtonOwner();\n    if (m_dateTimeEditElement)\n        m_dateTimeEditElement->removeEditControlOwner();\n    if (m_pickerIndicatorElement)\n        m_pickerIndicatorElement->removePickerIndicatorOwner();\n}\n",
        "target": 0
    },
    {
        "id": 3062,
        "func": "void PageHandler::Wire(UberDispatcher* dispatcher) {\n  frontend_.reset(new Page::Frontend(dispatcher->channel()));\n  Page::Dispatcher::wire(dispatcher, this);\n}\n",
        "target": 0
    },
    {
        "id": 3063,
        "func": "aura::Window* Shell::GetAppListWindow() {\n  return app_list_controller_.get() ? app_list_controller_->GetWindow()\n                                    : nullptr;\n}\n",
        "target": 0
    },
    {
        "id": 3064,
        "func": "static int sched_autogroup_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_autogroup_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3065,
        "func": "const KURL& FrameFetchContext::Url() const {\n  if (IsDetached())\n    return frozen_state_->url;\n  if (!document_)\n    return NullURL();\n  return document_->Url();\n}\n",
        "target": 0
    },
    {
        "id": 3066,
        "func": "void WebPluginImpl::didFinishLoading() {\n  delegate_->DidFinishManualLoading();\n}\n",
        "target": 0
    },
    {
        "id": 3067,
        "func": "BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\n\t\tstream_read_UINT16(s, len); /* 0x10 */\n\t\tstream_read_BYTE(s, version); /* 0x1 */\n\t\tstream_read_BYTE(s, pad);\n\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t/* signature */\n\n\t\tlength -= 12;\n\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; /* TODO */\n\t\t}\n\n\t\t/* is this what needs adjusting? */\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tsecurity_decrypt(s->p, length, rdp);\n\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t\t/*\n\t\t * Because Standard RDP Security is totally broken,\n\t\t * and cannot protect against MITM, don't treat signature\n\t\t * verification failure as critical. This at least enables\n\t\t * us to work with broken RDP clients and servers that\n\t\t * generate invalid signatures.\n\t\t */\n\t\t//return FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "target": 1
    },
    {
        "id": 3068,
        "func": "void RenderThreadImpl::ScheduleIdleHandler(int64 initial_delay_ms) {\n  idle_notification_delay_in_ms_ = initial_delay_ms;\n  idle_timer_.Stop();\n  idle_timer_.Start(FROM_HERE,\n      base::TimeDelta::FromMilliseconds(initial_delay_ms),\n      this, &RenderThreadImpl::IdleHandler);\n}\n",
        "target": 0
    },
    {
        "id": 3069,
        "func": "void BrowserView::FocusAppMenu() {\n  if (toolbar_->IsAppMenuFocused()) {\n    RestoreFocus();\n  } else {\n    toolbar_->SetPaneFocusAndFocusAppMenu();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3070,
        "func": "void RenderFrameImpl::OnSelectPopupMenuItem(int selected_index) {\n  if (external_popup_menu_ == NULL)\n     return;\n \n   blink::WebScopedUserGesture gesture(frame_);\n  external_popup_menu_->DidSelectItem(selected_index);\n  external_popup_menu_.reset();\n }\n",
        "target": 1
    },
    {
        "id": 3071,
        "func": "static int magicmouse_input_mapping(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\n\tif (!msc->input)\n\t\tmsc->input = hi->input;\n\n\t/* Magic Trackpad does not give relative data after switching to MT */\n\tif (hi->input->id.product == USB_DEVICE_ID_APPLE_MAGICTRACKPAD &&\n\t    field->flags & HID_MAIN_ITEM_RELATIVE)\n\t\treturn -1;\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3072,
        "func": "int generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3073,
        "func": "RenderProcessHost* RenderProcessHostImpl::GetDefaultSubframeProcessHost(\n    BrowserContext* browser_context,\n    SiteInstanceImpl* site_instance,\n    bool is_for_guests_only) {\n  DefaultSubframeProcessHostHolder* holder =\n      static_cast<DefaultSubframeProcessHostHolder*>(\n          browser_context->GetUserData(&kDefaultSubframeProcessHostHolderKey));\n  if (!holder) {\n    holder = new DefaultSubframeProcessHostHolder(browser_context);\n    browser_context->SetUserData(kDefaultSubframeProcessHostHolderKey,\n                                 base::WrapUnique(holder));\n  }\n\n  return holder->GetProcessHost(site_instance, is_for_guests_only);\n}\n",
        "target": 0
    },
    {
        "id": 3074,
        "func": "void RenderViewImpl::showContextMenu(\n    WebFrame* frame, const WebContextMenuData& data) {\n  ContextMenuParams params(data);\n\n  string16 selection_text;\n  if (!selection_text_.empty() && !selection_range_.is_empty()) {\n    const int start = selection_range_.GetMin() - selection_text_offset_;\n    const size_t length = selection_range_.length();\n    if (start >= 0 && start + length <= selection_text_.length())\n      selection_text = selection_text_.substr(start, length);\n  }\n  if (params.selection_text != selection_text) {\n    selection_text_ = params.selection_text;\n    selection_text_offset_ = 0;\n    selection_range_ = ui::Range(0, selection_text_.length());\n    Send(new ViewHostMsg_SelectionChanged(routing_id_,\n                                          selection_text_,\n                                          selection_text_offset_,\n                                          selection_range_));\n  }\n\n  if (frame)\n    params.frame_id = frame->identifier();\n\n  if (params.src_url.spec().size() > kMaxURLChars)\n    params.src_url = GURL();\n  context_menu_node_ = data.node;\n\n#if defined(OS_ANDROID)\n  gfx::Rect start_rect;\n  gfx::Rect end_rect;\n  GetSelectionBounds(&start_rect, &end_rect);\n  params.selection_start =\n      gfx::Point(start_rect.x(), start_rect.bottom()) + GetScrollOffset();\n  params.selection_end =\n      gfx::Point(end_rect.right(), end_rect.bottom()) + GetScrollOffset();\n#endif\n\n  Send(new ViewHostMsg_ContextMenu(routing_id_, params));\n\n  FOR_EACH_OBSERVER(\n      RenderViewObserver, observers_, DidRequestShowContextMenu(frame, data));\n}\n",
        "target": 0
    },
    {
        "id": 3075,
        "func": "  void UntrackOriginOnIDBThread(const url::Origin& origin) {\n    DCHECK(context_->TaskRunner()->RunsTasksInCurrentSequence());\n    origins_.erase(origin);\n  }\n",
        "target": 0
    },
    {
        "id": 3076,
        "func": "static void intel_pmu_pebs_disable_all(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tif (cpuc->pebs_enabled)\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n}",
        "target": 0
    },
    {
        "id": 3077,
        "func": "static unsigned int CRC32(const unsigned char *message,const size_t length)\n{\n  register ssize_t\n    i;\n\n  static MagickBooleanType\n    crc_initial = MagickFalse;\n\n  static unsigned int\n    crc_xor[256];\n\n  unsigned int\n    crc;\n\n  /*\n    Generate a 32-bit cyclic redundancy check for the message.\n  */\n  if (crc_initial == MagickFalse)\n    {\n      register unsigned int\n        i;\n\n      unsigned int\n        alpha;\n\n      for (i=0; i < 256; i++)\n      {\n        register ssize_t\n          j;\n\n        alpha=i;\n        for (j=0; j < 8; j++)\n          alpha=(alpha & 0x01) ? (0xEDB88320 ^ (alpha >> 1)) : (alpha >> 1);\n        crc_xor[i]=alpha;\n      }\n      crc_initial=MagickTrue;\n    }\n  crc=0xFFFFFFFF;\n  for (i=0; i < (ssize_t) length; i++)\n    crc=crc_xor[(crc ^ message[i]) & 0xff] ^ (crc >> 8);\n  return(crc ^ 0xFFFFFFFF);\n}",
        "target": 0
    },
    {
        "id": 3078,
        "func": "static void tcp_v4_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\tsk_rcv_saddr_set(req_to_sk(req), ip_hdr(skb)->daddr);\n\tsk_daddr_set(req_to_sk(req), ip_hdr(skb)->saddr);\n\tireq->opt = tcp_v4_save_options(skb);\n}",
        "target": 0
    },
    {
        "id": 3079,
        "func": "static inline bool should_fail_request(struct hd_struct *part,\n\t\t\t\t\tunsigned int bytes)\n{\n\treturn false;\n}",
        "target": 0
    },
    {
        "id": 3080,
        "func": "void server_connect_own_ip_save(SERVER_CONNECT_REC *conn,\n\t\t\t\tIPADDR *ip4, IPADDR *ip6)\n{\n\tif (ip4 == NULL || ip4->family == 0)\n\t\tg_free_and_null(conn->own_ip4);\n\tif (ip6 == NULL || ip6->family == 0)\n\t\tg_free_and_null(conn->own_ip6);\n\n\tif (ip4 != NULL && ip4->family != 0) {\n\t\t/* IPv4 address was found */\n\t\tif (conn->own_ip4 == NULL)\n\t\t\tconn->own_ip4 = g_new0(IPADDR, 1);\n\t\tmemcpy(conn->own_ip4, ip4, sizeof(IPADDR));\n\t}\n\n\tif (ip6 != NULL && ip6->family != 0) {\n\t\t/* IPv6 address was found */\n\t\tif (conn->own_ip6 == NULL)\n\t\t\tconn->own_ip6 = g_new0(IPADDR, 1);\n\t\tmemcpy(conn->own_ip6, ip6, sizeof(IPADDR));\n\t}\n}",
        "target": 0
    },
    {
        "id": 3081,
        "func": "static void sock_def_destruct(struct sock *sk)\n{\n}",
        "target": 0
    },
    {
        "id": 3082,
        "func": "AXObject* AXLayoutObject::accessibilityImageMapHitTest(\n    HTMLAreaElement* area,\n    const IntPoint& point) const {\n  if (!area)\n    return 0;\n\n  AXObject* parent = axObjectCache().getOrCreate(area->imageElement());\n  if (!parent)\n    return 0;\n\n  for (const auto& child : parent->children()) {\n    if (child->getBoundsInFrameCoordinates().contains(point))\n      return child.get();\n  }\n\n  return 0;\n}\n",
        "target": 0
    },
    {
        "id": 3083,
        "func": "void Browser::RequestMediaAccessPermission(\n    content::WebContents* web_contents,\n    const content::MediaStreamRequest& request,\n    const content::MediaResponseCallback& callback) {\n  ::RequestMediaAccessPermission(web_contents, profile_, request, callback);\n}\n",
        "target": 0
    },
    {
        "id": 3084,
        "func": "bool IsChromeBrowserPresent() {\n  return IsProductInstalled(USER_LEVEL_INSTALLATION, kBrowserAppGuid) ||\n      IsProductInstalled(SYSTEM_LEVEL_INSTALLATION, kBrowserAppGuid);\n}\n",
        "target": 0
    },
    {
        "id": 3085,
        "func": "void ServiceWorkerDevToolsAgentHost::Reload() {\n}\n",
        "target": 0
    },
    {
        "id": 3086,
        "func": "TabContentsWrapper* Browser::GetSelectedTabContentsWrapper() const {\n  return tabstrip_model()->GetActiveTabContents();\n}\n",
        "target": 0
    },
    {
        "id": 3087,
        "func": "static int dccp_init_net(struct net *net, u_int16_t proto)\n{\n\tstruct dccp_net *dn = dccp_pernet(net);\n\tstruct nf_proto_net *pn = &dn->pn;\n\n\tif (!pn->users) {\n\t\t/* default values */\n\t\tdn->dccp_loose = 1;\n\t\tdn->dccp_timeout[CT_DCCP_REQUEST]\t= 2 * DCCP_MSL;\n\t\tdn->dccp_timeout[CT_DCCP_RESPOND]\t= 4 * DCCP_MSL;\n\t\tdn->dccp_timeout[CT_DCCP_PARTOPEN]\t= 4 * DCCP_MSL;\n\t\tdn->dccp_timeout[CT_DCCP_OPEN]\t\t= 12 * 3600 * HZ;\n\t\tdn->dccp_timeout[CT_DCCP_CLOSEREQ]\t= 64 * HZ;\n\t\tdn->dccp_timeout[CT_DCCP_CLOSING]\t= 64 * HZ;\n\t\tdn->dccp_timeout[CT_DCCP_TIMEWAIT]\t= 2 * DCCP_MSL;\n\t}\n\n\treturn dccp_kmemdup_sysctl_table(net, pn, dn);\n}",
        "target": 0
    },
    {
        "id": 3088,
        "func": " PrintDialogGtk::~PrintDialogGtk() {\n }\n",
        "target": 1
    },
    {
        "id": 3089,
        "func": "bool SQLiteDatabase::TableExists(const String& tablename) {\n  if (!IsOpen())\n    return false;\n\n  String statement =\n      \"SELECT name FROM sqlite_master WHERE type = 'table' AND name = '\" +\n      tablename + \"';\";\n\n  SQLiteStatement sql(*this, statement);\n  sql.Prepare();\n  return sql.Step() == SQLITE_ROW;\n}\n",
        "target": 0
    },
    {
        "id": 3090,
        "func": "bool AppCacheDatabase::FindEntriesForUrl(\n    const GURL& url, std::vector<EntryRecord>* records) {\n  DCHECK(records && records->empty());\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, url, flags, response_id, response_size, padding_size \"\n      \"FROM Entries\"\n       \"  WHERE url = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindString(0, url.spec());\n\n  while (statement.Step()) {\n    records->push_back(EntryRecord());\n    ReadEntryRecord(statement, &records->back());\n    DCHECK(records->back().url == url);\n  }\n\n  return statement.Succeeded();\n}\n",
        "target": 0
    },
    {
        "id": 3091,
        "func": "static int QDECL paksort( const void *a, const void *b ) {\n\tchar\t*aa, *bb;\n\n\taa = *(char **)a;\n\tbb = *(char **)b;\n\n\treturn FS_PathCmp( aa, bb );\n}\n",
        "target": 0
    },
    {
        "id": 3092,
        "func": "static void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}\n",
        "target": 0
    },
    {
        "id": 3093,
        "func": "RenderFlexibleBox::RenderFlexibleBox(Element* element)\n    : RenderBlock(element)\n    , m_orderIterator(this)\n    , m_numberOfInFlowChildrenOnFirstLine(-1)\n{\n    setChildrenInline(false); // All of our children must be block-level.\n}\n",
        "target": 0
    },
    {
        "id": 3094,
        "func": "static void tg3_setup_rxbd_thresholds(struct tg3 *tp)\n{\n\tu32 val, bdcache_maxcnt, host_rep_thresh, nic_rep_thresh;\n\n\tif (!tg3_flag(tp, 5750_PLUS) ||\n\t    tg3_flag(tp, 5780_CLASS) ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5750 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5752 ||\n\t    tg3_flag(tp, 57765_PLUS))\n\t\tbdcache_maxcnt = TG3_SRAM_RX_STD_BDCACHE_SIZE_5700;\n\telse if (tg3_asic_rev(tp) == ASIC_REV_5755 ||\n\t\t tg3_asic_rev(tp) == ASIC_REV_5787)\n\t\tbdcache_maxcnt = TG3_SRAM_RX_STD_BDCACHE_SIZE_5755;\n\telse\n\t\tbdcache_maxcnt = TG3_SRAM_RX_STD_BDCACHE_SIZE_5906;\n\n\tnic_rep_thresh = min(bdcache_maxcnt / 2, tp->rx_std_max_post);\n\thost_rep_thresh = max_t(u32, tp->rx_pending / 8, 1);\n\n\tval = min(nic_rep_thresh, host_rep_thresh);\n\ttw32(RCVBDI_STD_THRESH, val);\n\n\tif (tg3_flag(tp, 57765_PLUS))\n\t\ttw32(STD_REPLENISH_LWM, bdcache_maxcnt);\n\n\tif (!tg3_flag(tp, JUMBO_CAPABLE) || tg3_flag(tp, 5780_CLASS))\n\t\treturn;\n\n\tbdcache_maxcnt = TG3_SRAM_RX_JMB_BDCACHE_SIZE_5700;\n\n\thost_rep_thresh = max_t(u32, tp->rx_jumbo_pending / 8, 1);\n\n\tval = min(bdcache_maxcnt / 2, host_rep_thresh);\n\ttw32(RCVBDI_JUMBO_THRESH, val);\n\n\tif (tg3_flag(tp, 57765_PLUS))\n\t\ttw32(JMB_REPLENISH_LWM, bdcache_maxcnt);\n}",
        "target": 0
    },
    {
        "id": 3095,
        "func": "void reactor_stop(reactor_t *reactor) {\n  assert(reactor != NULL);\n\n  eventfd_write(reactor->event_fd, EVENT_REACTOR_STOP);\n}\n",
        "target": 0
    },
    {
        "id": 3096,
        "func": "xsltCompileLocationPathPattern(xsltParserContextPtr ctxt, int novar) {\n    SKIP_BLANKS;\n    if ((CUR == '/') && (NXT(1) == '/')) {\n\t/*\n\t * since we reverse the query\n\t * a leading // can be safely ignored\n\t */\n\tNEXT;\n\tNEXT;\n\tctxt->comp->priority = 0.5;\t/* '//' means not 0 priority */\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else if (CUR == '/') {\n\t/*\n\t * We need to find root as the parent\n\t */\n\tNEXT;\n\tSKIP_BLANKS;\n\tPUSH(XSLT_OP_ROOT, NULL, NULL, novar);\n\tif ((CUR != 0) && (CUR != '|')) {\n\t    PUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n\t    xsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t}\n    } else if (CUR == '*') {\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else if (CUR == '@') {\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else {\n\txmlChar *name;\n\tname = xsltScanNCName(ctxt);\n\tif (name == NULL) {\n\t    xsltTransformError(NULL, NULL, NULL,\n\t\t    \"xsltCompileLocationPathPattern : Name expected\\n\");\n\t    ctxt->error = 1;\n\t    return;\n\t}\n \tSKIP_BLANKS;\n \tif ((CUR == '(') && !xmlXPathIsNodeType(name)) {\n \t    xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);\n \t    if ((CUR == '/') && (NXT(1) == '/')) {\n \t\tPUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);\n \t\tNEXT;\n\t\tNEXT;\n\t\tSKIP_BLANKS;\n\t\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t    } else if (CUR == '/') {\n\t\tPUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n\t\tNEXT;\n\t\tSKIP_BLANKS;\n\t\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t    }\n\t    return;\n\t}\n\txsltCompileRelativePathPattern(ctxt, name, novar);\n    }\nerror:\n    return;\n}\n",
        "target": 1
    },
    {
        "id": 3097,
        "func": "void GfxColorSpace::getGrayLine(Guchar *in, unsigned char *out, int length) {\n  int i, j, n;\n  GfxColor color;\n  GfxGray gray;\n\n  n = getNComps();\n  for (i = 0; i < length; i++) {\n    \n    for (j = 0; j < n; j++)\n      color.c[j] = in[i * n + j] * 256;\n\n    getGray (&color, &gray);\n    out[i] = colToByte(gray);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3098,
        "func": "int security_transition_sid(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t    const struct qstr *qstr, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    qstr ? qstr->name : NULL, out_sid, true);\n}",
        "target": 0
    },
    {
        "id": 3099,
        "func": "static void ipa_udata_init(wmfAPI * API, wmfUserData_t * userdata)\n{\n  (void) API;\n  (void) userdata;\n  /* wmf_magick_t* ddata = WMF_MAGICK_GetData (API); */\n\n}\n",
        "target": 0
    },
    {
        "id": 3100,
        "func": "void BrowserPluginGuest::RenderViewGone(base::TerminationStatus status) {\n  if (pending_input_event_reply_.get()) {\n    IPC::Message* reply_message = pending_input_event_reply_.release();\n    BrowserPluginHostMsg_HandleInputEvent::WriteReplyParams(reply_message,\n                                                            false);\n    SendMessageToEmbedder(reply_message);\n  }\n  int process_id = web_contents()->GetRenderProcessHost()->GetID();\n  SendMessageToEmbedder(new BrowserPluginMsg_GuestGone(embedder_routing_id(),\n                                                       instance_id(),\n                                                       process_id,\n                                                       status));\n  IDMap<RenderViewHost>::const_iterator iter(&pending_updates_);\n  while (!iter.IsAtEnd()) {\n    pending_updates_.Remove(iter.GetCurrentKey());\n    iter.Advance();\n  }\n\n  switch (status) {\n    case base::TERMINATION_STATUS_PROCESS_WAS_KILLED:\n      RecordAction(UserMetricsAction(\"BrowserPlugin.Guest.Killed\"));\n      break;\n    case base::TERMINATION_STATUS_PROCESS_CRASHED:\n      RecordAction(UserMetricsAction(\"BrowserPlugin.Guest.Crashed\"));\n      break;\n    case base::TERMINATION_STATUS_ABNORMAL_TERMINATION:\n      RecordAction(UserMetricsAction(\"BrowserPlugin.Guest.AbnormalDeath\"));\n      break;\n    default:\n      break;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3101,
        "func": "ProcListHosts(ClientPtr client)\n{\n    xListHostsReply reply;\n    int len, nHosts, result;\n    BOOL enabled;\n    void *pdata;\n\n    /* REQUEST(xListHostsReq); */\n\n    REQUEST_SIZE_MATCH(xListHostsReq);\n\n    /* untrusted clients can't list hosts */\n    result = XaceHook(XACE_SERVER_ACCESS, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    result = GetHosts(&pdata, &nHosts, &len, &enabled);\n    if (result != Success)\n        return result;\n\n    reply = (xListHostsReply) {\n        .type = X_Reply,\n        .enabled = enabled,\n        .sequenceNumber = client->sequence,\n        .length = bytes_to_int32(len),\n        .nHosts = nHosts\n    };\n    WriteReplyToClient(client, sizeof(xListHostsReply), &reply);\n    if (nHosts) {\n        client->pSwapReplyFunc = (ReplySwapPtr) SLHostsExtend;\n        WriteSwappedDataToClient(client, len, pdata);\n    }\n    free(pdata);\n    return Success;\n}\n",
        "target": 0
    },
    {
        "id": 3102,
        "func": "static int saved_cmdlines_show(struct seq_file *m, void *v)\n{\n\tchar buf[TASK_COMM_LEN];\n\tunsigned int *pid = v;\n\n\t__trace_find_cmdline(*pid, buf);\n\tseq_printf(m, \"%d %s\\n\", *pid, buf);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3103,
        "func": "void HTMLCanvasElement::OnWebLayerUpdated() {\n  SetNeedsCompositingUpdate();\n}\n",
        "target": 0
    },
    {
        "id": 3104,
        "func": "void SendTabToSelfEntry::SetNotificationDismissed(bool notification_dismissed) {\n  notification_dismissed_ = notification_dismissed;\n}\n",
        "target": 0
    },
    {
        "id": 3105,
        "func": "static int timerslack_ns_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\tint err =  0;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (ptrace_may_access(p, PTRACE_MODE_ATTACH_FSCREDS)) {\n\t\ttask_lock(p);\n\t\tseq_printf(m, \"%llu\\n\", p->timer_slack_ns);\n\t\ttask_unlock(p);\n\t} else\n\t\terr = -EPERM;\n\n\tput_task_struct(p);\n\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3106,
        "func": "static void VoidMethodSequenceStringArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"voidMethodSequenceStringArg\");\n\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n    return;\n  }\n\n  Vector<String> string_sequence_arg;\n  string_sequence_arg = NativeValueTraits<IDLSequence<IDLString>>::NativeValue(info.GetIsolate(), info[0], exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->voidMethodSequenceStringArg(string_sequence_arg);\n}\n",
        "target": 0
    },
    {
        "id": 3107,
        "func": "void TestingAutomationProvider::SendSuccessReply(IPC::Message* reply_message) {\n  AutomationJSONReply(this, reply_message).SendSuccess(NULL);\n}\n",
        "target": 0
    },
    {
        "id": 3108,
        "func": "PHP_FUNCTION(locale_accept_from_http)\n{\n\tUEnumeration *available;\n\tchar *http_accept = NULL;\n\tint http_accept_len;\n\tUErrorCode status = 0;\n\tint len;\n\tchar resultLocale[INTL_MAX_LOCALE_LEN+1];\n\tUAcceptResult outResult;\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &http_accept, &http_accept_len) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n \t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n \tavailable = ures_openAvailableLocales(NULL, &status);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN, \n \t\t\t\t\t\t&outResult, http_accept, available, &status);\n \tuenum_close(available);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");\n\tif (len < 0 || outResult == ULOC_ACCEPT_FAILED) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(resultLocale, len, 1);\n}\n",
        "target": 1
    },
    {
        "id": 3109,
        "func": "static int satsub64be(const unsigned char *v1,const unsigned char *v2)\n{\tint ret,sat,brw,i;\n\n\tif (sizeof(long) == 8) do\n\t{\tconst union { long one; char little; } is_endian = {1};\n\t\tlong l;\n\n\t\tif (is_endian.little)\t\t\tbreak;\n\t\t/* not reached on little-endians */\n\t\t/* following test is redundant, because input is\n\t\t * always aligned, but I take no chances... */\n\t\tif (((size_t)v1|(size_t)v2)&0x7)\tbreak;\n\n\t\tl  = *((long *)v1);\n\t\tl -= *((long *)v2);\n\t\tif (l>128)\t\treturn 128;\n\t\telse if (l<-128)\treturn -128;\n\t\telse\t\t\treturn (int)l;\n\t} while (0);\n\n\tret = (int)v1[7]-(int)v2[7];\n\tsat = 0;\n\tbrw = ret>>8;\t/* brw is either 0 or -1 */\n\tif (ret & 0x80)\n\t{\tfor (i=6;i>=0;i--)\n\t\t{\tbrw += (int)v1[i]-(int)v2[i];\n\t\t\tsat |= ~brw;\n\t\t\tbrw >>= 8;\n\t\t}\n\t}\n\telse\n\t{\tfor (i=6;i>=0;i--)\n\t\t{\tbrw += (int)v1[i]-(int)v2[i];\n\t\t\tsat |= brw;\n\t\t\tbrw >>= 8;\n\t\t}\n\t}\n\tbrw <<= 8;\t/* brw is either 0 or -256 */\n\n\tif (sat&0xff)\treturn brw | 0x80;\n\telse\t\treturn brw + (ret&0xFF);\n}\n",
        "target": 0
    },
    {
        "id": 3110,
        "func": "static void _c2s_pidfile(c2s_t c2s) {\n    const char *pidfile;\n    FILE *f;\n    pid_t pid;\n\n    pidfile = config_get_one(c2s->config, \"pidfile\", 0);\n    if(pidfile == NULL)\n        return;\n\n    pid = getpid();\n\n    if((f = fopen(pidfile, \"w+\")) == NULL) {\n        log_write(c2s->log, LOG_ERR, \"couldn't open %s for writing: %s\", pidfile, strerror(errno));\n        return;\n    }\n\n    if(fprintf(f, \"%d\", pid) < 0) {\n        log_write(c2s->log, LOG_ERR, \"couldn't write to %s: %s\", pidfile, strerror(errno));\n        fclose(f);\n        return;\n    }\n\n    fclose(f);\n\n    log_write(c2s->log, LOG_INFO, \"process id is %d, written to %s\", pid, pidfile);\n}",
        "target": 0
    },
    {
        "id": 3111,
        "func": "static void ActivityLoggingGetterForAllWorldsLongAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Local<v8::Object> holder = info.Holder();\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V8SetReturnValueInt(info, impl->activityLoggingGetterForAllWorldsLongAttribute());\n}\n",
        "target": 0
    },
    {
        "id": 3112,
        "func": "static int handle_invalid_op(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 3113,
        "func": "static int rds_still_queued(struct rds_sock *rs, struct rds_incoming *inc,\n\t\t\t    int drop)\n{\n\tstruct sock *sk = rds_rs_to_sk(rs);\n\tint ret = 0;\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&rs->rs_recv_lock, flags);\n\tif (!list_empty(&inc->i_item)) {\n\t\tret = 1;\n\t\tif (drop) {\n\t\t\t/* XXX make sure this i_conn is reliable */\n\t\t\trds_recv_rcvbuf_delta(rs, sk, inc->i_conn->c_lcong,\n\t\t\t\t\t      -be32_to_cpu(inc->i_hdr.h_len),\n\t\t\t\t\t      inc->i_hdr.h_dport);\n\t\t\tlist_del_init(&inc->i_item);\n\t\t\trds_inc_put(inc);\n\t\t}\n\t}\n\twrite_unlock_irqrestore(&rs->rs_recv_lock, flags);\n\n\trdsdebug(\"inc %p rs %p still %d dropped %d\\n\", inc, rs, ret, drop);\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 3114,
        "func": "static void CreateContextProviderOnMainThread(\n    ContextProviderCreationInfo* creation_info,\n    base::WaitableEvent* waitable_event) {\n  DCHECK(IsMainThread());\n  *creation_info->using_gpu_compositing =\n      !Platform::Current()->IsGpuCompositingDisabled();\n  creation_info->created_context_provider =\n      Platform::Current()->CreateOffscreenGraphicsContext3DProvider(\n          creation_info->context_attributes, creation_info->url,\n          creation_info->gl_info);\n  waitable_event->Signal();\n}\n",
        "target": 0
    },
    {
        "id": 3115,
        "func": "static int __init set_trace_boot_clock(char *str)\n{\n\tstrlcpy(trace_boot_clock_buf, str, MAX_TRACER_SIZE);\n\ttrace_boot_clock = trace_boot_clock_buf;\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 3116,
        "func": "   ChromeInvalidationClientTest()\n      : fake_push_client_(new notifier::FakePushClient()),\n        client_(scoped_ptr<notifier::PushClient>(fake_push_client_)),\n        kBookmarksId_(kChromeSyncSourceId, \"BOOKMARK\"),\n         kPreferencesId_(kChromeSyncSourceId, \"PREFERENCE\"),\n         kExtensionsId_(kChromeSyncSourceId, \"EXTENSION\"),\n        kAppsId_(kChromeSyncSourceId, \"APP\") {}\n",
        "target": 1
    },
    {
        "id": 3117,
        "func": "static void brcmf_update_ht_cap(struct ieee80211_supported_band *band,\n\t\t\t\tu32 bw_cap[2], u32 nchain)\n{\n\tband->ht_cap.ht_supported = true;\n\tif (bw_cap[band->band] & WLC_BW_40MHZ_BIT) {\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\tband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_20;\n\tband->ht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;\n\tband->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tband->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\n\tmemset(band->ht_cap.mcs.rx_mask, 0xff, nchain);\n\tband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n}",
        "target": 0
    },
    {
        "id": 3118,
        "func": "int Textfield::GetBaseline() const {\n  return GetInsets().top() + GetRenderText()->GetBaseline();\n}\n",
        "target": 0
    },
    {
        "id": 3119,
        "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *out;\n    int needs_copy = frame_needs_copy(s, in);\n\n    if (needs_copy) {\n        av_log(inlink->dst, AV_LOG_DEBUG, \"Direct padding impossible allocating new frame\\n\");\n        out = ff_get_video_buffer(inlink->dst->outputs[0],\n                                  FFMAX(inlink->w, s->w),\n                                  FFMAX(inlink->h, s->h));\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n\n        av_frame_copy_props(out, in);\n    } else {\n        int i;\n\n        out = in;\n        for (i = 0; i < 4 && out->data[i] && out->linesize[i]; i++) {\n            int hsub = s->draw.hsub[i];\n            int vsub = s->draw.vsub[i];\n            out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] +\n                            (s->y >> vsub) * out->linesize[i];\n        }\n    }\n\n    /* top bar */\n    if (s->y) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, 0, s->w, s->y);\n    }\n\n    /* bottom bar */\n    if (s->h > s->y + s->in_h) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, s->y + s->in_h, s->w, s->h - s->y - s->in_h);\n    }\n\n    /* left border */\n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      0, s->y, s->x, in->height);\n\n    if (needs_copy) {\n        ff_copy_rectangle2(&s->draw,\n                          out->data, out->linesize, in->data, in->linesize,\n                          s->x, s->y, 0, 0, in->width, in->height);\n    }\n\n    /* right border */\n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      s->x + s->in_w, s->y, s->w - s->x - s->in_w,\n                      in->height);\n\n    out->width  = s->w;\n    out->height = s->h;\n\n    if (in != out)\n        av_frame_free(&in);\n    return ff_filter_frame(inlink->dst->outputs[0], out);\n}",
        "target": 0
    },
    {
        "id": 3120,
        "func": "static inline unsigned long buffer_offset(void *buf)\n{\n\treturn (unsigned long)buf & (ARCH_KMALLOC_MINALIGN - 1);\n}",
        "target": 0
    },
    {
        "id": 3121,
        "func": "void PrintPreviewUI::OnDidPreviewPage(int page_number,\n                                       int preview_request_id) {\n   DCHECK_GE(page_number, 0);\n   base::FundamentalValue number(page_number);\n  StringValue ui_identifier(preview_ui_addr_str_);\n   base::FundamentalValue request_id(preview_request_id);\n   web_ui()->CallJavascriptFunction(\n       \"onDidPreviewPage\", number, ui_identifier, request_id);\n }\n",
        "target": 1
    },
    {
        "id": 3122,
        "func": "jpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tuchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tif (streams) {\n\t\tjpc_streamlist_destroy(streams);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 3123,
        "func": "void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tatomic_inc(&p->u.count);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = p->name;\n\t} else {\n\t\tmemcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = name->inline_name;\n\t}\n}",
        "target": 0
    },
    {
        "id": 3124,
        "func": "   virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n\n     inv_txfm_ = GET_PARAM(1);\n     version_  = GET_PARAM(2);  // 0: high precision forward transform\n   }\n",
        "target": 1
    },
    {
        "id": 3125,
        "func": "static int sctp_getsockopt_peeloff_flags(struct sock *sk, int len,\n\t\t\t\t\t char __user *optval, int __user *optlen)\n{\n\tsctp_peeloff_flags_arg_t peeloff;\n\tstruct file *newfile = NULL;\n\tint retval = 0;\n\n\tif (len < sizeof(sctp_peeloff_flags_arg_t))\n\t\treturn -EINVAL;\n\tlen = sizeof(sctp_peeloff_flags_arg_t);\n\tif (copy_from_user(&peeloff, optval, len))\n\t\treturn -EFAULT;\n\n\tretval = sctp_getsockopt_peeloff_common(sk, &peeloff.p_arg,\n\t\t\t\t\t\t&newfile, peeloff.flags);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* Return the fd mapped to the new socket.  */\n\tif (put_user(len, optlen)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_to_user(optval, &peeloff, len)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\tfd_install(retval, newfile);\nout:\n\treturn retval;\n}",
        "target": 0
    },
    {
        "id": 3126,
        "func": "int generic_pipe_buf_confirm(struct pipe_inode_info *info,\n\t\t\t     struct pipe_buffer *buf)\n{\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3127,
        "func": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; /* too big for stack allocation */\n\tchar *ptr;\n\tint err;\n\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\t/* bitmap disabled, zero the first byte and copy out */\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\n\tkfree(file);\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 3128,
        "func": "int SocketStream::HandleCertificateError(int result) {\n  DCHECK(IsCertificateError(result));\n   SSLClientSocket* ssl_socket = static_cast<SSLClientSocket*>(socket_.get());\n   DCHECK(ssl_socket);\n \n  if (!context_.get())\n     return result;\n \n   if (SSLClientSocket::IgnoreCertError(result, LOAD_IGNORE_ALL_CERT_ERRORS)) {\n    const HttpNetworkSession::Params* session_params =\n        context_->GetNetworkSessionParams();\n    if (session_params && session_params->ignore_certificate_errors)\n      return OK;\n  }\n\n  if (!delegate_)\n    return result;\n\n  SSLInfo ssl_info;\n  ssl_socket->GetSSLInfo(&ssl_info);\n\n  TransportSecurityState::DomainState domain_state;\n  const bool fatal = context_->transport_security_state() &&\n      context_->transport_security_state()->GetDomainState(url_.host(),\n          SSLConfigService::IsSNIAvailable(context_->ssl_config_service()),\n          &domain_state) &&\n      domain_state.ShouldSSLErrorsBeFatal();\n\n  delegate_->OnSSLCertificateError(this, ssl_info, fatal);\n  return ERR_IO_PENDING;\n}\n",
        "target": 1
    },
    {
        "id": 3129,
        "func": "int git_smart__store_refs(transport_smart *t, int flushes)\n{\n\tgitno_buffer *buf = &t->buffer;\n\tgit_vector *refs = &t->refs;\n\tint error, flush = 0, recvd;\n\tconst char *line_end = NULL;\n\tgit_pkt *pkt = NULL;\n\tsize_t i;\n\n\t/* Clear existing refs in case git_remote_connect() is called again\n\t * after git_remote_disconnect().\n\t */\n\tgit_vector_foreach(refs, i, pkt) {\n\t\tgit_pkt_free(pkt);\n\t}\n\tgit_vector_clear(refs);\n\tpkt = NULL;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\t\treturn recvd;\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\treturn GIT_EEOF;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\t\tif (pkt->type == GIT_PKT_ERR) {\n\t\t\tgiterr_set(GITERR_NET, \"Remote error: %s\", ((git_pkt_err *)pkt)->error);\n\t\t\tgit__free(pkt);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pkt->type != GIT_PKT_FLUSH && git_vector_insert(refs, pkt) < 0)\n\t\t\treturn -1;\n\n\t\tif (pkt->type == GIT_PKT_FLUSH) {\n\t\t\tflush++;\n\t\t\tgit_pkt_free(pkt);\n\t\t}\n\t} while (flush < flushes);\n\n\treturn flush;\n}",
        "target": 0
    },
    {
        "id": 3130,
        "func": " void ClassicPendingScript::SetStreamer(ScriptStreamer* streamer) {\n  DCHECK(streamer);\n  DCHECK(!streamer_);\n  DCHECK(!IsWatchingForLoad() || ready_state_ != kWaitingForResource);\n  DCHECK(!streamer->IsFinished());\n  DCHECK(ready_state_ == kWaitingForResource || ready_state_ == kReady);\n\n  streamer_ = streamer;\n  is_currently_streaming_ = true;\n  if (streamer && ready_state_ == kReady)\n    AdvanceReadyState(kReadyStreaming);\n\n  CheckState();\n}\n",
        "target": 0
    },
    {
        "id": 3131,
        "func": "std::unique_ptr<content::BluetoothChooser> Browser::RunBluetoothChooser(\n    content::RenderFrameHost* frame,\n    const content::BluetoothChooser::EventHandler& event_handler) {\n  std::unique_ptr<BluetoothChooserController> bluetooth_chooser_controller(\n      new BluetoothChooserController(frame, event_handler));\n\n  std::unique_ptr<BluetoothChooserDesktop> bluetooth_chooser_desktop(\n      new BluetoothChooserDesktop(bluetooth_chooser_controller.get()));\n\n  std::unique_ptr<ChooserBubbleDelegate> chooser_bubble_delegate(\n      new ChooserBubbleDelegate(frame,\n                                std::move(bluetooth_chooser_controller)));\n\n  Browser* browser = chrome::FindBrowserWithWebContents(\n      WebContents::FromRenderFrameHost(frame));\n  BubbleReference bubble_reference = browser->GetBubbleManager()->ShowBubble(\n      std::move(chooser_bubble_delegate));\n\n  return std::move(bluetooth_chooser_desktop);\n}\n",
        "target": 0
    },
    {
        "id": 3132,
        "func": "resetimage(Image *image)\n{\n if (image->input_file != NULL)\n      rewind(image->input_file);\n}\n",
        "target": 0
    },
    {
        "id": 3133,
        "func": "void Document::setParsing(bool b)\n{\n    m_bParsing = b;\n\n    if (m_bParsing && !m_sharedObjectPool)\n        m_sharedObjectPool = DocumentSharedObjectPool::create();\n\n    if (!m_bParsing && view())\n        view()->scheduleRelayout();\n\n#ifdef INSTRUMENT_LAYOUT_SCHEDULING\n    if (!ownerElement() && !m_bParsing)\n        printf(\"Parsing finished at %d\\n\", elapsedTime());\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 3134,
        "func": "static void DefragTrackerInit(DefragTracker *dt, Packet *p)\n{\n    /* copy address */\n    COPY_ADDRESS(&p->src, &dt->src_addr);\n    COPY_ADDRESS(&p->dst, &dt->dst_addr);\n\n    if (PKT_IS_IPV4(p)) {\n        dt->id = (int32_t)IPV4_GET_IPID(p);\n        dt->af = AF_INET;\n    } else {\n        dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);\n        dt->af = AF_INET6;\n    }\n    dt->vlan_id[0] = p->vlan_id[0];\n    dt->vlan_id[1] = p->vlan_id[1];\n    dt->policy = DefragGetOsPolicy(p);\n    dt->host_timeout = DefragPolicyGetHostTimeout(p);\n    dt->remove = 0;\n    dt->seen_last = 0;\n\n    TAILQ_INIT(&dt->frags);\n    (void) DefragTrackerIncrUsecnt(dt);\n}",
        "target": 1
    },
    {
        "id": 3135,
        "func": "delelement (struct fileinfo *f, struct fileinfo **start)\n{\n  struct fileinfo *prev = f->prev;\n  struct fileinfo *next = f->next;\n\n  xfree (f->name);\n  xfree (f->linkto);\n  xfree (f);\n\n  if (next)\n    next->prev = prev;\n  if (prev)\n    prev->next = next;\n  else\n    *start = next;\n  return next;\n}\n",
        "target": 0
    },
    {
        "id": 3136,
        "func": "RilSapSocket::RilSapSocket(const char *socketName,\n        RIL_SOCKET_ID socketId,\n        RIL_RadioFunctions *inputUimFuncs):\n RilSocket(socketName, socketId) {\n if (inputUimFuncs) {\n        uimFuncs = inputUimFuncs;\n }\n}\n",
        "target": 0
    },
    {
        "id": 3137,
        "func": "  const Vp9Segmentation& GetSegmentation() const {\n    return vp9_parser_.GetSegmentation();\n  }\n",
        "target": 1
    },
    {
        "id": 3138,
        "func": " OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n {\n        static const char module[]=\"OJPEGDecode\";\n \tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n \t(void)s;\n        if( !sp->decoder_ok )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Cannot decode: decoder not correctly initialized\");\n            return 0;\n        }\n \tif (sp->libjpeg_jpeg_query_style==0)\n \t{\n \t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}\n",
        "target": 0
    },
    {
        "id": 3139,
        "func": " RTCPeerConnectionHandlerDummy::RTCPeerConnectionHandlerDummy(RTCPeerConnectionHandlerClient* client)\n     : m_client(client)\n {\n    ASSERT(m_client);\n }\n",
        "target": 0
    },
    {
        "id": 3140,
        "func": "static int cg_opendir(const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tconst char *cgroup;\n\tstruct file_info *dir_info;\n\tchar *controller = NULL;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tcgroup = NULL;\n\t\tcontroller = NULL;\n\t} else {\n\t\t// return list of keys for the controller, and list of child cgroups\n\t\tcontroller = pick_controller_from_path(fc, path);\n\t\tif (!controller)\n\t\t\treturn -EIO;\n\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\t/* this is just /cgroup/controller, return its contents */\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\n\tif (cgroup) {\n\t\tif (!caller_may_see_dir(fc->pid, controller, cgroup))\n\t\t\treturn -ENOENT;\n\t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))\n\t\t\treturn -EACCES;\n\t}\n\n\t/* we'll free this at cg_releasedir */\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;\n\tdir_info->file = NULL;\n\tdir_info->buflen = 0;\n\n\tfi->fh = (unsigned long)dir_info;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3141,
        "func": "static u8 GetByte(struct ngiflib_gif * g) {\n#ifndef NGIFLIB_NO_FILE\n\tif(g->mode & NGIFLIB_MODE_FROM_MEM) {\n#endif /* NGIFLIB_NO_FILE */\n\t\treturn *(g->input.bytes++);\n#ifndef NGIFLIB_NO_FILE\n\t} else {\n\t\treturn (u8)(getc(g->input.file));\n\t}\n#endif /* NGIFLIB_NO_FILE */\n}",
        "target": 0
    },
    {
        "id": 3142,
        "func": " void UpdateContentLengthPrefs(\n    int received_content_length, int original_content_length,\n    bool with_data_reduction_proxy_enabled, bool via_data_reduction_proxy,\n     PrefService* prefs) {\n   int64 total_received = prefs->GetInt64(prefs::kHttpReceivedContentLength);\n   int64 total_original = prefs->GetInt64(prefs::kHttpOriginalContentLength);\n  total_received += received_content_length;\n  total_original += original_content_length;\n  prefs->SetInt64(prefs::kHttpReceivedContentLength, total_received);\n  prefs->SetInt64(prefs::kHttpOriginalContentLength, total_original);\n\n#if defined(OS_ANDROID) || defined(OS_IOS)\n  UpdateContentLengthPrefsForDataReductionProxy(\n       received_content_length,\n       original_content_length,\n       with_data_reduction_proxy_enabled,\n      via_data_reduction_proxy,\n       base::Time::Now(),\n       prefs);\n #endif  // defined(OS_ANDROID) || defined(OS_IOS)\n\n}\n",
        "target": 1
    },
    {
        "id": 3143,
        "func": "const char *tty_driver_name(const struct tty_struct *tty)\n{\n\tif (!tty || !tty->driver)\n\t\treturn \"\";\n\treturn tty->driver->name;\n}",
        "target": 0
    },
    {
        "id": 3144,
        "func": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 3145,
        "func": "static int nfs4_do_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_open_expired(ctx, state);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t\t\terr = 0;\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3146,
        "func": "void kvm_free_physmem(struct kvm *kvm)\n{\n\tstruct kvm_memslots *slots = kvm->memslots;\n\tstruct kvm_memory_slot *memslot;\n\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_free_physmem_slot(memslot, NULL);\n\n\tkfree(kvm->memslots);\n}",
        "target": 0
    },
    {
        "id": 3147,
        "func": "TabContents* Browser::GetOrCloneTabForDisposition(\n       WindowOpenDisposition disposition) {\n  TabContentsWrapper* current_tab = GetSelectedTabContentsWrapper();\n  if (ShouldOpenNewTabForWindowDisposition(disposition)) {\n    current_tab = current_tab->Clone();\n    tab_handler_->GetTabStripModel()->AddTabContents(\n        current_tab, -1, PageTransition::LINK,\n        disposition == NEW_FOREGROUND_TAB ? TabStripModel::ADD_SELECTED :\n                                            TabStripModel::ADD_NONE);\n  }\n  return current_tab->tab_contents();\n}\n",
        "target": 0
    },
    {
        "id": 3148,
        "func": "void PepperRendererConnection::OnMsgDidCreateInProcessInstance(\n     PP_Instance instance,\n     const PepperRendererInstanceData& instance_data) {\n   PepperRendererInstanceData data = instance_data;\n   data.render_process_id = render_process_id_;\n   in_process_host_->AddInstance(instance, data);\n }\n",
        "target": 1
    },
    {
        "id": 3149,
        "func": "static void __init early_reserve_initrd(void)\n{\n}\n",
        "target": 0
    },
    {
        "id": 3150,
        "func": "static int nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n\t\tu64 cookie, struct page **pages, unsigned int count, int plus)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dentry->d_inode),\n\t\t\t\t_nfs4_proc_readdir(dentry, cred, cookie,\n\t\t\t\t\tpages, count, plus),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3151,
        "func": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n if (mSyncSampleOffset >= 0 || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n    mSyncSampleOffset = data_offset;\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mNumSyncSamples = U32_AT(&header[4]);\n\n if (mNumSyncSamples < 2) {\n\n         ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n     }\n \n    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);\n    if (allocSize > SIZE_MAX) {\n        return ERROR_OUT_OF_RANGE;\n    }\n\n     mSyncSamples = new uint32_t[mNumSyncSamples];\n     size_t size = mNumSyncSamples * sizeof(uint32_t);\n     if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)\n != (ssize_t)size) {\n return ERROR_IO;\n }\n\n for (size_t i = 0; i < mNumSyncSamples; ++i) {\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n }\n\n return OK;\n}\n",
        "target": 0
    },
    {
        "id": 3152,
        "func": "bool isNodeAriaVisible(Node* node) {\n  if (!node)\n    return false;\n\n   if (!node->isElementNode())\n     return false;\n \n  return equalIgnoringCase(toElement(node)->getAttribute(aria_hiddenAttr),\n                           \"false\");\n }\n",
        "target": 1
    },
    {
        "id": 3153,
        "func": " void PrintWebViewHelper::OnPrintingDone(bool success) {\n   notify_browser_of_print_failure_ = false;\n   if (!success)\n     LOG(ERROR) << \"Failure in OnPrintingDone\";\n  DidFinishPrinting(success ? OK : FAIL_PRINT);\n}\n",
        "target": 1
    },
    {
        "id": 3154,
        "func": "bool ShelfLayoutManager::IsStatusAreaWindow(aura::Window* window) {\n  if (!window)\n    return false;\n  const aura::Window* status_window =\n      shelf_widget_->status_area_widget()->GetNativeWindow();\n  return status_window && status_window->Contains(window);\n}\n",
        "target": 0
    },
    {
        "id": 3155,
        "func": "const Cues* Segment::GetCues() const\n",
        "target": 0
    },
    {
        "id": 3156,
        "func": " views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(\n     views::Widget* widget) {\n  ShellWindowFrameView* frame_view = new ShellWindowFrameView();\n   frame_view->Init(window_);\n   return frame_view;\n }\n",
        "target": 1
    },
    {
        "id": 3157,
        "func": "EventListener* Document::getWindowAttributeEventListener(const AtomicString& eventType, DOMWrapperWorld* isolatedWorld)\n{\n    DOMWindow* domWindow = this->domWindow();\n    if (!domWindow)\n        return 0;\n    return domWindow->getAttributeEventListener(eventType, isolatedWorld);\n}\n",
        "target": 0
    },
    {
        "id": 3158,
        "func": "static int unix_dgram_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct sockaddr_un *sunaddr = (struct sockaddr_un *)addr;\n\tstruct sock *other;\n\tunsigned int hash;\n\tint err;\n\n\tif (addr->sa_family != AF_UNSPEC) {\n\t\terr = unix_mkname(sunaddr, alen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\talen = err;\n\n\t\tif (test_bit(SOCK_PASSCRED, &sock->flags) &&\n\t\t    !unix_sk(sk)->addr && (err = unix_autobind(sock)) != 0)\n\t\t\tgoto out;\n\nrestart:\n\t\tother = unix_find_other(net, sunaddr, alen, sock->type, hash, &err);\n\t\tif (!other)\n\t\t\tgoto out;\n\n\t\tunix_state_double_lock(sk, other);\n\n\t\t/* Apparently VFS overslept socket death. Retry. */\n\t\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t\tunix_state_double_unlock(sk, other);\n\t\t\tsock_put(other);\n\t\t\tgoto restart;\n\t\t}\n\n\t\terr = -EPERM;\n\t\tif (!unix_may_send(sk, other))\n\t\t\tgoto out_unlock;\n\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t} else {\n\t\t/*\n\t\t *\t1003.1g breaking connected state with AF_UNSPEC\n\t\t */\n\t\tother = NULL;\n\t\tunix_state_double_lock(sk, other);\n\t}\n\n\t/*\n\t * If it was connected, reconnect.\n\t */\n\tif (unix_peer(sk)) {\n\t\tstruct sock *old_peer = unix_peer(sk);\n\t\tunix_peer(sk) = other;\n\t\tunix_state_double_unlock(sk, other);\n\n\t\tif (other != old_peer)\n\t\t\tunix_dgram_disconnected(sk, old_peer);\n\t\tsock_put(old_peer);\n\t} else {\n\t\tunix_peer(sk) = other;\n\t\tunix_state_double_unlock(sk, other);\n\t}\n\treturn 0;\n\nout_unlock:\n\tunix_state_double_unlock(sk, other);\n\tsock_put(other);\nout:\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 3159,
        "func": "int ssl3_check_finished(SSL *s)\n\t{\n\tint ok;\n\tlong n;\n\t/* If we have no ticket it cannot be a resumed session. */\n\tif (!s->session->tlsext_tick)\n\t\treturn 1;\n\t/* this function is called when we really expect a Certificate\n\t * message, so permit appropriate message length */\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_CERT_A,\n\t\tSSL3_ST_CR_CERT_B,\n\t\t-1,\n\t\ts->max_cert_list,\n\t\t&ok);\n\tif (!ok) return((int)n);\n\ts->s3->tmp.reuse_message = 1;\n\tif ((s->s3->tmp.message_type == SSL3_MT_FINISHED)\n\t\t|| (s->s3->tmp.message_type == SSL3_MT_NEWSESSION_TICKET))\n\t\treturn 2;\n\n\treturn 1;\n\t}\n",
        "target": 0
    },
    {
        "id": 3160,
        "func": "istr_set_get_as_list (GHashTable *table)\n{\n    GList *list;\n\n    list = NULL;\n    g_hash_table_foreach (table, add_istr_to_list, &list);\n    return list;\n}",
        "target": 0
    },
    {
        "id": 3161,
        "func": "unsigned long iov_pages(const struct iovec *iov, int offset,\n\t\t\tunsigned long nr_segs)\n{\n\tunsigned long seg, base;\n\tint pages = 0, len, size;\n\n\twhile (nr_segs && (offset >= iov->iov_len)) {\n\t\toffset -= iov->iov_len;\n\t\t++iov;\n\t\t--nr_segs;\n\t}\n\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tbase = (unsigned long)iov[seg].iov_base + offset;\n\t\tlen = iov[seg].iov_len - offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tpages += size;\n\t\toffset = 0;\n\t}\n\n\treturn pages;\n}",
        "target": 0
    },
    {
        "id": 3162,
        "func": "void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {\n  if (is_voice_interaction_oobe_)\n    return;\n\n  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||\n      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {\n    return;\n  }\n\n  oobe_startup_sound_played_ = true;\n\n  if (base::TimeTicks::Now() - login_prompt_visible_time_ >\n      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {\n    return;\n  }\n\n  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,\n                                          PlaySoundOption::ALWAYS);\n}\n",
        "target": 0
    },
    {
        "id": 3163,
        "func": "nfs41_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t    struct nfs_fsinfo *info)\n{\n\tint err;\n\tstruct page *page;\n\trpc_authflavor_t flavor;\n\tstruct nfs4_secinfo_flavors *flavors;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tflavors = page_address(page);\n\terr = nfs41_proc_secinfo_no_name(server, fhandle, info, flavors);\n\n\t/*\n\t * Fall back on \"guess and check\" method if\n\t * the server doesn't support SECINFO_NO_NAME\n\t */\n\tif (err == -NFS4ERR_WRONGSEC || err == -NFS4ERR_NOTSUPP) {\n\t\terr = nfs4_find_root_sec(server, fhandle, info);\n\t\tgoto out_freepage;\n\t}\n\tif (err)\n\t\tgoto out_freepage;\n\n\tflavor = nfs_find_best_sec(flavors);\n\tif (err == 0)\n\t\terr = nfs4_lookup_root_sec(server, fhandle, info, flavor);\n\nout_freepage:\n\tput_page(page);\n\tif (err == -EACCES)\n\t\treturn -EPERM;\nout:\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3164,
        "func": "void GDataCache::DestroyOnUIThread() {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  ui_weak_ptr_factory_.InvalidateWeakPtrs();\n\n  pool_->GetSequencedTaskRunner(sequence_token_)->PostTask(\n      FROM_HERE,\n      base::Bind(&GDataCache::Destroy,\n                 base::Unretained(this)));\n}\n",
        "target": 0
    },
    {
        "id": 3165,
        "func": "static void __maybe_unused timersubspec(struct timespec *a, const struct timespec *b)\n{\n\ta->tv_sec -= b->tv_sec;\n\ta->tv_nsec -= b->tv_nsec;\n\tif (a->tv_nsec < 0) {\n\t\ta->tv_nsec += 1000000000;\n\t\ta->tv_sec--;\n\t}\n}",
        "target": 0
    },
    {
        "id": 3166,
        "func": "M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\n\t(void)info;\n\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n\t}\n\n\t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n \t * starts with a '.'. */\n\tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n\tlen = M_list_str_len(path_parts);\n\tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 3167,
        "func": "ssh_packet_inc_alive_timeouts(struct ssh *ssh)\n{\n\treturn ++ssh->state->keep_alive_timeouts;\n}",
        "target": 0
    },
    {
        "id": 3168,
        "func": "static void LocationWithPerWorldBindingsAttributeSetter(\n    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Isolate* isolate = info.GetIsolate();\n  ALLOW_UNUSED_LOCAL(isolate);\n\n  v8::Local<v8::Object> holder = info.Holder();\n  ALLOW_UNUSED_LOCAL(holder);\n\n  ExceptionState exception_state(isolate, ExceptionState::kSetterContext, \"TestObject\", \"locationWithPerWorldBindings\");\n  v8::Local<v8::Value> target;\n  if (!holder->Get(isolate->GetCurrentContext(), V8AtomicString(isolate, \"locationWithPerWorldBindings\"))\n      .ToLocal(&target)) {\n    return;\n  }\n  if (!target->IsObject()) {\n    exception_state.ThrowTypeError(\"The attribute value is not an object\");\n    return;\n  }\n  bool result;\n  if (!target.As<v8::Object>()->Set(\n          isolate->GetCurrentContext(),\n          V8AtomicString(isolate, \"href\"),\n          v8_value).To(&result)) {\n    return;\n  }\n  if (!result)\n    return;\n}\n",
        "target": 0
    },
    {
        "id": 3169,
        "func": "static unsigned long get_reaper_busy(pid_t task)\n{\n\tpid_t init = get_task_reaper_pid(task);\n\tchar *cgroup = NULL, *usage_str = NULL;\n\tunsigned long usage = 0;\n\n\tif (init == -1)\n\t\treturn 0;\n\n\tcgroup = get_pid_cgroup(task, \"cpuacct\");\n\tif (!cgroup)\n\t\tgoto out;\n\tif (!cgfs_get_value(\"cpuacct\", cgroup, \"cpuacct.usage\", &usage_str))\n\t\tgoto out;\n\tusage = strtoul(usage_str, NULL, 10);\n\tusage /= 100000000;\n\nout:\n\tfree(cgroup);\n\tfree(usage_str);\n\treturn usage;\n}",
        "target": 0
    },
    {
        "id": 3170,
        "func": "bool PrintMsg_Print_Params_IsEqual(\n    const PrintMsg_PrintPages_Params& oldParams,\n    const PrintMsg_PrintPages_Params& newParams) {\n  return PageLayoutIsEqual(oldParams, newParams) &&\n         oldParams.params.max_shrink == newParams.params.max_shrink &&\n         oldParams.params.min_shrink == newParams.params.min_shrink &&\n         oldParams.params.selection_only == newParams.params.selection_only &&\n         oldParams.params.supports_alpha_blend ==\n             newParams.params.supports_alpha_blend &&\n         oldParams.pages.size() == newParams.pages.size() &&\n         oldParams.params.print_to_pdf == newParams.params.print_to_pdf &&\n         oldParams.params.print_scaling_option ==\n             newParams.params.print_scaling_option &&\n         oldParams.params.display_header_footer ==\n             newParams.params.display_header_footer &&\n         oldParams.params.date == newParams.params.date &&\n         oldParams.params.title == newParams.params.title &&\n         oldParams.params.url == newParams.params.url &&\n         std::equal(oldParams.pages.begin(), oldParams.pages.end(),\n             newParams.pages.begin());\n}\n",
        "target": 0
    },
    {
        "id": 3171,
        "func": "static uint32_t fdctrl_read_data(FDCtrl *fdctrl)\n {\n     FDrive *cur_drv;\n     uint32_t retval = 0;\n    int pos;\n \n     cur_drv = get_cur_drv(fdctrl);\n     fdctrl->dsr &= ~FD_DSR_PWRDOWN;\n    if (!(fdctrl->msr & FD_MSR_RQM) || !(fdctrl->msr & FD_MSR_DIO)) {\n        FLOPPY_DPRINTF(\"error: controller not ready for reading\\n\");\n         return 0;\n     }\n     pos = fdctrl->data_pos;\n     if (fdctrl->msr & FD_MSR_NONDMA) {\n        pos %= FD_SECTOR_LEN;\n         if (pos == 0) {\n             if (fdctrl->data_pos != 0)\n                 if (!fdctrl_seek_to_next_sect(fdctrl, cur_drv)) {\n                    FLOPPY_DPRINTF(\"error seeking to next sector %d\\n\",\n                                   fd_sector(cur_drv));\n                    return 0;\n                }\n            if (blk_read(cur_drv->blk, fd_sector(cur_drv), fdctrl->fifo, 1)\n                < 0) {\n                FLOPPY_DPRINTF(\"error getting sector %d\\n\",\n                               fd_sector(cur_drv));\n                /* Sure, image size is too small... */\n                memset(fdctrl->fifo, 0, FD_SECTOR_LEN);\n            }\n        }\n    }\n    retval = fdctrl->fifo[pos];\n    if (++fdctrl->data_pos == fdctrl->data_len) {\n        fdctrl->data_pos = 0;\n        /* Switch from transfer mode to status mode\n         * then from status mode to command mode\n         */\n        if (fdctrl->msr & FD_MSR_NONDMA) {\n            fdctrl_stop_transfer(fdctrl, 0x00, 0x00, 0x00);\n        } else {\n            fdctrl_reset_fifo(fdctrl);\n            fdctrl_reset_irq(fdctrl);\n        }\n    }\n    FLOPPY_DPRINTF(\"data register: 0x%02x\\n\", retval);\n\n    return retval;\n}\n",
        "target": 1
    },
    {
        "id": 3172,
        "func": "  bool do_prevent_preload() { return prevent_preload_; }\n",
        "target": 0
    },
    {
        "id": 3173,
        "func": "GLint GLES2DecoderImpl::ComputeMaxSamples() {\n  GLint max_samples = 0;\n  DoGetIntegerv(GL_MAX_SAMPLES, &max_samples, 1);\n\n  if (feature_info_->IsWebGLContext() &&\n      feature_info_->feature_flags().nv_internalformat_sample_query) {\n    std::vector<GLint> temp;\n\n    auto minWithSamplesForFormat = [&](GLenum internalformat) {\n      temp.clear();\n      InternalFormatSampleCountsHelper(GL_RENDERBUFFER, internalformat, &temp);\n      max_samples = std::min(max_samples, temp[0]);\n    };\n\n\n    minWithSamplesForFormat(GL_RGBA8);\n    minWithSamplesForFormat(GL_SRGB8_ALPHA8);\n    minWithSamplesForFormat(GL_RGB10_A2);\n    minWithSamplesForFormat(GL_RGBA4);\n    minWithSamplesForFormat(GL_RGB5_A1);\n    minWithSamplesForFormat(GL_RGB8);\n    minWithSamplesForFormat(GL_RGB565);\n    minWithSamplesForFormat(GL_RG8);\n    minWithSamplesForFormat(GL_R8);\n  }\n\n  return max_samples;\n}\n",
        "target": 0
    },
    {
        "id": 3174,
        "func": "status_t MediaRecorder::initCheck()\n{\n return mMediaRecorder != 0 ? NO_ERROR : NO_INIT;\n}\n",
        "target": 0
    },
    {
        "id": 3175,
        "func": "Syncer::~Syncer() {}\n",
        "target": 0
    },
    {
        "id": 3176,
        "func": "void PDFiumEngine::AppendPage(PDFEngine* engine, int index) {\n  pages_[index]->Unload();\n  pages_[index]->set_calculated_links(false);\n  pp::Size curr_page_size = GetPageSize(index);\n  FPDFPage_Delete(doc_, index);\n  FPDF_ImportPages(doc_, static_cast<PDFiumEngine*>(engine)->doc(), \"1\", index);\n  pp::Size new_page_size = GetPageSize(index);\n  if (curr_page_size != new_page_size)\n    LoadPageInfo(true);\n  client_->Invalidate(GetPageScreenRect(index));\n}\n",
        "target": 0
    },
    {
        "id": 3177,
        "func": "WTF::PassRefPtr<WebCore::Frame> ewk_view_frame_create(Evas_Object* ewkView, Evas_Object* frame, const WTF::String& name, WebCore::HTMLFrameOwnerElement* ownerElement, const WebCore::KURL& url, const WTF::String& referrer)\n{\n    DBG(\"ewkView=%p, frame=%p, name=%s, ownerElement=%p, url=%s, referrer=%s\",\n        ewkView, frame, name.utf8().data(), ownerElement,\n        url.string().utf8().data(), referrer.utf8().data());\n\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, 0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, 0);\n\n    WTF::RefPtr<WebCore::Frame> coreFrame = _ewk_view_core_frame_new\n                                         (smartData, priv, ownerElement);\n    if (!coreFrame) {\n        ERR(\"Could not create child core frame '%s'\", name.utf8().data());\n        return 0;\n    }\n\n    if (!ewk_frame_child_add(frame, coreFrame, name, url, referrer)) {\n        ERR(\"Could not create child frame object '%s'\", name.utf8().data());\n        return 0;\n    }\n\n    if (!coreFrame->page() || !coreFrame->tree() || !coreFrame->tree()->parent())\n        return 0;\n\n    smartData->changed.frame_rect = true;\n    _ewk_view_smart_changed(smartData);\n\n    return coreFrame.release();\n}\n",
        "target": 0
    },
    {
        "id": 3178,
        "func": "    static void testTimeout(void* self)\n    {\n        CCLayerTreeHostTest* test = static_cast<CCLayerTreeHostTest*>(self);\n        if (!test->m_running)\n            return;\n        test->m_timedOut = true;\n        test->endTest();\n    }\n",
        "target": 1
    },
    {
        "id": 3179,
        "func": "void ASCIIHexStream::reset() {\n  str->reset();\n  buf = EOF;\n  eof = gFalse;\n}\n",
        "target": 0
    },
    {
        "id": 3180,
        "func": "void WebInspectorProxy::platformInspectedURLChanged(const String& url)\n{\n    m_client.inspectedURLChanged(this, url);\n\n    if (!m_inspectorWindow)\n        return;\n    GOwnPtr<gchar> title(g_strdup_printf(\"%s - %s\", _(\"Web Inspector\"), url.utf8().data()));\n    gtk_window_set_title(GTK_WINDOW(m_inspectorWindow), title.get());\n}\n",
        "target": 0
    },
    {
        "id": 3181,
        "func": "static int lex(struct cstate *g)\n{\n\tint quoted = nextrune(g);\n\tif (quoted) {\n\t\tswitch (g->yychar) {\n\t\tcase 'b': return L_WORD;\n\t\tcase 'B': return L_NWORD;\n\t\tcase 'd': newcclass(g); addranges_d(g); return L_CCLASS;\n\t\tcase 's': newcclass(g); addranges_s(g); return L_CCLASS;\n\t\tcase 'w': newcclass(g); addranges_w(g); return L_CCLASS;\n\t\tcase 'D': newcclass(g); addranges_d(g); return L_NCCLASS;\n\t\tcase 'S': newcclass(g); addranges_s(g); return L_NCCLASS;\n\t\tcase 'W': newcclass(g); addranges_w(g); return L_NCCLASS;\n\t\tcase '0': g->yychar = 0; return L_CHAR;\n\t\t}\n\t\tif (g->yychar >= '0' && g->yychar <= '9') {\n\t\t\tg->yychar -= '0';\n\t\t\tif (*g->source >= '0' && *g->source <= '9')\n\t\t\t\tg->yychar = g->yychar * 10 + *g->source++ - '0';\n\t\t\treturn L_REF;\n\t\t}\n\t\treturn L_CHAR;\n\t}\n\n\tswitch (g->yychar) {\n\tcase 0:\n\tcase '$': case ')': case '*': case '+':\n\tcase '.': case '?': case '^': case '|':\n\t\treturn g->yychar;\n\t}\n\n\tif (g->yychar == '{')\n\t\treturn lexcount(g);\n\tif (g->yychar == '[')\n\t\treturn lexclass(g);\n\tif (g->yychar == '(') {\n\t\tif (g->source[0] == '?') {\n\t\t\tif (g->source[1] == ':') {\n\t\t\t\tg->source += 2;\n\t\t\t\treturn L_NC;\n\t\t\t}\n\t\t\tif (g->source[1] == '=') {\n\t\t\t\tg->source += 2;\n\t\t\t\treturn L_PLA;\n\t\t\t}\n\t\t\tif (g->source[1] == '!') {\n\t\t\t\tg->source += 2;\n\t\t\t\treturn L_NLA;\n\t\t\t}\n\t\t}\n\t\treturn '(';\n\t}\n\n\treturn L_CHAR;\n}",
        "target": 0
    },
    {
        "id": 3182,
        "func": "static void rds6_tcp_tc_info(struct socket *sock, unsigned int len,\n\t\t\t     struct rds_info_iterator *iter,\n\t\t\t     struct rds_info_lengths *lens)\n{\n\tstruct rds6_info_tcp_socket tsinfo6;\n\tstruct rds_tcp_connection *tc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rds_tcp_tc_list_lock, flags);\n\n\tif (len / sizeof(tsinfo6) < rds6_tcp_tc_count)\n\t\tgoto out;\n\n\tlist_for_each_entry(tc, &rds_tcp_tc_list, t_list_item) {\n\t\tstruct sock *sk = tc->t_sock->sk;\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\ttsinfo6.local_addr = sk->sk_v6_rcv_saddr;\n\t\ttsinfo6.local_port = inet->inet_sport;\n\t\ttsinfo6.peer_addr = sk->sk_v6_daddr;\n\t\ttsinfo6.peer_port = inet->inet_dport;\n\n\t\ttsinfo6.hdr_rem = tc->t_tinc_hdr_rem;\n\t\ttsinfo6.data_rem = tc->t_tinc_data_rem;\n\t\ttsinfo6.last_sent_nxt = tc->t_last_sent_nxt;\n\t\ttsinfo6.last_expected_una = tc->t_last_expected_una;\n\t\ttsinfo6.last_seen_una = tc->t_last_seen_una;\n\n\t\trds_info_copy(iter, &tsinfo6, sizeof(tsinfo6));\n\t}\n\nout:\n\tlens->nr = rds6_tcp_tc_count;\n\tlens->each = sizeof(tsinfo6);\n\n\tspin_unlock_irqrestore(&rds_tcp_tc_list_lock, flags);\n}",
        "target": 0
    },
    {
        "id": 3183,
        "func": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\n\t/* Build the IP header. */\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\t/* Send it out. */\n\treturn ip_local_out(skb);\n}",
        "target": 1
    },
    {
        "id": 3184,
        "func": "void GLES2DecoderImpl::DoSubscribeValueCHROMIUM(GLenum target,\n                                                GLenum subscription) {\n  if (!CheckCurrentValuebuffer(\"glSubscribeValueCHROMIUM\")) {\n    return;\n  }\n  state_.bound_valuebuffer.get()->AddSubscription(subscription);\n}\n",
        "target": 0
    },
    {
        "id": 3185,
        "func": "void SVGDocumentExtensions::addSVGRootWithRelativeLengthDescendents(SVGSVGElement* svgRoot)\n{\n    ASSERT(!m_inRelativeLengthSVGRootsInvalidation);\n    m_relativeLengthSVGRoots.add(svgRoot);\n}\n",
        "target": 0
    },
    {
        "id": 3186,
        "func": "void InspectorNetworkAgent::DidBlockRequest(\n    ExecutionContext* execution_context,\n     const ResourceRequest& request,\n     DocumentLoader* loader,\n     const FetchInitiatorInfo& initiator_info,\n    ResourceRequestBlockedReason reason) {\n   unsigned long identifier = CreateUniqueIdentifier();\n   WillSendRequestInternal(execution_context, identifier, loader, request,\n                          ResourceResponse(), initiator_info);\n \n   String request_id = IdentifiersFactory::RequestId(identifier);\n   String protocol_reason = BuildBlockedReason(reason);\n  GetFrontend()->loadingFailed(\n      request_id, MonotonicallyIncreasingTime(),\n      InspectorPageAgent::ResourceTypeJson(\n          resources_data_->GetResourceType(request_id)),\n      String(), false, protocol_reason);\n}\n",
        "target": 1
    },
    {
        "id": 3187,
        "func": "void ThreadHeap::CompleteSweep() {\n  static_assert(BlinkGC::kEagerSweepArenaIndex == 0,\n                \"Eagerly swept arenas must be processed first.\");\n  for (int i = 0; i < BlinkGC::kNumberOfArenas; i++)\n    arenas_[i]->CompleteSweep();\n}\n",
        "target": 0
    },
    {
        "id": 3188,
        "func": "void MemBackendImpl::EvictIfNeeded() {\n  if (current_size_ <= max_size_)\n    return;\n\n  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);\n\n   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();\n   while (current_size_ > target_size && entry != lru_list_.end()) {\n     MemEntryImpl* to_doom = entry->value();\n\n    do {\n      entry = entry->next();\n      // It's possible that entry now points to a child of to_doom, and the\n      // parent is about to be deleted. Skip past any child entries.\n    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);\n\n     if (!to_doom->InUse())\n       to_doom->Doom();\n   }\n}\n",
        "target": 0
    },
    {
        "id": 3189,
        "func": "int bpf_analyzer(struct bpf_prog *prog, const struct bpf_ext_analyzer_ops *ops,\n\t\t void *priv)\n{\n\tstruct bpf_verifier_env *env;\n\tint ret;\n\n\tenv = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\tenv->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *\n\t\t\t\t     prog->len);\n\tret = -ENOMEM;\n\tif (!env->insn_aux_data)\n\t\tgoto err_free_env;\n\tenv->prog = prog;\n\tenv->analyzer_ops = ops;\n\tenv->analyzer_priv = priv;\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tlog_level = 0;\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct bpf_verifier_state_list *),\n\t\t\t\t       GFP_KERNEL);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = do_check(env);\n\nskip_full_check:\n\twhile (pop_stack(env, NULL) >= 0);\n\tfree_states(env);\n\n\tmutex_unlock(&bpf_verifier_lock);\n\tvfree(env->insn_aux_data);\nerr_free_env:\n\tkfree(env);\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 3190,
        "func": "GF_Err href_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextHyperTextBox*p = (GF_TextHyperTextBox*)a;\n\tgf_isom_box_dump_start(a, \"TextHyperTextBox\", trace);\n\tfprintf(trace, \"startcharoffset=\\\"%d\\\" endcharoffset=\\\"%d\\\" URL=\\\"%s\\\" altString=\\\"%s\\\">\\n\", p->startcharoffset, p->endcharoffset, p->URL ? p->URL : \"NULL\", p->URL_hint ? p->URL_hint : \"NULL\");\n\tgf_isom_box_dump_done(\"TextHyperTextBox\", a, trace);\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 3191,
        "func": "void DownloadItemImpl::DeleteFile(const base::Callback<void(bool)>& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  if (GetState() != DownloadItem::COMPLETE) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DeleteDownloadedFileDone,\n                       base::WeakPtr<DownloadItemImpl>(), callback, false));\n    return;\n  }\n  if (GetFullPath().empty() || file_externally_removed_) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DeleteDownloadedFileDone,\n                       base::WeakPtr<DownloadItemImpl>(), callback, true));\n    return;\n  }\n  base::PostTaskAndReplyWithResult(\n      GetDownloadTaskRunner().get(), FROM_HERE,\n      base::Bind(&DeleteDownloadedFile, GetFullPath()),\n      base::Bind(&DeleteDownloadedFileDone, weak_ptr_factory_.GetWeakPtr(),\n                 callback));\n}\n",
        "target": 0
    },
    {
        "id": 3192,
        "func": "void AfterTranslateInfoBar::RunMenu(views::View* source,\n                                    const gfx::Point& pt) {\n  if (source == original_language_menu_button_) {\n    if (!original_language_menu_.get()) {\n      original_language_menu_.reset(\n          new views::Menu2(&original_language_menu_model_));\n    }\n    original_language_menu_->RunMenuAt(pt, views::Menu2::ALIGN_TOPRIGHT);\n  } else if (source == target_language_menu_button_) {\n      if (!target_language_menu_.get()) {\n        target_language_menu_.reset(\n            new views::Menu2(&target_language_menu_model_));\n      }\n      target_language_menu_->RunMenuAt(pt, views::Menu2::ALIGN_TOPRIGHT);\n  } else if (source == options_menu_button_) {\n    if (!options_menu_.get())\n      options_menu_.reset(new views::Menu2(&options_menu_model_));\n    options_menu_->RunMenuAt(pt, views::Menu2::ALIGN_TOPRIGHT);\n  } else {\n    NOTREACHED();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3193,
        "func": "u32 acpi_ns_opens_scope(acpi_object_type type)\n{\n\tACPI_FUNCTION_ENTRY();\n\n\tif (type > ACPI_TYPE_LOCAL_MAX) {\n\n\t\t/* type code out of range  */\n\n\t\tACPI_WARNING((AE_INFO, \"Invalid Object Type 0x%X\", type));\n\t\treturn (ACPI_NS_NORMAL);\n\t}\n\n\treturn (((u32)acpi_gbl_ns_properties[type]) & ACPI_NS_NEWSCOPE);\n}",
        "target": 0
    },
    {
        "id": 3194,
        "func": "  FakeLoadingPredictorKeyValueTable() : LoadingPredictorKeyValueTable<T>(\"\") {}\n",
        "target": 0
    },
    {
        "id": 3195,
        "func": "static inline int ipv6_addr_type(const struct in6_addr *addr)\n{\n\treturn __ipv6_addr_type(addr) & 0xffff;\n}",
        "target": 0
    },
    {
        "id": 3196,
        "func": "void WebBluetoothServiceImpl::OnGetDeviceSuccess(\n    RequestDeviceCallback callback,\n    blink::mojom::WebBluetoothRequestDeviceOptionsPtr options,\n    const std::string& device_address) {\n  device_chooser_controller_.reset();\n\n  const device::BluetoothDevice* const device =\n      GetAdapter()->GetDevice(device_address);\n  if (device == nullptr) {\n    DVLOG(1) << \"Device \" << device_address << \" no longer in adapter\";\n    RecordRequestDeviceOutcome(UMARequestDeviceOutcome::CHOSEN_DEVICE_VANISHED);\n    std::move(callback).Run(\n        blink::mojom::WebBluetoothResult::CHOSEN_DEVICE_VANISHED,\n        nullptr /* device */);\n    return;\n  }\n\n  const WebBluetoothDeviceId device_id =\n      allowed_devices().AddDevice(device_address, options);\n\n  DVLOG(1) << \"Device: \" << device->GetNameForDisplay();\n\n  blink::mojom::WebBluetoothDevicePtr device_ptr =\n      blink::mojom::WebBluetoothDevice::New();\n  device_ptr->id = device_id;\n  device_ptr->name = device->GetName();\n\n  RecordRequestDeviceOutcome(UMARequestDeviceOutcome::SUCCESS);\n  std::move(callback).Run(blink::mojom::WebBluetoothResult::SUCCESS,\n                          std::move(device_ptr));\n}\n",
        "target": 0
    },
    {
        "id": 3197,
        "func": "void lock_sock_nested(struct sock *sk, int subclass)\n{\n\tmight_sleep();\n\tspin_lock_bh(&sk->sk_lock.slock);\n\tif (sk->sk_lock.owned)\n\t\t__lock_sock(sk);\n\tsk->sk_lock.owned = 1;\n\tspin_unlock(&sk->sk_lock.slock);\n\t/*\n\t * The sk_lock has mutex_lock() semantics here:\n\t */\n\tmutex_acquire(&sk->sk_lock.dep_map, subclass, 0, _RET_IP_);\n\tlocal_bh_enable();\n}",
        "target": 0
    },
    {
        "id": 3198,
        "func": "void RegisterOrRemovePreviousRunMetricsFile(\n    bool metrics_reporting_enabled,\n    const base::FilePath& dir,\n    base::StringPiece metrics_name,\n    metrics::FileMetricsProvider::SourceAssociation association,\n    metrics::FileMetricsProvider* file_metrics_provider) {\n  base::FilePath metrics_file;\n  base::GlobalHistogramAllocator::ConstructFilePaths(\n      dir, metrics_name, &metrics_file, nullptr, nullptr);\n\n  if (metrics_reporting_enabled) {\n    file_metrics_provider->RegisterSource(metrics::FileMetricsProvider::Params(\n        metrics_file,\n        metrics::FileMetricsProvider::SOURCE_HISTOGRAMS_ATOMIC_FILE,\n        association, metrics_name));\n  } else {\n    base::PostTaskWithTraits(\n        FROM_HERE,\n        {base::MayBlock(), base::TaskPriority::BEST_EFFORT,\n         base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},\n        base::BindOnce(base::IgnoreResult(&base::DeleteFile), metrics_file,\n                       /*recursive=*/false));\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3199,
        "func": "lldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n\n    tlen = len;\n    tptr = pptr;\n\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n\n    /*\n     * The OID is optional.\n     */\n    if (tlen) {\n        oid_len = *tptr;\n\n        if (tlen < oid_len) {\n            return 0;\n        }\n        if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n\n    return 1;\n}",
        "target": 1
    },
    {
        "id": 3200,
        "func": "entry_guard_has_higher_priority(entry_guard_t *a, entry_guard_t *b)\n{\n  tor_assert(a && b);\n  if (a == b)\n    return 0;\n\n  /* Confirmed is always better than unconfirmed; lower index better\n     than higher */\n  if (a->confirmed_idx < 0) {\n    if (b->confirmed_idx >= 0)\n      return 0;\n  } else {\n    if (b->confirmed_idx < 0)\n      return 1;\n\n    /* Lower confirmed_idx is better than higher. */\n    return (a->confirmed_idx < b->confirmed_idx);\n  }\n\n  /* If we reach this point, both are unconfirmed. If one is pending, it\n   * has higher priority. */\n  if (a->is_pending) {\n    if (! b->is_pending)\n      return 1;\n\n    /* Both are pending: earlier last_tried_connect wins. */\n    return a->last_tried_to_connect < b->last_tried_to_connect;\n  } else {\n    if (b->is_pending)\n      return 0;\n\n    /* Neither is pending: priorities are equal. */\n    return 0;\n  }\n}",
        "target": 0
    },
    {
        "id": 3201,
        "func": "megasas_fw_crash_state_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", instance->fw_crash_state);\n}",
        "target": 0
    },
    {
        "id": 3202,
        "func": " virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video,\n                                  libvpx_test::Encoder *encoder) {\n if (video->frame() == kStepDownFrame) {\n struct vpx_scaling_mode mode = {VP8E_FOURFIVE, VP8E_THREEFIVE};\n      encoder->Control(VP8E_SET_SCALEMODE, &mode);\n }\n if (video->frame() == kStepUpFrame) {\n struct vpx_scaling_mode mode = {VP8E_NORMAL, VP8E_NORMAL};\n      encoder->Control(VP8E_SET_SCALEMODE, &mode);\n }\n }\n",
        "target": 0
    },
    {
        "id": 3203,
        "func": "RequestQuery ParseQuery(const GURL& url) {\n  RequestQuery queries;\n  for (QueryIterator it(url); !it.IsAtEnd(); it.Advance()) {\n    std::string unescaped_query;\n    UnescapeBinaryURLComponent(\n        it.GetKey(), UnescapeRule::REPLACE_PLUS_WITH_SPACE, &unescaped_query);\n    queries[unescaped_query].push_back(it.GetUnescapedValue());\n  }\n  return queries;\n}\n",
        "target": 0
    },
    {
        "id": 3204,
        "func": "DataReductionProxyConfigServiceClient::DataReductionProxyConfigServiceClient(\n    const net::BackoffEntry::Policy& backoff_policy,\n    DataReductionProxyRequestOptions* request_options,\n    DataReductionProxyMutableConfigValues* config_values,\n    DataReductionProxyConfig* config,\n    DataReductionProxyIOData* io_data,\n    network::NetworkConnectionTracker* network_connection_tracker,\n    ConfigStorer config_storer)\n    : request_options_(request_options),\n      config_values_(config_values),\n      config_(config),\n      io_data_(io_data),\n      network_connection_tracker_(network_connection_tracker),\n      config_storer_(config_storer),\n      backoff_policy_(backoff_policy),\n      backoff_entry_(&backoff_policy_),\n      config_service_url_(util::AddApiKeyToUrl(params::GetConfigServiceURL())),\n      enabled_(false),\n      remote_config_applied_(false),\n#if defined(OS_ANDROID)\n      foreground_fetch_pending_(false),\n#endif\n      previous_request_failed_authentication_(false),\n      failed_attempts_before_success_(0),\n      fetch_in_progress_(false),\n      client_config_override_used_(false) {\n  DCHECK(request_options);\n  DCHECK(config_values);\n   DCHECK(config);\n   DCHECK(io_data);\n   DCHECK(config_service_url_.is_valid());\n \n   const base::CommandLine& command_line =\n       *base::CommandLine::ForCurrentProcess();\n  client_config_override_ = command_line.GetSwitchValueASCII(\n      switches::kDataReductionProxyServerClientConfig);\n\n  thread_checker_.DetachFromThread();\n}\n",
        "target": 1
    },
    {
        "id": 3205,
        "func": "static int floppy_revalidate(struct gendisk *disk)\n{\n\tint drive = (long)disk->private_data;\n\tint cf;\n\tint res = 0;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive)) {\n\t\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t\t \"VFS: revalidate called on non-open device.\\n\"))\n\t\t\treturn -EFAULT;\n\n\t\tlock_fdc(drive, false);\n\t\tcf = (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t\t      test_bit(FD_VERIFY_BIT, &UDRS->flags));\n\t\tif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {\n\t\t\tprocess_fd_request();\t/*already done by another thread */\n\t\t\treturn 0;\n\t\t}\n\t\tUDRS->maxblock = 0;\n\t\tUDRS->maxtrack = 0;\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t\tclear_bit(drive, &fake_change);\n\t\tclear_bit(FD_DISK_CHANGED_BIT, &UDRS->flags);\n\t\tif (cf)\n\t\t\tUDRS->generation++;\n\t\tif (drive_no_geom(drive)) {\n\t\t\t/* auto-sensing */\n\t\t\tres = __floppy_read_block_0(opened_bdev[drive], drive);\n\t\t} else {\n\t\t\tif (cf)\n\t\t\t\tpoll_drive(false, FD_RAW_NEED_DISK);\n\t\t\tprocess_fd_request();\n\t\t}\n\t}\n\tset_capacity(disk, floppy_sizes[UDRS->fd_device]);\n\treturn res;\n}",
        "target": 0
    },
    {
        "id": 3206,
        "func": "static char *tcm_loop_parse_pr_out_transport_id(\n\tstruct se_portal_group *se_tpg,\n\tconst char *buf,\n\tu32 *out_tid_len,\n\tchar **port_nexus_ptr)\n{\n\tstruct tcm_loop_tpg *tl_tpg =\n\t\t\t(struct tcm_loop_tpg *)se_tpg->se_tpg_fabric_ptr;\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\t\t\tport_nexus_ptr);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\t\t\tport_nexus_ptr);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\t\t\tport_nexus_ptr);\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown tl_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tl_hba->tl_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\n\t\t\tport_nexus_ptr);\n}",
        "target": 0
    },
    {
        "id": 3207,
        "func": "dissect_SPOOL_PRINTER_INFO(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t   proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tproto_tree *subtree;\n\tguint32 level;\n\tproto_tree *item;\n\n\tsubtree = proto_tree_add_subtree(\n\t\ttree, tvb, offset, 0, ett_SPOOL_PRINTER_INFO_LEVEL, &item, \"Spool printer info level\");\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, subtree, di, drep, hf_level, &level);\n\n\tswitch(level) {\n\tcase 3: {\n\t\tguint32 devmode_ptr, secdesc_ptr;\n\n\t\t/* I can't seem to get this working with the correct\n\t\t   dissect_ndr_pointer() function so let's cheat and\n\t\t   dissect the pointers by hand. )-: */\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_spool_printer_info_devmode_ptr,\n\t\t\t&devmode_ptr);\n\n\t\toffset = dissect_ndr_uint32(\n\t\t\ttvb, offset, pinfo, subtree, di, drep,\n\t\t\thf_spool_printer_info_secdesc_ptr,\n\t\t\t&secdesc_ptr);\n\n\t\tif (devmode_ptr)\n\t\t\toffset = dissect_DEVMODE_CTR(\n\t\t\t\ttvb, offset, pinfo, subtree, di, drep);\n\n\t\tif (secdesc_ptr)\n\t\t\toffset = dissect_SEC_DESC_BUF(\n\t\t\t\ttvb, offset, pinfo, subtree, di, drep);\n\n\tbreak;\n\t}\n\tcase 2:\n\tdefault:\n\t\texpert_add_info_format(pinfo, item, &ei_spool_printer_info_level, \"Unknown spool printer info level %d\", level);\n\t\tbreak;\n\t}\n\n\treturn offset;\n}",
        "target": 0
    },
    {
        "id": 3208,
        "func": "Document* BaseAudioContext::GetDocument() const {\n  return To<Document>(GetExecutionContext());\n}\n",
        "target": 0
    },
    {
        "id": 3209,
        "func": "GF_Err sidx_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SegmentIndexBox *ptr = (GF_SegmentIndexBox*) s;\n\n\tptr->reference_ID = gf_bs_read_u32(bs);\n\tptr->timescale = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 8);\n\n\tif (ptr->version==0) {\n\t\tptr->earliest_presentation_time = gf_bs_read_u32(bs);\n\t\tptr->first_offset = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t} else {\n\t\tptr->earliest_presentation_time = gf_bs_read_u64(bs);\n\t\tptr->first_offset = gf_bs_read_u64(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t}\n\tgf_bs_read_u16(bs); /* reserved */\n\tptr->nb_refs = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tptr->refs = gf_malloc(sizeof(GF_SIDXReference)*ptr->nb_refs);\n\tfor (i=0; i<ptr->nb_refs; i++) {\n\t\tptr->refs[i].reference_type = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].reference_size = gf_bs_read_int(bs, 31);\n\t\tptr->refs[i].subsegment_duration = gf_bs_read_u32(bs);\n\t\tptr->refs[i].starts_with_SAP = gf_bs_read_int(bs, 1);\n\t\tptr->refs[i].SAP_type = gf_bs_read_int(bs, 3);\n\t\tptr->refs[i].SAP_delta_time = gf_bs_read_int(bs, 28);\n\n\t\tISOM_DECREASE_SIZE(ptr, 12);\n\t}\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 3210,
        "func": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\n\t}\n\tput_io_context(ioc);\n}",
        "target": 1
    },
    {
        "id": 3211,
        "func": "PassRefPtr<TypeBuilder::Page::Frame> InspectorPageAgent::buildObjectForFrame(Frame* frame)\n{\n    RefPtr<TypeBuilder::Page::Frame> frameObject = TypeBuilder::Page::Frame::create()\n        .setId(frameId(frame))\n        .setLoaderId(loaderId(frame->loader().documentLoader()))\n        .setUrl(urlWithoutFragment(frame->document()->url()).string())\n        .setMimeType(frame->loader().documentLoader()->responseMIMEType())\n        .setSecurityOrigin(frame->document()->securityOrigin()->toRawString());\n    if (frame->tree().parent())\n        frameObject->setParentId(frameId(frame->tree().parent()));\n    if (frame->ownerElement()) {\n        AtomicString name = frame->ownerElement()->getNameAttribute();\n        if (name.isEmpty())\n            name = frame->ownerElement()->getAttribute(HTMLNames::idAttr);\n        frameObject->setName(name);\n    }\n\n    return frameObject;\n}\n",
        "target": 0
    },
    {
        "id": 3212,
        "func": "struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttpgt_str += 5; /* Skip ahead of \"tpgt_\" */\n\ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\n\tif (tpgt > TL_TPGS_PER_HBA) {\n\t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n\t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\t/*\n\t * Register the tl_tpg as a emulated SAS TCM Target Endpoint\n\t */\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\n\treturn &tl_tpg->tl_se_tpg;\n}",
        "target": 1
    },
    {
        "id": 3213,
        "func": "void PreconnectManager::FinishPreresolveJob(PreresolveJobId job_id,\n                                            bool success) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  PreresolveJob* job = preresolve_jobs_.Lookup(job_id);\n  DCHECK(job);\n\n  bool need_preconnect = success && job->need_preconnect();\n  if (need_preconnect) {\n    PreconnectUrl(job->url, job->num_sockets, job->allow_credentials,\n                  job->network_isolation_key);\n   }\n \n   PreresolveInfo* info = job->info;\n  if (info)\n    info->stats->requests_stats.emplace_back(job->url, need_preconnect);\n   preresolve_jobs_.Remove(job_id);\n   --inflight_preresolves_count_;\n   if (info) {\n    DCHECK_LE(1u, info->inflight_count);\n    --info->inflight_count;\n  }\n  if (info && info->is_done())\n    AllPreresolvesForUrlFinished(info);\n  TryToLaunchPreresolveJobs();\n}\n",
        "target": 1
    },
    {
        "id": 3214,
        "func": "num_entries(char *bufstart, char *end_of_buf, char **lastentry, size_t size)\n{\n\tint len;\n\tunsigned int entrycount = 0;\n\tunsigned int next_offset = 0;\n\tchar *entryptr;\n\tFILE_DIRECTORY_INFO *dir_info;\n\n\tif (bufstart == NULL)\n\t\treturn 0;\n\n\tentryptr = bufstart;\n\n\twhile (1) {\n\t\tif (entryptr + next_offset < entryptr ||\n\t\t    entryptr + next_offset > end_of_buf ||\n\t\t    entryptr + next_offset + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"malformed search entry would overflow\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tentryptr = entryptr + next_offset;\n\t\tdir_info = (FILE_DIRECTORY_INFO *)entryptr;\n\n\t\tlen = le32_to_cpu(dir_info->FileNameLength);\n\t\tif (entryptr + len < entryptr ||\n\t\t    entryptr + len > end_of_buf ||\n\t\t    entryptr + len + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"directory entry name would overflow frame end of buf %p\\n\",\n\t\t\t\t end_of_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\t*lastentry = entryptr;\n\t\tentrycount++;\n\n\t\tnext_offset = le32_to_cpu(dir_info->NextEntryOffset);\n\t\tif (!next_offset)\n\t\t\tbreak;\n\t}\n\n\treturn entrycount;\n}",
        "target": 0
    },
    {
        "id": 3215,
        "func": "static const char *ext4_decode_error(struct super_block *sb, int errno,\n\t\t\t\t     char nbuf[16])\n{\n\tchar *errstr = NULL;\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n\t\t\terrstr = \"Journal has aborted\";\n\t\telse\n\t\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tdefault:\n\t\t/* If the caller passed in an extra buffer for unknown\n\t\t * errors, textualise them now.  Else we just return\n\t\t * NULL. */\n\t\tif (nbuf) {\n\t\t\t/* Check for truncated error codes... */\n\t\t\tif (snprintf(nbuf, 16, \"error %d\", -errno) >= 0)\n\t\t\t\terrstr = nbuf;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
        "target": 0
    },
    {
        "id": 3216,
        "func": "void SkiaOutputSurfaceImpl::OnGpuVSync(base::TimeTicks timebase,\n                                       base::TimeDelta interval) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  if (gpu_vsync_callback_)\n    gpu_vsync_callback_.Run(timebase, interval);\n}\n",
        "target": 0
    },
    {
        "id": 3217,
        "func": "put_fields_property(struct ofpbuf *reply,\n                    const struct mf_bitmap *fields,\n                    const struct mf_bitmap *masks,\n                    enum ofp13_table_feature_prop_type property,\n                    enum ofp_version version)\n{\n    size_t start_ofs;\n    int field;\n\n    start_ofs = ofpprop_start(reply, property);\n    BITMAP_FOR_EACH_1 (field, MFF_N_IDS, fields->bm) {\n        nx_put_header(reply, field, version,\n                      masks && bitmap_is_set(masks->bm, field));\n    }\n    ofpprop_end(reply, start_ofs);\n}\n",
        "target": 0
    },
    {
        "id": 3218,
        "func": "bool WebGLRenderingContextBase::ExtensionSupportedAndAllowed(\n    const ExtensionTracker* tracker) {\n  if (tracker->Draft() &&\n      !RuntimeEnabledFeatures::WebGLDraftExtensionsEnabled())\n    return false;\n  if (!tracker->Supported(this))\n    return false;\n  if (disabled_extensions_.Contains(String(tracker->ExtensionName())))\n    return false;\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 3219,
        "func": "ScriptPromise Document::createCSSStyleSheet(ScriptState* script_state,\n                                            const String& text,\n                                            const CSSStyleSheetInit& options,\n                                            ExceptionState& exception_state) {\n  CSSStyleSheet* sheet = CSSStyleSheet::Create(*this, options, exception_state);\n  sheet->SetText(text);\n  sheet->SetAssociatedDocument(this);\n  return ScriptPromise::Cast(script_state,\n                             ScriptValue::From(script_state, sheet));\n}\n",
        "target": 0
    },
    {
        "id": 3220,
        "func": "Address ThreadHeap::CheckAndMarkPointer(MarkingVisitor* visitor,\n                                        Address address) {\n  DCHECK(thread_state_->InAtomicMarkingPause());\n\n#if !DCHECK_IS_ON()\n  if (address_cache_->Lookup(address))\n    return nullptr;\n#endif\n\n  if (BasePage* page = LookupPageForAddress(address)) {\n#if DCHECK_IS_ON()\n    DCHECK(page->Contains(address));\n#endif\n    DCHECK(!address_cache_->Lookup(address));\n    DCHECK(&visitor->Heap() == &page->Arena()->GetThreadState()->Heap());\n    visitor->ConservativelyMarkAddress(page, address);\n    return address;\n  }\n\n#if !DCHECK_IS_ON()\n  address_cache_->AddEntry(address);\n#else\n  if (!address_cache_->Lookup(address))\n    address_cache_->AddEntry(address);\n#endif\n  return nullptr;\n}\n",
        "target": 0
    },
    {
        "id": 3221,
        "func": "static int nfs4_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\terr = nfs4_set_lock_state(state, request);\n\tif (err != 0)\n\t\treturn err;\n\tdo {\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, 0);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3222,
        "func": "void RenderView::DidStartLoadingForPlugin() {\n  didStartLoading();\n}\n",
        "target": 0
    },
    {
        "id": 3223,
        "func": "InfoBar* ExtensionInfoBarDelegate::CreateInfoBar() {\n  return new ExtensionInfoBar(this);\n}\n",
        "target": 0
    },
    {
        "id": 3224,
        "func": "sctp_disposition_t sctp_sf_do_4_C(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  const sctp_subtype_t type,\n\t\t\t\t  void *arg,\n\t\t\t\t  sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* RFC 2960 6.10 Bundling\n\t *\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_COMPLETE chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* RFC 2960 10.2 SCTP-to-ULP\n\t *\n\t * H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t/* Upon reception of the SHUTDOWN COMPLETE chunk the endpoint\n\t * will verify that it is in SHUTDOWN-ACK-SENT state, if it is\n\t * not the chunk should be discarded. If the endpoint is in\n\t * the SHUTDOWN-ACK-SENT state the endpoint should stop the\n\t * T2-shutdown timer and remove all knowledge of the\n\t * association (and thus the association enters the CLOSED\n\t * state).\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}",
        "target": 0
    },
    {
        "id": 3225,
        "func": "void UpdateTargetInfoAvPairs(bool is_mic_enabled,\n                             bool is_epa_enabled,\n                             const std::string& channel_bindings,\n                             const std::string& spn,\n                             std::vector<AvPair>* av_pairs,\n                             uint64_t* server_timestamp,\n                             size_t* target_info_len) {\n  *server_timestamp = UINT64_MAX;\n  *target_info_len = 0;\n\n  bool need_flags_added = is_mic_enabled;\n  for (AvPair& pair : *av_pairs) {\n    *target_info_len += pair.avlen + kAvPairHeaderLen;\n    switch (pair.avid) {\n      case TargetInfoAvId::kFlags:\n        if (is_mic_enabled) {\n          pair.flags = pair.flags | TargetInfoAvFlags::kMicPresent;\n        }\n\n        need_flags_added = false;\n        break;\n      case TargetInfoAvId::kTimestamp:\n        *server_timestamp = pair.timestamp;\n        break;\n      case TargetInfoAvId::kEol:\n      case TargetInfoAvId::kChannelBindings:\n      case TargetInfoAvId::kTargetName:\n        NOTREACHED();\n        break;\n      default:\n        break;\n    }\n  }\n\n  if (need_flags_added) {\n    DCHECK(is_mic_enabled);\n    AvPair flags_pair(TargetInfoAvId::kFlags, sizeof(uint32_t));\n    flags_pair.flags = TargetInfoAvFlags::kMicPresent;\n\n    av_pairs->push_back(flags_pair);\n    *target_info_len += kAvPairHeaderLen + flags_pair.avlen;\n  }\n\n  if (is_epa_enabled) {\n    std::vector<uint8_t> channel_bindings_hash(kChannelBindingsHashLen, 0);\n \n     if (!channel_bindings.empty()) {\n      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);\n     }\n \n     av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,\n                           std::move(channel_bindings_hash));\n\n    base::string16 spn16 = base::UTF8ToUTF16(spn);\n    NtlmBufferWriter spn_writer(spn16.length() * 2);\n    bool spn_writer_result =\n        spn_writer.WriteUtf16String(spn16) && spn_writer.IsEndOfBuffer();\n    DCHECK(spn_writer_result);\n\n    av_pairs->emplace_back(TargetInfoAvId::kTargetName, spn_writer.Pass());\n\n    *target_info_len +=\n        (2 * kAvPairHeaderLen) + kChannelBindingsHashLen + (spn16.length() * 2);\n  }\n\n  *target_info_len += kAvPairHeaderLen;\n}\n",
        "target": 1
    },
    {
        "id": 3226,
        "func": "void PushMessagingServiceImpl::DidHandleMessage(\n    const std::string& app_id,\n    const base::Closure& message_handled_closure) {\n  auto in_flight_iterator = in_flight_message_deliveries_.find(app_id);\n  DCHECK(in_flight_iterator != in_flight_message_deliveries_.end());\n\n  in_flight_message_deliveries_.erase(in_flight_iterator);\n\n#if BUILDFLAG(ENABLE_BACKGROUND)\n  if (in_flight_message_deliveries_.empty())\n    in_flight_keep_alive_.reset();\n#endif\n \n   message_handled_closure.Run();\n \n#if defined(OS_ANDROID)\n  chrome::android::Java_PushMessagingServiceObserver_onMessageHandled(\n      base::android::AttachCurrentThread());\n#endif\n }\n",
        "target": 0
    },
    {
        "id": 3227,
        "func": "void ObserverOnLogoAvailable(LogoObserver* observer,\n                             bool from_cache,\n                             LogoCallbackReason type,\n                             const base::Optional<Logo>& logo) {\n  switch (type) {\n    case LogoCallbackReason::DISABLED:\n    case LogoCallbackReason::CANCELED:\n    case LogoCallbackReason::FAILED:\n      break;\n    case LogoCallbackReason::REVALIDATED:\n      break;\n    case LogoCallbackReason::DETERMINED:\n      observer->OnLogoAvailable(logo ? &logo.value() : nullptr, from_cache);\n      break;\n  }\n  if (!from_cache) {\n    observer->OnObserverRemoved();\n  }\n}\n",
        "target": 1
    },
    {
        "id": 3228,
        "func": "bool AppCacheDatabase::FindCache(int64_t cache_id, CacheRecord* record) {\n  DCHECK(record);\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, group_id, online_wildcard, update_time, cache_size\"\n       \" FROM Caches WHERE cache_id = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindInt64(0, cache_id);\n\n  if (!statement.Step())\n    return false;\n\n  ReadCacheRecord(statement, record);\n  return true;\n}\n",
        "target": 1
    },
    {
        "id": 3229,
        "func": "int FS_LoadStack( void )\n{\n\treturn fs_loadStack;\n}\n",
        "target": 0
    },
    {
        "id": 3230,
        "func": "void GLES2DecoderImpl::DoReleaseTexImage2DCHROMIUM(\n    GLenum target, GLint image_id) {\n  TRACE_EVENT0(\"gpu\", \"GLES2DecoderImpl::DoReleaseTexImage2DCHROMIUM\");\n\n  TextureRef* texture_ref =\n      texture_manager()->GetTextureInfoForTargetUnlessDefault(&state_, target);\n  if (!texture_ref) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION,\n        \"glReleaseTexImage2DCHROMIUM\", \"no texture bound\");\n    return;\n  }\n\n  gl::GLImage* image = image_manager()->LookupImage(image_id);\n  if (!image) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION,\n        \"glReleaseTexImage2DCHROMIUM\", \"no image found with the given ID\");\n    return;\n  }\n\n  Texture::ImageState image_state;\n\n  if (texture_ref->texture()->GetLevelImage(target, 0, &image_state) != image)\n    return;\n\n  if (image_state == Texture::BOUND) {\n    ScopedGLErrorSuppressor suppressor(\n        \"GLES2DecoderImpl::DoReleaseTexImage2DCHROMIUM\", GetErrorState());\n\n    image->ReleaseTexImage(target);\n    texture_manager()->SetLevelInfo(texture_ref, target, 0, GL_RGBA, 0, 0, 1, 0,\n                                    GL_RGBA, GL_UNSIGNED_BYTE, gfx::Rect());\n  }\n\n  texture_manager()->SetLevelImage(texture_ref, target, 0, nullptr,\n                                   Texture::UNBOUND);\n}\n",
        "target": 0
    },
    {
        "id": 3231,
        "func": "static void configureRequest(\n    FetchRequest& request,\n    ImageLoader::BypassMainWorldBehavior bypassBehavior,\n    Element& element,\n    const ClientHintsPreferences& clientHintsPreferences) {\n  if (bypassBehavior == ImageLoader::BypassMainWorldCSP)\n    request.setContentSecurityCheck(DoNotCheckContentSecurityPolicy);\n\n  CrossOriginAttributeValue crossOrigin = crossOriginAttributeValue(\n      element.fastGetAttribute(HTMLNames::crossoriginAttr));\n  if (crossOrigin != CrossOriginAttributeNotSet) {\n    request.setCrossOriginAccessControl(element.document().getSecurityOrigin(),\n                                        crossOrigin);\n  }\n\n  if (clientHintsPreferences.shouldSendResourceWidth() &&\n      isHTMLImageElement(element))\n    request.setResourceWidth(toHTMLImageElement(element).getResourceWidth());\n}\n",
        "target": 0
    },
    {
        "id": 3232,
        "func": "  static Value* LoadJSONFile(const std::string& filename) {\n    FilePath path = GetTestFilePath(filename);\n\n    std::string error;\n    JSONFileValueSerializer serializer(path);\n    Value* value = serializer.Deserialize(NULL, &error);\n    EXPECT_TRUE(value) <<\n        \"Parse error \" << path.value() << \": \" << error;\n    return value;\n  }\n",
        "target": 0
    },
    {
        "id": 3233,
        "func": "fbFetchPixel_x8r8g8b8 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    return READ((CARD32 *)bits + offset) | 0xff000000;\n}\n",
        "target": 0
    },
    {
        "id": 3234,
        "func": "    WebFrameTest()\n        : m_baseURL(\"http://www.test.com/\")\n        , m_chromeURL(\"chrome://\")\n    {\n    }\n",
        "target": 0
    },
    {
        "id": 3235,
        "func": "SessionManager::~SessionManager() {}\n",
        "target": 0
    },
    {
        "id": 3236,
        "func": "void page_move_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n\tstruct anon_vma *anon_vma = vma->anon_vma;\n\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\tVM_BUG_ON(!anon_vma);\n\tVM_BUG_ON_PAGE(page->index != linear_page_index(vma, address), page);\n\n\tanon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;\n\tpage->mapping = (struct address_space *) anon_vma;\n}",
        "target": 0
    },
    {
        "id": 3237,
        "func": "void ProfileSyncService::ChangePreferredDataTypes(\n    syncable::ModelTypeSet preferred_types) {\n\n  DVLOG(1) << \"ChangePreferredDataTypes invoked\";\n  const syncable::ModelTypeSet registered_types = GetRegisteredDataTypes();\n  const syncable::ModelTypeSet registered_preferred_types =\n      Intersection(registered_types, preferred_types);\n  sync_prefs_.SetPreferredDataTypes(registered_types,\n                                    registered_preferred_types);\n\n  ReconfigureDatatypeManager();\n}\n",
        "target": 0
    },
    {
        "id": 3238,
        "func": "void vm_stat_account(struct mm_struct *mm, vm_flags_t flags, long npages)\n{\n\tmm->total_vm += npages;\n\n\tif (is_exec_mapping(flags))\n\t\tmm->exec_vm += npages;\n\telse if (is_stack_mapping(flags))\n\t\tmm->stack_vm += npages;\n\telse if (is_data_mapping(flags))\n\t\tmm->data_vm += npages;\n}",
        "target": 0
    },
    {
        "id": 3239,
        "func": "bool PanelBrowserView::OnTitlebarMouseDragged(\n    const gfx::Point& mouse_location) {\n  if (!mouse_pressed_)\n    return false;\n\n  int delta_x = mouse_location.x() - last_mouse_location_.x();\n  int delta_y = mouse_location.y() - last_mouse_location_.y();\n   if (mouse_dragging_state_ == NO_DRAGGING &&\n       ExceededDragThreshold(delta_x, delta_y)) {\n    old_focused_view_ = GetFocusManager()->GetFocusedView();\n    GetFocusManager()->SetFocusedView(GetFrameView());\n \n     panel_->manager()->StartDragging(panel_.get(), last_mouse_location_);\n     mouse_dragging_state_ = DRAGGING_STARTED;\n  }\n  if (mouse_dragging_state_ == DRAGGING_STARTED) {\n    panel_->manager()->Drag(mouse_location);\n\n    last_mouse_location_ = mouse_location;\n  }\n  return true;\n}\n",
        "target": 1
    },
    {
        "id": 3240,
        "func": "static void overloadedMethodBMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    if (((info.Length() == 1))) {\n        overloadedMethodB1Method(info);\n        return;\n    }\n    if (((info.Length() == 1)) || ((info.Length() == 2))) {\n        overloadedMethodB2Method(info);\n        return;\n    }\n    ExceptionState exceptionState(ExceptionState::ExecutionContext, \"overloadedMethodB\", \"TestObjectPython\", info.Holder(), info.GetIsolate());\n    if (UNLIKELY(info.Length() < 1)) {\n        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    exceptionState.throwTypeError(\"No function was found that matched the signature provided.\");\n    exceptionState.throwIfNeeded();\n}\n",
        "target": 0
    },
    {
        "id": 3241,
        "func": "static void virtfs_reset(V9fsPDU *pdu)\n{\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp = NULL;\n\n    /* Free all fids */\n    while (s->fid_list) {\n        fidp = s->fid_list;\n        s->fid_list = fidp->next;\n\n        if (fidp->ref) {\n            fidp->clunked = 1;\n        } else {\n            free_fid(pdu, fidp);\n        }\n    }\n    if (fidp) {\n        /* One or more unclunked fids found... */\n        error_report(\"9pfs:%s: One or more uncluncked fids \"\n                     \"found during reset\", __func__);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 3242,
        "func": "ScriptPromise WebGLRenderingContextBase::commit(\n    ScriptState* script_state,\n    ExceptionState& exception_state) {\n  WebFeature feature = WebFeature::kOffscreenCanvasCommitWebGL;\n  UseCounter::Count(ExecutionContext::From(script_state), feature);\n  int width = GetDrawingBuffer()->Size().Width();\n  int height = GetDrawingBuffer()->Size().Height();\n  if (!GetDrawingBuffer()) {\n    bool is_web_gl_software_rendering = false;\n    return host()->Commit(nullptr, SkIRect::MakeWH(width, height),\n                          is_web_gl_software_rendering, script_state,\n                          exception_state);\n  }\n\n  RefPtr<StaticBitmapImage> image;\n  if (CreationAttributes().preserveDrawingBuffer()) {\n    SkImageInfo image_info =\n        SkImageInfo::Make(width, height, kRGBA_8888_SkColorType,\n                          CreationAttributes().alpha() ? kPremul_SkAlphaType\n                                                       : kOpaque_SkAlphaType);\n    image = StaticBitmapImage::Create(MakeImageSnapshot(image_info));\n  } else {\n    image = GetDrawingBuffer()->TransferToStaticBitmapImage();\n  }\n\n  return host()->Commit(\n      std::move(image), SkIRect::MakeWH(width, height),\n      GetDrawingBuffer()->ContextProvider()->IsSoftwareRendering(),\n      script_state, exception_state);\n}\n",
        "target": 0
    },
    {
        "id": 3243,
        "func": "static int cm_rtu_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_rtu_msg *rtu_msg;\n\tint ret;\n\n\trtu_msg = (struct cm_rtu_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(rtu_msg->remote_comm_id,\n\t\t\t\t   rtu_msg->local_comm_id);\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;\n\n\twork->cm_event.private_data = &rtu_msg->private_data;\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state != IB_CM_REP_SENT &&\n\t    cm_id_priv->id.state != IB_CM_MRA_REP_RCVD) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tatomic_long_inc(&work->port->counter_group[CM_RECV_DUPLICATES].\n\t\t\t\tcounter[CM_RTU_COUNTER]);\n\t\tgoto out;\n\t}\n\tcm_id_priv->id.state = IB_CM_ESTABLISHED;\n\n\tib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\n\tret = atomic_inc_and_test(&cm_id_priv->work_count);\n\tif (!ret)\n\t\tlist_add_tail(&work->list, &cm_id_priv->work_list);\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\tif (ret)\n\t\tcm_process_work(cm_id_priv, work);\n\telse\n\t\tcm_deref_id(cm_id_priv);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}",
        "target": 0
    },
    {
        "id": 3244,
        "func": "bson_iter_document (const bson_iter_t *iter,  /* IN */\n                    uint32_t *document_len,   /* OUT */\n                    const uint8_t **document) /* OUT */\n{\n   BSON_ASSERT (iter);\n   BSON_ASSERT (document_len);\n   BSON_ASSERT (document);\n\n   *document = NULL;\n   *document_len = 0;\n\n   if (ITER_TYPE (iter) == BSON_TYPE_DOCUMENT) {\n      memcpy (document_len, (iter->raw + iter->d1), sizeof (*document_len));\n      *document_len = BSON_UINT32_FROM_LE (*document_len);\n      *document = (iter->raw + iter->d1);\n   }\n}",
        "target": 0
    },
    {
        "id": 3245,
        "func": "static void ReflectUnsignedLongAttributeAttributeSetter(\n    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Isolate* isolate = info.GetIsolate();\n  ALLOW_UNUSED_LOCAL(isolate);\n\n  v8::Local<v8::Object> holder = info.Holder();\n  ALLOW_UNUSED_LOCAL(holder);\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V0CustomElementProcessingStack::CallbackDeliveryScope delivery_scope;\n\n  ExceptionState exception_state(isolate, ExceptionState::kSetterContext, \"TestObject\", \"reflectUnsignedLongAttribute\");\n\n  uint32_t cpp_value = NativeValueTraits<IDLUnsignedLong>::NativeValue(info.GetIsolate(), v8_value, exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->SetUnsignedIntegralAttribute(html_names::kReflectunsignedlongattributeAttr, cpp_value);\n}\n",
        "target": 0
    },
    {
        "id": 3246,
        "func": "  InotifyReaderTask(InotifyReader* reader, int inotify_fd, int shutdown_fd)\n       : reader_(reader),\n         inotify_fd_(inotify_fd),\n         shutdown_fd_(shutdown_fd) {\n   }\n",
        "target": 1
    },
    {
        "id": 3247,
        "func": "void ResetScreenHandler::Show() {\n  if (!page_is_ready()) {\n    show_on_init_ = true;\n    return;\n  }\n\n  PrefService* prefs = g_browser_process->local_state();\n  restart_required_ = !CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kFirstExecAfterBoot);\n  reboot_was_requested_ = false;\n   rollback_available_ = false;\n   if (!restart_required_)  // First exec after boot.\n     reboot_was_requested_ = prefs->GetBoolean(prefs::kFactoryResetRequested);\n  if (!restart_required_ && reboot_was_requested_) {\n     rollback_available_ = prefs->GetBoolean(prefs::kRollbackRequested);\n     ShowWithParams();\n  } else {\n    chromeos::DBusThreadManager::Get()->GetUpdateEngineClient()->\n        CanRollbackCheck(base::Bind(&ResetScreenHandler::OnRollbackCheck,\n        weak_ptr_factory_.GetWeakPtr()));\n  }\n}\n",
        "target": 1
    },
    {
        "id": 3248,
        "func": "bool DownloadItemImpl::IsPaused() const {\n  return job_ ? job_->is_paused() : false;\n}\n",
        "target": 0
    },
    {
        "id": 3249,
        "func": " void BrowserEventRouter::DispatchTabUpdatedEvent(\n    WebContents* contents, scoped_ptr<DictionaryValue> changed_properties) {\n   DCHECK(changed_properties);\n   DCHECK(contents);\n \n  scoped_ptr<ListValue> args_base(new ListValue());\n\n   args_base->AppendInteger(ExtensionTabUtil::GetTabId(contents));\n \n  // Second arg: An object containing the changes to the tab state.  Filled in\n  // by WillDispatchTabUpdatedEvent as a copy of changed_properties, if the\n  // extension has the tabs permission.\n \n  Profile* profile = Profile::FromBrowserContext(contents->GetBrowserContext());\n\n  scoped_ptr<Event> event(new Event(events::kOnTabUpdated, args_base.Pass()));\n   event->restrict_to_profile = profile;\n   event->user_gesture = EventRouter::USER_GESTURE_NOT_ENABLED;\n   event->will_dispatch_callback =\n      base::Bind(&WillDispatchTabUpdatedEvent,\n                 contents, changed_properties.get());\n   ExtensionSystem::Get(profile)->event_router()->BroadcastEvent(event.Pass());\n }\n",
        "target": 0
    },
    {
        "id": 3250,
        "func": "static int ati_remote2_post_reset(struct usb_interface *interface)\n{\n\tstruct ati_remote2 *ar2;\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tint r = 0;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn 0;\n\n\tar2 = usb_get_intfdata(interface);\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tif (ar2->flags == ATI_REMOTE2_OPENED)\n\t\tr = ati_remote2_submit_urbs(ar2);\n\n\tmutex_unlock(&ati_remote2_mutex);\n\n\treturn r;\n}",
        "target": 0
    },
    {
        "id": 3251,
        "func": "OMX_ERRORTYPE SoftAMRNBEncoder::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAMR;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            amrParams->nChannels = 1;\n            amrParams->nBitRate = mBitRate;\n            amrParams->eAMRBandMode = (OMX_AUDIO_AMRBANDMODETYPE)(mMode + 1);\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelCF;\n\n            pcmParams->nChannels = 1;\n            pcmParams->nSamplingRate = kSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n",
        "target": 1
    },
    {
        "id": 3252,
        "func": "PaintArtifactCompositor::PendingLayer::PendingLayer(\n    const PaintChunk& first_paint_chunk,\n    size_t chunk_index,\n    bool chunk_requires_own_layer)\n     : bounds(first_paint_chunk.bounds),\n       rect_known_to_be_opaque(\n           first_paint_chunk.known_to_be_opaque ? bounds : FloatRect()),\n      property_tree_state(first_paint_chunk.properties),\n       requires_own_layer(chunk_requires_own_layer) {\n   paint_chunk_indices.push_back(chunk_index);\n }\n",
        "target": 0
    },
    {
        "id": 3253,
        "func": "static int linkSane(FD_t wfd, const char *dest)\n{\n    struct stat sb, lsb;\n\n    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&\n\t    (sb.st_mode & ~S_IFMT) == S_IWUSR &&\n\t    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&\n\t    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);\n}",
        "target": 0
    },
    {
        "id": 3254,
        "func": "static int atusb_set_hw_addr_filt(struct ieee802154_hw *hw,\n\t\t\t\t  struct ieee802154_hw_addr_filt *filt,\n\t\t\t\t  unsigned long changed)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct device *dev = &atusb->usb_dev->dev;\n\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tu16 addr = le16_to_cpu(filt->short_addr);\n\n\t\tdev_vdbg(dev, \"atusb_set_hw_addr_filt called for saddr\\n\");\n\t\tatusb_write_reg(atusb, RG_SHORT_ADDR_0, addr);\n\t\tatusb_write_reg(atusb, RG_SHORT_ADDR_1, addr >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tu16 pan = le16_to_cpu(filt->pan_id);\n\n\t\tdev_vdbg(dev, \"atusb_set_hw_addr_filt called for pan id\\n\");\n\t\tatusb_write_reg(atusb, RG_PAN_ID_0, pan);\n\t\tatusb_write_reg(atusb, RG_PAN_ID_1, pan >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tu8 i, addr[IEEE802154_EXTENDED_ADDR_LEN];\n\n\t\tmemcpy(addr, &filt->ieee_addr, IEEE802154_EXTENDED_ADDR_LEN);\n\t\tdev_vdbg(dev, \"atusb_set_hw_addr_filt called for IEEE addr\\n\");\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tatusb_write_reg(atusb, RG_IEEE_ADDR_0 + i, addr[i]);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANC_CHANGED) {\n\t\tdev_vdbg(dev,\n\t\t\t \"atusb_set_hw_addr_filt called for panc change\\n\");\n\t\tif (filt->pan_coord)\n\t\t\tatusb_write_subreg(atusb, SR_AACK_I_AM_COORD, 1);\n\t\telse\n\t\t\tatusb_write_subreg(atusb, SR_AACK_I_AM_COORD, 0);\n\t}\n\n\treturn atusb_get_and_clear_error(atusb);\n}",
        "target": 0
    },
    {
        "id": 3255,
        "func": "static ssize_t in_read(struct audio_stream_in *stream, void *buffer,\n size_t bytes)\n{\n struct stream_in *in = (struct stream_in *)stream;\n struct audio_device *adev = in->dev;\n ssize_t frames = -1;\n int ret = -1;\n int read_and_process_successful = false;\n\n size_t frames_rq = bytes / audio_stream_in_frame_size(stream);\n\n /* no need to acquire adev->lock_inputs because API contract prevents a close */\n    lock_input_stream(in);\n if (in->standby) {\n        pthread_mutex_unlock(&in->lock);\n        pthread_mutex_lock(&adev->lock_inputs);\n        lock_input_stream(in);\n if (!in->standby) {\n            pthread_mutex_unlock(&adev->lock_inputs);\n goto false_alarm;\n }\n        pthread_mutex_lock(&adev->lock);\n        ret = start_input_stream(in);\n        pthread_mutex_unlock(&adev->lock);\n        pthread_mutex_unlock(&adev->lock_inputs);\n if (ret != 0) {\n goto exit;\n }\n        in->standby = 0;\n }\nfalse_alarm:\n\n if (!list_empty(&in->pcm_dev_list)) {\n if (in->usecase == USECASE_AUDIO_CAPTURE_HOTWORD) {\n            bytes = read_bytes_from_dsp(in, buffer, bytes);\n if (bytes > 0)\n                read_and_process_successful = true;\n } else {\n /*\n             * Read PCM and:\n             * - resample if needed\n             * - process if pre-processors are attached\n             * - discard unwanted channels\n             */\n            frames = read_and_process_frames(stream, buffer, frames_rq);\n if (frames >= 0)\n                read_and_process_successful = true;\n }\n }\n\n /*\n     * Instead of writing zeroes here, we could trust the hardware\n     * to always provide zeroes when muted.\n     */\n if (read_and_process_successful == true && adev->mic_mute)\n        memset(buffer, 0, bytes);\n\nexit:\n    pthread_mutex_unlock(&in->lock);\n\n if (read_and_process_successful == false) {\n        in_standby(&in->stream.common);\n        ALOGV(\"%s: read failed - sleeping for buffer duration\", __func__);\n        usleep(bytes * 1000000 / audio_stream_in_frame_size(stream) /\n               in->requested_rate);\n }\n return bytes;\n}\n",
        "target": 0
    },
    {
        "id": 3256,
        "func": " void DraggedTabGtk::Layout() {\n   if (attached_) {\n    renderer_->SetBounds(gfx::Rect(GetPreferredSize()));\n   } else {\n     int left = 0;\n     if (base::i18n::IsRTL())\n      left = GetPreferredSize().width() - attached_tab_size_.width();\n\n    renderer_->SetBounds(gfx::Rect(left, 0, attached_tab_size_.width(),\n                         attached_tab_size_.height()));\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3257,
        "func": "TIFFWriteBufferSetup(TIFF* tif, void* bp, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFWriteBufferSetup\";\n\n\tif (tif->tif_rawdata) {\n\t\tif (tif->tif_flags & TIFF_MYBUFFER) {\n\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\t\t}\n\t\ttif->tif_rawdata = NULL;\n\t}\n\tif (size == (tmsize_t)(-1)) {\n\t\tsize = (isTiled(tif) ?\n\t\t    tif->tif_tilesize : TIFFStripSize(tif));\n\t\t/*\n\t\t * Make raw data buffer at least 8K\n\t\t */\n\t\tif (size < 8*1024)\n\t\t\tsize = 8*1024;\n\t\tbp = NULL;\t\t\t/* NB: force malloc */\n\t}\n\tif (bp == NULL) {\n\t\tbp = _TIFFmalloc(size);\n\t\tif (bp == NULL) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"No space for output buffer\");\n\t\t\treturn (0);\n\t\t}\n\t\ttif->tif_flags |= TIFF_MYBUFFER;\n\t} else\n\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\ttif->tif_rawdata = (uint8*) bp;\n\ttif->tif_rawdatasize = size;\n\ttif->tif_rawcc = 0;\n\ttif->tif_rawcp = tif->tif_rawdata;\n\ttif->tif_flags |= TIFF_BUFFERSETUP;\n\treturn (1);\n}\n",
        "target": 0
    },
    {
        "id": 3258,
        "func": "void PageInfo::OnChangePasswordButtonPressed(\n     content::WebContents* web_contents) {\n #if defined(FULL_SAFE_BROWSING)\n   DCHECK(password_protection_service_);\n  DCHECK(safe_browsing_status_ == SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE ||\n         safe_browsing_status_ ==\n             SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE);\n   password_protection_service_->OnUserAction(\n       web_contents,\n      safe_browsing_status_ == SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE\n           ? PasswordReuseEvent::SIGN_IN_PASSWORD\n           : PasswordReuseEvent::ENTERPRISE_PASSWORD,\n       safe_browsing::WarningUIType::PAGE_INFO,\n      safe_browsing::WarningAction::CHANGE_PASSWORD);\n#endif\n}\n",
        "target": 1
    },
    {
        "id": 3259,
        "func": "bool HTMLMediaElement::hasVideo() const {\n  return webMediaPlayer() && webMediaPlayer()->hasVideo();\n}\n",
        "target": 0
    },
    {
        "id": 3260,
        "func": "int mm_take_all_locks(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct anon_vma_chain *avc;\n\n\tBUG_ON(down_read_trylock(&mm->mmap_sem));\n\n\tmutex_lock(&mm_all_locks_mutex);\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\tis_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->vm_file && vma->vm_file->f_mapping &&\n\t\t\t\t!is_vm_hugetlb_page(vma))\n\t\t\tvm_lock_mapping(mm, vma->vm_file->f_mapping);\n\t}\n\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tif (signal_pending(current))\n\t\t\tgoto out_unlock;\n\t\tif (vma->anon_vma)\n\t\t\tlist_for_each_entry(avc, &vma->anon_vma_chain, same_vma)\n\t\t\t\tvm_lock_anon_vma(mm, avc->anon_vma);\n\t}\n\n\treturn 0;\n\nout_unlock:\n\tmm_drop_all_locks(mm);\n\treturn -EINTR;\n}",
        "target": 0
    },
    {
        "id": 3261,
        "func": "PassRefPtr<RTCSessionDescriptionDescriptor> RTCPeerConnectionHandlerChromium::remoteDescription()\n",
        "target": 0
    },
    {
        "id": 3262,
        "func": "bool WebContentsImpl::HasRecentInteractiveInputEvent() const {\n  static constexpr base::TimeDelta kMaxInterval =\n      base::TimeDelta::FromSeconds(5);\n  base::TimeDelta delta =\n      ui::EventTimeForNow() - last_interactive_input_event_time_;\n  UMA_HISTOGRAM_TIMES(\"Tabs.TimeSinceLastInteraction\", delta);\n  return delta <= kMaxInterval;\n}\n",
        "target": 0
    },
    {
        "id": 3263,
        "func": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\n\t/* Local packets: make them go to loopback */\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\n\t\tnewdst = 0;\n\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\n\t/* Transfer from original range. */\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\n\t/* Hand modified range to generic setup. */\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}",
        "target": 1
    },
    {
        "id": 3264,
        "func": "BrowserContext* OTRBrowserContextImpl::GetOriginalContext() const {\n  return original_context_.get();\n }\n",
        "target": 1
    },
    {
        "id": 3265,
        "func": "static int red_channel_client_peer_get_out_msg_size(void *opaque)\n{\n    RedChannelClient *rcc = (RedChannelClient *)opaque;\n\n    return rcc->send_data.size;\n}\n",
        "target": 0
    },
    {
        "id": 3266,
        "func": "void AppControllerImpl::OnAppUpdate(const apps::AppUpdate& update) {\nvoid AppControllerService::OnAppUpdate(const apps::AppUpdate& update) {\n   if (!update.StateIsNull() && !update.NameChanged() &&\n       !update.ReadinessChanged()) {\n    return;\n  }\n\n  if (client_) {\n    client_->OnAppChanged(CreateAppPtr(update));\n   }\n }\n",
        "target": 0
    },
    {
        "id": 3267,
        "func": "void TabStripModelObserver::TabDetachedAt(TabContents* contents,\n                                           int index) {\n }\n",
        "target": 1
    },
    {
        "id": 3268,
        "func": "RenderFrameHostManager::RenderFrameHostManager(\n    FrameTreeNode* frame_tree_node,\n    RenderFrameHostDelegate* render_frame_delegate,\n    RenderWidgetHostDelegate* render_widget_delegate,\n    Delegate* delegate)\n    : frame_tree_node_(frame_tree_node),\n       delegate_(delegate),\n       render_frame_delegate_(render_frame_delegate),\n       render_widget_delegate_(render_widget_delegate),\n      interstitial_page_(nullptr),\n       weak_factory_(this) {\n   DCHECK(frame_tree_node_);\n }\n",
        "target": 1
    },
    {
        "id": 3269,
        "func": "static int blk_mq_alloc_rq_maps(struct blk_mq_tag_set *set)\n{\n\tunsigned int depth;\n\tint err;\n\n\tdepth = set->queue_depth;\n\tdo {\n\t\terr = __blk_mq_alloc_rq_maps(set);\n\t\tif (!err)\n\t\t\tbreak;\n\n\t\tset->queue_depth >>= 1;\n\t\tif (set->queue_depth < set->reserved_tags + BLK_MQ_TAG_MIN) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t} while (set->queue_depth);\n\n\tif (!set->queue_depth || err) {\n\t\tpr_err(\"blk-mq: failed to allocate request map\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (depth != set->queue_depth)\n\t\tpr_info(\"blk-mq: reduced tag depth (%u -> %u)\\n\",\n\t\t\t\t\t\tdepth, set->queue_depth);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3270,
        "func": "videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdprintk(2,\"vm_open %p [count=%u,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count++;\n}",
        "target": 0
    },
    {
        "id": 3271,
        "func": "bool DevToolsToolboxDelegate::PreHandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event,\n    bool* is_keyboard_shortcut) {\n  BrowserWindow* window = GetInspectedBrowserWindow();\n  if (window)\n    return window->PreHandleKeyboardEvent(event, is_keyboard_shortcut);\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 3272,
        "func": "static int pppol2tp_session_getsockopt(struct sock *sk,\n\t\t\t\t       struct l2tp_session *session,\n\t\t\t\t       int optname, int *val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_RECVSEQ:\n\t\t*val = session->recv_seq;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get recv_seq=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_SENDSEQ:\n\t\t*val = session->send_seq;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get send_seq=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_LNSMODE:\n\t\t*val = session->lns_mode;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get lns_mode=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_DEBUG:\n\t\t*val = session->debug;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: get debug=%d\\n\",\n\t\t\t  session->name, *val);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_REORDERTO:\n\t\t*val = (int) jiffies_to_msecs(session->reorder_timeout);\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: get reorder_timeout=%d\\n\", session->name, *val);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3273,
        "func": "sec_rsa_encrypt(uint8 * out, uint8 * in, int len, uint32 modulus_size, uint8 * modulus,\n\t\tuint8 * exponent)\n{\n\trdssl_rsa_encrypt(out, in, len, modulus_size, modulus, exponent);\n}",
        "target": 0
    },
    {
        "id": 3274,
        "func": "CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)\n{\n    replace_item_in_object(object, string, newitem, false);\n}",
        "target": 0
    },
    {
        "id": 3275,
        "func": "static MagickBooleanType DrawStrokePolygon(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n\n  MagickBooleanType\n    closed_path;\n\n  MagickStatusType\n    status;\n\n  PrimitiveInfo\n    *stroke_polygon;\n\n  register const PrimitiveInfo\n    *p,\n    *q;\n\n  /*\n    Draw stroked polygon.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    begin draw-stroke-polygon\");\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill=draw_info->stroke;\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,\n      MagickTrue,exception);\n  clone_info->stroke.alpha=(Quantum) TransparentAlpha;\n  clone_info->stroke_width=0.0;\n  clone_info->fill_rule=NonZeroRule;\n  status=MagickTrue;\n  for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)\n  {\n    stroke_polygon=TraceStrokePolygon(draw_info,p);\n    status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);\n    if (status == 0)\n      break;\n    stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);\n    q=p+p->coordinates-1;\n    closed_path=(q->point.x == p->point.x) && (q->point.y == p->point.y) ?\n      MagickTrue : MagickFalse;\n    if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))\n      {\n        DrawRoundLinecap(image,draw_info,p,exception);\n        DrawRoundLinecap(image,draw_info,q,exception);\n      }\n  }\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    end draw-stroke-polygon\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
        "target": 1
    },
    {
        "id": 3276,
        "func": "SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 3277,
        "func": "bool HTMLFormControlElement::wasChangedSinceLastFormControlChangeEvent() const\n{\n    return m_wasChangedSinceLastFormControlChangeEvent;\n}\n",
        "target": 0
    },
    {
        "id": 3278,
        "func": "get_path_component(char *name, size_t n, const char *fn)\n{\n\tchar *p;\n\tsize_t l;\n\n\tp = strchr(fn, '/');\n\tif (p == NULL) {\n\t\tif ((l = strlen(fn)) == 0)\n\t\t\treturn (0);\n\t} else\n\t\tl = p - fn;\n\tif (l > n -1)\n\t\treturn (-1);\n\tmemcpy(name, fn, l);\n\tname[l] = '\\0';\n\n\treturn ((int)l);\n}\n",
        "target": 0
    },
    {
        "id": 3279,
        "func": "static int udp_send_skb(struct sk_buff *skb, struct flowi4 *fl4)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udphdr *uh;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint offset = skb_transport_offset(skb);\n\tint len = skb->len - offset;\n\t__wsum csum = 0;\n\n\t/*\n\t * Create a UDP header\n\t */\n\tuh = udp_hdr(skb);\n\tuh->source = inet->inet_sport;\n\tuh->dest = fl4->fl4_dport;\n\tuh->len = htons(len);\n\tuh->check = 0;\n\n\tif (is_udplite)  \t\t\t\t /*     UDP-Lite      */\n\t\tcsum = udplite_csum(skb);\n\n\telse if (sk->sk_no_check == UDP_CSUM_NOXMIT) {   /* UDP csum disabled */\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tgoto send;\n\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */\n\n\t\tudp4_hwcsum(skb, fl4->saddr, fl4->daddr);\n\t\tgoto send;\n\n\t} else\n\t\tcsum = udp_csum(skb);\n\n\t/* add protocol-dependent pseudo-header */\n\tuh->check = csum_tcpudp_magic(fl4->saddr, fl4->daddr, len,\n\t\t\t\t      sk->sk_protocol, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip_send_skb(sock_net(sk), skb);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet->recverr) {\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t   UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t   UDP_MIB_OUTDATAGRAMS, is_udplite);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3280,
        "func": "static void rds_ib_send_complete(struct rds_message *rm,\n\t\t\t\t int wc_status,\n\t\t\t\t void (*complete)(struct rds_message *rm, int status))\n{\n\tint notify_status;\n\n\tswitch (wc_status) {\n\tcase IB_WC_WR_FLUSH_ERR:\n\t\treturn;\n\n\tcase IB_WC_SUCCESS:\n\t\tnotify_status = RDS_RDMA_SUCCESS;\n\t\tbreak;\n\n\tcase IB_WC_REM_ACCESS_ERR:\n\t\tnotify_status = RDS_RDMA_REMOTE_ERROR;\n\t\tbreak;\n\n\tdefault:\n\t\tnotify_status = RDS_RDMA_OTHER_ERROR;\n\t\tbreak;\n\t}\n\tcomplete(rm, notify_status);\n}",
        "target": 0
    },
    {
        "id": 3281,
        "func": "void DoReplaceStateWhilePending(Shell* shell,\n                                const GURL& start_url,\n                                const GURL& stalled_url,\n                                const std::string& replace_state_filename) {\n  NavigationControllerImpl& controller =\n      static_cast<NavigationControllerImpl&>(\n          shell->web_contents()->GetController());\n\n  FrameTreeNode* root =\n      static_cast<WebContentsImpl*>(shell->web_contents())->\n          GetFrameTree()->root();\n\n  EXPECT_TRUE(NavigateToURL(shell, start_url));\n\n  NavigationStallDelegate stall_delegate(stalled_url);\n  ResourceDispatcherHost::Get()->SetDelegate(&stall_delegate);\n  controller.LoadURL(\n      stalled_url, Referrer(), ui::PAGE_TRANSITION_LINK, std::string());\n\n  NavigationEntryImpl* entry = controller.GetPendingEntry();\n  ASSERT_NE(nullptr, entry);\n  EXPECT_EQ(stalled_url, entry->GetURL());\n\n  {\n    FrameNavigateParamsCapturer capturer(root);\n    capturer.set_wait_for_load(false);\n    std::string script =\n        \"history.replaceState({}, '', '\" + replace_state_filename + \"')\";\n    EXPECT_TRUE(ExecuteScript(root, script));\n    capturer.Wait();\n\n    EXPECT_EQ(NAVIGATION_TYPE_EXISTING_PAGE, capturer.navigation_type());\n    EXPECT_TRUE(capturer.is_same_document());\n  }\n\n  ResourceDispatcherHost::Get()->SetDelegate(nullptr);\n}\n",
        "target": 0
    },
    {
        "id": 3282,
        "func": " PHP_FUNCTION(xml_parser_create)\n {\n       php_xml_parser_create_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);        \n }\n",
        "target": 1
    },
    {
        "id": 3283,
        "func": "cmd_len(conn c)\n{\n    return scan_line_end(c->cmd, c->cmd_read);\n}",
        "target": 0
    },
    {
        "id": 3284,
        "func": " png_get_uint_32(png_bytep buf)\n {\n   png_uint_32 i = ((png_uint_32)(*buf) << 24) +\n      ((png_uint_32)(*(buf + 1)) << 16) +\n      ((png_uint_32)(*(buf + 2)) << 8) +\n      (png_uint_32)(*(buf + 3));\n \n    return (i);\n }\n",
        "target": 1
    },
    {
        "id": 3285,
        "func": "ExprResolveKeySym(struct xkb_context *ctx, const ExprDef *expr,\n                  xkb_keysym_t *sym_rtrn)\n{\n    int val;\n\n    if (expr->expr.op == EXPR_IDENT) {\n        const char *str = xkb_atom_text(ctx, expr->ident.ident);\n        *sym_rtrn = xkb_keysym_from_name(str, 0);\n        if (*sym_rtrn != XKB_KEY_NoSymbol)\n            return true;\n    }\n\n    if (!ExprResolveInteger(ctx, expr, &val))\n        return false;\n\n    if (val < 0 || val >= 10)\n        return false;\n\n    *sym_rtrn = XKB_KEY_0 + (xkb_keysym_t) val;\n    return true;\n}",
        "target": 0
    },
    {
        "id": 3286,
        "func": "static int udf_get_block(struct inode *inode, sector_t block,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tint err, new;\n\tsector_t phys = 0;\n\tstruct udf_inode_info *iinfo;\n\n\tif (!create) {\n\t\tphys = udf_block_map(inode, block);\n\t\tif (phys)\n\t\t\tmap_bh(bh_result, inode->i_sb, phys);\n\t\treturn 0;\n\t}\n\n\terr = -EIO;\n\tnew = 0;\n\tiinfo = UDF_I(inode);\n\n\tdown_write(&iinfo->i_data_sem);\n\tif (block == iinfo->i_next_alloc_block + 1) {\n\t\tiinfo->i_next_alloc_block++;\n\t\tiinfo->i_next_alloc_goal++;\n\t}\n\n\tudf_clear_extent_cache(inode);\n\tphys = inode_getblk(inode, block, &err, &new);\n\tif (!phys)\n\t\tgoto abort;\n\n\tif (new)\n\t\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, inode->i_sb, phys);\n\nabort:\n\tup_write(&iinfo->i_data_sem);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3287,
        "func": "void perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct perf_event *event)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event_header__init_id(header, data, event);\n}",
        "target": 0
    },
    {
        "id": 3288,
        "func": "void InsertValueIntoBuffer(std::vector<uint8_t>* data,\n                           const T& value,\n                           size_t offset) {\n  DCHECK_LE(offset + sizeof(T), data->size());\n  memcpy(data->data() + offset, &value, sizeof(T));\n}\n",
        "target": 0
    },
    {
        "id": 3289,
        "func": "bool ContentSecurityPolicy::AllowPluginTypeForDocument(\n    const Document& document,\n    const String& type,\n    const String& type_attribute,\n    const KURL& url,\n    SecurityViolationReportingPolicy reporting_policy) const {\n  if (document.GetContentSecurityPolicy() &&\n      !document.GetContentSecurityPolicy()->AllowPluginType(\n           type, type_attribute, url, reporting_policy))\n     return false;\n \n  LocalFrame* frame = document.GetFrame();\n  if (frame && frame->Tree().Parent() && document.IsPluginDocument()) {\n    ContentSecurityPolicy* parent_csp = frame->Tree()\n                                            .Parent()\n                                            ->GetSecurityContext()\n                                            ->GetContentSecurityPolicy();\n    if (parent_csp && !parent_csp->AllowPluginType(type, type_attribute, url,\n                                                   reporting_policy))\n      return false;\n  }\n   return true;\n }\n",
        "target": 1
    },
    {
        "id": 3290,
        "func": "int ReadFile(const FilePath& filename, char* data, int size) {\n  base::ThreadRestrictions::AssertIOAllowed();\n  int fd = HANDLE_EINTR(open(filename.value().c_str(), O_RDONLY));\n  if (fd < 0)\n    return -1;\n\n  ssize_t bytes_read = HANDLE_EINTR(read(fd, data, size));\n  if (int ret = HANDLE_EINTR(close(fd)) < 0)\n    return ret;\n  return bytes_read;\n}\n",
        "target": 0
    },
    {
        "id": 3291,
        "func": "SPL_METHOD(SplFileObject, hasChildren)\n{\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n \tRETURN_FALSE;\n } /* }}} */\n \n/* {{{ proto bool SplFileObject::getChildren()\n",
        "target": 1
    },
    {
        "id": 3292,
        "func": "NPObject* WebPluginProxy::GetPluginElement() {\n  if (plugin_element_)\n    return WebBindings::retainObject(plugin_element_);\n \n   int npobject_route_id = channel_->GenerateRouteID();\n   bool success = false;\n  intptr_t npobject_ptr = NULL;\n  Send(new PluginHostMsg_GetPluginElement(\n      route_id_, npobject_route_id, &success, &npobject_ptr));\n   if (!success)\n     return NULL;\n \n  plugin_element_ = NPObjectProxy::Create(\n      channel_, npobject_route_id, containing_window_, page_url_);\n\n  return plugin_element_;\n}\n",
        "target": 1
    },
    {
        "id": 3293,
        "func": "  static void Unregister(const GURL& url) {\n    EXPECT_TRUE(\n        content::BrowserThread::CurrentlyOn(content::BrowserThread::IO));\n    net::URLRequestFilter::GetInstance()->RemoveUrlHandler(url);\n   }\n",
        "target": 1
    },
    {
        "id": 3294,
        "func": "int snd_timer_continue(struct snd_timer_instance *timeri)\n{\n\t/* timer can continue only after pause */\n\tif (!(timeri->flags & SNDRV_TIMER_IFLG_PAUSED))\n\t\treturn -EINVAL;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_start_slave(timeri, false);\n\telse\n\t\treturn snd_timer_start1(timeri, false, 0);\n}",
        "target": 0
    },
    {
        "id": 3295,
        "func": "static uint32_t elf_flags_to_mattr(uint32_t flags)\n{\n\tuint32_t mattr = 0;\n\n\tif (flags & PF_X)\n\t\tmattr |= TEE_MATTR_UX;\n\tif (flags & PF_W)\n\t\tmattr |= TEE_MATTR_UW;\n\tif (flags & PF_R)\n\t\tmattr |= TEE_MATTR_UR;\n\n\treturn mattr;\n}",
        "target": 0
    },
    {
        "id": 3296,
        "func": " void ExtensionUninstaller::Run() {\n   const extensions::Extension* extension =\n      extensions::ExtensionSystem::Get(profile_)->extension_service()->\n          GetInstalledExtension(app_id_);\n   if (!extension) {\n     CleanUp();\n     return;\n  }\n  controller_->OnShowChildDialog();\n  dialog_.reset(extensions::ExtensionUninstallDialog::Create(\n      profile_, controller_->GetAppListWindow(), this));\n  dialog_->ConfirmUninstall(extension,\n                            extensions::UNINSTALL_REASON_USER_INITIATED);\n}\n",
        "target": 1
    },
    {
        "id": 3297,
        "func": "void RenderWidgetHostImpl::ParentChanged(gfx::NativeViewId new_parent) {\n#if defined(OS_WIN)\n  HWND hwnd = reinterpret_cast<HWND>(new_parent);\n  if (!hwnd)\n    hwnd = WebPluginDelegateImpl::GetDefaultWindowParent();\n  for (std::list<HWND>::iterator i = dummy_windows_for_activation_.begin();\n        i != dummy_windows_for_activation_.end(); ++i) {\n    SetParent(*i, hwnd);\n  }\n #endif\n }\n",
        "target": 0
    },
    {
        "id": 3298,
        "func": "static inline void set_idle_cores(int cpu, int val)\n{\n\tstruct sched_domain_shared *sds;\n\n\tsds = rcu_dereference(per_cpu(sd_llc_shared, cpu));\n\tif (sds)\n\t\tWRITE_ONCE(sds->has_idle_cores, val);\n}",
        "target": 0
    },
    {
        "id": 3299,
        "func": "bool RenderViewImpl::CanUpdateLayout() {\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 3300,
        "func": "static int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 3301,
        "func": "xfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\t__uint32_t\t\tlen,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\tint\t\t\terror = EFAULT;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn EPERM;\n\tif (len > XATTR_SIZE_MAX)\n\t\treturn EINVAL;\n\n\tkbuf = memdup_user(ubuf, len);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\terror = xfs_attr_set(XFS_I(inode), name, kbuf, len, flags);\n\n\treturn error;\n}",
        "target": 0
    },
    {
        "id": 3302,
        "func": "  static void MakeRequestFailOnIO(const std::string& host) {\n    net::URLRequestFilter* filter = net::URLRequestFilter::GetInstance();\n    filter->AddHostnameInterceptor(\"http\", host,\n                                   std::unique_ptr<net::URLRequestInterceptor>(\n                                       new FailedJobInterceptor()));\n    filter->AddHostnameInterceptor(\"https\", host,\n                                   std::unique_ptr<net::URLRequestInterceptor>(\n                                       new FailedJobInterceptor()));\n  }\n",
        "target": 0
    },
    {
        "id": 3303,
        "func": "bool ExtensionTtsController::IsSpeaking() const {\n  return current_utterance_ != NULL;\n}\n",
        "target": 1
    },
    {
        "id": 3304,
        "func": "static BOOLEAN btm_dev_authorized (tBTM_SEC_DEV_REC *p_dev_rec)\n{\n if(p_dev_rec->sec_flags & BTM_SEC_AUTHORIZED)\n {\n return(TRUE);\n }\n return(FALSE);\n}\n",
        "target": 0
    },
    {
        "id": 3305,
        "func": "BlobDataHandle::BlobDataHandle(PassOwnPtr<BlobData> data, long long size)\n {\n     UNUSED_PARAM(size);\n     m_internalURL = BlobURL::createInternalURL();\n    ThreadableBlobRegistry::registerBlobURL(m_internalURL, data);\n }\n",
        "target": 1
    },
    {
        "id": 3306,
        "func": "void BaseRenderingContext2D::scale(double sx, double sy) {\n  PaintCanvas* c = DrawingCanvas();\n  if (!c)\n    return;\n\n  if (!std::isfinite(sx) || !std::isfinite(sy))\n    return;\n\n  AffineTransform new_transform = GetState().Transform();\n  new_transform.ScaleNonUniform(sx, sy);\n  if (GetState().Transform() == new_transform)\n    return;\n\n  ModifiableState().SetTransform(new_transform);\n  if (!GetState().IsTransformInvertible())\n    return;\n\n  c->scale(sx, sy);\n  path_.Transform(AffineTransform().ScaleNonUniform(1.0 / sx, 1.0 / sy));\n}\n",
        "target": 0
    },
    {
        "id": 3307,
        "func": "status_t AudioSource::read(\n MediaBuffer **out, const ReadOptions * /* options */) {\n Mutex::Autolock autoLock(mLock);\n *out = NULL;\n\n if (mInitCheck != OK) {\n return NO_INIT;\n }\n\n while (mStarted && mBuffersReceived.empty()) {\n        mFrameAvailableCondition.wait(mLock);\n }\n if (!mStarted) {\n return OK;\n }\n MediaBuffer *buffer = *mBuffersReceived.begin();\n    mBuffersReceived.erase(mBuffersReceived.begin());\n ++mNumClientOwnedBuffers;\n    buffer->setObserver(this);\n    buffer->add_ref();\n\n int64_t timeUs;\n    CHECK(buffer->meta_data()->findInt64(kKeyTime, &timeUs));\n int64_t elapsedTimeUs = timeUs - mStartTimeUs;\n if (elapsedTimeUs < kAutoRampStartUs) {\n        memset((uint8_t *) buffer->data(), 0, buffer->range_length());\n } else if (elapsedTimeUs < kAutoRampStartUs + kAutoRampDurationUs) {\n int32_t autoRampDurationFrames =\n ((int64_t)kAutoRampDurationUs * mSampleRate + 500000LL) / 1000000LL; //Need type casting\n\n int32_t autoRampStartFrames =\n ((int64_t)kAutoRampStartUs * mSampleRate + 500000LL) / 1000000LL; //Need type casting\n\n int32_t nFrames = mNumFramesReceived - autoRampStartFrames;\n        rampVolume(nFrames, autoRampDurationFrames,\n (uint8_t *) buffer->data(), buffer->range_length());\n }\n\n if (mTrackMaxAmplitude) {\n        trackMaxAmplitude(\n (int16_t *) buffer->data(), buffer->range_length() >> 1);\n }\n\n if (mSampleRate != mOutSampleRate) {\n if (mFirstSampleTimeUs < 0) {\n            mFirstSampleTimeUs = timeUs;\n }\n        timeUs = mFirstSampleTimeUs + (timeUs - mFirstSampleTimeUs)\n * (int64_t)mSampleRate / (int64_t)mOutSampleRate;\n        buffer->meta_data()->setInt64(kKeyTime, timeUs);\n }\n\n *out = buffer;\n return OK;\n}\n",
        "target": 0
    },
    {
        "id": 3308,
        "func": "static void hwahc_init(struct hwahc *hwahc)\n{\n\twa_init(&hwahc->wa);\n}",
        "target": 0
    },
    {
        "id": 3309,
        "func": "void PersistentHistogramAllocator::ClearLastCreatedReferenceForTesting() {\n   subtle::NoBarrier_Store(&last_created_, 0);\n }\n",
        "target": 0
    },
    {
        "id": 3310,
        "func": "void WallpaperManager::SetDefaultWallpaperPath(\n    const base::FilePath& default_small_wallpaper_file,\n    std::unique_ptr<gfx::ImageSkia> small_wallpaper_image,\n    const base::FilePath& default_large_wallpaper_file,\n    std::unique_ptr<gfx::ImageSkia> large_wallpaper_image) {\n  default_small_wallpaper_file_ = default_small_wallpaper_file;\n  default_large_wallpaper_file_ = default_large_wallpaper_file;\n\n  ash::WallpaperController* controller =\n      ash::Shell::Get()->wallpaper_controller();\n\n  const bool need_update_screen =\n      default_wallpaper_image_.get() &&\n      controller->WallpaperIsAlreadyLoaded(default_wallpaper_image_->image(),\n                                           false /* compare_layouts */,\n                                           wallpaper::WALLPAPER_LAYOUT_CENTER);\n\n  default_wallpaper_image_.reset();\n  if (GetAppropriateResolution() == WALLPAPER_RESOLUTION_SMALL) {\n    if (small_wallpaper_image) {\n      default_wallpaper_image_.reset(\n          new user_manager::UserImage(*small_wallpaper_image));\n      default_wallpaper_image_->set_file_path(default_small_wallpaper_file);\n    }\n  } else {\n    if (large_wallpaper_image) {\n      default_wallpaper_image_.reset(\n          new user_manager::UserImage(*large_wallpaper_image));\n      default_wallpaper_image_->set_file_path(default_large_wallpaper_file);\n     }\n   }\n \n  if (need_update_screen)\n    DoSetDefaultWallpaper(EmptyAccountId(), MovableOnDestroyCallbackHolder());\n }\n",
        "target": 1
    },
    {
        "id": 3311,
        "func": "void killchild(gpointer key, gpointer value, gpointer user_data) {\n\tpid_t *pid=value;\n\n\tkill(*pid, SIGTERM);\n}",
        "target": 0
    },
    {
        "id": 3312,
        "func": "const char* Track::GetCodecNameAsUTF8() const\n{\n    return m_info.codecNameAsUTF8;\n}\n",
        "target": 1
    },
    {
        "id": 3313,
        "func": "enum ndp_msg_type ndp_msg_type(struct ndp_msg *msg)\n{\n\tenum ndp_msg_type msg_type;\n\tint err;\n\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\t/* Type should be always set correctly (ensured by ndp_msg_init) */\n\tBUG_ON(err);\n\treturn msg_type;\n}",
        "target": 0
    },
    {
        "id": 3314,
        "func": "connection_edge_end(edge_connection_t *conn, uint8_t reason)\n{\n  char payload[RELAY_PAYLOAD_SIZE];\n  size_t payload_len=1;\n  circuit_t *circ;\n  uint8_t control_reason = reason;\n\n  if (conn->edge_has_sent_end) {\n    log_warn(LD_BUG,\"(Harmless.) Calling connection_edge_end (reason %d) \"\n             \"on an already ended stream?\", reason);\n    tor_fragile_assert();\n    return -1;\n  }\n\n  if (conn->base_.marked_for_close) {\n    log_warn(LD_BUG,\n             \"called on conn that's already marked for close at %s:%d.\",\n             conn->base_.marked_for_close_file, conn->base_.marked_for_close);\n    return 0;\n  }\n\n  circ = circuit_get_by_edge_conn(conn);\n  if (circ && CIRCUIT_PURPOSE_IS_CLIENT(circ->purpose)) {\n    /* If this is a client circuit, don't send the server an informative\n     * reason code; it doesn't need to know why the client stream is\n     * failing. */\n    reason = END_STREAM_REASON_MISC;\n  }\n\n  payload[0] = (char)reason;\n  if (reason == END_STREAM_REASON_EXITPOLICY &&\n      !connection_edge_is_rendezvous_stream(conn)) {\n    int addrlen;\n    if (tor_addr_family(&conn->base_.addr) == AF_INET) {\n      set_uint32(payload+1, tor_addr_to_ipv4n(&conn->base_.addr));\n      addrlen = 4;\n    } else {\n      memcpy(payload+1, tor_addr_to_in6_addr8(&conn->base_.addr), 16);\n      addrlen = 16;\n    }\n    set_uint32(payload+1+addrlen, htonl(dns_clip_ttl(conn->address_ttl)));\n    payload_len += 4+addrlen;\n  }\n\n  if (circ && !circ->marked_for_close) {\n    log_debug(LD_EDGE,\"Sending end on conn (fd \"TOR_SOCKET_T_FORMAT\").\",\n              conn->base_.s);\n    connection_edge_send_command(conn, RELAY_COMMAND_END,\n                                 payload, payload_len);\n    /* We'll log warn if the connection was an hidden service and couldn't be\n     * made because the service wasn't available. */\n    warn_if_hs_unreachable(conn, control_reason);\n  } else {\n    log_debug(LD_EDGE,\"No circ to send end on conn \"\n              \"(fd \"TOR_SOCKET_T_FORMAT\").\",\n              conn->base_.s);\n  }\n\n  conn->edge_has_sent_end = 1;\n  conn->end_reason = control_reason;\n  return 0;\n}",
        "target": 0
    },
    {
        "id": 3315,
        "func": "static int set_sec_attr_from_acl(sc_card_t *card, sc_file_t *file)\n{\n\tconst sc_acl_entry_t *entry;\n\tu8 sec_attr[SC_RTECP_SEC_ATTR_SIZE] = { 0 };\n\tint r;\n\n\tassert(card && card->ctx && file);\n\tassert(!file->sec_attr  &&  file->sec_attr_len == 0);\n\tassert(1 + 6 < sizeof(sec_attr));\n\n\tentry = sc_file_get_acl_entry(file, SC_AC_OP_DELETE);\n\tif (entry)\n\t{\n\t\tsec_attr[0] |= 0x40;\n\t\tsec_attr[1 + 6] = to_sec_attr(entry->method, entry->key_ref);\n\t}\n\tif (file->type == SC_FILE_TYPE_DF)\n\t{\n\t\tentry = sc_file_get_acl_entry(file, SC_AC_OP_CREATE);\n\t\tif (entry)\n\t\t{\n\t\t\t/* ATTR: Create DF/EF file */\n\t\t\tsec_attr[0] |= 0x01;\n\t\t\tsec_attr[1 + 0] = to_sec_attr(entry->method, entry->key_ref);\n\t\t\t/* ATTR: Create Internal EF (RSF) file */\n\t\t\tsec_attr[0] |= 0x02;\n\t\t\tsec_attr[1 + 1] = to_sec_attr(entry->method, entry->key_ref);\n\t\t}\n\t}\n\telse\n\t{\n\t\tentry = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\t\tif (entry)\n\t\t{\n\t\t\tsec_attr[0] |= 0x01;\n\t\t\tsec_attr[1 + 0] = to_sec_attr(entry->method, entry->key_ref);\n\t\t}\n\t\tentry = sc_file_get_acl_entry(file, SC_AC_OP_WRITE);\n\t\tif (entry)\n\t\t{\n\t\t\tsec_attr[0] |= 0x02;\n\t\t\tsec_attr[1 + 1] = to_sec_attr(entry->method, entry->key_ref);\n\t\t}\n\t\tentry = sc_file_get_acl_entry(file, SC_AC_OP_UPDATE);\n\t\tif (entry)\n\t\t{\n\t\t\t/* rewrite if sec_attr[1 + 1] already set */\n\t\t\tsec_attr[0] |= 0x02;\n\t\t\tsec_attr[1 + 1] = to_sec_attr(entry->method, entry->key_ref);\n\t\t}\n\t}\n\t/* FIXME: Find the best solution */\n\tif (file->path.len == 2 && !memcmp(file->path.value, \"\\x3F\\x00\", 2))\n\t{\n\t\t/* ATTR: Put data */\n\t\tsec_attr[0] |= 0x04;\n\t\tsec_attr[1 + 2] = 1; /* so-pin reference */\n\t}\n\tr = sc_file_set_sec_attr(file, sec_attr, sizeof(sec_attr));\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n",
        "target": 0
    },
    {
        "id": 3316,
        "func": "static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 3317,
        "func": "static int task_switch_16(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_16 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tsave_state_to_tss16(ctxt, &tss_seg);\n\n\tret = ops->write_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t     &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss16(ctxt, &tss_seg);\n}",
        "target": 0
    },
    {
        "id": 3318,
        "func": "RenderBlockFlow::RenderBlockFlow(ContainerNode* node)\n    : RenderBlock(node)\n{\n    COMPILE_ASSERT(sizeof(MarginInfo) == sizeof(SameSizeAsMarginInfo), MarginInfo_should_stay_small);\n}\n",
        "target": 0
    },
    {
        "id": 3319,
        "func": "void PasswordAutofillAgent::FillField(WebInputElement* input,\n                                      const base::string16& credential) {\n  DCHECK(input);\n  DCHECK(!input->IsNull());\n  input->SetAutofillValue(WebString::FromUTF16(credential));\n  input->SetAutofillState(WebAutofillState::kAutofilled);\n  field_data_manager_.UpdateFieldDataMap(\n      *input, credential, FieldPropertiesFlags::AUTOFILLED_ON_USER_TRIGGER);\n}\n",
        "target": 0
    },
    {
        "id": 3320,
        "func": " bool InputWindowInfo::isTrustedOverlay() const {\n     return layoutParamsType == TYPE_INPUT_METHOD\n             || layoutParamsType == TYPE_INPUT_METHOD_DIALOG\n             || layoutParamsType == TYPE_MAGNIFICATION_OVERLAY\n             || layoutParamsType == TYPE_SECURE_SYSTEM_OVERLAY;\n }\n",
        "target": 1
    },
    {
        "id": 3321,
        "func": "static unsigned int Sys_CountFileList(char **list)\n{\n\tint i = 0;\n\n\tif (list)\n\t{\n\t\twhile (*list)\n\t\t{\n\t\t\tlist++;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n",
        "target": 0
    },
    {
        "id": 3322,
        "func": "isoent_add_child_tail(struct isoent *parent, struct isoent *child)\n{\n\n\tif (!__archive_rb_tree_insert_node(\n\t    &(parent->rbtree), (struct archive_rb_node *)child))\n\t\treturn (0);\n\tchild->chnext = NULL;\n\t*parent->children.last = child;\n\tparent->children.last = &(child->chnext);\n\tparent->children.cnt++;\n\tchild->parent = parent;\n\n\t/* Add a child to a sub-directory chain */\n\tchild->drnext = NULL;\n\tif (child->dir) {\n\t\t*parent->subdirs.last = child;\n\t\tparent->subdirs.last = &(child->drnext);\n\t\tparent->subdirs.cnt++;\n\t\tchild->parent = parent;\n\t}\n\treturn (1);\n}\n",
        "target": 0
    },
    {
        "id": 3323,
        "func": "void PasswordAutofillAgent::SetLoggingState(bool active) {\n  logging_state_active_ = active;\n}\n",
        "target": 0
    },
    {
        "id": 3324,
        "func": " const PropertyTreeState& PropertyTreeState::Root() {\n   DEFINE_STATIC_LOCAL(\n      PropertyTreeState, root,\n      (&TransformPaintPropertyNode::Root(), &ClipPaintPropertyNode::Root(),\n       &EffectPaintPropertyNode::Root()));\n  return root;\n }\n",
        "target": 0
    },
    {
        "id": 3325,
        "func": "static MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(q,QuantumRange*a);\n      SetPixelb(q,QuantumRange*b);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n",
        "target": 0
    },
    {
        "id": 3326,
        "func": "GahpClient::gt4_gram_client_ping(const char * resource_contact)\n{\n\tstatic const char* command = \"GT4_GRAM_PING\";\n\n\tif  (server->m_commands_supported->contains_anycase(command)==FALSE) {\n\t\treturn GAHPCLIENT_COMMAND_NOT_SUPPORTED;\n\t}\n\n\tif (!resource_contact) resource_contact=NULLSTRING;\n\tstd::string reqline;\n\tint x = sprintf(reqline,\"%s\",escapeGahpString(resource_contact));\n\tASSERT( x > 0 );\n\tconst char *buf = reqline.c_str();\n\n\tif ( !is_pending(command,buf) ) {\n\t\tif ( m_mode == results_only ) {\n\t\t\treturn GAHPCLIENT_COMMAND_NOT_SUBMITTED;\n\t\t}\n\t\tnow_pending(command,buf,normal_proxy);\n\t}\n\n\t\t\n\tGahp_Args* result = get_pending_result(command,buf);\n\tif ( result ) {\n\t\tif (result->argc != 3) {\n\t\t\tEXCEPT(\"Bad %s Result\",command);\n\t\t}\n\t\tint rc = atoi(result->argv[1]);\n\t\tif ( strcasecmp(result->argv[2], NULLSTRING) ) {\n\t\t\terror_string = result->argv[2];\n\t\t} else {\n\t\t\terror_string = \"\";\n\t\t}\n\t\tdelete result;\n\t\treturn rc;\n\t}\n\n\tif ( check_pending_timeout(command,buf) ) {\n\t\tsprintf( error_string, \"%s timed out\", command );\n\t\treturn GAHPCLIENT_COMMAND_TIMED_OUT;\n\t}\n\n\treturn GAHPCLIENT_COMMAND_PENDING;\n}\n",
        "target": 0
    },
    {
        "id": 3327,
        "func": "SkBitmap Browser::GetCurrentPageIcon() const {\n  TabContents* contents = GetSelectedTabContents();\n  return contents ? contents->GetFavIcon() : SkBitmap();\n}\n",
        "target": 0
    },
    {
        "id": 3328,
        "func": "krb5_gss_context_time(minor_status, context_handle, time_rec)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    OM_uint32 *time_rec;\n{\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    if ((code = krb5_timeofday(ctx->k5_context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, ctx->k5_context);\n        return(GSS_S_FAILURE);\n    }\n\n    if ((lifetime = ctx->krb_times.endtime - now) <= 0) {\n        *time_rec = 0;\n        *minor_status = 0;\n        return(GSS_S_CONTEXT_EXPIRED);\n    } else {\n        *time_rec = lifetime;\n        *minor_status = 0;\n        return(GSS_S_COMPLETE);\n    }\n}",
        "target": 1
    },
    {
        "id": 3329,
        "func": "static CURLcode imap_dophase_done(struct connectdata *conn,\n                                  bool connected)\n{\n  struct FTP *imap = conn->data->state.proto.imap;\n  (void)connected;\n\n  if(imap->transfer != FTPTRANSFER_BODY)\n    /* no data to transfer */\n    Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n\n  return CURLE_OK;\n}",
        "target": 0
    },
    {
        "id": 3330,
        "func": "hstoreArrayToPairs(ArrayType *a, int *npairs)\n{\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tPairs\t   *key_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdeconstruct_array(a,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\n\tif (key_count == 0)\n\t{\n\t\t*npairs = 0;\n\t\treturn NULL;\n\t}\n\n\tkey_pairs = palloc(sizeof(Pairs) * key_count);\n\n\tfor (i = 0, j = 0; i < key_count; i++)\n\t{\n\t\tif (!key_nulls[i])\n\t\t{\n\t\t\tkey_pairs[j].key = VARDATA(key_datums[i]);\n\t\t\tkey_pairs[j].keylen = VARSIZE(key_datums[i]) - VARHDRSZ;\n\t\t\tkey_pairs[j].val = NULL;\n\t\t\tkey_pairs[j].vallen = 0;\n\t\t\tkey_pairs[j].needfree = 0;\n\t\t\tkey_pairs[j].isnull = 1;\n\t\t\tj++;\n\t\t}\n\t}\n\n\t*npairs = hstoreUniquePairs(key_pairs, j, &bufsiz);\n\n\treturn key_pairs;\n}",
        "target": 1
    },
    {
        "id": 3331,
        "func": "PHP_FUNCTION(pg_pconnect)\n{\n\tphp_pgsql_do_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU,1);\n}\n",
        "target": 0
    },
    {
        "id": 3332,
        "func": "struct dentry *d_add_ci(struct dentry *dentry, struct inode *inode,\n\t\t\tstruct qstr *name)\n{\n\tstruct dentry *found, *res;\n\n\t/*\n\t * First check if a dentry matching the name already exists,\n\t * if not go ahead and create it now.\n\t */\n\tfound = d_hash_and_lookup(dentry->d_parent, name);\n\tif (found) {\n\t\tiput(inode);\n\t\treturn found;\n\t}\n\tif (d_in_lookup(dentry)) {\n\t\tfound = d_alloc_parallel(dentry->d_parent, name,\n\t\t\t\t\tdentry->d_wait);\n\t\tif (IS_ERR(found) || !d_in_lookup(found)) {\n\t\t\tiput(inode);\n\t\t\treturn found;\n\t\t}\n\t} else {\n\t\tfound = d_alloc(dentry->d_parent, name);\n\t\tif (!found) {\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t} \n\t}\n\tres = d_splice_alias(inode, found);\n\tif (res) {\n\t\tdput(found);\n\t\treturn res;\n\t}\n\treturn found;\n}",
        "target": 0
    },
    {
        "id": 3333,
        "func": "int tcp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint err = 0;\n\tint old_state = sk->sk_state;\n\n\tif (old_state != TCP_CLOSE)\n\t\ttcp_set_state(sk, TCP_CLOSE);\n\n\t/* ABORT function of RFC793 */\n\tif (old_state == TCP_LISTEN) {\n\t\tinet_csk_listen_stop(sk);\n\t} else if (unlikely(tp->repair)) {\n\t\tsk->sk_err = ECONNABORTED;\n\t} else if (tcp_need_reset(old_state) ||\n\t\t   (tp->snd_nxt != tp->write_seq &&\n\t\t    (1 << old_state) & (TCPF_CLOSING | TCPF_LAST_ACK))) {\n\t\t/* The last check adjusts for discrepancy of Linux wrt. RFC\n\t\t * states\n\t\t */\n\t\ttcp_send_active_reset(sk, gfp_any());\n\t\tsk->sk_err = ECONNRESET;\n\t} else if (old_state == TCP_SYN_SENT)\n\t\tsk->sk_err = ECONNRESET;\n\n\ttcp_clear_xmit_timers(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\ttcp_write_queue_purge(sk);\n\ttcp_fastopen_active_disable_ofo_check(sk);\n\tskb_rbtree_purge(&tp->out_of_order_queue);\n\n\tinet->inet_dport = 0;\n\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\n\tsk->sk_shutdown = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ttp->srtt_us = 0;\n\ttp->write_seq += tp->max_window + 2;\n\tif (tp->write_seq == 0)\n\t\ttp->write_seq = 1;\n\ticsk->icsk_backoff = 0;\n\ttp->snd_cwnd = 2;\n\ticsk->icsk_probes_out = 0;\n\ttp->packets_out = 0;\n\ttp->snd_ssthresh = TCP_INFINITE_SSTHRESH;\n\ttp->snd_cwnd_cnt = 0;\n\ttp->window_clamp = 0;\n\ttcp_set_ca_state(sk, TCP_CA_Open);\n\ttcp_clear_retrans(tp);\n\tinet_csk_delack_init(sk);\n\ttcp_init_send_head(sk);\n\tmemset(&tp->rx_opt, 0, sizeof(tp->rx_opt));\n\t__sk_dst_reset(sk);\n\ttcp_saved_syn_free(tp);\n\n\t/* Clean up fastopen related fields */\n\ttcp_free_fastopen_req(tp);\n\tinet->defer_connect = 0;\n\n\tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\n\n\tsk->sk_error_report(sk);\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 3334,
        "func": "display_rc(const display *d, int strict)\n{\n return d->error_count + (strict ? d->warning_count : 0);\n}\n",
        "target": 0
    },
    {
        "id": 3335,
        "func": "static void ext4_destroy_inode(struct inode *inode)\n{\n\text4_ioend_wait(inode);\n\tif (!list_empty(&(EXT4_I(inode)->i_orphan))) {\n\t\text4_msg(inode->i_sb, KERN_ERR,\n\t\t\t \"Inode %lu (%p): orphan list check failed!\",\n\t\t\t inode->i_ino, EXT4_I(inode));\n\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\tEXT4_I(inode), sizeof(struct ext4_inode_info),\n\t\t\t\ttrue);\n\t\tdump_stack();\n\t}\n\tcall_rcu(&inode->i_rcu, ext4_i_callback);\n}",
        "target": 0
    },
    {
        "id": 3336,
        "func": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\tif (sbi->s_mb_cache) {\n\t\text2_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}",
        "target": 0
    },
    {
        "id": 3337,
        "func": "reactor_status_t reactor_run_once(reactor_t *reactor) {\n  assert(reactor != NULL);\n return run_reactor(reactor, 1);\n}\n",
        "target": 0
    },
    {
        "id": 3338,
        "func": " WebstoreBindings::WebstoreBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"Install\",\n                 base::Bind(&WebstoreBindings::Install, base::Unretained(this)));\n }\n",
        "target": 1
    },
    {
        "id": 3339,
        "func": "xps_encode_font_char(xps_font_t *font, int code)\n{\n    int gid = xps_encode_font_char_imp(font, code);\n    if (gid == 0 && font->usepua)\n        gid = xps_encode_font_char_imp(font, 0xF000 | code);\n    return gid;\n}\n",
        "target": 0
    },
    {
        "id": 3340,
        "func": "GfxState *GfxState::restore() {\n  GfxState *oldState;\n\n  if (saved) {\n    oldState = saved;\n\n    oldState->path = path;\n    oldState->curX = curX;\n    oldState->curY = curY;\n    oldState->lineX = lineX;\n    oldState->lineY = lineY;\n\n    path = NULL;\n    saved = NULL;\n    delete this;\n\n  } else {\n    oldState = this;\n  }\n\n  return oldState;\n}\n",
        "target": 0
    },
    {
        "id": 3341,
        "func": "lacks_extension_info (NautilusFile *file)\n{\n    return file->details->pending_info_providers != NULL;\n}",
        "target": 0
    },
    {
        "id": 3342,
        "func": "   Core(const OAuthProviderInfo& info,\n        net::URLRequestContextGetter* request_context_getter)\n       : provider_info_(info),\n         request_context_getter_(request_context_getter),\n        delegate_(NULL) {\n   }\n",
        "target": 1
    },
    {
        "id": 3343,
        "func": "static void *session_malloc(size_t size, void *ctx)\n{\n    h2_session *session = ctx;\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE6, 0, session->c,\n                  \"h2_session(%ld): malloc(%ld)\",\n                  session->id, (long)size);\n    return malloc(size);\n}\n",
        "target": 0
    },
    {
        "id": 3344,
        "func": "status_t MediaPlayer::setDataSource(const sp<IDataSource> &source)\n{\n    ALOGV(\"setDataSource(IDataSource)\");\n status_t err = UNKNOWN_ERROR;\n const sp<IMediaPlayerService>& service(getMediaPlayerService());\n if (service != 0) {\n        sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(source))) {\n            player.clear();\n }\n        err = attachNewPlayer(player);\n }\n return err;\n}\n",
        "target": 0
    },
    {
        "id": 3345,
        "func": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\t/* if rootfs->path is a blockdev path, allow container fstab to\n\t * use $lxcpath/CN/rootfs as the target prefix */\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\n\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\n\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}",
        "target": 1
    },
    {
        "id": 3346,
        "func": "static js_Ast *arrayelement(js_State *J)\n{\n\tif (J->lookahead == ',')\n\t\treturn EXP0(UNDEF);\n\treturn assignment(J, 0);\n}\n",
        "target": 0
    },
    {
        "id": 3347,
        "func": "change_charset(struct parsed_tagarg *arg)\n{\n    Buffer *buf = Currentbuf->linkBuffer[LB_N_INFO];\n    wc_ces charset;\n\n    if (buf == NULL)\n\treturn;\n    delBuffer(Currentbuf);\n    Currentbuf = buf;\n    if (Currentbuf->bufferprop & BP_INTERNAL)\n\treturn;\n    charset = Currentbuf->document_charset;\n    for (; arg; arg = arg->next) {\n\tif (!strcmp(arg->arg, \"charset\"))\n\t    charset = atoi(arg->value);\n    }\n    _docCSet(charset);\n}",
        "target": 0
    },
    {
        "id": 3348,
        "func": "BGD_DECLARE(void) gdImageGetClip (gdImagePtr im, int *x1P, int *y1P, int *x2P, int *y2P)\n{\n\t*x1P = im->cx1;\n\t*y1P = im->cy1;\n\t*x2P = im->cx2;\n\t*y2P = im->cy2;\n}",
        "target": 0
    },
    {
        "id": 3349,
        "func": "void CopyFeatureSwitch(const base::CommandLine& src,\n                       base::CommandLine* dest,\n                       const char* switch_name) {\n  std::vector<std::string> features = FeaturesFromSwitch(src, switch_name);\n  if (!features.empty())\n    dest->AppendSwitchASCII(switch_name, base::JoinString(features, \",\"));\n}\n",
        "target": 0
    },
    {
        "id": 3350,
        "func": "void WebGLRenderingContextBase::vertexAttrib2fv(\n    GLuint index,\n    MaybeShared<const DOMFloat32Array> v) {\n  if (isContextLost())\n    return;\n  if (!v.View() || v.View()->length() < 2) {\n    SynthesizeGLError(GL_INVALID_VALUE, \"vertexAttrib2fv\", \"invalid array\");\n    return;\n  }\n  ContextGL()->VertexAttrib2fv(index, v.View()->DataMaybeShared());\n  SetVertexAttribType(index, kFloat32ArrayType);\n}\n",
        "target": 0
    },
    {
        "id": 3351,
        "func": "static bool has_unmap_ctx(struct userfaultfd_ctx *ctx, struct list_head *unmaps,\n\t\t\t  unsigned long start, unsigned long end)\n{\n\tstruct userfaultfd_unmap_ctx *unmap_ctx;\n\n\tlist_for_each_entry(unmap_ctx, unmaps, list)\n\t\tif (unmap_ctx->ctx == ctx && unmap_ctx->start == start &&\n\t\t    unmap_ctx->end == end)\n\t\t\treturn true;\n\n\treturn false;\n}",
        "target": 0
    },
    {
        "id": 3352,
        "func": "void WebContentsImpl::ClearDeviceEmulationSize() {\n  RenderWidgetHostView* rwhv = GetMainFrame()->GetView();\n  if (!view_size_before_emulation_.IsEmpty() && rwhv &&\n      rwhv->GetViewBounds().size() == device_emulation_size_) {\n    rwhv->SetSize(view_size_before_emulation_);\n  }\n  device_emulation_size_ = gfx::Size();\n  view_size_before_emulation_ = gfx::Size();\n}\n",
        "target": 0
    },
    {
        "id": 3353,
        "func": "DrawingBuffer::DrawingBuffer(\n    std::unique_ptr<WebGraphicsContext3DProvider> context_provider,\n    std::unique_ptr<Extensions3DUtil> extensions_util,\n    Client* client,\n    bool discard_framebuffer_supported,\n     bool want_alpha_channel,\n     bool premultiplied_alpha,\n     PreserveDrawingBuffer preserve,\n    WebGLVersion web_gl_version,\n     bool want_depth,\n     bool want_stencil,\n     ChromiumImageUsage chromium_image_usage,\n     const CanvasColorParams& color_params)\n     : client_(client),\n       preserve_drawing_buffer_(preserve),\n      web_gl_version_(web_gl_version),\n       context_provider_(WTF::WrapUnique(new WebGraphicsContext3DProviderWrapper(\n           std::move(context_provider)))),\n       gl_(this->ContextProvider()->ContextGL()),\n      extensions_util_(std::move(extensions_util)),\n      discard_framebuffer_supported_(discard_framebuffer_supported),\n      want_alpha_channel_(want_alpha_channel),\n      premultiplied_alpha_(premultiplied_alpha),\n      software_rendering_(this->ContextProvider()->IsSoftwareRendering()),\n      want_depth_(want_depth),\n      want_stencil_(want_stencil),\n      color_space_(color_params.GetGfxColorSpace()),\n      chromium_image_usage_(chromium_image_usage) {\n  TRACE_EVENT_INSTANT0(\"test_gpu\", \"DrawingBufferCreation\",\n                       TRACE_EVENT_SCOPE_GLOBAL);\n}\n",
        "target": 1
    },
    {
        "id": 3354,
        "func": "void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm, bool fullmm)\n{\n\ttlb->mm = mm;\n\n\ttlb->fullmm     = fullmm;\n\ttlb->need_flush = 0;\n\ttlb->fast_mode  = (num_possible_cpus() == 1);\n\ttlb->local.next = NULL;\n\ttlb->local.nr   = 0;\n\ttlb->local.max  = ARRAY_SIZE(tlb->__pages);\n\ttlb->active     = &tlb->local;\n\n#ifdef CONFIG_HAVE_RCU_TABLE_FREE\n\ttlb->batch = NULL;\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 3355,
        "func": "void LoginPromptBrowserTestObserver::AddHandler(LoginHandler* handler) {\n  std::list<LoginHandler*>::iterator i = std::find(handlers_.begin(),\n                                                   handlers_.end(),\n                                                   handler);\n  EXPECT_TRUE(i == handlers_.end());\n  if (i == handlers_.end())\n    handlers_.push_back(handler);\n}\n",
        "target": 0
    },
    {
        "id": 3356,
        "func": "void WebContentsImpl::EnsureOpenerProxiesExist(RenderFrameHost* source_rfh) {\n  WebContentsImpl* source_web_contents = static_cast<WebContentsImpl*>(\n      WebContents::FromRenderFrameHost(source_rfh));\n\n  if (source_web_contents) {\n    if (GetBrowserPluginEmbedder() &&\n        GuestMode::IsCrossProcessFrameGuest(source_web_contents)) {\n      return;\n    }\n\n    if (this != source_web_contents && GetBrowserPluginGuest()) {\n      source_web_contents->GetRenderManager()->CreateRenderFrameProxy(\n          GetSiteInstance());\n    } else {\n      RenderFrameHostImpl* source_rfhi =\n          static_cast<RenderFrameHostImpl*>(source_rfh);\n      source_rfhi->frame_tree_node()->render_manager()->CreateOpenerProxies(\n          GetSiteInstance(), nullptr);\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3357,
        "func": "void TextAutosizer::setMultiplier(RenderObject* renderer, float multiplier)\n{\n    RefPtr<RenderStyle> newStyle = RenderStyle::clone(renderer->style());\n    newStyle->setTextAutosizingMultiplier(multiplier);\n    renderer->setStyle(newStyle.release());\n}\n",
        "target": 0
    },
    {
        "id": 3358,
        "func": "WebString WebLocalFrameImpl::SelectionAsText() const {\n  DCHECK(GetFrame());\n  WebPluginContainerImpl* plugin_container =\n      GetFrame()->GetWebPluginContainer();\n  if (plugin_container)\n    return plugin_container->Plugin()->SelectionAsText();\n\n  GetFrame()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();\n\n  String text = GetFrame()->Selection().SelectedText(\n      TextIteratorBehavior::EmitsObjectReplacementCharacterBehavior());\n#if defined(OS_WIN)\n  ReplaceNewlinesWithWindowsStyleNewlines(text);\n#endif\n  ReplaceNBSPWithSpace(text);\n  return text;\n}\n",
        "target": 0
    },
    {
        "id": 3359,
        "func": "static int prepend(char **buffer, int *buflen, const char *str, int namelen)\n{\n\t*buflen -= namelen;\n\tif (*buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\t*buffer -= namelen;\n\tmemcpy(*buffer, str, namelen);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3360,
        "func": "const KURL& DocumentLoader::requestURL() const\n{\n    return request().url();\n}\n",
        "target": 0
    },
    {
        "id": 3361,
        "func": " PP_Resource ResourceTracker::AddResource(Resource* resource) {\n   if (last_resource_id_ ==\n      (std::numeric_limits<PP_Resource>::max() >> kPPIdTypeBits))\n    return 0;\n\n  PP_Resource new_id = MakeTypedId(++last_resource_id_, PP_ID_TYPE_RESOURCE);\n  live_resources_.insert(std::make_pair(new_id, std::make_pair(resource, 1)));\n\n   PP_Instance pp_instance = resource->instance()->pp_instance();\n   DCHECK(instance_map_.find(pp_instance) != instance_map_.end());\n  instance_map_[pp_instance]->ref_resources.insert(new_id);\n   return new_id;\n }\n",
        "target": 0
    },
    {
        "id": 3362,
        "func": "SPL_METHOD(SplHeap, recoverFromCorruption)\n{\n\tspl_heap_object *intern;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"\") == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = (spl_heap_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tintern->heap->flags = intern->heap->flags & ~SPL_HEAP_CORRUPTED;\n\n\tRETURN_TRUE;\n}\n",
        "target": 0
    },
    {
        "id": 3363,
        "func": "void ShutdownWatcherHelper::Arm(const base::TimeDelta& duration) {\n  DCHECK_EQ(thread_id_, base::PlatformThread::CurrentId());\n  DCHECK(!shutdown_watchdog_);\n  base::TimeDelta actual_duration = duration;\n\n   version_info::Channel channel = chrome::GetChannel();\n   if (channel == version_info::Channel::STABLE) {\n     actual_duration *= 20;\n  } else if (channel == version_info::Channel::BETA ||\n             channel == version_info::Channel::DEV) {\n     actual_duration *= 10;\n   }\n \n #if defined(OS_WIN)\n  if (base::win::GetVersion() <= base::win::VERSION_XP)\n    actual_duration *= 2;\n#endif\n\n  shutdown_watchdog_ = new ShutdownWatchDogThread(actual_duration);\n  shutdown_watchdog_->Arm();\n}\n",
        "target": 1
    },
    {
        "id": 3364,
        "func": "static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = rfcomm_pi(sk)->sec_level;\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 3365,
        "func": "Gfx::Gfx(XRef *xrefA, OutputDev *outA, Dict *resDict, Catalog *catalogA,\n\t PDFRectangle *box, PDFRectangle *cropBox,\n\t GBool (*abortCheckCbkA)(void *data),\n\t void *abortCheckCbkDataA)\n #ifdef USE_CMS\n : iccColorSpaceCache(5)\n#endif\n{\n  int i;\n\n  xref = xrefA;\n  catalog = catalogA;\n  subPage = gTrue;\n  printCommands = globalParams->getPrintCommands();\n  profileCommands = globalParams->getProfileCommands();\n  textHaveCSPattern = gFalse;\n  drawText = gFalse;\n   drawText = gFalse;\n   maskHaveCSPattern = gFalse;\n   mcStack = NULL;\n \n   res = new GfxResources(xref, resDict, NULL);\n  out = outA;\n  state = new GfxState(72, 72, box, 0, gFalse);\n  stackHeight = 1;\n  pushStateGuard();\n  fontChanged = gFalse;\n  clip = clipNone;\n  ignoreUndef = 0;\n  for (i = 0; i < 6; ++i) {\n    baseMatrix[i] = state->getCTM()[i];\n  }\n  formDepth = 0;\n  abortCheckCbk = abortCheckCbkA;\n  abortCheckCbkData = abortCheckCbkDataA;\n\n  if (cropBox) {\n    state->moveTo(cropBox->x1, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y2);\n    state->lineTo(cropBox->x1, cropBox->y2);\n    state->closePath();\n    state->clip();\n    out->clip(state);\n    state->clearPath();\n  }\n}\n",
        "target": 1
    },
    {
        "id": 3366,
        "func": "static char *get_field_name(PGconn *pgsql, Oid oid, HashTable *list)\n{\n\tPGresult *result;\n\tsmart_str str = {0};\n\tzend_resource *field_type;\n\tchar *ret=NULL;\n\n\t/* try to lookup the type in the resource list */\n\tsmart_str_appends(&str, \"pgsql_oid_\");\n\tsmart_str_append_unsigned(&str, oid);\n\tsmart_str_0(&str);\n\n\tif ((field_type = zend_hash_find_ptr(list, str.s)) != NULL) {\n\t\tret = estrdup((char *)field_type->ptr);\n\t} else { /* hash all oid's */\n\t\tint i, num_rows;\n\t\tint oid_offset,name_offset;\n\t\tchar *tmp_oid, *end_ptr, *tmp_name;\n\t\tzend_resource new_oid_entry;\n\n\t\tif ((result = PQexec(pgsql, \"select oid,typname from pg_type\")) == NULL || PQresultStatus(result) != PGRES_TUPLES_OK) {\n\t\t\tif (result) {\n\t\t\t\tPQclear(result);\n\t\t\t}\n\t\t\tsmart_str_free(&str);\n\t\t\treturn estrndup(\"\", sizeof(\"\") - 1);\n\t\t}\n\t\tnum_rows = PQntuples(result);\n\t\toid_offset = PQfnumber(result,\"oid\");\n\t\tname_offset = PQfnumber(result,\"typname\");\n\n\t\tfor (i=0; i<num_rows; i++) {\n\t\t\tif ((tmp_oid = PQgetvalue(result,i,oid_offset))==NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tstr.s->len = 0;\n\t\t\tsmart_str_appends(&str, \"pgsql_oid_\");\n\t\t\tsmart_str_appends(&str, tmp_oid);\n\t\t\tsmart_str_0(&str);\n\n\t\t\tif ((tmp_name = PQgetvalue(result,i,name_offset))==NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew_oid_entry.type = le_string;\n\t\t\tnew_oid_entry.ptr = estrdup(tmp_name);\n\t\t\tzend_hash_update_mem(list, str.s, (void *) &new_oid_entry, sizeof(zend_resource));\n\t\t\tif (!ret && strtoul(tmp_oid, &end_ptr, 10)==oid) {\n\t\t\t\tret = estrdup(tmp_name);\n\t\t\t}\n\t\t}\n\t\tPQclear(result);\n\t}\n\n\tsmart_str_free(&str);\n\treturn ret;\n}\n",
        "target": 0
    },
    {
        "id": 3367,
        "func": "void InlineFlowBox::extractLine()\n{\n    if (!m_extracted)\n        extractLineBoxFromRenderObject();\n    for (InlineBox* child = firstChild(); child; child = child->nextOnLine())\n        child->extractLine();\n}\n",
        "target": 0
    },
    {
        "id": 3368,
        "func": "int64 MakeServerNodeForType(UserShare* share,\n                            ModelType model_type) {\n  sync_pb::EntitySpecifics specifics;\n  syncable::AddDefaultFieldValue(model_type, &specifics);\n  syncable::WriteTransaction trans(\n      FROM_HERE, syncable::UNITTEST, share->directory.get());\n  std::string type_tag = syncable::ModelTypeToRootTag(model_type);\n  syncable::Id node_id = syncable::Id::CreateFromServerId(type_tag);\n  syncable::MutableEntry entry(&trans, syncable::CREATE_NEW_UPDATE_ITEM,\n                               node_id);\n  EXPECT_TRUE(entry.good());\n  entry.Put(syncable::BASE_VERSION, 1);\n  entry.Put(syncable::SERVER_VERSION, 1);\n  entry.Put(syncable::IS_UNAPPLIED_UPDATE, false);\n  entry.Put(syncable::SERVER_PARENT_ID, syncable::GetNullId());\n  entry.Put(syncable::SERVER_IS_DIR, true);\n  entry.Put(syncable::IS_DIR, true);\n  entry.Put(syncable::SERVER_SPECIFICS, specifics);\n  entry.Put(syncable::UNIQUE_SERVER_TAG, type_tag);\n  entry.Put(syncable::NON_UNIQUE_NAME, type_tag);\n  entry.Put(syncable::IS_DEL, false);\n  entry.Put(syncable::SPECIFICS, specifics);\n  return entry.Get(syncable::META_HANDLE);\n}\n",
        "target": 0
    },
    {
        "id": 3369,
        "func": " WebviewInfo::WebviewInfo() {\n }\n",
        "target": 0
    },
    {
        "id": 3370,
        "func": "void ebt_unregister_table(struct net *net, struct ebt_table *table,\n\t\t\t  const struct nf_hook_ops *ops)\n{\n\tif (ops)\n\t\tnf_unregister_net_hooks(net, ops, hweight32(table->valid_hooks));\n\t__ebt_unregister_table(net, table);\n}",
        "target": 0
    },
    {
        "id": 3371,
        "func": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\t\tstruct user_struct *user = get_current_user();\n\n\t\tif (!too_many_pipe_buffers_hard(user)) {\n\t\t\tif (too_many_pipe_buffers_soft(user))\n\t\t\t\tpipe_bufs = 1;\n\t\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);\n\t\t}\n\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = pipe_bufs;\n\t\t\tpipe->user = user;\n\t\t\taccount_pipe_buffers(pipe, 0, pipe_bufs);\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tfree_uid(user);\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 3372,
        "func": " void GraphicsContext::drawFocusRing(const Vector<IntRect>& rects, int width, int offset, const Color& color)\n{\n    if (paintingDisabled())\n        return;\n\n    notImplemented();\n}\n",
        "target": 0
    },
    {
        "id": 3373,
        "func": "void RenderFrameImpl::InstallCreateHook(\n    CreateRenderFrameImplFunction create_frame) {\n  DCHECK(!g_create_render_frame_impl);\n  g_create_render_frame_impl = create_frame;\n}\n",
        "target": 0
    },
    {
        "id": 3374,
        "func": "void DownloadItemImpl::SetExternalData(\n    const void* key, DownloadItem::ExternalData* data) {\n  std::map<const void*, ExternalData*>::iterator it =\n      external_data_map_.find(key);\n\n  if (it == external_data_map_.end()) {\n    external_data_map_[key] = data;\n  } else if (it->second != data) {\n    delete it->second;\n    it->second = data;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3375,
        "func": "static int sched_feat_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, sched_feat_show, NULL);\n}",
        "target": 0
    },
    {
        "id": 3376,
        "func": "static inline pte_t gup_get_pte(pte_t *ptep)\n{\n\treturn READ_ONCE(*ptep);\n}\n",
        "target": 0
    },
    {
        "id": 3377,
        "func": "ChildProcessTerminationInfo ChildProcessLauncherHelper::GetTerminationInfo(\n    const ChildProcessLauncherHelper::Process& process,\n    bool known_dead) {\n  ChildProcessTerminationInfo info;\n   if (!java_peer_avaiable_on_client_thread_)\n     return info;\n \n  Java_ChildProcessLauncherHelperImpl_getTerminationInfo(\n       AttachCurrentThread(), java_peer_, reinterpret_cast<intptr_t>(&info));\n \n   base::android::ApplicationState app_state =\n      base::android::ApplicationStatusListener::GetState();\n  bool app_foreground =\n      app_state == base::android::APPLICATION_STATE_HAS_RUNNING_ACTIVITIES ||\n      app_state == base::android::APPLICATION_STATE_HAS_PAUSED_ACTIVITIES;\n\n  if (app_foreground &&\n      (info.binding_state == base::android::ChildBindingState::MODERATE ||\n       info.binding_state == base::android::ChildBindingState::STRONG)) {\n    info.status = base::TERMINATION_STATUS_OOM_PROTECTED;\n  } else {\n    info.status = base::TERMINATION_STATUS_NORMAL_TERMINATION;\n  }\n  return info;\n}\n",
        "target": 1
    },
    {
        "id": 3378,
        "func": "PHP_FUNCTION(openssl_spki_verify)\n{\n\tsize_t spkstr_len;\n\tint i = 0, spkstr_cleaned_len = 0;\n\tchar *spkstr = NULL, * spkstr_cleaned = NULL;\n\n\tEVP_PKEY *pkey = NULL;\n\tNETSCAPE_SPKI *spki = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &spkstr, &spkstr_len) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tif (spkstr == NULL) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Unable to use supplied SPKAC\");\n\t\tgoto cleanup;\n\t}\n\n\tspkstr_cleaned = emalloc(spkstr_len + 1);\n\tspkstr_cleaned_len = (int)(spkstr_len - openssl_spki_cleanup(spkstr, spkstr_cleaned));\n\n\tif (spkstr_cleaned_len == 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Invalid SPKAC\");\n\t\tgoto cleanup;\n\t}\n\n\tspki = NETSCAPE_SPKI_b64_decode(spkstr_cleaned, spkstr_cleaned_len);\n\tif (spki == NULL) {\n\t\tphp_openssl_store_errors();\n\t\tphp_error_docref(NULL, E_WARNING, \"Unable to decode supplied SPKAC\");\n\t\tgoto cleanup;\n\t}\n\n\tpkey = X509_PUBKEY_get(spki->spkac->pubkey);\n\tif (pkey == NULL) {\n\t\tphp_openssl_store_errors();\n\t\tphp_error_docref(NULL, E_WARNING, \"Unable to acquire signed public key\");\n\t\tgoto cleanup;\n\t}\n\n\ti = NETSCAPE_SPKI_verify(spki, pkey);\n\tgoto cleanup;\n\ncleanup:\n\tif (spki != NULL) {\n\t\tNETSCAPE_SPKI_free(spki);\n\t}\n\tif (pkey != NULL) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tif (spkstr_cleaned != NULL) {\n\t\tefree(spkstr_cleaned);\n\t}\n\n\tif (i > 0) {\n\t\tRETVAL_TRUE;\n\t} else {\n\t\tphp_openssl_store_errors();\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 3379,
        "func": "void V8TestObject::HighEntropyAttributeWithMeasureAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_highEntropyAttributeWithMeasure_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  UseCounter::Count(CurrentExecutionContext(info.GetIsolate()), WebFeature::kV8TestObject_HighEntropyAttributeWithMeasure_AttributeSetter);\n\n  test_object_v8_internal::HighEntropyAttributeWithMeasureAttributeSetter(v8_value, info);\n}\n",
        "target": 0
    },
    {
        "id": 3380,
        "func": "xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {\n register const xmlChar *cmp = other;\n register const xmlChar *in;\n const xmlChar *ret;\n\n    GROW;\n if (ctxt->instate == XML_PARSER_EOF)\n return(NULL);\n\n    in = ctxt->input->cur;\n while (*in != 0 && *in == *cmp) {\n ++in;\n ++cmp;\n\tctxt->input->col++;\n }\n if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {\n /* success */\n\tctxt->input->cur = in;\n return (const xmlChar*) 1;\n }\n /* failure (or end of input buffer), check with full function */\n    ret = xmlParseName (ctxt);\n /* strings coming from the dictionary direct compare possible */\n if (ret == other) {\n return (const xmlChar*) 1;\n }\n return ret;\n}\n",
        "target": 0
    },
    {
        "id": 3381,
        "func": "bool PDFiumEngine::OnKeyDown(const pp::KeyboardInputEvent& event) {\n  if (last_page_mouse_down_ == -1)\n    return false;\n\n  bool rv = !!FORM_OnKeyDown(\n      form_, pages_[last_page_mouse_down_]->GetPage(),\n      event.GetKeyCode(), event.GetModifiers());\n\n  if (event.GetKeyCode() == ui::VKEY_BACK ||\n      event.GetKeyCode() == ui::VKEY_ESCAPE) {\n    std::string str;\n    str.push_back(event.GetKeyCode());\n    pp::KeyboardInputEvent synthesized(pp::KeyboardInputEvent(\n        client_->GetPluginInstance(),\n        PP_INPUTEVENT_TYPE_CHAR,\n        event.GetTimeStamp(),\n        event.GetModifiers(),\n        event.GetKeyCode(),\n        str));\n    OnChar(synthesized);\n  }\n\n  return rv;\n}\n",
        "target": 0
    },
    {
        "id": 3382,
        "func": "void DownloadRequestLimiter::TabDownloadState::DidStartNavigation(\n    content::NavigationHandle* navigation_handle) {\n  if (!navigation_handle->IsInMainFrame())\n    return;\n\n   download_seen_ = false;\n   ui_status_ = DOWNLOAD_UI_DEFAULT;\n \n  if (navigation_handle->IsRendererInitiated() &&\n      (status_ == PROMPT_BEFORE_DOWNLOAD || status_ == DOWNLOADS_NOT_ALLOWED)) {\n    return;\n   }\n \n   if (status_ == DownloadRequestLimiter::ALLOW_ALL_DOWNLOADS ||\n      status_ == DownloadRequestLimiter::DOWNLOADS_NOT_ALLOWED) {\n    if (!initial_page_host_.empty() &&\n        navigation_handle->GetURL().host_piece() == initial_page_host_) {\n      return;\n    }\n  }\n\n  NotifyCallbacks(false);\n  host_->Remove(this, web_contents());\n}\n",
        "target": 1
    },
    {
        "id": 3383,
        "func": "sshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}\n",
        "target": 0
    },
    {
        "id": 3384,
        "func": "static const char *user_agent(void)\n{\n\tconst char *custom = git_libgit2__user_agent();\n\n\tif (custom)\n\t\treturn custom;\n\n\treturn \"libgit2 \" LIBGIT2_VERSION;\n}",
        "target": 0
    },
    {
        "id": 3385,
        "func": "static int decode_attr_space_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_SPACE_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_SPACE_AVAIL)) {\n\t\tREAD_BUF(8);\n\t\tREAD64(*res);\n\t\tbitmap[1] &= ~FATTR4_WORD1_SPACE_AVAIL;\n\t}\n\tdprintk(\"%s: space avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\n}",
        "target": 0
    },
    {
        "id": 3386,
        "func": "static inline void free_mm_slot(struct mm_slot *mm_slot)\n{\n\tkmem_cache_free(mm_slot_cache, mm_slot);\n}",
        "target": 0
    },
    {
        "id": 3387,
        "func": "static int rtc_ioctl(unsigned fd, unsigned cmd, void __user *argp)\n{\n\tmm_segment_t oldfs = get_fs();\n\tcompat_ulong_t val32;\n\tunsigned long kval;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase RTC_IRQP_READ32:\n\tcase RTC_EPOCH_READ32:\n\t\tset_fs(KERNEL_DS);\n\t\tret = sys_ioctl(fd, (cmd == RTC_IRQP_READ32) ?\n\t\t\t\t\tRTC_IRQP_READ : RTC_EPOCH_READ,\n\t\t\t\t\t(unsigned long)&kval);\n\t\tset_fs(oldfs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval32 = kval;\n\t\treturn put_user(val32, (unsigned int __user *)argp);\n\tcase RTC_IRQP_SET32:\n\t\treturn sys_ioctl(fd, RTC_IRQP_SET, (unsigned long)argp);\n\tcase RTC_EPOCH_SET32:\n\t\treturn sys_ioctl(fd, RTC_EPOCH_SET, (unsigned long)argp);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}",
        "target": 0
    },
    {
        "id": 3388,
        "func": "bool Document::HaveImportsLoaded() const {\n  if (!imports_controller_)\n    return true;\n  return !imports_controller_->ShouldBlockScriptExecution(*this);\n}\n",
        "target": 0
    },
    {
        "id": 3389,
        "func": "static void nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tUINT16 i;\n\tBYTE* rle;\n\tUINT32 planeSize;\n\tUINT32 originalSize;\n\trle = context->Planes;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toriginalSize = context->OrgByteCount[i];\n\t\tplaneSize = context->PlaneByteCount[i];\n\n\t\tif (planeSize == 0)\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\telse if (planeSize < originalSize)\n\t\t\tnsc_rle_decode(rle, context->priv->PlaneBuffers[i], originalSize);\n\t\telse\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\n\t\trle += planeSize;\n\t}\n}",
        "target": 1
    },
    {
        "id": 3390,
        "func": "BrowserActionButton::BrowserActionButton(Extension* extension,\n                                         BrowserActionsContainer* panel)\n    : MenuButton(this, L\"\", NULL, false),\n      browser_action_(extension->browser_action()),\n      extension_(extension),\n      tracker_(NULL),\n      showing_context_menu_(false),\n      panel_(panel) {\n  set_alignment(TextButton::ALIGN_CENTER);\n\n\n  registrar_.Add(this, NotificationType::EXTENSION_BROWSER_ACTION_UPDATED,\n                 Source<ExtensionAction>(browser_action_));\n\n  std::string relative_path = browser_action_->default_icon_path();\n  if (relative_path.empty())\n    return;\n\n  tracker_ = new ImageLoadingTracker(this, 1);\n  tracker_->PostLoadImageTask(\n      extension->GetResource(relative_path),\n      gfx::Size(Extension::kBrowserActionIconMaxSize,\n                Extension::kBrowserActionIconMaxSize));\n}\n",
        "target": 0
    },
    {
        "id": 3391,
        "func": " MountError PerformFakeMount(const std::string& source_path,\n                            const base::FilePath& mounted_path) {\n   if (mounted_path.empty())\n     return MOUNT_ERROR_INVALID_ARGUMENT;\n \n  if (!base::CreateDirectory(mounted_path)) {\n    DLOG(ERROR) << \"Failed to create directory at \" << mounted_path.value();\n     return MOUNT_ERROR_DIRECTORY_CREATION_FAILED;\n   }\n \n   const base::FilePath dummy_file_path =\n       mounted_path.Append(\"SUCCESSFULLY_PERFORMED_FAKE_MOUNT.txt\");\n  const std::string dummy_file_content = \"This is a dummy file.\";\n  const int write_result = base::WriteFile(\n      dummy_file_path, dummy_file_content.data(), dummy_file_content.size());\n  if (write_result != static_cast<int>(dummy_file_content.size())) {\n    DLOG(ERROR) << \"Failed to put a dummy file at \"\n                << dummy_file_path.value();\n    return MOUNT_ERROR_MOUNT_PROGRAM_FAILED;\n  }\n\n  return MOUNT_ERROR_NONE;\n}\n",
        "target": 1
    },
    {
        "id": 3392,
        "func": "get_schema_name(int version)\n{\n    if (version < 0 || version >= xml_schema_max) {\n        return \"unknown\";\n    }\n    return known_schemas[version].name;\n}\n",
        "target": 0
    },
    {
        "id": 3393,
        "func": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\n\t/*\n\t * Make sure the root blkg exists and count the existing blkgs.  As\n\t * @q is bypassing at this point, blkg_lookup_create() can't be\n\t * used.  Open code insertion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 3394,
        "func": "file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\n\tif (a->num_values)\n\t{\n\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n\n             case MAPI_ATTACH_MIME_TAG:\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n\n                case MAPI_ATTACH_CONTENT_ID:\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                    memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\n                    break;\n\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    }\n}",
        "target": 1
    },
    {
        "id": 3395,
        "func": "static BOOLEAN flush_incoming_que_on_wr_signal_l(l2cap_socket *sock)\n{\n uint8_t *buf;\n\n     uint32_t len;\n \n     while (packet_get_head_l(sock, &buf, &len)) {\n        int sent = send(sock->our_fd, buf, len, MSG_DONTWAIT);\n \n         if (sent == (signed)len)\n             osi_free(buf);\n else if (sent >= 0) {\n            packet_put_head_l(sock, buf + sent, len - sent);\n            osi_free(buf);\n if (!sent) /* special case if other end not keeping up */\n return TRUE;\n }\n else {\n            packet_put_head_l(sock, buf, len);\n            osi_free(buf);\n return errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN;\n }\n }\n\n return FALSE;\n}\n",
        "target": 1
    },
    {
        "id": 3396,
        "func": "static int spl_array_has_dimension_ex(int check_inherited, zval *object, zval *offset, int check_empty TSRMLS_DC) /* {{{ */\n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tlong index;\n\tzval *rv, *value = NULL, **tmp;\n\n\tif (check_inherited && intern->fptr_offset_has) {\n\t\tzval *offset_tmp = offset;\n\t\tSEPARATE_ARG_IF_REF(offset_tmp);\n\t\tzend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_has, \"offsetExists\", &rv, offset_tmp);\n\t\tzval_ptr_dtor(&offset_tmp);\n\n\t\tif (rv && zend_is_true(rv)) {\n\t\t\tzval_ptr_dtor(&rv);\n\t\t\tif (check_empty != 1) {\n\t\t\t\treturn 1;\n\t\t\t} else if (intern->fptr_offset_get) {\n\t\t\t\tvalue = spl_array_read_dimension_ex(1, object, offset, BP_VAR_R TSRMLS_CC);\n\t\t\t}\n\t\t} else {\n\t\t\tif (rv) {\n\t\t\t\tzval_ptr_dtor(&rv);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!value) {\n \t\tHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n \n \t\tswitch(Z_TYPE_P(offset)) {\n\t\t\tcase IS_STRING: \n \t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **) &tmp) != FAILURE) {\n \t\t\t\t\tif (check_empty == 2) {\n \t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n \n \t\t\tcase IS_DOUBLE:\n \t\t\tcase IS_RESOURCE:\n\t\t\tcase IS_BOOL: \n \t\t\tcase IS_LONG:\n \t\t\t\tif (offset->type == IS_DOUBLE) {\n \t\t\t\t\tindex = (long)Z_DVAL_P(offset);\n\t\t\t\t} else {\n\t\t\t\t\tindex = Z_LVAL_P(offset);\n\t\t\t\t}\n\t\t\t\tif (zend_hash_index_find(ht, index, (void **)&tmp) != FAILURE) {\n\t\t\t\t\tif (check_empty == 2) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tzend_error(E_WARNING, \"Illegal offset type\");\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (check_empty && check_inherited && intern->fptr_offset_get) {\n\t\t\tvalue = spl_array_read_dimension_ex(1, object, offset, BP_VAR_R TSRMLS_CC);\n\t\t} else {\n\t\t\tvalue = *tmp;\n\t\t}\n\t}\n\n\treturn check_empty ? zend_is_true(value) : Z_TYPE_P(value) != IS_NULL;\n} /* }}} */\n",
        "target": 1
    },
    {
        "id": 3397,
        "func": "  MockCoordinator(MemoryTracingIntegrationTest* client) : client_(client) {}\n",
        "target": 0
    },
    {
        "id": 3398,
        "func": "void Document::UpdateViewportDescription() {\n  if (GetFrame() && GetFrame()->IsMainFrame()) {\n    GetPage()->GetChromeClient().DispatchViewportPropertiesDidChange(\n        GetViewportDescription());\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3399,
        "func": "  void PostTask() {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&RenderProcessHostIsReadyObserver::CallTask,\n                       weak_factory_.GetWeakPtr()));\n  }\n",
        "target": 0
    },
    {
        "id": 3400,
        "func": "static PCIBus *acpi_pcihp_find_hotplug_bus(AcpiPciHpState *s, int bsel)\n{\n    AcpiPciHpFind find = { .bsel = bsel, .bus = NULL };\n\n    if (bsel < 0) {\n        return NULL;\n    }\n\n    pci_for_each_bus(s->root, acpi_pcihp_test_hotplug_bus, &find);\n\n    /* Make bsel 0 eject root bus if bsel property is not set,\n     * for compatibility with non acpi setups.\n     * TODO: really needed?\n     */\n    if (!bsel && !find.bus) {\n        find.bus = s->root;\n    }\n    return find.bus;\n}\n",
        "target": 0
    },
    {
        "id": 3401,
        "func": "int ZEXPORT inflatePrime(strm, bits, value)\nz_streamp strm;\nint bits;\nint value;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (bits < 0) {\n        state->hold = 0;\n        state->bits = 0;\n        return Z_OK;\n    }\n    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;\n    value &= (1L << bits) - 1;\n    state->hold += value << state->bits;\n    state->bits += bits;\n    return Z_OK;\n}",
        "target": 0
    },
    {
        "id": 3402,
        "func": "static int _hid_get_descriptor(struct hid_device_priv* dev, HANDLE hid_handle, int recipient,\n",
        "target": 0
    },
    {
        "id": 3403,
        "func": "static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t *ctx,\n const struct vpx_internal_error_info *error) {\n if (error->error_code)\n    set_error_detail(ctx, error->has_detail ? error->detail : NULL);\n\n return error->error_code;\n}\n",
        "target": 0
    },
    {
        "id": 3404,
        "func": "makeJsonLexContext(text *json, bool need_escapes)\n{\n\treturn makeJsonLexContextCstringLen(VARDATA(json),\n\t\t\t\t\t\t\t\t\t\tVARSIZE(json) - VARHDRSZ,\n\t\t\t\t\t\t\t\t\t\tneed_escapes);\n}\n",
        "target": 0
    },
    {
        "id": 3405,
        "func": "u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,\n\t\t\t    struct vm_area_struct *vma,\n\t\t\t    struct address_space *mapping,\n\t\t\t    pgoff_t idx, unsigned long address)\n{\n\tunsigned long key[2];\n\tu32 hash;\n\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tkey[0] = (unsigned long) mapping;\n\t\tkey[1] = idx;\n\t} else {\n\t\tkey[0] = (unsigned long) mm;\n\t\tkey[1] = address >> huge_page_shift(h);\n\t}\n\n\thash = jhash2((u32 *)&key, sizeof(key)/sizeof(u32), 0);\n\n\treturn hash & (num_fault_mutexes - 1);\n}",
        "target": 0
    },
    {
        "id": 3406,
        "func": "mailimf_only_optional_field_parse(const char * message,\n\t\t\t\t  size_t length,\n\t\t\t\t  size_t * indx,\n\t\t\t\t  struct mailimf_field ** result)\n{\n  int r;\n  size_t cur_token;\n  struct mailimf_optional_field * optional_field;\n  struct mailimf_field * field;\n\n  cur_token = * indx;\n\n  r = mailimf_optional_field_parse(message, length, &cur_token,\n\t\t\t\t   &optional_field);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  field = mailimf_field_new(MAILIMF_FIELD_OPTIONAL_FIELD, NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, NULL, NULL,\n      NULL, NULL, NULL, optional_field);\n  if (field == NULL) {\n    mailimf_optional_field_free(optional_field);\n    return MAILIMF_ERROR_MEMORY;\n  }\n\n  * result = field;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n}",
        "target": 0
    },
    {
        "id": 3407,
        "func": " void GpuProcessHost::OnChannelEstablished(\n     const IPC::ChannelHandle& channel_handle) {\n  DCHECK(gpu_process_);\n   EstablishChannelCallback callback = channel_requests_.front();\n   channel_requests_.pop();\n \n  if (!channel_handle.name.empty() &&\n      !GpuDataManagerImpl::GetInstance()->GpuAccessAllowed()) {\n    Send(new GpuMsg_CloseChannel(channel_handle));\n    EstablishChannelError(callback,\n                          IPC::ChannelHandle(),\n                          base::kNullProcessHandle,\n                          content::GPUInfo());\n    RouteOnUIThread(GpuHostMsg_OnLogMessage(\n        logging::LOG_WARNING,\n        \"WARNING\",\n        \"Hardware acceleration is unavailable.\"));\n     return;\n   }\n \n  callback.Run(channel_handle, gpu_process_,\n                GpuDataManagerImpl::GetInstance()->GetGPUInfo());\n }\n",
        "target": 1
    },
    {
        "id": 3408,
        "func": "static VncBasicInfo *vnc_basic_info_get_from_server_addr(int fd)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen;\n\n    salen = sizeof(sa);\n    if (getsockname(fd, (struct sockaddr*)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    return vnc_basic_info_get(&sa, salen);\n}\n",
        "target": 0
    },
    {
        "id": 3409,
        "func": "static ZIPARCHIVE_METHOD(addEmptyDir)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tchar *dirname;\n\tint   dirname_len;\n\tint idx;\n\tstruct zip_stat sb;\n\tchar *s;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t\t\t\t&dirname, &dirname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (dirname_len<1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dirname[dirname_len-1] != '/') {\n\t\ts=(char *)emalloc(dirname_len+2);\n\t\tstrcpy(s, dirname);\n\t\ts[dirname_len] = '/';\n\t\ts[dirname_len+1] = '\\0';\n\t} else {\n\t\ts = dirname;\n\t}\n\n\tidx = zip_stat(intern, s, 0, &sb);\n\tif (idx >= 0) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tif (zip_add_dir(intern, (const char *)s) == -1) {\n\t\t\tRETVAL_FALSE;\n\t\t}\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (s != dirname) {\n\t\tefree(s);\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 3410,
        "func": "void ChromeMockRenderThread::OnUpdatePrintSettings(\n    int document_cookie,\n    const base::DictionaryValue& job_settings,\n    PrintMsg_PrintPages_Params* params) {\n  std::string dummy_string;\n  int margins_type = 0;\n  if (!job_settings.GetBoolean(printing::kSettingLandscape, NULL) ||\n      !job_settings.GetBoolean(printing::kSettingCollate, NULL) ||\n      !job_settings.GetInteger(printing::kSettingColor, NULL) ||\n      !job_settings.GetBoolean(printing::kSettingPrintToPDF, NULL) ||\n      !job_settings.GetBoolean(printing::kIsFirstRequest, NULL) ||\n       !job_settings.GetString(printing::kSettingDeviceName, &dummy_string) ||\n       !job_settings.GetInteger(printing::kSettingDuplexMode, NULL) ||\n       !job_settings.GetInteger(printing::kSettingCopies, NULL) ||\n      !job_settings.GetString(printing::kPreviewUIAddr, &dummy_string) ||\n       !job_settings.GetInteger(printing::kPreviewRequestID, NULL) ||\n       !job_settings.GetInteger(printing::kSettingMarginsType, &margins_type)) {\n     return;\n   }\n \n  if (printer_.get()) {\n    const ListValue* page_range_array;\n    printing::PageRanges new_ranges;\n    if (job_settings.GetList(printing::kSettingPageRange, &page_range_array)) {\n      for (size_t index = 0; index < page_range_array->GetSize(); ++index) {\n        const base::DictionaryValue* dict;\n        if (!page_range_array->GetDictionary(index, &dict))\n          continue;\n        printing::PageRange range;\n        if (!dict->GetInteger(printing::kSettingPageRangeFrom, &range.from) ||\n            !dict->GetInteger(printing::kSettingPageRangeTo, &range.to)) {\n          continue;\n        }\n        range.from--;\n        range.to--;\n        new_ranges.push_back(range);\n       }\n     }\n    std::vector<int> pages(printing::PageRange::GetPages(new_ranges));\n    printer_->UpdateSettings(document_cookie, params, pages, margins_type);\n   }\n }\n",
        "target": 1
    },
    {
        "id": 3411,
        "func": "static void floatSequenceAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestObj.floatSequenceAttr._set\");\n    TestObj* imp = V8TestObj::toNative(info.Holder());\n    Vector<float> v = toNativeArray<float>(value);\n    imp->setFloatSequenceAttr(v);\n    return;\n}\n",
        "target": 0
    },
    {
        "id": 3412,
        "func": "static void __init i8042_register_ports(void)\n{\n\tint i;\n\n\tfor (i = 0; i < I8042_NUM_PORTS; i++) {\n\t\tstruct serio *serio = i8042_ports[i].serio;\n\n\t\tif (serio) {\n\t\t\tprintk(KERN_INFO \"serio: %s at %#lx,%#lx irq %d\\n\",\n\t\t\t\tserio->name,\n\t\t\t\t(unsigned long) I8042_DATA_REG,\n\t\t\t\t(unsigned long) I8042_COMMAND_REG,\n\t\t\t\ti8042_ports[i].irq);\n\t\t\tserio_register_port(serio);\n\t\t\tdevice_set_wakeup_capable(&serio->dev, true);\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 3413,
        "func": "bool DownloadManagerImpl::IsNextIdInitialized() const {\n  return is_history_download_id_retrieved_ && in_progress_cache_initialized_;\n}\n",
        "target": 0
    },
    {
        "id": 3414,
        "func": "static void btrfs_add_delalloc_inodes(struct btrfs_root *root,\n\t\t\t\t      struct inode *inode)\n{\n\tspin_lock(&root->delalloc_lock);\n\tif (list_empty(&BTRFS_I(inode)->delalloc_inodes)) {\n\t\tlist_add_tail(&BTRFS_I(inode)->delalloc_inodes,\n\t\t\t      &root->delalloc_inodes);\n\t\tset_bit(BTRFS_INODE_IN_DELALLOC_LIST,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\troot->nr_delalloc_inodes++;\n\t\tif (root->nr_delalloc_inodes == 1) {\n\t\t\tspin_lock(&root->fs_info->delalloc_root_lock);\n\t\t\tBUG_ON(!list_empty(&root->delalloc_root));\n\t\t\tlist_add_tail(&root->delalloc_root,\n\t\t\t\t      &root->fs_info->delalloc_roots);\n\t\t\tspin_unlock(&root->fs_info->delalloc_root_lock);\n\t\t}\n\t}\n\tspin_unlock(&root->delalloc_lock);\n}",
        "target": 0
    },
    {
        "id": 3415,
        "func": "  Compute_Funcs( TT_ExecContext  exc )\n  {\n    if ( exc->GS.freeVector.x == 0x4000 )\n      exc->F_dot_P = exc->GS.projVector.x;\n    else if ( exc->GS.freeVector.y == 0x4000 )\n      exc->F_dot_P = exc->GS.projVector.y;\n    else\n      exc->F_dot_P =\n        ( (FT_Long)exc->GS.projVector.x * exc->GS.freeVector.x +\n          (FT_Long)exc->GS.projVector.y * exc->GS.freeVector.y ) >> 14;\n\n    if ( exc->GS.projVector.x == 0x4000 )\n      exc->func_project = (TT_Project_Func)Project_x;\n    else if ( exc->GS.projVector.y == 0x4000 )\n      exc->func_project = (TT_Project_Func)Project_y;\n    else\n      exc->func_project = (TT_Project_Func)Project;\n\n    if ( exc->GS.dualVector.x == 0x4000 )\n      exc->func_dualproj = (TT_Project_Func)Project_x;\n    else if ( exc->GS.dualVector.y == 0x4000 )\n      exc->func_dualproj = (TT_Project_Func)Project_y;\n    else\n      exc->func_dualproj = (TT_Project_Func)Dual_Project;\n\n    exc->func_move      = (TT_Move_Func)Direct_Move;\n    exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig;\n\n    if ( exc->F_dot_P == 0x4000L )\n    {\n      if ( exc->GS.freeVector.x == 0x4000 )\n      {\n        exc->func_move      = (TT_Move_Func)Direct_Move_X;\n        exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;\n      }\n      else if ( exc->GS.freeVector.y == 0x4000 )\n      {\n        exc->func_move      = (TT_Move_Func)Direct_Move_Y;\n        exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;\n      }\n    }\n\n    /* at small sizes, F_dot_P can become too small, resulting   */\n    /* in overflows and `spikes' in a number of glyphs like `w'. */\n\n    if ( FT_ABS( exc->F_dot_P ) < 0x400L )\n      exc->F_dot_P = 0x4000L;\n\n    /* Disable cached aspect ratio */\n    exc->tt_metrics.ratio = 0;\n  }\n",
        "target": 0
    },
    {
        "id": 3416,
        "func": "static inline bool nested_cpu_has_vmwrite_any_field(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.misc_low &\n\t\tMSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS;\n}",
        "target": 0
    },
    {
        "id": 3417,
        "func": "image_transform_png_set_strip_16_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if (that->bit_depth == 16)\n    {\n      that->sample_depth = that->bit_depth = 8;\n if (that->red_sBIT > 8) that->red_sBIT = 8;\n if (that->green_sBIT > 8) that->green_sBIT = 8;\n if (that->blue_sBIT > 8) that->blue_sBIT = 8;\n if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;\n\n /* Prior to 1.5.4 png_set_strip_16 would use an 'accurate' method if this\n       * configuration option is set.  From 1.5.4 the flag is never set and the\n       * 'scale' API (above) must be used.\n       */\n#     ifdef PNG_READ_ACCURATE_SCALE_SUPPORTED\n#        if PNG_LIBPNG_VER >= 10504\n#           error PNG_READ_ACCURATE_SCALE should not be set\n#        endif\n\n /* The strip 16 algorithm drops the low 8 bits rather than calculating\n          * 1/257, so we need to adjust the permitted errors appropriately:\n          * Notice that this is only relevant prior to the addition of the\n\n           * png_set_scale_16 API in 1.5.4 (but 1.5.4+ always defines the above!)\n           */\n          {\n            PNG_CONST double d = (255-128.5)/65535;\n             that->rede += d;\n             that->greene += d;\n             that->bluee += d;\n            that->alphae += d;\n }\n#     endif\n }\n\n this->next->mod(this->next, that, pp, display);\n}\n",
        "target": 1
    },
    {
        "id": 3418,
        "func": "Chapters::~Chapters() {\n while (m_editions_count > 0) {\n\n     Edition& e = m_editions[--m_editions_count];\n     e.Clear();\n   }\n }\n",
        "target": 1
    },
    {
        "id": 3419,
        "func": "void WebContentsImpl::NotifyMainFrameSwappedFromRenderManager(\n    RenderFrameHost* old_host,\n    RenderFrameHost* new_host) {\n  NotifyViewSwapped(old_host ? old_host->GetRenderViewHost() : nullptr,\n                    new_host->GetRenderViewHost());\n}\n",
        "target": 0
    },
    {
        "id": 3420,
        "func": "static int\nnl80211_send_sched_scan_msg(struct sk_buff *msg,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct net_device *netdev,\n\t\t\t    u32 pid, u32 seq, int flags, u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;",
        "target": 0
    },
    {
        "id": 3421,
        "func": "parse_single_hex_dump_line(char* rec, guint8 *buf, guint byte_offset)\n{\n\tint num_items_scanned;\n\tguint8 character;\n\tguint8 byte;\n\n\n\tfor (num_items_scanned = 0; num_items_scanned < 16; num_items_scanned++) {\n\t\tcharacter = *rec++;\n\t\tif (character >= '0' && character <= '9')\n\t\t\tbyte = character - '0' + 0;\n\t\telse if (character >= 'A' && character <= 'F')\n\t\t\tbyte = character - 'A' + 0xA;\n\t\telse if (character >= 'a' && character <= 'f')\n\t\t\tbyte = character - 'a' + 0xa;\n\t\telse if (character == ' ' || character == '\\r' || character == '\\n' || character == '\\0') {\n\t\t\t/* Nothing more to parse */\n\t\t\tbreak;\n\t\t} else\n\t\t\treturn -1; /* not a hex digit, space before ASCII dump, or EOL */\n\t\tbyte <<= 4;\n\t\tcharacter = *rec++ & 0xFF;\n\t\tif (character >= '0' && character <= '9')\n\t\t\tbyte += character - '0' + 0;\n\t\telse if (character >= 'A' && character <= 'F')\n\t\t\tbyte += character - 'A' + 0xA;\n\t\telse if (character >= 'a' && character <= 'f')\n\t\t\tbyte += character - 'a' + 0xa;\n\t\telse\n\t\t\treturn -1; /* not a hex digit */\n\t\tbuf[byte_offset + num_items_scanned] = byte;\n\t\tcharacter = *rec++ & 0xFF;\n\t\tif (character == '\\0' || character == '\\r' || character == '\\n') {\n\t\t\t/* Nothing more to parse */\n\t\t\tbreak;\n\t\t} else if (character != ' ') {\n\t\t\t/* not space before ASCII dump */\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (num_items_scanned == 0)\n\t\treturn -1;\n\n\treturn num_items_scanned;\n}",
        "target": 0
    },
    {
        "id": 3422,
        "func": "  cf2_getUnitsPerEm( CFF_Decoder*  decoder )\n  {\n    FT_ASSERT( decoder && decoder->builder.face );\n    FT_ASSERT( decoder->builder.face->root.units_per_EM );\n\n    return decoder->builder.face->root.units_per_EM;\n  }\n",
        "target": 0
    },
    {
        "id": 3423,
        "func": "void IRCView::appendCommandMessage(const QString& type,const QString& message, bool parseURL, bool self)\n{\n    QString commandColor = Preferences::self()->color(Preferences::CommandMessage).name();\n    QString prefix=\"***\";\n    m_tabNotification = Konversation::tnfControl;\n\n    if(type == i18nc(\"Message type\", \"Join\"))\n    {\n        prefix=\"-->\";\n        parseURL=false;\n    }\n    else if(type == i18nc(\"Message type\", \"Part\") || type == i18nc(\"Message type\", \"Quit\"))\n    {\n        prefix=\"<--\";\n    }\n\n    prefix=Qt::escape(prefix);\n\n    QString line;\n    QChar::Direction dir;\n    QString text(filter(message, commandColor, 0, true, parseURL, self, &dir));\n    bool rtl = (dir == QChar::DirR);\n\n    if(rtl)\n    {\n        line = RLE;\n        line += LRE;\n        line += \"<font color=\\\"\" + commandColor + \"\\\">%2 %1\" + PDF + \" %3</font>\";\n    }\n    else\n    {\n        if (!QApplication::isLeftToRight())\n            line += LRE;\n\n        line += \"<font color=\\\"\" + commandColor + \"\\\">%1 %2 %3</font>\";\n    }\n\n    line = line.arg(timeStamp(), prefix, text);\n\n    emit textToLog(QString(\"%1\\t%2\").arg(type, message));\n\n    doAppend(line, rtl, self);\n}\n",
        "target": 0
    },
    {
        "id": 3424,
        "func": "static void parse_mark(void)\n{\n\tconst char *v;\n\tif (skip_prefix(command_buf.buf, \"mark :\", &v)) {\n\t\tnext_mark = strtoumax(v, NULL, 10);\n\t\tread_next_command();\n\t}\n\telse\n\t\tnext_mark = 0;\n}",
        "target": 0
    },
    {
        "id": 3425,
        "func": "void AppCacheDatabase::Disable() {\n  VLOG(1) << \"Disabling appcache database.\";\n  is_disabled_ = true;\n  ResetConnectionAndTables();\n }\n",
        "target": 0
    },
    {
        "id": 3426,
        "func": "static void btreeReleaseAllCursorPages(BtCursor *pCur){\n  int i;\n  if( pCur->iPage>=0 ){\n    for(i=0; i<pCur->iPage; i++){\n      releasePageNotNull(pCur->apPage[i]);\n    }\n    releasePageNotNull(pCur->pPage);\n    pCur->iPage = -1;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3427,
        "func": "xdr_generic_ret(XDR *xdrs, generic_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn(TRUE);\n}",
        "target": 0
    },
    {
        "id": 3428,
        "func": "void transit_unintern(struct transit *transit)\n{\n\tif (transit->refcnt)\n\t\ttransit->refcnt--;\n\n\tif (transit->refcnt == 0) {\n\t\thash_release(transit_hash, transit);\n\t\ttransit_free(transit);\n\t}\n}",
        "target": 0
    },
    {
        "id": 3429,
        "func": "void BrowserCommandController::UpdateCommandsForMediaRouter() {\n  if (is_locked_fullscreen_)\n    return;\n\n  command_updater_.UpdateCommandEnabled(IDC_ROUTE_MEDIA,\n                                        CanRouteMedia(browser_));\n}\n",
        "target": 0
    },
    {
        "id": 3430,
        "func": "static inline double MagickRound(double x)\n{\n  /*\n    Round the fraction to nearest integer.\n  */\n  if ((x-floor(x)) < (ceil(x)-x))\n    return(floor(x));\n  return(ceil(x));\n}\n",
        "target": 0
    },
    {
        "id": 3431,
        "func": "void WebFrameLoaderClient::didFinishLoad() {\n  OwnPtr<WebPluginLoadObserver> plugin_load_observer = GetPluginLoadObserver();\n  if (plugin_load_observer)\n    plugin_load_observer->didFinishLoading();\n}\n",
        "target": 0
    },
    {
        "id": 3432,
        "func": "NDIS_STATUS ParaNdis6_ReceivePauseRestart(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN bPause,\n    ONPAUSECOMPLETEPROC Callback\n    )\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n\n    if (bPause)\n    {\n        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);\n\n        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);\n        if (pContext->m_upstreamPacketPending != 0)\n        {\n            pContext->ReceiveState = srsPausing;\n            pContext->ReceivePauseCompletionProc = Callback;\n            status = NDIS_STATUS_PENDING;\n        }\n        else\n        {\n            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);\n            pContext->ReceiveState = srsDisabled;\n        }\n    }\n    else\n    {\n        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);\n        pContext->ReceiveState = srsEnabled;\n    }\n    return status;\n}",
        "target": 0
    },
    {
        "id": 3433,
        "func": "static int phar_update_cached_entry(void *data, void *argument) /* {{{ */\n{\n\tphar_entry_info *entry = (phar_entry_info *)data;\n\tTSRMLS_FETCH();\n\n\tentry->phar = (phar_archive_data *)argument;\n\n\tif (entry->link) {\n\t\tentry->link = estrdup(entry->link);\n\t}\n\n\tif (entry->tmp) {\n\t\tentry->tmp = estrdup(entry->tmp);\n\t}\n\n\tentry->metadata_str.c = 0;\n\tentry->filename = estrndup(entry->filename, entry->filename_len);\n\tentry->is_persistent = 0;\n\n\tif (entry->metadata) {\n\t\tif (entry->metadata_len) {\n\t\t\tchar *buf = estrndup((char *) entry->metadata, entry->metadata_len);\n\t\t\t/* assume success, we would have failed before */\n\t\t\tphar_parse_metadata((char **) &buf, &entry->metadata, entry->metadata_len TSRMLS_CC);\n\t\t\tefree(buf);\n\t\t} else {\n\t\t\tzval *t;\n\n\t\t\tt = entry->metadata;\n\t\t\tALLOC_ZVAL(entry->metadata);\n\t\t\t*entry->metadata = *t;\n\t\t\tzval_copy_ctor(entry->metadata);\n\t\t\tZ_SET_REFCOUNT_P(entry->metadata, 1);\n\t\t\tentry->metadata_str.c = NULL;\n\t\t\tentry->metadata_str.len = 0;\n\t\t}\n\t}\n\treturn ZEND_HASH_APPLY_KEEP;\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 3434,
        "func": "void HTMLMediaElement::scheduleTimeupdateEvent(bool periodicEvent) {\n  double mediaTime = currentPlaybackPosition();\n  double now = WTF::currentTime();\n\n  bool haveNotRecentlyFiredTimeupdate =\n      (now - m_lastTimeUpdateEventWallTime) >= maxTimeupdateEventFrequency;\n  bool mediaTimeHasProgressed = mediaTime != m_lastTimeUpdateEventMediaTime;\n\n  if (!periodicEvent ||\n      (haveNotRecentlyFiredTimeupdate && mediaTimeHasProgressed)) {\n    scheduleEvent(EventTypeNames::timeupdate);\n    m_lastTimeUpdateEventWallTime = now;\n    m_lastTimeUpdateEventMediaTime = mediaTime;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3435,
        "func": "void StoragePartitionImpl::OpenLocalStorage(\n    const url::Origin& origin,\n    blink::mojom::StorageAreaRequest request) {\n  int process_id = bindings_.dispatch_context();\n  if (!ChildProcessSecurityPolicy::GetInstance()->CanAccessDataForOrigin(\n          process_id, origin.GetURL())) {\n    SYSLOG(WARNING) << \"Killing renderer: illegal localStorage request.\";\n    bindings_.ReportBadMessage(\"Access denied for localStorage request\");\n    return;\n  }\n  dom_storage_context_->OpenLocalStorage(origin, std::move(request));\n}\n",
        "target": 0
    },
    {
        "id": 3436,
        "func": "static int vfat_cmpi(const struct dentry *parent, const struct inode *pinode,\n\t\tconst struct dentry *dentry, const struct inode *inode,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct nls_table *t = MSDOS_SB(parent->d_sb)->nls_io;\n\tunsigned int alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = vfat_striptail_len(name);\n\tblen = __vfat_striptail_len(len, str);\n\tif (alen == blen) {\n\t\tif (nls_strnicmp(t, name->name, str, alen) == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 3437,
        "func": "R_API ut64 r_core_bin_impaddr(RBin *bin, int va, const char *name) {\n\tRList *symbols;\n\n\tif (!name || !*name) {\n\t\treturn false;\n\t}\n\tif (!(symbols = r_bin_get_symbols (bin))) {\n\t\treturn false;\n\t}\n\tchar *impname = r_str_newf (\"imp.%s\", name);\n\tRBinSymbol *s = get_symbol (bin, symbols, impname, 0LL);\n\t// maybe ut64_MAX to indicate import not found?\n\tut64 addr = 0LL;\n\tif (s) {\n\t\tif (va) {\n\t\t\tif (s->paddr == UT64_MAX) {\n\t\t\t\taddr = s->vaddr;\n\t\t\t} else {\n\t\t\t\taddr = r_bin_get_vaddr (bin, s->paddr, s->vaddr);\n\t\t\t}\n\t\t} else {\n\t\t\taddr = s->paddr;\n\t\t}\n\t}\n\tfree (impname);\n\treturn addr;\n}",
        "target": 0
    },
    {
        "id": 3438,
        "func": "static void VoidMethodElementSequenceOrByteStringDoubleOrStringRecordMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"voidMethodElementSequenceOrByteStringDoubleOrStringRecord\");\n\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n    return;\n  }\n\n  ElementSequenceOrByteStringDoubleOrStringRecord arg;\n  V8ElementSequenceOrByteStringDoubleOrStringRecord::ToImpl(info.GetIsolate(), info[0], arg, UnionTypeConversionMode::kNotNullable, exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->voidMethodElementSequenceOrByteStringDoubleOrStringRecord(arg);\n}\n",
        "target": 0
    },
    {
        "id": 3439,
        "func": "static int process_cmd_sock(int h)\n\n {\n     sock_cmd_t cmd = {-1, 0, 0, 0, 0};\n     int fd = ts[h].cmd_fdr;\n    if(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL) != sizeof(cmd))\n     {\n         APPL_TRACE_ERROR(\"recv cmd errno:%d\", errno);\n         return FALSE;\n }\n    APPL_TRACE_DEBUG(\"cmd.id:%d\", cmd.id);\n switch(cmd.id)\n {\n case CMD_ADD_FD:\n            add_poll(h, cmd.fd, cmd.type, cmd.flags, cmd.user_id);\n break;\n case CMD_REMOVE_FD:\n for (int i = 1; i < MAX_POLL; ++i)\n {\n poll_slot_t *poll_slot = &ts[h].ps[i];\n if (poll_slot->pfd.fd == cmd.fd)\n {\n                    remove_poll(h, poll_slot, poll_slot->flags);\n break;\n }\n }\n            close(cmd.fd);\n break;\n case CMD_WAKEUP:\n break;\n case CMD_USER_PRIVATE:\n            asrt(ts[h].cmd_callback);\n if(ts[h].cmd_callback)\n                ts[h].cmd_callback(fd, cmd.type, cmd.flags, cmd.user_id);\n break;\n case CMD_EXIT:\n return FALSE;\n default:\n            APPL_TRACE_DEBUG(\"unknown cmd: %d\", cmd.id);\n break;\n }\n return TRUE;\n}\n",
        "target": 1
    },
    {
        "id": 3440,
        "func": "static PHP_FUNCTION(gzopen)\n{\n\tchar *filename;\n\tchar *mode;\n\tint filename_len, mode_len;\n\tint flags = REPORT_ERRORS;\n        php_stream *stream;\n        long use_include_path = 0;\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|l\", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {\n                return;\n        }\n \n\tif (use_include_path) {\n\t\tflags |= USE_PATH;\n\t}\n\n\tstream = php_stream_gzopen(NULL, filename, mode, flags, NULL, NULL STREAMS_CC TSRMLS_CC);\n\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\tphp_stream_to_zval(stream, return_value);\n}\n",
        "target": 1
    },
    {
        "id": 3441,
        "func": "gfx::Point RenderFrameHostImpl::AccessibilityOriginInScreen(\n    const gfx::Rect& bounds) const {\n  RenderWidgetHostViewBase* view = static_cast<RenderWidgetHostViewBase*>(\n      render_view_host_->GetWidget()->GetView());\n  if (view)\n    return view->AccessibilityOriginInScreen(bounds);\n  return gfx::Point();\n}\n",
        "target": 0
    },
    {
        "id": 3442,
        "func": "iperf_json_printf(const char *format, ...)\n{\n    cJSON* o;\n    va_list argp;\n    const char *cp;\n    char name[100];\n    char* np;\n    cJSON* j;\n\n    o = cJSON_CreateObject();\n    if (o == NULL)\n        return NULL;\n    va_start(argp, format);\n    np = name;\n    for (cp = format; *cp != '\\0'; ++cp) {\n\tswitch (*cp) {\n\t    case ' ':\n\t    break;\n\t    case ':':\n\t    *np = '\\0';\n\t    break;\n\t    case '%':\n\t    ++cp;\n\t    switch (*cp) {\n\t\tcase 'b':\n\t\tj = cJSON_CreateBool(va_arg(argp, int));\n\t\tbreak;\n\t\tcase 'd':\n\t\tj = cJSON_CreateNumber(va_arg(argp, int64_t));\n\t\tbreak;\n\t\tcase 'f':\n\t\tj = cJSON_CreateNumber(va_arg(argp, double));\n\t\tbreak;\n\t\tcase 's':\n\t\tj = cJSON_CreateString(va_arg(argp, char *));\n\t\tbreak;\n\t\tdefault:\n\t\treturn NULL;\n\t    }\n\t    if (j == NULL)\n\t\treturn NULL;\n\t    cJSON_AddItemToObject(o, name, j);\n\t    np = name;\n\t    break;\n\t    default:\n\t    *np++ = *cp;\n\t    break;\n\t}\n    }\n    va_end(argp);\n    return o;\n}",
        "target": 0
    },
    {
        "id": 3443,
        "func": "void NetworkChangeNotifierMac::Forwarder::Init()  {\n  net_config_watcher_->SetInitialConnectionType();\n}\n",
        "target": 0
    },
    {
        "id": 3444,
        "func": "PGTYPESdate_to_asc(date dDate)\n{\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\tint\t\t\tDateStyle = 1;\n\tbool\t\tEuroDates = FALSE;\n\n\tj2date(dDate + date2j(2000, 1, 1), &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\tEncodeDateOnly(tm, DateStyle, buf, EuroDates);\n\treturn pgtypes_strdup(buf);\n}",
        "target": 0
    },
    {
        "id": 3445,
        "func": "bool Shell::CanAcceptEvent(const ui::Event& event) {\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 3446,
        "func": "void WebGLObject::detach()\n{\n    m_attachmentCount = 0; // Make sure OpenGL resource is deleted.\n    }\n",
        "target": 0
    },
    {
        "id": 3447,
        "func": "static PassRefPtr<CSSPrimitiveValue> fontSizeFromStyle(RenderStyle* style)\n{\n    return zoomAdjustedPixelValue(style->fontDescription().computedPixelSize(), style);\n}\n",
        "target": 0
    },
    {
        "id": 3448,
        "func": "RenderFrameHostImpl* RenderFrameHostImpl::FromAXTreeID(\n    ui::AXTreeID ax_tree_id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  ui::AXTreeIDRegistry::FrameID frame_id =\n      ui::AXTreeIDRegistry::GetInstance()->GetFrameID(ax_tree_id);\n  return RenderFrameHostImpl::FromID(frame_id.first, frame_id.second);\n}\n",
        "target": 0
    },
    {
        "id": 3449,
        "func": "int ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tif ((task->thread.regs == NULL) || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\tif (regno < (sizeof(struct pt_regs) / sizeof(unsigned long))) {\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
        "target": 0
    },
    {
        "id": 3450,
        "func": "void LayerTreeHostImpl::SetLayerTreeMutator(\n    std::unique_ptr<LayerTreeMutator> mutator) {\n  if (mutator == mutator_)\n    return;\n  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"compositor-worker\"),\n               \"LayerTreeHostImpl::SetLayerTreeMutator\");\n  mutator_ = std::move(mutator);\n  mutator_->SetClient(this);\n}\n",
        "target": 0
    },
    {
        "id": 3451,
        "func": "_XcursorReadImage (XcursorFile\t\t*file,\n\t\t   XcursorFileHeader\t*fileHeader,\n\t\t   int\t\t\ttoc)\n{\n    XcursorChunkHeader\tchunkHeader;\n    XcursorImage\thead;\n    XcursorImage\t*image;\n    int\t\t\tn;\n    XcursorPixel\t*p;\n\n    if (!file || !fileHeader)\n        return NULL;\n\n    if (!_XcursorFileReadChunkHeader (file, fileHeader, toc, &chunkHeader))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.width))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.height))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.xhot))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.yhot))\n\treturn NULL;\n    if (!_XcursorReadUInt (file, &head.delay))\n\treturn NULL;\n    /* sanity check data */\n    if (head.width >= 0x10000 || head.height > 0x10000)\n\treturn NULL;\n     if (!_XcursorReadUInt (file, &head.delay))\n \treturn NULL;\n     /* sanity check data */\n    if (head.width >= 0x10000 || head.height > 0x10000)\n \treturn NULL;\n     if (head.width == 0 || head.height == 0)\n \treturn NULL;\n\t    return NULL;\n    if (chunkHeader.version < image->version)\n\timage->version = chunkHeader.version;\n    image->size = chunkHeader.subtype;\n    image->xhot = head.xhot;\n    image->yhot = head.yhot;\n    image->delay = head.delay;\n    n = image->width * image->height;\n    p = image->pixels;\n    while (n--)\n    {\n\tif (!_XcursorReadUInt (file, p))\n\t{\n\t    XcursorImageDestroy (image);\n\t    return NULL;\n\t}\n\tp++;\n    }\n    return image;\n}\n",
        "target": 1
    },
    {
        "id": 3452,
        "func": "static void compositionToUnderlines(const Vector<DWORD>& clauses, const Vector<BYTE>& attributes, Vector<CompositionUnderline>& underlines)\n{\n    if (clauses.isEmpty()) {\n        underlines.clear();\n        return;\n    }\n  \n    size_t numBoundaries = clauses.size() - 1;\n    underlines.resize(numBoundaries);\n    for (unsigned i = 0; i < numBoundaries; ++i) {\n        underlines[i].startOffset = clauses[i];\n        underlines[i].endOffset = clauses[i + 1];\n        BYTE attribute = attributes[clauses[i]];\n        underlines[i].thick = attribute == ATTR_TARGET_CONVERTED || attribute == ATTR_TARGET_NOTCONVERTED;\n        underlines[i].color = Color::black;\n    }\n}\n",
        "target": 0
    },
    {
        "id": 3453,
        "func": "ofputil_decode_ofp13_table_stats(struct ofpbuf *msg,\n                                 struct ofputil_table_stats *stats,\n                                 struct ofputil_table_features *features)\n{\n    struct ofp13_table_stats *ots;\n\n    ots = ofpbuf_try_pull(msg, sizeof *ots);\n    if (!ots) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    features->table_id = ots->table_id;\n\n    stats->table_id = ots->table_id;\n    stats->active_count = ntohl(ots->active_count);\n    stats->lookup_count = ntohll(ots->lookup_count);\n    stats->matched_count = ntohll(ots->matched_count);\n\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 3454,
        "func": "static void openssl_add_method_or_alias(const OBJ_NAME *name, void *arg) /* {{{ */\n{\n\tadd_next_index_string((zval*)arg, (char*)name->name, 1);\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 3455,
        "func": "GeometryMapper::SourceToDestinationProjectionInternal(\n    const TransformPaintPropertyNode* source,\n    const TransformPaintPropertyNode* destination,\n    bool& success) {\n  DCHECK(source && destination);\n  DEFINE_STATIC_LOCAL(TransformationMatrix, identity, (TransformationMatrix()));\n  DEFINE_STATIC_LOCAL(TransformationMatrix, temp, (TransformationMatrix()));\n\n  if (source == destination) {\n    success = true;\n    return identity;\n  }\n\n  const GeometryMapperTransformCache& source_cache =\n      source->GetTransformCache();\n  const GeometryMapperTransformCache& destination_cache =\n      destination->GetTransformCache();\n\n  if (source_cache.plane_root() == destination_cache.plane_root()) {\n    success = true;\n    if (source == destination_cache.plane_root())\n      return destination_cache.from_plane_root();\n    if (destination == source_cache.plane_root())\n      return source_cache.to_plane_root();\n    temp = destination_cache.from_plane_root();\n    temp.Multiply(source_cache.to_plane_root());\n    return temp;\n  }\n\n  if (!destination_cache.projection_from_screen_is_valid()) {\n    success = false;\n    return identity;\n  }\n \n  const auto* root = &TransformPaintPropertyNode::Root();\n   success = true;\n   if (source == root)\n     return destination_cache.projection_from_screen();\n  if (destination == root) {\n    temp = source_cache.to_screen();\n  } else {\n    temp = destination_cache.projection_from_screen();\n    temp.Multiply(source_cache.to_screen());\n  }\n  temp.FlattenTo2d();\n  return temp;\n}\n",
        "target": 0
    },
    {
        "id": 3456,
        "func": "void IRCView::appendQueryAction(const QString& nick, const QString& message)\n{\n    m_tabNotification = Konversation::tnfPrivate;\n    appendAction(nick, message);\n}\n",
        "target": 0
    },
    {
        "id": 3457,
        "func": "dnslabel_clear(struct dnslabel_table *table)\n{\n\tint i;\n\tfor (i = 0; i < table->n_labels; ++i)\n\t\tmm_free(table->labels[i].v);\n\ttable->n_labels = 0;\n}",
        "target": 0
    },
    {
        "id": 3458,
        "func": "void UpdateContentLengthPrefs(int received_content_length,\n                              int original_content_length,\n                              bool via_data_reduction_proxy) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n   DCHECK_GE(received_content_length, 0);\n   DCHECK_GE(original_content_length, 0);\n\n  if (!g_browser_process)\n    return;\n\n  PrefService* prefs = g_browser_process->local_state();\n  if (!prefs)\n    return;\n\n#if defined(OS_ANDROID)\n  bool with_data_reduction_proxy_enabled =\n      g_browser_process->profile_manager()->GetDefaultProfile()->\n      GetPrefs()->GetBoolean(prefs::kSpdyProxyAuthEnabled);\n#else\n  bool with_data_reduction_proxy_enabled = false;\n#endif\n\n  chrome_browser_net::UpdateContentLengthPrefs(\n       received_content_length,\n       original_content_length,\n       with_data_reduction_proxy_enabled,\n      via_data_reduction_proxy, prefs);\n }\n",
        "target": 1
    },
    {
        "id": 3459,
        "func": "void PrintWebViewHelper::ComputePageLayoutInPointsForCss(\n    blink::WebFrame* frame,\n    int page_index,\n    const PrintMsg_Print_Params& page_params,\n    bool ignore_css_margins,\n    double* scale_factor,\n    PageSizeMargins* page_layout_in_points) {\n  PrintMsg_Print_Params params = CalculatePrintParamsForCss(\n      frame, page_index, page_params, ignore_css_margins,\n      page_params.print_scaling_option ==\n          blink::WebPrintScalingOptionFitToPrintableArea,\n      scale_factor);\n  CalculatePageLayoutFromPrintParams(params, page_layout_in_points);\n}\n",
        "target": 0
    },
    {
        "id": 3460,
        "func": "bool PrintWebViewHelper::CopyMetafileDataToSharedMem(\n    printing::Metafile* metafile,\n    base::SharedMemoryHandle* shared_mem_handle) {\n  uint32 buf_size = metafile->GetDataSize();\n  base::SharedMemoryHandle mem_handle =\n      content::RenderThread::Get()->HostAllocateSharedMemoryBuffer(buf_size);\n  if (base::SharedMemory::IsHandleValid(mem_handle)) {\n    base::SharedMemory shared_buf(mem_handle, false);\n    if (shared_buf.Map(buf_size)) {\n      metafile->GetData(shared_buf.memory(), buf_size);\n      shared_buf.GiveToProcess(base::GetCurrentProcessHandle(),\n                               shared_mem_handle);\n      return true;\n    }\n  }\n  NOTREACHED();\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 3461,
        "func": "void InputWindowHandle::releaseInfo() {\n if (mInfo) {\n delete mInfo;\n        mInfo = NULL;\n }\n}\n",
        "target": 0
    },
    {
        "id": 3462,
        "func": "static ssize_t write_null(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn count;\n}",
        "target": 0
    },
    {
        "id": 3463,
        "func": "void WebContentsImpl::OnSetSelectedColorInColorChooser(int color_chooser_id,\n                                                       SkColor color) {\n  if (color_chooser_ &&\n      color_chooser_id == color_chooser_identifier_)\n    color_chooser_->SetSelectedColor(color);\n}\n",
        "target": 0
    },
    {
        "id": 3464,
        "func": "void InputDispatcher::onANRLocked(\n nsecs_t currentTime, const sp<InputApplicationHandle>& applicationHandle,\n const sp<InputWindowHandle>& windowHandle,\n nsecs_t eventTime, nsecs_t waitStartTime, const char* reason) {\n float dispatchLatency = (currentTime - eventTime) * 0.000001f;\n float waitDuration = (currentTime - waitStartTime) * 0.000001f;\n    ALOGI(\"Application is not responding: %s.  \"\n \"It has been %0.1fms since event, %0.1fms since wait started.  Reason: %s\",\n            getApplicationWindowLabelLocked(applicationHandle, windowHandle).string(),\n            dispatchLatency, waitDuration, reason);\n\n time_t t = time(NULL);\n struct tm tm;\n    localtime_r(&t, &tm);\n char timestr[64];\n    strftime(timestr, sizeof(timestr), \"%F %T\", &tm);\n    mLastANRState.clear();\n    mLastANRState.append(INDENT \"ANR:\\n\");\n    mLastANRState.appendFormat(INDENT2 \"Time: %s\\n\", timestr);\n    mLastANRState.appendFormat(INDENT2 \"Window: %s\\n\",\n            getApplicationWindowLabelLocked(applicationHandle, windowHandle).string());\n    mLastANRState.appendFormat(INDENT2 \"DispatchLatency: %0.1fms\\n\", dispatchLatency);\n    mLastANRState.appendFormat(INDENT2 \"WaitDuration: %0.1fms\\n\", waitDuration);\n    mLastANRState.appendFormat(INDENT2 \"Reason: %s\\n\", reason);\n    dumpDispatchStateLocked(mLastANRState);\n\n CommandEntry* commandEntry = postCommandLocked(\n & InputDispatcher::doNotifyANRLockedInterruptible);\n    commandEntry->inputApplicationHandle = applicationHandle;\n    commandEntry->inputWindowHandle = windowHandle;\n    commandEntry->reason = reason;\n}\n",
        "target": 0
    },
    {
        "id": 3465,
        "func": "void ScreenRecorder::DoFinishOneRecording() {\n  DCHECK_EQ(capture_loop_, MessageLoop::current());\n\n  if (!is_recording_)\n    return;\n\n  --recordings_;\n  DCHECK_GE(recordings_, 0);\n\n  if (frame_skipped_)\n    DoCapture();\n}\n",
        "target": 0
    },
    {
        "id": 3466,
        "func": " int UnpackEntry(sqlite_utils::SQLStatement* statement, EntryKernel** kernel) {\n   *kernel = NULL;\n   int query_result = statement->step();\n  if (query_result == SQLITE_ROW) {\n    *kernel = new EntryKernel();\n    DCHECK_EQ(statement->column_count(), static_cast<int>(FIELD_COUNT));\n     int i = 0;\n     for (i = BEGIN_FIELDS; i < INT64_FIELDS_END; ++i) {\n       (*kernel)->put(static_cast<Int64Field>(i), statement->column_int64(i));\n     }\n    for ( ; i < TIME_FIELDS_END; ++i) {\n      (*kernel)->put(static_cast<TimeField>(i),\n                     browser_sync::ProtoTimeToTime(\n                         statement->column_int64(i)));\n    }\n     for ( ; i < ID_FIELDS_END; ++i) {\n       (*kernel)->mutable_ref(static_cast<IdField>(i)).s_ =\n           statement->column_string(i);\n    }\n    for ( ; i < BIT_FIELDS_END; ++i) {\n      (*kernel)->put(static_cast<BitField>(i), (0 != statement->column_int(i)));\n    }\n    for ( ; i < STRING_FIELDS_END; ++i) {\n      (*kernel)->put(static_cast<StringField>(i),\n          statement->column_string(i));\n    }\n    for ( ; i < PROTO_FIELDS_END; ++i) {\n       (*kernel)->mutable_ref(static_cast<ProtoField>(i)).ParseFromArray(\n           statement->column_blob(i), statement->column_bytes(i));\n     }\n   } else {\n    DCHECK_EQ(query_result, SQLITE_DONE);\n     (*kernel) = NULL;\n   }\n   return query_result;\n}\n",
        "target": 1
    },
    {
        "id": 3467,
        "func": "\nGF_Err trun_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrunEntry *p;\n\tGF_TrackFragmentRunBox *ptr = (GF_TrackFragmentRunBox *)s;\n\n\t//check this is a good file\n\tif ((ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) && (ptr->flags & GF_ISOM_TRUN_FLAGS))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->sample_count = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\t//The rest depends on the flags\n\tif (ptr->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n\t\tptr->data_offset = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\tif (ptr->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tptr->first_sample_flags = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\tif (! (ptr->flags & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {\n\t\tGF_SAFEALLOC(p, GF_TrunEntry);\n\t\tp->nb_pack = ptr->sample_count;\n\t\tgf_list_add(ptr->entries, p);\n\t\treturn GF_OK;\n\t}\n\n\t//read each entry (even though nothing may be written)\n\tfor (i=0; i<ptr->sample_count; i++) {\n\t\tu32 trun_size = 0;\n\t\tp = (GF_TrunEntry *) gf_malloc(sizeof(GF_TrunEntry));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tmemset(p, 0, sizeof(GF_TrunEntry));\n\n\t\tif (ptr->flags & GF_ISOM_TRUN_DURATION) {\n\t\t\tp->Duration = gf_bs_read_u32(bs);\n\t\t\ttrun_size += 4;\n\t\t}\n\t\tif (ptr->flags & GF_ISOM_TRUN_SIZE) {\n\t\t\tp->size = gf_bs_read_u32(bs);\n\t\t\ttrun_size += 4;\n\t\t}\n\t\t//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED\n\t\tif (ptr->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\tp->flags = gf_bs_read_u32(bs);\n\t\t\ttrun_size += 4;\n\t\t}\n\t\tif (ptr->flags & GF_ISOM_TRUN_CTS_OFFSET) {\n\t\t\tif (ptr->version==0) {\n\t\t\t\tp->CTS_Offset = (u32) gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tp->CTS_Offset = (s32) gf_bs_read_u32(bs);\n\t\t\t}\n\t\t}\n\t\tgf_list_add(ptr->entries, p);\n\t\tISOM_DECREASE_SIZE(ptr, trun_size);\n\t}\n\treturn GF_OK;",
        "target": 0
    },
    {
        "id": 3468,
        "func": " static base::TimeDelta GetSwapDelay() {\n  CommandLine* cmd_line = CommandLine::ForCurrentProcess();\n  int delay = 0;\n  if (cmd_line->HasSwitch(switches::kGpuSwapDelay)) {\n    base::StringToInt(cmd_line->GetSwitchValueNative(\n        switches::kGpuSwapDelay).c_str(), &delay);\n  }\n  return base::TimeDelta::FromMilliseconds(delay);\n}\n",
        "target": 0
    },
    {
        "id": 3469,
        "func": "int netlink_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,\n\t\t\t\t\t\t     struct nlmsghdr *))\n{\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)\n\t\t\treturn 0;\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST))\n\t\t\tgoto ack;\n\n\t\t/* Skip control messages */\n\t\tif (nlh->nlmsg_type < NLMSG_MIN_TYPE)\n\t\t\tgoto ack;\n\n\t\terr = cb(skb, nlh);\n\t\tif (err == -EINTR)\n\t\t\tgoto skip;\n\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err)\n\t\t\tnetlink_ack(skb, nlh, err);\n\nskip:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3470,
        "func": "psf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf)\n{\tsf_count_t\tk = 0 ;\n\tsf_count_t\t\tcount ;\n\n\twhile (k < bufsize - 1)\n\t{\tcount = read (psf->file.filedes, &(buffer [k]), 1) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0 || buffer [k++] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tbuffer [k] = 0 ;\n\n\treturn k ;\n} /* psf_fgets */",
        "target": 0
    },
    {
        "id": 3471,
        "func": "static int ext4_remove_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_extent *ex,\n\t\t\t\text4_lblk_t from, ext4_lblk_t to)\n{\n\tunsigned short ee_len =  ext4_ext_get_actual_len(ex);\n\tint flags = EXT4_FREE_BLOCKS_FORGET;\n\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n#ifdef EXTENTS_STATS\n\t{\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t\tspin_lock(&sbi->s_ext_stats_lock);\n\t\tsbi->s_ext_blocks += ee_len;\n\t\tsbi->s_ext_extents++;\n\t\tif (ee_len < sbi->s_ext_min)\n\t\t\tsbi->s_ext_min = ee_len;\n\t\tif (ee_len > sbi->s_ext_max)\n\t\t\tsbi->s_ext_max = ee_len;\n\t\tif (ext_depth(inode) > sbi->s_depth_max)\n\t\t\tsbi->s_depth_max = ext_depth(inode);\n\t\tspin_unlock(&sbi->s_ext_stats_lock);\n\t}\n#endif\n\tif (from >= le32_to_cpu(ex->ee_block)\n\t    && to == le32_to_cpu(ex->ee_block) + ee_len - 1) {\n\t\t/* tail removal */\n\t\text4_lblk_t num;\n\t\text4_fsblk_t start;\n\n\t\tnum = le32_to_cpu(ex->ee_block) + ee_len - from;\n\t\tstart = ext4_ext_pblock(ex) + ee_len - num;\n\t\text_debug(\"free last %u blocks starting %llu\\n\", num, start);\n\t\text4_free_blocks(handle, inode, NULL, start, num, flags);\n\t} else if (from == le32_to_cpu(ex->ee_block)\n\t\t   && to <= le32_to_cpu(ex->ee_block) + ee_len - 1) {\n\t\tprintk(KERN_INFO \"strange request: removal %u-%u from %u:%u\\n\",\n\t\t\tfrom, to, le32_to_cpu(ex->ee_block), ee_len);\n\t} else {\n\t\tprintk(KERN_INFO \"strange request: removal(2) \"\n\t\t\t\t\"%u-%u from %u:%u\\n\",\n\t\t\t\tfrom, to, le32_to_cpu(ex->ee_block), ee_len);\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3472,
        "func": "void MakeSectionBold(views::StyledLabel* label,\n                     const base::string16& text,\n                     const base::Optional<int>& bold_start,\n                     int bold_length) {\n  auto create_style = [&](bool is_bold) {\n    views::StyledLabel::RangeStyleInfo style;\n    if (is_bold) {\n      style.custom_font = label->GetDefaultFontList().Derive(\n          0, gfx::Font::FontStyle::NORMAL, gfx::Font::Weight::BOLD);\n    }\n    style.override_color = SK_ColorWHITE;\n    return style;\n  };\n\n  auto add_style = [&](const views::StyledLabel::RangeStyleInfo& style,\n                       int start, int end) {\n    if (start >= end)\n      return;\n\n    label->AddStyleRange(gfx::Range(start, end), style);\n  };\n\n  views::StyledLabel::RangeStyleInfo regular_style =\n      create_style(false /*is_bold*/);\n  views::StyledLabel::RangeStyleInfo bold_style =\n      create_style(true /*is_bold*/);\n  if (!bold_start || bold_length == 0) {\n    add_style(regular_style, 0, text.length());\n    return;\n  }\n\n  add_style(regular_style, 0, *bold_start - 1);\n  add_style(bold_style, *bold_start, *bold_start + bold_length);\n  add_style(regular_style, *bold_start + bold_length + 1, text.length());\n}\n",
        "target": 0
    },
    {
        "id": 3473,
        "func": "static struct dst_entry *ipv4_dst_check(struct dst_entry *dst, u32 cookie)\n{\n\tstruct rtable *rt = (struct rtable *) dst;\n\n\t/* All IPV4 dsts are created with ->obsolete set to the value\n\t * DST_OBSOLETE_FORCE_CHK which forces validation calls down\n\t * into this function always.\n\t *\n\t * When a PMTU/redirect information update invalidates a route,\n\t * this is indicated by setting obsolete to DST_OBSOLETE_KILL or\n\t * DST_OBSOLETE_DEAD.\n\t */\n\tif (dst->obsolete != DST_OBSOLETE_FORCE_CHK || rt_is_expired(rt))\n\t\treturn NULL;\n\treturn dst;\n}",
        "target": 0
    },
    {
        "id": 3474,
        "func": "status_t SoftHEVC::initDecoder() {\n    IV_API_CALL_STATUS_T status;\n\n    mNumCores = GetCPUCoreCount();\n    mCodecCtx = NULL;\n\n    mStride = outputBufferWidth();\n\n /* Initialize the decoder */\n {\n ivdext_create_ip_t s_create_ip;\n ivdext_create_op_t s_create_op;\n\n void *dec_fxns = (void *)ivdec_api_function;\n\n        s_create_ip.s_ivd_create_ip_t.u4_size = sizeof(ivdext_create_ip_t);\n        s_create_ip.s_ivd_create_ip_t.e_cmd = IVD_CMD_CREATE;\n        s_create_ip.s_ivd_create_ip_t.u4_share_disp_buf = 0;\n        s_create_op.s_ivd_create_op_t.u4_size = sizeof(ivdext_create_op_t);\n        s_create_ip.s_ivd_create_ip_t.e_output_format = mIvColorFormat;\n        s_create_ip.s_ivd_create_ip_t.pf_aligned_alloc = ivd_aligned_malloc;\n        s_create_ip.s_ivd_create_ip_t.pf_aligned_free = ivd_aligned_free;\n        s_create_ip.s_ivd_create_ip_t.pv_mem_ctxt = NULL;\n\n        status = ivdec_api_function(mCodecCtx, (void *)&s_create_ip, (void *)&s_create_op);\n\n        mCodecCtx = (iv_obj_t*)s_create_op.s_ivd_create_op_t.pv_handle;\n        mCodecCtx->pv_fxns = dec_fxns;\n        mCodecCtx->u4_size = sizeof(iv_obj_t);\n\n if (status != IV_SUCCESS) {\n            ALOGE(\"Error in create: 0x%x\",\n                    s_create_op.s_ivd_create_op_t.u4_error_code);\n            deInitDecoder();\n            mCodecCtx = NULL;\n return UNKNOWN_ERROR;\n }\n }\n\n /* Reset the plugin state */\n    resetPlugin();\n\n /* Set the run time (dynamic) parameters */\n    setParams(mStride);\n\n /* Set number of cores/threads to be used by the codec */\n    setNumCores();\n\n /* Get codec version */\n    logVersion();\n\n    mFlushNeeded = false;\n return OK;\n}\n",
        "target": 0
    },
    {
        "id": 3475,
        "func": "getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static getprivs_ret            ret;\n    gss_buffer_desc                client_name, service_name;\n    OM_uint32                      minor_stat;\n    kadm5_server_handle_t          handle;\n    const char                     *errmsg = NULL;\n\n    xdr_free(xdr_getprivs_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n\n    if (errmsg != NULL)\n        krb5_free_error_message(handle->context, errmsg);\n\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
        "target": 1
    },
    {
        "id": 3476,
        "func": "status_t BufferQueueConsumer::setTransformHint(uint32_t hint) {\n    ATRACE_CALL();\n    BQ_LOGV(\"setTransformHint: %#x\", hint);\n Mutex::Autolock lock(mCore->mMutex);\n    mCore->mTransformHint = hint;\n return NO_ERROR;\n}\n",
        "target": 0
    },
    {
        "id": 3477,
        "func": "static ssize_t snd_compr_read(struct file *f, char __user *buf,\n\t\tsize_t count, loff_t *offset)\n{\n\treturn -ENXIO;\n}",
        "target": 0
    },
    {
        "id": 3478,
        "func": "GF_Err rssr_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ReceivedSsrcBox *ptr = (GF_ReceivedSsrcBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->ssrc);\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 3479,
        "func": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
        "target": 0
    },
    {
        "id": 3480,
        "func": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\n\t/* Walk through the list of cached ASCONF-ACKs and find the\n\t * ack chunk whose serial number matches that of the request.\n\t */\n\tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n\t\tif (ack->subh.addip_hdr->serial == serial) {\n\t\t\tsctp_chunk_hold(ack);\n\t\t\treturn ack;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "id": 3481,
        "func": "static void pdf_run_d1(fz_context *ctx, pdf_processor *proc, float wx, float wy, float llx, float lly, float urx, float ury)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tif (pr->nested_depth > 1)\n\t\treturn;\n\tpr->dev->flags |= FZ_DEVFLAG_MASK | FZ_DEVFLAG_BBOX_DEFINED;\n\tpr->dev->flags &= ~(FZ_DEVFLAG_FILLCOLOR_UNDEFINED |\n\t\t\t\tFZ_DEVFLAG_STROKECOLOR_UNDEFINED |\n\t\t\t\tFZ_DEVFLAG_STARTCAP_UNDEFINED |\n\t\t\t\tFZ_DEVFLAG_DASHCAP_UNDEFINED |\n\t\t\t\tFZ_DEVFLAG_ENDCAP_UNDEFINED |\n\t\t\t\tFZ_DEVFLAG_LINEJOIN_UNDEFINED |\n\t\t\t\tFZ_DEVFLAG_MITERLIMIT_UNDEFINED |\n\t\t\t\tFZ_DEVFLAG_LINEWIDTH_UNDEFINED);\n\tpr->dev->d1_rect.x0 = fz_min(llx, urx);\n\tpr->dev->d1_rect.y0 = fz_min(lly, ury);\n\tpr->dev->d1_rect.x1 = fz_max(llx, urx);\n\tpr->dev->d1_rect.y1 = fz_max(lly, ury);\n}\n",
        "target": 0
    },
    {
        "id": 3482,
        "func": "NaClProcessHost::NaClProcessHost(const GURL& manifest_url, bool off_the_record)\n    : manifest_url_(manifest_url),\n#if defined(OS_WIN)\n      process_launched_by_broker_(false),\n#elif defined(OS_LINUX)\n      wait_for_nacl_gdb_(false),\n#endif\n      reply_msg_(NULL),\n#if defined(OS_WIN)\n      debug_exception_handler_requested_(false),\n#endif\n      internal_(new NaClInternal()),\n      ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),\n      enable_exception_handling_(false),\n      off_the_record_(off_the_record) {\n  process_.reset(content::BrowserChildProcessHost::Create(\n      content::PROCESS_TYPE_NACL_LOADER, this));\n\n  process_->SetName(net::FormatUrl(manifest_url_, std::string()));\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableNaClExceptionHandling) ||\n       getenv(\"NACL_UNTRUSTED_EXCEPTION_HANDLING\") != NULL) {\n     enable_exception_handling_ = true;\n   }\n  enable_ipc_proxy_ = CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableNaClIPCProxy);\n }\n",
        "target": 1
    },
    {
        "id": 3483,
        "func": "ip_printroute(netdissect_options *ndo,\n              register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\n\tif (length < 3) {\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn;\n\t}\n\tif ((length + 1) & 3)\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n\t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n\n\tfor (len = 3; len < length; len += 4) {\n\t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n\t\tif (ptr > len)\n\t\t\tND_PRINT((ndo, \",\"));\n\t}\n}",
        "target": 1
    },
    {
        "id": 3484,
        "func": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n\n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n       {\n         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n         w = DIV2(w);\n         h = DIV2(h);\n       }\n    }\n  return(MagickTrue);\n}\n",
        "target": 1
    },
    {
        "id": 3485,
        "func": "char* MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *mhtype = \"Unknown\";\n\tswitch (hdr->filetype) {\n\tcase MH_OBJECT:     mhtype = \"Relocatable object\"; break;\n\tcase MH_EXECUTE:    mhtype = \"Executable file\"; break;\n\tcase MH_FVMLIB:     mhtype = \"Fixed VM shared library\"; break;\n\tcase MH_CORE:       mhtype = \"Core file\"; break;\n\tcase MH_PRELOAD:    mhtype = \"Preloaded executable file\"; break;\n\tcase MH_DYLIB:      mhtype = \"Dynamically bound shared library\"; break;\n\tcase MH_DYLINKER:   mhtype = \"Dynamic link editor\"; break;\n\tcase MH_BUNDLE:     mhtype = \"Dynamically bound bundle file\"; break;\n\tcase MH_DYLIB_STUB: mhtype = \"Shared library stub for static linking (no sections)\"; break;\n\tcase MH_DSYM:       mhtype = \"Companion file with only debug sections\"; break;\n\t}\n\treturn strdup (mhtype);\n}",
        "target": 0
    },
    {
        "id": 3486,
        "func": "struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n\t\t\t\t\t\tint port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\n\tnum = port >= 0 ? port : 0;\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t/* store the port number in the port */\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n\n\treturn new_port;\n}",
        "target": 1
    },
    {
        "id": 3487,
        "func": "png_set_PLTE(png_structp png_ptr, png_infop info_ptr,\n    png_colorp palette, int num_palette)\n {\n \n   png_uint_32 max_palette_length;\n\n    png_debug1(1, \"in %s storage function\", \"PLTE\");\n \n    if (png_ptr == NULL || info_ptr == NULL)\n       return;\n \n   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;\n\n   if (num_palette < 0 || num_palette > (int) max_palette_length)\n    {\n       if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n          png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n\n   /* It may not actually be necessary to set png_ptr->palette here;\n    * we do it for backward compatibility with the way the png_handle_tRNS\n    * function used to do the allocation.\n    */\n#ifdef PNG_FREE_ME_SUPPORTED\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n #endif\n \n    /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead\n    * of num_palette entries, in case of an invalid PNG file or incorrect\n    * call to png_set_PLTE() with too-large sample values.\n     */\n    png_ptr->palette = (png_colorp)png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * png_sizeof(png_color));\n   png_memcpy(png_ptr->palette, palette, num_palette * png_sizeof(png_color));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n\n#ifdef PNG_FREE_ME_SUPPORTED\n   info_ptr->free_me |= PNG_FREE_PLTE;\n#else\n   png_ptr->flags |= PNG_FLAG_FREE_PLTE;\n#endif\n\n   info_ptr->valid |= PNG_INFO_PLTE;\n}\n",
        "target": 0
    },
    {
        "id": 3488,
        "func": "  check_points( CFF_Builder*  builder,\n                FT_Int        count )\n  {\n    return FT_GLYPHLOADER_CHECK_POINTS( builder->loader, count, 0 );\n  }\n",
        "target": 0
    },
    {
        "id": 3489,
        "func": "static int irda_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tstruct irda_sock *self;\n\n\tif (net != &init_net)\n\t\treturn -EAFNOSUPPORT;\n\n\t/* Check for valid socket type */\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:     /* For TTP connections with SAR disabled */\n\tcase SOCK_SEQPACKET:  /* For TTP connections with SAR enabled */\n\tcase SOCK_DGRAM:      /* For TTP Unitdata or LMP Ultra transfers */\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\t/* Allocate networking socket */\n\tsk = sk_alloc(net, PF_IRDA, GFP_KERNEL, &irda_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tself = irda_sk(sk);\n\tpr_debug(\"%s() : self is %p\\n\", __func__, self);\n\n\tinit_waitqueue_head(&self->query_wait);\n\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:\n\t\tsock->ops = &irda_stream_ops;\n\t\tself->max_sdu_size_rx = TTP_SAR_DISABLE;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tsock->ops = &irda_seqpacket_ops;\n\t\tself->max_sdu_size_rx = TTP_SAR_UNBOUND;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tswitch (protocol) {\n#ifdef CONFIG_IRDA_ULTRA\n\t\tcase IRDAPROTO_ULTRA:\n\t\t\tsock->ops = &irda_ultra_ops;\n\t\t\t/* Initialise now, because we may send on unbound\n\t\t\t * sockets. Jean II */\n\t\t\tself->max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER;\n\t\t\tself->max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER;\n\t\t\tbreak;\n#endif /* CONFIG_IRDA_ULTRA */\n\t\tcase IRDAPROTO_UNITDATA:\n\t\t\tsock->ops = &irda_dgram_ops;\n\t\t\t/* We let Unitdata conn. be like seqpack conn. */\n\t\t\tself->max_sdu_size_rx = TTP_SAR_UNBOUND;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsk_free(sk);\n\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsk_free(sk);\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\t/* Initialise networking socket struct */\n\tsock_init_data(sock, sk);\t/* Note : set sk->sk_refcnt to 1 */\n\tsk->sk_family = PF_IRDA;\n\tsk->sk_protocol = protocol;\n\n\t/* Register as a client with IrLMP */\n\tself->ckey = irlmp_register_client(0, NULL, NULL, NULL);\n\tself->mask.word = 0xffff;\n\tself->rx_flow = self->tx_flow = FLOW_START;\n\tself->nslots = DISCOVERY_DEFAULT_SLOTS;\n\tself->daddr = DEV_ADDR_ANY;\t/* Until we get connected */\n\tself->saddr = 0x0;\t\t/* so IrLMP assign us any link */\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 3490,
        "func": "  static void  Ins_SMD( INS_ARG )\n  {\n    CUR.GS.minimum_distance = args[0];\n  }\n",
        "target": 0
    },
    {
        "id": 3491,
        "func": "static int parse_audio_unit(struct mixer_build *state, int unitid)\n{\n\tunsigned char *p1;\n\n\tif (test_and_set_bit(unitid, state->unitbitmap))\n\t\treturn 0; /* the unit already visited */\n\n\tp1 = find_audio_control_unit(state, unitid);\n\tif (!p1) {\n\t\tusb_audio_err(state->chip, \"unit %d not found!\\n\", unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p1[2]) {\n\tcase UAC_INPUT_TERMINAL:\n\t\treturn 0; /* NOP */\n\tcase UAC_MIXER_UNIT:\n\t\treturn parse_audio_mixer_unit(state, unitid, p1);\n\tcase UAC2_CLOCK_SOURCE:\n\t\treturn parse_clock_source_unit(state, unitid, p1);\n\tcase UAC_SELECTOR_UNIT:\n\tcase UAC2_CLOCK_SELECTOR:\n\t\treturn parse_audio_selector_unit(state, unitid, p1);\n\tcase UAC_FEATURE_UNIT:\n\t\treturn parse_audio_feature_unit(state, unitid, p1);\n\tcase UAC1_PROCESSING_UNIT:\n\t/*   UAC2_EFFECT_UNIT has the same value */\n\t\tif (state->mixer->protocol == UAC_VERSION_1)\n\t\t\treturn parse_audio_processing_unit(state, unitid, p1);\n\t\telse\n\t\t\treturn 0; /* FIXME - effect units not implemented yet */\n\tcase UAC1_EXTENSION_UNIT:\n\t/*   UAC2_PROCESSING_UNIT_V2 has the same value */\n\t\tif (state->mixer->protocol == UAC_VERSION_1)\n\t\t\treturn parse_audio_extension_unit(state, unitid, p1);\n\t\telse /* UAC_VERSION_2 */\n\t\t\treturn parse_audio_processing_unit(state, unitid, p1);\n\tcase UAC2_EXTENSION_UNIT_V2:\n\t\treturn parse_audio_extension_unit(state, unitid, p1);\n\tdefault:\n\t\tusb_audio_err(state->chip,\n\t\t\t\"unit %u: unexpected type 0x%02x\\n\", unitid, p1[2]);\n\t\treturn -EINVAL;\n\t}\n}",
        "target": 0
    },
    {
        "id": 3492,
        "func": "void QQuickWebView::mouseMoveEvent(QMouseEvent* event)\n{\n    Q_D(QQuickWebView);\n    d->handleMouseEvent(event);\n}\n",
        "target": 0
    },
    {
        "id": 3493,
        "func": "static void session_clear_tty(struct pid *session)\n{\n\tstruct task_struct *p;\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\tproc_clear_tty(p);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n}",
        "target": 0
    },
    {
        "id": 3494,
        "func": "GF_Err paen_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\n\tif (ptr->blocks_and_symbols) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);\n\t\tif (e) return e;\n\t\tptr->size += ptr->blocks_and_symbols->size;\n\t}\n\tif (ptr->FEC_symbol_locations) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);\n\t\tif (e) return e;\n\t\tptr->size += ptr->FEC_symbol_locations->size;\n\t}\n\tif (ptr->File_symbol_locations) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);\n\t\tif (e) return e;\n\t\tptr->size += ptr->File_symbol_locations->size;\n\t}\n\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 3495,
        "func": "nfs3svc_release_fhandle2(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fhandle_pair *resp)\n{\n\tfh_put(&resp->fh1);\n\tfh_put(&resp->fh2);\n\treturn 1;\n}\n",
        "target": 0
    },
    {
        "id": 3496,
        "func": "static int amd_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned group,\n\t\t\t      const unsigned **pins,\n\t\t\t      unsigned *num_pins)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = gpio_dev->groups[group].pins;\n\t*num_pins = gpio_dev->groups[group].npins;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3497,
        "func": " status_t OMXNodeInstance::updateNativeHandleInMeta(\n        OMX_U32 portIndex, const sp<NativeHandle>& nativeHandle, OMX::buffer_id buffer) {\n Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);\n if (header == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n }\n\n if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n return BAD_VALUE;\n }\n\n\n     BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);\n     sp<ABuffer> data = bufferMeta->getBuffer(\n            header, portIndex == kPortIndexInput /* backup */, false /* limit */);\n     bufferMeta->setNativeHandle(nativeHandle);\n     if (mMetadataType[portIndex] == kMetadataBufferTypeNativeHandleSource\n             && data->capacity() >= sizeof(VideoNativeHandleMetadata)) {\n VideoNativeHandleMetadata &metadata = *(VideoNativeHandleMetadata *)(data->data());\n        metadata.eType = mMetadataType[portIndex];\n        metadata.pHandle =\n            nativeHandle == NULL ? NULL : const_cast<native_handle*>(nativeHandle->handle());\n } else {\n        CLOG_ERROR(updateNativeHandleInMeta, BAD_VALUE, \"%s:%u, %#x bad type (%d) or size (%zu)\",\n            portString(portIndex), portIndex, buffer, mMetadataType[portIndex], data->capacity());\n return BAD_VALUE;\n }\n\n    CLOG_BUFFER(updateNativeHandleInMeta, \"%s:%u, %#x := %p\",\n            portString(portIndex), portIndex, buffer,\n            nativeHandle == NULL ? NULL : nativeHandle->handle());\n return OK;\n}\n",
        "target": 1
    },
    {
        "id": 3498,
        "func": "void WallpaperManager::SetCustomizedDefaultWallpaperAfterCheck(\n    const GURL& wallpaper_url,\n    const base::FilePath& downloaded_file,\n    std::unique_ptr<CustomizedWallpaperRescaledFiles> rescaled_files) {\n  PrefService* pref_service = g_browser_process->local_state();\n\n  std::string current_url =\n      pref_service->GetString(prefs::kCustomizationDefaultWallpaperURL);\n  if (current_url != wallpaper_url.spec() || !rescaled_files->AllSizesExist()) {\n    DCHECK(rescaled_files->downloaded_exists());\n\n    user_image_loader::StartWithFilePath(\n        task_runner_, downloaded_file, ImageDecoder::ROBUST_JPEG_CODEC,\n        0,  // Do not crop.\n        base::Bind(&WallpaperManager::OnCustomizedDefaultWallpaperDecoded,\n                   weak_factory_.GetWeakPtr(), wallpaper_url,\n                   base::Passed(std::move(rescaled_files))));\n  } else {\n    SetDefaultWallpaperPath(rescaled_files->path_rescaled_small(),\n                            std::unique_ptr<gfx::ImageSkia>(),\n                            rescaled_files->path_rescaled_large(),\n                            std::unique_ptr<gfx::ImageSkia>());\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3499,
        "func": "m_authenticate(struct Client *client_p, struct Client *source_p,\n\tint parc, const char *parv[])\n{\n\tstruct Client *agent_p = NULL;\n\tstruct Client *saslserv_p = NULL;\n\n\t/* They really should use CAP for their own sake. */\n\tif(!IsCapable(source_p, CLICAP_SASL))\n\t\treturn 0;\n\n\tif (strlen(client_p->id) == 3)\n\t{\n\t\texit_client(client_p, client_p, client_p, \"Mixing client and server protocol\");\n\t\treturn 0;\n\t}\n\n\tsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);\n\tif (saslserv_p == NULL || !IsService(saslserv_p))\n\t{\n\t\tsendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\n\t\treturn 0;\n\t}\n\n\tif(source_p->localClient->sasl_complete)\n\t{\n\t\t*source_p->localClient->sasl_agent = '\\0';\n\t\tsource_p->localClient->sasl_complete = 0;\n\t}\n\n\tif(strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\n\t\treturn 0;\n\t}\n\n\tif(!*source_p->id)\n\t{\n\t\t/* Allocate a UID. */\n\t\tstrcpy(source_p->id, generate_uid());\n\t\tadd_to_id_hash(source_p->id, source_p);\n\t}\n\n\tif(*source_p->localClient->sasl_agent)\n\t\tagent_p = find_id(source_p->localClient->sasl_agent);\n\n\tif(agent_p == NULL)\n\t{\n\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s H %s %s\",\n\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\tsource_p->host, source_p->sockhost);\n\n\t\tif (!strcmp(parv[1], \"EXTERNAL\") && source_p->certfp != NULL)\n\t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s %s\",\n\t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\t\tparv[1], source_p->certfp);\n\t\telse\n\t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s\",\n\t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\t\tparv[1]);\n\n\t\trb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);\n\t}\n\telse\n\t\tsendto_one(agent_p, \":%s ENCAP %s SASL %s %s C %s\",\n\t\t\t\tme.id, agent_p->servptr->name, source_p->id, agent_p->id,\n\t\t\t\tparv[1]);\n\tsource_p->localClient->sasl_out++;\n\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 3500,
        "func": "static void *s_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_iterator *iter = m->private;\n\tint i = (int)*pos;\n\tvoid *ent;\n\n\tWARN_ON_ONCE(iter->leftover);\n\n\t(*pos)++;\n\n\t/* can't go backwards */\n\tif (iter->idx > i)\n\t\treturn NULL;\n\n\tif (iter->idx < 0)\n\t\tent = trace_find_next_entry_inc(iter);\n\telse\n\t\tent = iter;\n\n\twhile (ent && iter->idx < i)\n\t\tent = trace_find_next_entry_inc(iter);\n\n\titer->pos = *pos;\n\n\treturn ent;\n}",
        "target": 0
    },
    {
        "id": 3501,
        "func": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithUnsignedLongArray(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     Vector<unsigned long> unsignedLongArray(jsUnsignedLongArrayToVector(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->methodWithUnsignedLongArray(unsignedLongArray);\n    return JSValue::encode(jsUndefined());\n}\n",
        "target": 1
    },
    {
        "id": 3502,
        "func": "sctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\n\tif (unlikely(chunk_length < required_length))\n\t\treturn 0;\n\n\treturn 1;\n}",
        "target": 1
    },
    {
        "id": 3503,
        "func": "void FrameView::scheduleOrPerformPostLayoutTasks()\n{\n    if (m_postLayoutTasksTimer.isActive())\n        return;\n\n    if (!m_inSynchronousPostLayout) {\n        m_inSynchronousPostLayout = true;\n        performPostLayoutTasks();\n        m_inSynchronousPostLayout = false;\n    }\n\n    if (!m_postLayoutTasksTimer.isActive() && (needsLayout() || m_inSynchronousPostLayout)) {\n        m_postLayoutTasksTimer.startOneShot(0, FROM_HERE);\n        if (needsLayout())\n            layout();\n    }\n}\n",
        "target": 0
    },
    {
        "id": 3504,
        "func": "format_prefix(netdissect_options *ndo, const u_char *prefix, unsigned char plen)\n{\n    static char buf[50];\n    if(plen >= 96 && memcmp(prefix, v4prefix, 12) == 0)\n        snprintf(buf, 50, \"%s/%u\", ipaddr_string(ndo, prefix + 12), plen - 96);\n    else\n        snprintf(buf, 50, \"%s/%u\", ip6addr_string(ndo, prefix), plen);\n    buf[49] = '\\0';\n    return buf;\n}\n",
        "target": 0
    },
    {
        "id": 3505,
        "func": "status_t AudioFlinger::EffectModule::setVolume(uint32_t *left, uint32_t *right, bool controller)\n{\n Mutex::Autolock _l(mLock);\n if (mStatus != NO_ERROR) {\n return mStatus;\n }\n status_t status = NO_ERROR;\n if (isProcessEnabled() &&\n ((mDescriptor.flags & EFFECT_FLAG_VOLUME_MASK) == EFFECT_FLAG_VOLUME_CTRL ||\n (mDescriptor.flags & EFFECT_FLAG_VOLUME_MASK) == EFFECT_FLAG_VOLUME_IND)) {\n uint32_t volume[2];\n uint32_t *pVolume = NULL;\n uint32_t size = sizeof(volume);\n        volume[0] = *left;\n        volume[1] = *right;\n if (controller) {\n            pVolume = volume;\n }\n        status = (*mEffectInterface)->command(mEffectInterface,\n                                              EFFECT_CMD_SET_VOLUME,\n                                              size,\n                                              volume,\n &size,\n                                              pVolume);\n if (controller && status == NO_ERROR && size == sizeof(volume)) {\n *left = volume[0];\n *right = volume[1];\n }\n }\n return status;\n}\n",
        "target": 0
    },
    {
        "id": 3506,
        "func": " JSValue JSDirectoryEntry::getFile(ExecState* exec)\n {\n     if (exec->argumentCount() < 1)\n        return throwError(exec, createTypeError(exec, \"Not enough arguments\"));\n \n     DirectoryEntry* imp = static_cast<DirectoryEntry*>(impl());\n     const String& path = valueToStringWithUndefinedOrNullCheck(exec, exec->argument(0));\n    if (exec->hadException())\n        return jsUndefined();\n\n    int argsCount = exec->argumentCount();\n    if (argsCount <= 1) {\n        imp->getFile(path);\n        return jsUndefined();\n    }\n\n    RefPtr<WebKitFlags> flags;\n    if (!exec->argument(1).isNull() && !exec->argument(1).isUndefined() && exec->argument(1).isObject()) {\n        JSObject* object = exec->argument(1).getObject();\n        flags = WebKitFlags::create();\n        JSValue jsCreate = object->get(exec, Identifier(exec, \"create\"));\n        flags->setCreate(jsCreate.toBoolean(exec));\n        JSValue jsExclusive = object->get(exec, Identifier(exec, \"exclusive\"));\n        flags->setExclusive(jsExclusive.toBoolean(exec));\n    }\n    if (exec->hadException())\n        return jsUndefined();\n    RefPtr<EntryCallback> successCallback;\n    if (exec->argumentCount() > 2 && !exec->argument(2).isNull() && !exec->argument(2).isUndefined()) {\n        if (!exec->argument(2).isObject()) {\n            setDOMException(exec, TYPE_MISMATCH_ERR);\n            return jsUndefined();\n        }\n        successCallback = JSEntryCallback::create(asObject(exec->argument(2)), globalObject());\n    }\n    RefPtr<ErrorCallback> errorCallback;\n    if (exec->argumentCount() > 3 && !exec->argument(3).isNull() && !exec->argument(3).isUndefined()) {\n        if (!exec->argument(3).isObject()) {\n            setDOMException(exec, TYPE_MISMATCH_ERR);\n            return jsUndefined();\n        }\n        errorCallback = JSErrorCallback::create(asObject(exec->argument(3)), globalObject());\n    }\n\n    imp->getFile(path, flags, successCallback, errorCallback);\n    return jsUndefined();\n}\n",
        "target": 1
    },
    {
        "id": 3507,
        "func": "void DevToolsWindow::AddNewContents(WebContents* source,\n                                    WebContents* new_contents,\n                                    WindowOpenDisposition disposition,\n                                    const gfx::Rect& initial_rect,\n                                    bool user_gesture,\n                                    bool* was_blocked) {\n  if (new_contents == toolbox_web_contents_) {\n    toolbox_web_contents_->SetDelegate(\n        new DevToolsToolboxDelegate(toolbox_web_contents_,\n                                    inspected_contents_observer_.get()));\n    if (main_web_contents_->GetRenderWidgetHostView() &&\n        toolbox_web_contents_->GetRenderWidgetHostView()) {\n      gfx::Size size =\n          main_web_contents_->GetRenderWidgetHostView()->GetViewBounds().size();\n      toolbox_web_contents_->GetRenderWidgetHostView()->SetSize(size);\n    }\n    UpdateBrowserWindow();\n    return;\n  }\n\n  WebContents* inspected_web_contents = GetInspectedWebContents();\n  if (inspected_web_contents) {\n    inspected_web_contents->GetDelegate()->AddNewContents(\n        source, new_contents, disposition, initial_rect, user_gesture,\n        was_blocked);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3508,
        "func": "bool MasterPreferences::InitializeFromString(const std::string& json_data) {\n  if (!json_data.empty())\n    master_dictionary_.reset(ParseDistributionPreferences(json_data));\n\n  bool data_is_valid = true;\n  if (!master_dictionary_.get()) {\n    master_dictionary_.reset(new base::DictionaryValue());\n    data_is_valid = false;\n  } else {\n    master_dictionary_->GetDictionary(\n        installer::master_preferences::kDistroDict, &distribution_);\n  }\n\n  InitializeProductFlags();\n  EnforceLegacyPreferences();\n  return data_is_valid;\n}\n",
        "target": 0
    },
    {
        "id": 3509,
        "func": "build_config(char *prefix, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}",
        "target": 1
    },
    {
        "id": 3510,
        "func": "bool BrowserMainParts::MainMessageLoopRun(int* result_code) {\n  MessagePump::Get()->Start();\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 3511,
        "func": "GURL GetGoogleSearchURL(const GURL& google_homepage_url) {\n  GURL::Replacements replacements;\n  replacements.SetPathStr(\"search\");\n  replacements.SetQueryStr(\"q=\");\n  return google_homepage_url.ReplaceComponents(replacements);\n}\n",
        "target": 0
    },
    {
        "id": 3512,
        "func": "parse_asntime_into_isotime (unsigned char const **buf, size_t *len,\n                            ksba_isotime_t isotime)\n{\n  struct tag_info ti;\n  gpg_error_t err;\n\n  err = _ksba_ber_parse_tl (buf, len, &ti);\n  if (err)\n    ;\n  else if ( !(ti.class == CLASS_UNIVERSAL\n               && (ti.tag == TYPE_UTC_TIME || ti.tag == TYPE_GENERALIZED_TIME)\n               && !ti.is_constructed) )\n     err = gpg_error (GPG_ERR_INV_OBJ);\n   else if (!(err = _ksba_asntime_to_iso (*buf, ti.length,\n                                          ti.tag == TYPE_UTC_TIME, isotime)))\n     parse_skip (buf, len, &ti);\n}\n",
        "target": 1
    },
    {
        "id": 3513,
        "func": "std::string TransformToColMajorString(gfx::Transform& t) {\n  float array[16];\n  t.matrix().asColMajorf(array);\n  std::string array_string = \"[\";\n  for (int i = 0; i < 16; i++) {\n    array_string += base::NumberToString(array[i]) + \",\";\n  }\n  array_string.pop_back();\n  array_string.push_back(']');\n  return array_string;\n}\n",
        "target": 0
    },
    {
        "id": 3514,
        "func": "Eina_Bool ewk_view_setting_scripts_can_open_windows_set(Evas_Object* ewkView, Eina_Bool allow)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    allow = !!allow;\n    if (priv->settings.scriptsCanOpenWindows != allow) {\n        priv->pageSettings->setJavaScriptCanOpenWindowsAutomatically(allow);\n        priv->settings.scriptsCanOpenWindows = allow;\n    }\n    return true;\n}\n",
        "target": 0
    },
    {
        "id": 3515,
        "func": "BlockDriver *bdrv_find_whitelisted_format(const char *format_name,\n                                          bool read_only)\n{\n    BlockDriver *drv = bdrv_find_format(format_name);\n    return drv && bdrv_is_whitelisted(drv, read_only) ? drv : NULL;\n}\n",
        "target": 0
    },
    {
        "id": 3516,
        "func": "void t2p_tile_collapse_left(\n\ttdata_t buffer, \n\ttsize_t scanwidth, \n\tuint32 tilewidth, \n\tuint32 edgetilewidth, \n\tuint32 tilelength){\n\t\n\tuint32 i;\n\ttsize_t edgescanwidth=0;\n\t\n\tedgescanwidth = (scanwidth * edgetilewidth + (tilewidth - 1))/ tilewidth;\n\tfor(i=0;i<tilelength;i++){\n\t\t_TIFFmemcpy( \n\t\t\t&(((char*)buffer)[edgescanwidth*i]), \n\t\t\t&(((char*)buffer)[scanwidth*i]), \n\t\t\tedgescanwidth);\n\t}\n\t\n\treturn;\n}\n",
        "target": 0
    },
    {
        "id": 3517,
        "func": " */\nint skb_checksum_setup(struct sk_buff *skb, bool recalculate)\n{\n\tint err;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\terr = skb_checksum_setup_ipv4(skb, recalculate);\n\t\tbreak;\n\n\tcase htons(ETH_P_IPV6):\n\t\terr = skb_checksum_setup_ipv6(skb, recalculate);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EPROTO;\n\t\tbreak;\n\t}\n\n\treturn err;",
        "target": 0
    },
    {
        "id": 3518,
        "func": "MessageLoopForUI::MessageLoopForUI(std::unique_ptr<MessagePump> pump)\n    : MessageLoop(TYPE_UI, BindOnce(&ReturnPump, std::move(pump))) {}\n",
        "target": 0
    },
    {
        "id": 3519,
        "func": "void ResourceFetcher::ResourceTimingReportTimerFired(TimerBase* timer) {\n  DCHECK_EQ(timer, &resource_timing_report_timer_);\n  Vector<RefPtr<ResourceTimingInfo>> timing_reports;\n  timing_reports.Swap(scheduled_resource_timing_reports_);\n  for (const auto& timing_info : timing_reports)\n    Context().AddResourceTiming(*timing_info);\n}\n",
        "target": 0
    },
    {
        "id": 3520,
        "func": "void RenderThreadImpl::RegisterSchemes() {\n  WebString swappedout_scheme(ASCIIToUTF16(chrome::kSwappedOutScheme));\n  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(swappedout_scheme);\n  WebSecurityPolicy::registerURLSchemeAsEmptyDocument(swappedout_scheme);\n}\n",
        "target": 0
    },
    {
        "id": 3521,
        "func": "  WebRtcSetDescriptionObserverImpl(\n      base::WeakPtr<RTCPeerConnectionHandler> handler,\n      blink::WebRTCVoidRequest web_request,\n      base::WeakPtr<PeerConnectionTracker> tracker,\n      scoped_refptr<base::SingleThreadTaskRunner> task_runner,\n      PeerConnectionTracker::Action action,\n      webrtc::SdpSemantics sdp_semantics)\n      : handler_(handler),\n        main_thread_(task_runner),\n        web_request_(web_request),\n        tracker_(tracker),\n        action_(action),\n        sdp_semantics_(sdp_semantics) {}\n",
        "target": 0
    },
    {
        "id": 3522,
        "func": "ioeventfd_destructor(struct kvm_io_device *this)\n{\n\tstruct _ioeventfd *p = to_ioeventfd(this);\n\n\tioeventfd_release(p);\n}",
        "target": 0
    },
    {
        "id": 3523,
        "func": "void CLASS parse_fuji (int offset)\n{\n  unsigned entries, tag, len, save, c;\n\n  fseek (ifp, offset, SEEK_SET);\n  entries = get4();\n  if (entries > 255) return;\n  while (entries--) {\n    tag = get2();\n    len = get2();\n    save = ftell(ifp);\n    if (tag == 0x100) {\n      raw_height = get2();\n      raw_width  = get2();\n    } else if (tag == 0x121) {\n      height = get2();\n      if ((width = get2()) == 4284) width += 3;\n    } else if (tag == 0x130) {\n      fuji_layout = fgetc(ifp) >> 7;\n      load_raw = fgetc(ifp) & 8 ?\n\t&CLASS unpacked_load_raw : &CLASS fuji_load_raw;\n    } else if (tag == 0x2ff0) {\n      FORC4 cam_mul[c ^ 1] = get2();\n    } else if (tag == 0xc000) {\n      c = order;\n      order = 0x4949;\n      width  = get4();\n      height = get4();\n      order = c;\n    }\n    fseek (ifp, save+len, SEEK_SET);\n  }\n  height <<= fuji_layout;\n  width  >>= fuji_layout;\n}",
        "target": 0
    },
    {
        "id": 3524,
        "func": "bool Chapters::ExpandEditionsArray()\n{\n    if (m_editions_size > m_editions_count)\n        return true;  // nothing else to do\n \n    const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;\n \n    Edition* const editions = new (std::nothrow) Edition[size];\n \n    if (editions == NULL)\n        return false;\n \n    for (int idx = 0; idx < m_editions_count; ++idx)\n    {\n        m_editions[idx].ShallowCopy(editions[idx]);\n     }\n \n    delete[] m_editions;\n    m_editions = editions;\n \n    m_editions_size = size;\n    return true;\n }\n",
        "target": 1
    },
    {
        "id": 3525,
        "func": "void InputHandler::setPopupListIndexes(int size, const bool* selecteds)\n{\n    if (!isActiveSelectPopup())\n        return clearCurrentFocusElement();\n\n    if (size < 0)\n        return;\n\n    HTMLSelectElement* selectElement = static_cast<HTMLSelectElement*>(m_currentFocusElement.get());\n    const WTF::Vector<HTMLElement*>& items = selectElement->listItems();\n    if (items.size() != static_cast<unsigned int>(size))\n        return;\n\n    HTMLOptionElement* option;\n    for (int i = 0; i < size; i++) {\n        if (items[i]->hasTagName(HTMLNames::optionTag)) {\n            option = static_cast<HTMLOptionElement*>(items[i]);\n            option->setSelectedState(selecteds[i]);\n        }\n    }\n\n    selectElement->dispatchFormControlChangeEvent();\n    selectElement->renderer()->repaint();\n    clearCurrentFocusElement();\n}\n",
        "target": 0
    },
    {
        "id": 3526,
        "func": " void HostNPScriptObject::OnClientAuthenticated(const std::string& jid) {\n  DCHECK_EQ(MessageLoop::current(), host_context_.main_message_loop());\n \n   if (state_ == kDisconnecting) {\n    return;\n  }\n\n  client_username_ = jid;\n  size_t pos = client_username_.find('/');\n  if (pos != std::string::npos)\n    client_username_.replace(pos, std::string::npos, \"\");\n  LOG(INFO) << \"Client \" << client_username_ << \" connected.\";\n  SetState(kConnected);\n }\n",
        "target": 1
    },
    {
        "id": 3527,
        "func": "static struct sk_buff *netlink_trim(struct sk_buff *skb, gfp_t allocation)\n{\n\tint delta;\n\n\tskb_orphan(skb);\n\n\tdelta = skb->end - skb->tail;\n\tif (delta * 2 < skb->truesize)\n\t\treturn skb;\n\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *nskb = skb_clone(skb, allocation);\n\t\tif (!nskb)\n\t\t\treturn skb;\n\t\tconsume_skb(skb);\n\t\tskb = nskb;\n\t}\n\n\tif (!pskb_expand_head(skb, 0, -delta, allocation))\n\t\tskb->truesize -= delta;\n\n\treturn skb;\n}",
        "target": 0
    },
    {
        "id": 3528,
        "func": "  void ApplyEdits(BookmarkEditorView::EditorNode* node) {\n    editor_->ApplyEdits(node);\n  }\n",
        "target": 0
    },
    {
        "id": 3529,
        "func": "bool Document::IsInWebAppScope() const {\n  if (!GetSettings())\n    return false;\n\n  const String& web_app_scope = GetSettings()->GetWebAppScope();\n  if (web_app_scope.IsNull() || web_app_scope.IsEmpty())\n    return false;\n\n  DCHECK_EQ(KURL(web_app_scope).GetString(), web_app_scope);\n  return Url().GetString().StartsWith(web_app_scope);\n}\n",
        "target": 0
    },
    {
        "id": 3530,
        "func": "static inline int tcp_packet_delayed(const struct tcp_sock *tp)\n{\n\treturn !tp->retrans_stamp ||\n\t\t(tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t\t before(tp->rx_opt.rcv_tsecr, tp->retrans_stamp));\n}",
        "target": 0
    },
    {
        "id": 3531,
        "func": "int tcp_v4_gso_send_check(struct sk_buff *skb)\n{\n\tconst struct iphdr *iph;\n\tstruct tcphdr *th;\n\n\tif (!pskb_may_pull(skb, sizeof(*th)))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\tth = tcp_hdr(skb);\n\n\tth->check = 0;\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t__tcp_v4_send_check(skb, iph->saddr, iph->daddr);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3532,
        "func": "Track::EOSBlock::EOSBlock() :\n    BlockEntry(NULL, LONG_MIN)\n{\n}\n",
        "target": 1
    },
    {
        "id": 3533,
        "func": "static void pmcraid_release_minor(unsigned short minor)\n{\n\t__clear_bit(minor, pmcraid_minor);\n}",
        "target": 0
    },
    {
        "id": 3534,
        "func": "bool QQuickWebView::allowAnyHTTPSCertificateForLocalHost() const\n{\n    Q_D(const QQuickWebView);\n    return d->m_allowAnyHTTPSCertificateForLocalHost;\n}\n",
        "target": 0
    },
    {
        "id": 3535,
        "func": "static int fixed_msr_to_range_index(u32 msr)\n{\n\tint seg, unit;\n\n\tif (!fixed_msr_to_seg_unit(msr, &seg, &unit))\n\t\treturn -1;\n\n\treturn fixed_mtrr_seg_unit_range_index(seg, unit);\n}",
        "target": 0
    },
    {
        "id": 3536,
        "func": "v8::Handle<v8::Value> V8WebGLRenderingContext::getFramebufferAttachmentParameterCallback(const v8::Arguments& args)\n{\n     INC_STATS(\"DOM.WebGLRenderingContext.getFramebufferAttachmentParameter()\");\n \n     if (args.Length() != 3)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n    unsigned target = toInt32(args[0]);\n    unsigned attachment = toInt32(args[1]);\n    unsigned pname = toInt32(args[2]);\n    WebGLGetInfo info = context->getFramebufferAttachmentParameter(target, attachment, pname, ec);\n    if (ec) {\n        V8Proxy::setDOMException(ec, args.GetIsolate());\n        return v8::Undefined();\n    }\n    return toV8Object(info, args.GetIsolate());\n}\n",
        "target": 1
    },
    {
        "id": 3537,
        "func": "calc_enc_length (gnutls_session_t session, int data_size,\n\t\t int hash_size, uint8_t * pad, int random_pad,\n\t\t cipher_type_t block_algo, uint16_t blocksize)\n{\n  uint8_t rnd;\n  int length, ret;\n\n  *pad = 0;\n\n  switch (block_algo)\n    {\n    case CIPHER_STREAM:\n      length = data_size + hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      ret =_gnutls_rnd (RND_NONCE, &rnd, 1);\n      if ( ret < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* make rnd a multiple of blocksize */\n      if (session->security_parameters.version == GNUTLS_SSL3 ||\n\t  random_pad == 0)\n\t{\n\t  rnd = 0;\n\t}\n      else\n\t{\n\t  rnd = (rnd / blocksize) * blocksize;\n\t  /* added to avoid the case of pad calculated 0\n\t   * seen below for pad calculation.\n\t   */\n\t  if (rnd > blocksize)\n\t    rnd -= blocksize;\n\t}\n\n      length = data_size + hash_size;\n\n      *pad = (uint8_t) (blocksize - (length % blocksize)) + rnd;\n\n      length += *pad;\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\tlength += blocksize;\t/* for the IV */\n\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  return length;\n}\n",
        "target": 0
    },
    {
        "id": 3538,
        "func": "static inline unsigned long task_weight(struct task_struct *p, int nid,\n\t\t\t\t\tint dist)\n{\n\tunsigned long faults, total_faults;\n\n\tif (!p->numa_faults)\n\t\treturn 0;\n\n\ttotal_faults = p->total_numa_faults;\n\n\tif (!total_faults)\n\t\treturn 0;\n\n\tfaults = task_faults(p, nid);\n\tfaults += score_nearby_nodes(p, nid, dist, true);\n\n\treturn 1000 * faults / total_faults;\n}",
        "target": 0
    },
    {
        "id": 3539,
        "func": "ExtensionSystem* ExtensionSystem::Get(Profile* profile) {\n  return ExtensionSystemFactory::GetForProfile(profile);\n}\n",
        "target": 0
    },
    {
        "id": 3540,
        "func": "OMX_ERRORTYPE omx_vdec::enable_smoothstreaming() {\n struct v4l2_control control;\n struct v4l2_format fmt;\n    control.id = V4L2_CID_MPEG_VIDC_VIDEO_CONTINUE_DATA_TRANSFER;\n    control.value = 1;\n int rc = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL,&control);\n if (rc < 0) {\n        DEBUG_PRINT_ERROR(\"Failed to enable Smooth Streaming on driver.\");\n return OMX_ErrorHardware;\n }\n    m_smoothstreaming_mode = true;\n return OMX_ErrorNone;\n}\n",
        "target": 0
    },
    {
        "id": 3541,
        "func": "  void PumpLoop() {\n    message_loop_.RunAllPending();\n  }\n",
        "target": 0
    },
    {
        "id": 3542,
        "func": "void LocalFrameClientImpl::DispatchWillStartUsingPeerConnectionHandler(\n    WebRTCPeerConnectionHandler* handler) {\n  web_frame_->Client()->WillStartUsingPeerConnectionHandler(handler);\n}\n",
        "target": 0
    },
    {
        "id": 3543,
        "func": "RenderWidgetHostViewAndroid::GetNativeViewAccessible() {\n  NOTIMPLEMENTED();\n  return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 3544,
        "func": "rb_allocate_cpu_buffer(struct ring_buffer *buffer, long nr_pages, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct buffer_page *bpage;\n\tstruct page *page;\n\tint ret;\n\n\tcpu_buffer = kzalloc_node(ALIGN(sizeof(*cpu_buffer), cache_line_size()),\n\t\t\t\t  GFP_KERNEL, cpu_to_node(cpu));\n\tif (!cpu_buffer)\n\t\treturn NULL;\n\n\tcpu_buffer->cpu = cpu;\n\tcpu_buffer->buffer = buffer;\n\traw_spin_lock_init(&cpu_buffer->reader_lock);\n\tlockdep_set_class(&cpu_buffer->reader_lock, buffer->reader_lock_key);\n\tcpu_buffer->lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\tINIT_WORK(&cpu_buffer->update_pages_work, update_pages_handler);\n\tinit_completion(&cpu_buffer->update_done);\n\tinit_irq_work(&cpu_buffer->irq_work.work, rb_wake_up_waiters);\n\tinit_waitqueue_head(&cpu_buffer->irq_work.waiters);\n\tinit_waitqueue_head(&cpu_buffer->irq_work.full_waiters);\n\n\tbpage = kzalloc_node(ALIGN(sizeof(*bpage), cache_line_size()),\n\t\t\t    GFP_KERNEL, cpu_to_node(cpu));\n\tif (!bpage)\n\t\tgoto fail_free_buffer;\n\n\trb_check_bpage(cpu_buffer, bpage);\n\n\tcpu_buffer->reader_page = bpage;\n\tpage = alloc_pages_node(cpu_to_node(cpu), GFP_KERNEL, 0);\n\tif (!page)\n\t\tgoto fail_free_reader;\n\tbpage->page = page_address(page);\n\trb_init_page(bpage->page);\n\n\tINIT_LIST_HEAD(&cpu_buffer->reader_page->list);\n\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\n\tret = rb_allocate_pages(cpu_buffer, nr_pages);\n\tif (ret < 0)\n\t\tgoto fail_free_reader;\n\n\tcpu_buffer->head_page\n\t\t= list_entry(cpu_buffer->pages, struct buffer_page, list);\n\tcpu_buffer->tail_page = cpu_buffer->commit_page = cpu_buffer->head_page;\n\n\trb_head_page_activate(cpu_buffer);\n\n\treturn cpu_buffer;\n\n fail_free_reader:\n\tfree_buffer_page(cpu_buffer->reader_page);\n\n fail_free_buffer:\n\tkfree(cpu_buffer);\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 3545,
        "func": "int dm_suspended(struct dm_target *ti)\n{\n\treturn dm_suspended_md(dm_table_get_md(ti->table));\n}",
        "target": 0
    },
    {
        "id": 3546,
        "func": "VaapiVideoDecodeAccelerator::CreateSurface() {\n  DCHECK(decoder_thread_task_runner_->BelongsToCurrentThread());\n  base::AutoLock auto_lock(lock_);\n\n  if (available_va_surfaces_.empty())\n    return nullptr;\n\n  DCHECK(!awaiting_va_surfaces_recycle_);\n  scoped_refptr<VASurface> va_surface(new VASurface(\n      available_va_surfaces_.front(), requested_pic_size_,\n      vaapi_wrapper_->va_surface_format(), va_surface_release_cb_));\n  available_va_surfaces_.pop_front();\n\n  return new VaapiDecodeSurface(curr_input_buffer_->id(), va_surface);\n}\n",
        "target": 0
    },
    {
        "id": 3547,
        "func": " ContentUtilityClient* ShellMainDelegate::CreateContentUtilityClient() {\n  utility_client_.reset(new ShellContentUtilityClient);\n   return utility_client_.get();\n }\n",
        "target": 1
    },
    {
        "id": 3548,
        "func": "static int cxusb_dee1601_demod_init(struct dvb_frontend* fe)\n{\n\tstatic u8 clock_config []  = { CLOCK_CTL,  0x38, 0x28 };\n\tstatic u8 reset []         = { RESET,      0x80 };\n\tstatic u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };\n\tstatic u8 agc_cfg []       = { AGC_TARGET, 0x28, 0x20 };\n\tstatic u8 gpp_ctl_cfg []   = { GPP_CTL,    0x33 };\n\tstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\n\n\tmt352_write(fe, clock_config,   sizeof(clock_config));\n\tudelay(200);\n\tmt352_write(fe, reset,          sizeof(reset));\n\tmt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));\n\n\tmt352_write(fe, agc_cfg,        sizeof(agc_cfg));\n\tmt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));\n\tmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3549,
        "func": "static int shash_async_export(struct ahash_request *req, void *out)\n{\n\treturn crypto_shash_export(ahash_request_ctx(req), out);\n}",
        "target": 0
    },
    {
        "id": 3550,
        "func": "inline static jas_int_asl(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x << n;\n}",
        "target": 0
    },
    {
        "id": 3551,
        "func": "_poppler_page_new (PopplerDocument *document, Page *page, int index)\n{\n  PopplerPage *poppler_page;\n\n  g_return_val_if_fail (POPPLER_IS_DOCUMENT (document), NULL);\n\n  poppler_page = (PopplerPage *) g_object_new (POPPLER_TYPE_PAGE, NULL, NULL);\n  poppler_page->document = (PopplerDocument *) g_object_ref (document);\n  poppler_page->page = page;\n  poppler_page->index = index;\n\n  return poppler_page;\n}\n",
        "target": 0
    },
    {
        "id": 3552,
        "func": "    void setCrossOrigin(const String& corsSetting)\n    {\n        m_crossOrigin = crossOriginAttributeValue(corsSetting);\n    }\n",
        "target": 0
    },
    {
        "id": 3553,
        "func": "OxideQQuickWebView::editingCapabilities() const {\n  Q_D(const OxideQQuickWebView);\n\n  if (!d->proxy_) {\n    return NoCapability;\n  }\n\n  oxide::qt::EditCapabilityFlags flags = d->proxy_->editFlags();\n  return static_cast<EditCapabilities>(flags);\n}\n",
        "target": 0
    },
    {
        "id": 3554,
        "func": "void ProfileImplIOData::Handle::Init(\n      const FilePath& cookie_path,\n      const FilePath& origin_bound_cert_path,\n      const FilePath& cache_path,\n      int cache_max_size,\n      const FilePath& media_cache_path,\n      int media_cache_max_size,\n      const FilePath& extensions_cookie_path,\n      const FilePath& app_path,\n      chrome_browser_net::Predictor* predictor,\n      PrefService* local_state,\n      IOThread* io_thread,\n      bool restore_old_session_cookies) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!io_data_->lazy_params_.get());\n  DCHECK(predictor);\n\n  LazyParams* lazy_params = new LazyParams;\n\n  lazy_params->cookie_path = cookie_path;\n  lazy_params->origin_bound_cert_path = origin_bound_cert_path;\n  lazy_params->cache_path = cache_path;\n  lazy_params->cache_max_size = cache_max_size;\n  lazy_params->media_cache_path = media_cache_path;\n  lazy_params->media_cache_max_size = media_cache_max_size;\n  lazy_params->extensions_cookie_path = extensions_cookie_path;\n  lazy_params->restore_old_session_cookies = restore_old_session_cookies;\n\n  io_data_->lazy_params_.reset(lazy_params);\n\n  io_data_->app_path_ = app_path;\n\n  io_data_->predictor_.reset(predictor);\n\n  if (!main_request_context_getter_) {\n    main_request_context_getter_ =\n        ChromeURLRequestContextGetter::CreateOriginal(\n            profile_, io_data_);\n  }\n  io_data_->predictor_->InitNetworkPredictor(profile_->GetPrefs(),\n                                             local_state,\n                                             io_thread,\n                                             main_request_context_getter_);\n}\n",
        "target": 0
    },
    {
        "id": 3555,
        "func": "static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,  int numcmpts, int *cmpts)\n{\n\tint rowsize;\n\tint pad;\n\tunsigned int z;\n\tint nz;\n\tint c;\n\tint x;\n\tint y;\n\tint v;\n\tjas_matrix_t *data[3];\n\tint i;\n\n\tassert(numcmpts <= 3);\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tdata[i] = 0;\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (!(data[i] = jas_matrix_create(jas_image_height(image),\n\t\t  jas_image_width(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\trowsize = RAS_ROWSIZE(hdr);\n\tpad = rowsize - (hdr->width * hdr->depth + 7) / 8;\n\n\thdr->length = hdr->height * rowsize;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tfor (i = 0; i < numcmpts; ++i) {\n\t\t\tif (jas_image_readcmpt(image, cmpts[i], 0, y,\n\t\t\t\t\tjas_image_width(image), 1, data[i])) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tz = 0;\n\t\tnz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\tz <<= hdr->depth;\n\t\t\tif (RAS_ISRGB(hdr)) {\n\t\t\t\tv = RAS_RED((jas_matrix_getv(data[0], x))) |\n\t\t\t\t  RAS_GREEN((jas_matrix_getv(data[1], x))) |\n\t\t\t\t  RAS_BLUE((jas_matrix_getv(data[2], x)));\n\t\t\t} else {\n\t\t\t\tv = (jas_matrix_getv(data[0], x));\n\t\t\t}\n\t\t\tz |= v & RAS_ONES(hdr->depth);\n\t\t\tnz += hdr->depth;\n\t\t\twhile (nz >= 8) {\n\t\t\t\tc = (z >> (nz - 8)) & 0xff;\n\t\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tnz -= 8;\n\t\t\t\tz &= RAS_ONES(nz);\n\t\t\t}\n\t\t}\n\t\tif (nz > 0) {\n\t\t\tc = (z >> (8 - nz)) & RAS_ONES(nz);\n\t\t\tif (jas_stream_putc(out, c) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (pad % 2) {\n\t\t\tif (jas_stream_putc(out, 0) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t\tdata[i] = 0;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < numcmpts; ++i) {\n\t\tif (data[i]) {\n\t\t\tjas_matrix_destroy(data[i]);\n\t\t}\n\t}\n\treturn -1;\n}",
        "target": 0
    },
    {
        "id": 3556,
        "func": "status_t MPEG4Source::parseSampleAuxiliaryInformationSizes(\n off64_t offset, off64_t /* size */) {\n    ALOGV(\"parseSampleAuxiliaryInformationSizes\");\n uint8_t version;\n if (mDataSource->readAt(\n            offset, &version, sizeof(version))\n < (ssize_t)sizeof(version)) {\n return ERROR_IO;\n }\n\n if (version != 0) {\n return ERROR_UNSUPPORTED;\n }\n    offset++;\n\n uint32_t flags;\n if (!mDataSource->getUInt24(offset, &flags)) {\n return ERROR_IO;\n }\n    offset += 3;\n\n if (flags & 1) {\n uint32_t tmp;\n if (!mDataSource->getUInt32(offset, &tmp)) {\n return ERROR_MALFORMED;\n }\n        mCurrentAuxInfoType = tmp;\n        offset += 4;\n if (!mDataSource->getUInt32(offset, &tmp)) {\n return ERROR_MALFORMED;\n }\n        mCurrentAuxInfoTypeParameter = tmp;\n        offset += 4;\n }\n\n uint8_t defsize;\n if (mDataSource->readAt(offset, &defsize, 1) != 1) {\n return ERROR_MALFORMED;\n }\n    mCurrentDefaultSampleInfoSize = defsize;\n    offset++;\n\n uint32_t smplcnt;\n if (!mDataSource->getUInt32(offset, &smplcnt)) {\n return ERROR_MALFORMED;\n }\n    mCurrentSampleInfoCount = smplcnt;\n    offset += 4;\n\n if (mCurrentDefaultSampleInfoSize != 0) {\n        ALOGV(\"@@@@ using default sample info size of %d\", mCurrentDefaultSampleInfoSize);\n return OK;\n }\n if (smplcnt > mCurrentSampleInfoAllocSize) {\n uint8_t * newPtr = (uint8_t*) realloc(mCurrentSampleInfoSizes, smplcnt);\n if (newPtr == NULL) {\n            ALOGE(\"failed to realloc %u -> %u\", mCurrentSampleInfoAllocSize, smplcnt);\n return NO_MEMORY;\n }\n        mCurrentSampleInfoSizes = newPtr;\n        mCurrentSampleInfoAllocSize = smplcnt;\n }\n\n    mDataSource->readAt(offset, mCurrentSampleInfoSizes, smplcnt);\n return OK;\n}\n",
        "target": 0
    },
    {
        "id": 3557,
        "func": "AppCacheHost::AppCacheHost(int host_id, AppCacheFrontend* frontend,\n                           AppCacheServiceImpl* service)\n    : host_id_(host_id),\n      spawning_host_id_(kAppCacheNoHostId), spawning_process_id_(0),\n      parent_host_id_(kAppCacheNoHostId), parent_process_id_(0),\n      pending_main_resource_cache_id_(kAppCacheNoCacheId),\n      pending_selected_cache_id_(kAppCacheNoCacheId),\n      was_select_cache_called_(false),\n      is_cache_selection_enabled_(true),\n      frontend_(frontend), service_(service),\n      storage_(service->storage()),\n      pending_callback_param_(NULL),\n      main_resource_was_namespace_entry_(false),\n      main_resource_blocked_(false),\n      associated_cache_info_pending_(false) {\n  service_->AddObserver(this);\n}\n",
        "target": 0
    },
    {
        "id": 3558,
        "func": "void PpapiPluginProcessHost::OnRendererPluginChannelCreated(\n    const IPC::ChannelHandle& channel_handle) {\n  if (sent_requests_.empty())\n    return;\n\n  Client* client = sent_requests_.front();\n  sent_requests_.pop();\n\n  client->OnPpapiChannelOpened(channel_handle, process_->GetData().id);\n}\n",
        "target": 0
    },
    {
        "id": 3559,
        "func": "ChromeExtensionsAPIClient::CreateExtensionOptionsGuestDelegate(\n    ExtensionOptionsGuest* guest) const {\n  return new ChromeExtensionOptionsGuestDelegate(guest);\n}\n",
        "target": 0
    },
    {
        "id": 3560,
        "func": "reassemble_pkcs11_name(pkinit_identity_opts *idopts)\n{\n    struct k5buf buf;\n    int n = 0;\n    char *ret;\n\n    krb5int_buf_init_dynamic(&buf);\n    krb5int_buf_add(&buf, \"PKCS11:\");\n    n = 0;\n    if (idopts->p11_module_name != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%smodule_name=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->p11_module_name);\n    }\n    if (idopts->token_label != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%stoken=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->token_label);\n    }\n    if (idopts->cert_label != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%scertlabel=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->cert_label);\n    }\n    if (idopts->cert_id_string != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%scertid=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->cert_id_string);\n    }\n    if (idopts->slotid != PK_NOSLOT) {\n        krb5int_buf_add_fmt(&buf, \"%sslotid=%ld\",\n                            n++ ? \",\" : \"\",\n                            (long)idopts->slotid);\n    }\n    if (krb5int_buf_len(&buf) >= 0)\n        ret = strdup(krb5int_buf_data(&buf));\n    else\n        ret = NULL;\n    krb5int_free_buf(&buf);\n    return ret;\n}\n",
        "target": 0
    },
    {
        "id": 3561,
        "func": "static sctp_disposition_t sctp_sf_do_dupcook_b(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Update the content of current association.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t *\n\t * Sadly, this needs to be implemented as a side-effect, because\n\t * we are not guaranteed to have set the association id of the real\n\t * association and so these notifications need to be delayed until\n\t * the association id is allocated.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t *\n\t * This also needs to be done as a side effect for the same reason as\n\t * above.\n\t */\n\tif (asoc->peer.adaptation_ind)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}",
        "target": 0
    },
    {
        "id": 3562,
        "func": "void TabStrip::ShowContextMenuForTab(Tab* tab,\n                                     const gfx::Point& p,\n                                     ui::MenuSourceType source_type) {\n  controller_->ShowContextMenuForTab(tab, p, source_type);\n}\n",
        "target": 0
    },
    {
        "id": 3563,
        "func": "void RenderViewHostImpl::DisableScrollbarsForThreshold(const gfx::Size& size) {\n  Send(new ViewMsg_DisableScrollbarsForSmallWindows(GetRoutingID(), size));\n}\n",
        "target": 0
    },
    {
        "id": 3564,
        "func": "static int ti_do_config(struct edgeport_port *port, int feature, int on)\n{\n\tint port_number = port->port->port_number;\n\n\ton = !!on;\t/* 1 or 0 not bitmask */\n\treturn send_cmd(port->port->serial->dev,\n\t\t\tfeature, (__u8)(UMPM_UART1_PORT + port_number),\n\t\t\ton, NULL, 0);\n}",
        "target": 0
    },
    {
        "id": 3565,
        "func": "PasswordPopupSuggestionView::PasswordPopupSuggestionView(\n    AutofillPopupViewNativeViews* popup_view,\n    int line_number,\n    int frontend_id)\n    : AutofillPopupSuggestionView(popup_view, line_number, frontend_id) {\n  origin_ = popup_view_->controller()->GetElidedLabelAt(line_number_);\n  masked_password_ =\n      popup_view_->controller()->GetSuggestionAt(line_number_).additional_label;\n}\n",
        "target": 0
    },
    {
        "id": 3566,
        "func": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\n\tmutex_lock(&ctx->ring_lock);\n\n\t/* Access to ->ring_pages here is protected by ctx->ring_lock. */\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\n\tif (head == tail)\n\t\tgoto out;\n\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 3567,
        "func": "static void cswitch(JF, js_Ast *ref, js_Ast *head)\n{\n\tjs_Ast *node, *clause, *def = NULL;\n\tint end;\n\n\tcexp(J, F, ref);\n\n\t/* emit an if-else chain of tests for the case clause expressions */\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tif (clause->type == STM_DEFAULT) {\n\t\t\tif (def)\n\t\t\t\tjsC_error(J, clause, \"more than one default label in switch\");\n\t\t\tdef = clause;\n\t\t} else {\n\t\t\tcexp(J, F, clause->a);\n\t\t\temitline(J, F, clause);\n\t\t\tclause->casejump = emitjump(J, F, OP_JCASE);\n\t\t}\n\t}\n\temit(J, F, OP_POP);\n\tif (def) {\n\t\temitline(J, F, def);\n\t\tdef->casejump = emitjump(J, F, OP_JUMP);\n\t\tend = 0;\n\t} else {\n\t\tend = emitjump(J, F, OP_JUMP);\n\t}\n\n\t/* emit the case clause bodies */\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tlabel(J, F, clause->casejump);\n\t\tif (clause->type == STM_DEFAULT)\n\t\t\tcstmlist(J, F, clause->a);\n\t\telse\n\t\t\tcstmlist(J, F, clause->b);\n\t}\n\n\tif (end)\n\t\tlabel(J, F, end);\n}",
        "target": 0
    },
    {
        "id": 3568,
        "func": "void Player::pause()\n{\n    if (m_paused)\n        return;\n    m_paused = true;\n    updateTimingState(currentTime());\n    cancelAnimationOnCompositor();\n}\n",
        "target": 0
    },
    {
        "id": 3569,
        "func": "SPL_METHOD(SplObjectStorage, current)\n{\n\tspl_SplObjectStorageElement *element;\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tif (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_ZVAL(element->obj, 1, 0);\n} /* }}} */\n\n/* {{{ proto mixed SplObjectStorage::getInfo()\n",
        "target": 0
    },
    {
        "id": 3570,
        "func": "bits_image_fetch_pixel_convolution (bits_image_t   *image,\n\t\t\t\t    pixman_fixed_t  x,\n\t\t\t\t    pixman_fixed_t  y,\n\t\t\t\t    get_pixel_t     get_pixel)\n{\n    pixman_fixed_t *params = image->common.filter_params;\n    int x_off = (params[0] - pixman_fixed_1) >> 1;\n    int y_off = (params[1] - pixman_fixed_1) >> 1;\n    int32_t cwidth = pixman_fixed_to_int (params[0]);\n    int32_t cheight = pixman_fixed_to_int (params[1]);\n    int32_t i, j, x1, x2, y1, y2;\n    pixman_repeat_t repeat_mode = image->common.repeat;\n    int width = image->width;\n    int height = image->height;\n    int srtot, sgtot, sbtot, satot;\n\n    params += 2;\n\n    x1 = pixman_fixed_to_int (x - pixman_fixed_e - x_off);\n    y1 = pixman_fixed_to_int (y - pixman_fixed_e - y_off);\n    x2 = x1 + cwidth;\n    y2 = y1 + cheight;\n\n    srtot = sgtot = sbtot = satot = 0;\n\n    for (i = y1; i < y2; ++i)\n    {\n\tfor (j = x1; j < x2; ++j)\n\t{\n\t    int rx = j;\n\t    int ry = i;\n\n\t    pixman_fixed_t f = *params;\n\n\t    if (f)\n\t    {\n\t\tuint32_t pixel;\n\n\t\tif (repeat_mode != PIXMAN_REPEAT_NONE)\n\t\t{\n\t\t    repeat (repeat_mode, &rx, width);\n\t\t    repeat (repeat_mode, &ry, height);\n\n\t\t    pixel = get_pixel (image, rx, ry, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    pixel = get_pixel (image, rx, ry, TRUE);\n\t\t}\n\n\t\tsrtot += (int)RED_8 (pixel) * f;\n\t\tsgtot += (int)GREEN_8 (pixel) * f;\n\t\tsbtot += (int)BLUE_8 (pixel) * f;\n\t\tsatot += (int)ALPHA_8 (pixel) * f;\n\t    }\n\n\t    params++;\n\t}\n    }\n\n    satot = (satot + 0x8000) >> 16;\n    srtot = (srtot + 0x8000) >> 16;\n    sgtot = (sgtot + 0x8000) >> 16;\n    sbtot = (sbtot + 0x8000) >> 16;\n\n    satot = CLIP (satot, 0, 0xff);\n    srtot = CLIP (srtot, 0, 0xff);\n    sgtot = CLIP (sgtot, 0, 0xff);\n    sbtot = CLIP (sbtot, 0, 0xff);\n\n    return ((satot << 24) | (srtot << 16) | (sgtot <<  8) | (sbtot));\n}\n",
        "target": 0
    },
    {
        "id": 3571,
        "func": "void ChildProcessSecurityPolicyImpl::GrantRequestURL(\n    int child_id, const GURL& url) {\n\n  if (!url.is_valid())\n    return;  // Can't grant the capability to request invalid URLs.\n\n  if (IsWebSafeScheme(url.scheme()))\n    return;  // The scheme has already been whitelisted for every child process.\n\n  if (IsPseudoScheme(url.scheme())) {\n    if (url.SchemeIs(chrome::kViewSourceScheme)) {\n      GrantRequestURL(child_id, GURL(url.path()));\n    }\n\n    return;  // Can't grant the capability to request pseudo schemes.\n  }\n\n  {\n    base::AutoLock lock(lock_);\n    SecurityStateMap::iterator state = security_state_.find(child_id);\n    if (state == security_state_.end())\n      return;\n\n    state->second->GrantScheme(url.scheme());\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3572,
        "func": "static const struct sys_reg_desc *get_target_table(unsigned target,\n\t\t\t\t\t\t   bool mode_is_64,\n\t\t\t\t\t\t   size_t *num)\n{\n\tstruct kvm_sys_reg_target_table *table;\n\n\ttable = target_tables[target];\n\tif (mode_is_64) {\n\t\t*num = table->table64.num;\n\t\treturn table->table64.table;\n\t} else {\n\t\t*num = table->table32.num;\n\t\treturn table->table32.table;\n\t}\n}",
        "target": 0
    },
    {
        "id": 3573,
        "func": "void QQuickWebView::hoverEnterEvent(QHoverEvent* event)\n{\n    Q_D(QQuickWebView);\n    d->pageView->eventHandler()->handleHoverMoveEvent(event);\n}\n",
        "target": 0
    },
    {
        "id": 3574,
        "func": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}",
        "target": 1
    },
    {
        "id": 3575,
        "func": "void InputMethodBase::SetFocusedTextInputClient(TextInputClient* client) {\n  if (is_sticky_text_input_client_)\n    return;\n  SetFocusedTextInputClientInternal(client);\n}\n",
        "target": 0
    },
    {
        "id": 3576,
        "func": "static void overloadedMethodG1Method(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    imp->overloadedMethodG();\n}\n",
        "target": 0
    },
    {
        "id": 3577,
        "func": "static void efx_fini_io(struct efx_nic *efx)\n{\n\tnetif_dbg(efx, drv, efx->net_dev, \"shutting down I/O\\n\");\n\n\tif (efx->membase) {\n\t\tiounmap(efx->membase);\n\t\tefx->membase = NULL;\n\t}\n\n\tif (efx->membase_phys) {\n\t\tpci_release_region(efx->pci_dev, EFX_MEM_BAR);\n\t\tefx->membase_phys = 0;\n\t}\n\n\tpci_disable_device(efx->pci_dev);\n}\n",
        "target": 0
    },
    {
        "id": 3578,
        "func": "bool CanonicalizePort(const base::char16* spec,\n                      const Component& port,\n                      int default_port_for_scheme,\n                      CanonOutput* output,\n                      Component* out_port) {\n  return DoPort<base::char16, base::char16>(spec, port, default_port_for_scheme,\n                                            output, out_port);\n}\n",
        "target": 0
    },
    {
        "id": 3579,
        "func": "void WebPluginDelegateProxy::SendUpdateGeometry(\n    bool bitmaps_changed) {\n  PluginMsg_UpdateGeometry_Param param;\n  param.window_rect = plugin_rect_;\n  param.clip_rect = clip_rect_;\n  param.windowless_buffer0 = TransportDIB::DefaultHandleValue();\n  param.windowless_buffer1 = TransportDIB::DefaultHandleValue();\n  param.windowless_buffer_index = back_buffer_index();\n  param.background_buffer = TransportDIB::DefaultHandleValue();\n  param.transparent = transparent_;\n\n#if defined(OS_POSIX)\n  if (bitmaps_changed)\n#endif\n   {\n     if (transport_stores_[0].dib.get())\n       CopyTransportDIBHandleForMessage(transport_stores_[0].dib->handle(),\n                                       &param.windowless_buffer0);\n \n     if (transport_stores_[1].dib.get())\n       CopyTransportDIBHandleForMessage(transport_stores_[1].dib->handle(),\n                                       &param.windowless_buffer1);\n \n     if (background_store_.dib.get())\n       CopyTransportDIBHandleForMessage(background_store_.dib->handle(),\n                                       &param.background_buffer);\n   }\n \n   IPC::Message* msg;\n#if defined(OS_WIN)\n  if (UseSynchronousGeometryUpdates()) {\n    msg = new PluginMsg_UpdateGeometrySync(instance_id_, param);\n  } else  // NOLINT\n#endif\n  {\n    msg = new PluginMsg_UpdateGeometry(instance_id_, param);\n    msg->set_unblock(true);\n  }\n\n  Send(msg);\n}\n",
        "target": 1
    },
    {
        "id": 3580,
        "func": "static int set_name(RFlagItem *item, const char *name) {\n\tif (item->name != item->realname) {\n\t\tfree (item->name);\n\t}\n\titem->name = strdup (name);\n\tif (!item->name) {\n\t\treturn false;\n\t}\n\tr_str_chop (item->name);\n\tr_name_filter (item->name, 0); // TODO: name_filter should be chopping already\n\tfree (item->realname);\n\titem->realname = item->name;\n\treturn true;\n}",
        "target": 0
    },
    {
        "id": 3581,
        "func": "   virtual void Run() {\n    while (true) {\n      fd_set rfds;\n      FD_ZERO(&rfds);\n      FD_SET(inotify_fd_, &rfds);\n      FD_SET(shutdown_fd_, &rfds);\n\n      int select_result =\n        HANDLE_EINTR(select(std::max(inotify_fd_, shutdown_fd_) + 1,\n                            &rfds, NULL, NULL, NULL));\n      if (select_result < 0) {\n        DPLOG(WARNING) << \"select failed\";\n        return;\n      }\n\n      if (FD_ISSET(shutdown_fd_, &rfds))\n        return;\n\n      int buffer_size;\n      int ioctl_result = HANDLE_EINTR(ioctl(inotify_fd_, FIONREAD,\n                                            &buffer_size));\n\n      if (ioctl_result != 0) {\n        DPLOG(WARNING) << \"ioctl failed\";\n        return;\n      }\n\n      std::vector<char> buffer(buffer_size);\n\n      ssize_t bytes_read = HANDLE_EINTR(read(inotify_fd_, &buffer[0],\n                                             buffer_size));\n\n      if (bytes_read < 0) {\n        DPLOG(WARNING) << \"read from inotify fd failed\";\n        return;\n      }\n\n      ssize_t i = 0;\n      while (i < bytes_read) {\n        inotify_event* event = reinterpret_cast<inotify_event*>(&buffer[i]);\n        size_t event_size = sizeof(inotify_event) + event->len;\n        DCHECK(i + event_size <= static_cast<size_t>(bytes_read));\n        reader_->OnInotifyEvent(event);\n        i += event_size;\n      }\n    }\n  }\n",
        "target": 0
    },
    {
        "id": 3582,
        "func": "static void overloadedMethod3Method(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    if (UNLIKELY(info.Length() < 1)) {\n        throwTypeError(ExceptionMessages::failedToExecute(\"overloadedMethod\", \"TestObject\", ExceptionMessages::notEnoughArguments(1, info.Length())), info.GetIsolate());\n        return;\n    }\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_VOID(TestObject*, objArg, V8TestObject::toNativeWithTypeCheck(info.GetIsolate(), info[0]));\n    imp->overloadedMethod(objArg);\n}\n",
        "target": 0
    },
    {
        "id": 3583,
        "func": "  tt_sbit_decoder_init( TT_SBitDecoder       decoder,\n                        TT_Face              face,\n                        FT_ULong             strike_index,\n                        TT_SBit_MetricsRec*  metrics )\n  {\n    FT_Error   error;\n    FT_Stream  stream = face->root.stream;\n    FT_ULong   ebdt_size;\n\n\n    error = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\n    if ( error )\n      goto Exit;\n\n    decoder->face    = face;\n    decoder->stream  = stream;\n    decoder->bitmap  = &face->root.glyph->bitmap;\n    decoder->metrics = metrics;\n\n    decoder->metrics_loaded   = 0;\n    decoder->bitmap_allocated = 0;\n\n    decoder->ebdt_start = FT_STREAM_POS();\n    decoder->ebdt_size  = ebdt_size;\n\n    decoder->eblc_base  = face->sbit_table;\n    decoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n\n    /* now find the strike corresponding to the index */\n    {\n      FT_Byte*  p;\n\n\n      if ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n      {\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n\n      p = decoder->eblc_base + 8 + 48 * strike_index;\n\n      decoder->strike_index_array = FT_NEXT_ULONG( p );\n      p                          += 4;\n      decoder->strike_index_count = FT_NEXT_ULONG( p );\n       p                          += 34;\n       decoder->bit_depth          = *p;\n \n      /* decoder->strike_index_array +                               */\n      /*   8 * decoder->strike_index_count > face->sbit_table_size ? */\n      if ( decoder->strike_index_array > face->sbit_table_size           ||\n           decoder->strike_index_count >\n             ( face->sbit_table_size - decoder->strike_index_array ) / 8 )\n         error = FT_THROW( Invalid_File_Format );\n     }\n  }\n",
        "target": 0
    },
    {
        "id": 3584,
        "func": "void AppControllerImpl::GetApps(\n     mojom::AppController::GetAppsCallback callback) {\n   std::vector<chromeos::kiosk_next_home::mojom::AppPtr> app_list;\n  app_service_proxy_->AppRegistryCache().ForEachApp(\n      [this, &app_list](const apps::AppUpdate& update) {\n        app_list.push_back(CreateAppPtr(update));\n      });\n   std::move(callback).Run(std::move(app_list));\n }\n",
        "target": 1
    },
    {
        "id": 3585,
        "func": "  RenderViewHostManagerTestBrowserClient() {}\n",
        "target": 0
    },
    {
        "id": 3586,
        "func": "void RenderViewImpl::OnSetZoomLevelForLoadingURL(const GURL& url,\n                                                 double zoom_level) {\n#if !defined(OS_ANDROID)\n  host_zoom_levels_[url] = zoom_level;\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 3587,
        "func": "void RenderFrameImpl::RunScriptsAtDocumentIdle() {\n  GetContentClient()->renderer()->RunScriptsAtDocumentIdle(this);\n}\n",
        "target": 0
    },
    {
        "id": 3588,
        "func": "    FindUpdateWebFrameClient()\n        : m_findResultsAreReady(false)\n        , m_count(-1)\n    {\n    }\n",
        "target": 0
    },
    {
        "id": 3589,
        "func": "void PluginInfoMessageFilter::Context::DecidePluginStatus(\n    const GetPluginInfo_Params& params,\n    const WebPluginInfo& plugin,\n    PluginFinder* plugin_finder,\n    ChromeViewHostMsg_GetPluginInfo_Status* status,\n    std::string* group_identifier,\n    string16* group_name) const {\n  PluginInstaller* installer = plugin_finder->GetPluginInstaller(plugin);\n  *group_name = installer->name();\n  *group_identifier = installer->identifier();\n\n  ContentSetting plugin_setting = CONTENT_SETTING_DEFAULT;\n  bool uses_default_content_setting = true;\n  GetPluginContentSetting(plugin, params.top_origin_url, params.url,\n                          *group_identifier, &plugin_setting,\n                          &uses_default_content_setting);\n  DCHECK(plugin_setting != CONTENT_SETTING_DEFAULT);\n\n#if defined(ENABLE_PLUGIN_INSTALLATION)\n  PluginInstaller::SecurityStatus plugin_status =\n      installer->GetSecurityStatus(plugin);\n  if (plugin_status == PluginInstaller::SECURITY_STATUS_OUT_OF_DATE &&\n      !allow_outdated_plugins_.GetValue()) {\n    if (allow_outdated_plugins_.IsManaged()) {\n      status->value =\n          ChromeViewHostMsg_GetPluginInfo_Status::kOutdatedDisallowed;\n    } else {\n      status->value = ChromeViewHostMsg_GetPluginInfo_Status::kOutdatedBlocked;\n    }\n    return;\n   }\n \n  if ((plugin_status ==\n           PluginInstaller::SECURITY_STATUS_REQUIRES_AUTHORIZATION ||\n       PluginService::GetInstance()->IsPluginUnstable(plugin.path)) &&\n       plugin.type != WebPluginInfo::PLUGIN_TYPE_PEPPER_IN_PROCESS &&\n       plugin.type != WebPluginInfo::PLUGIN_TYPE_PEPPER_OUT_OF_PROCESS &&\n       !always_authorize_plugins_.GetValue() &&\n      plugin_setting != CONTENT_SETTING_BLOCK &&\n      uses_default_content_setting) {\n     status->value = ChromeViewHostMsg_GetPluginInfo_Status::kUnauthorized;\n     return;\n   }\n #endif\n \n   if (plugin_setting == CONTENT_SETTING_ASK)\n    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kClickToPlay;\n  else if (plugin_setting == CONTENT_SETTING_BLOCK)\n    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kBlocked;\n}\n",
        "target": 1
    },
    {
        "id": 3590,
        "func": "static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf,\n\t\tRBinDwarfCompUnit *cu, const RBinDwarfDebugAbbrev *da,\n\t\tsize_t offset, const ut8 *debug_str, size_t debug_str_len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7);\n\tut64 abbr_code;\n\tsize_t i;\n\t\n\tif (cu->hdr.length > debug_str_len) {\n\t\treturn NULL;\n\t}\n\twhile (buf && buf < buf_end && buf >= obuf) {\n\t\tif (cu->length && cu->capacity == cu->length) {\n\t\t\tr_bin_dwarf_expand_cu (cu);\n\t\t}\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &abbr_code);\n\t\tif (abbr_code > da->length || !buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tr_bin_dwarf_init_die (&cu->dies[cu->length]);\n\t\tif (!abbr_code) {\n\t\t\tcu->dies[cu->length].abbrev_code = 0;\n\t\t\tcu->length++;\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu->dies[cu->length].abbrev_code = abbr_code;\n\t\tcu->dies[cu->length].tag = da->decls[abbr_code - 1].tag;\n\t\tabbr_code += offset;\n\n\t\tif (da->capacity < abbr_code) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (i = 0; i < da->decls[abbr_code - 1].length; i++) {\n\t\t\tif (cu->dies[cu->length].length == cu->dies[cu->length].capacity) {\n\t\t\t\tr_bin_dwarf_expand_die (&cu->dies[cu->length]);\n\t\t\t}\n\t\t\tif (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) {\n\t\t\t\teprintf (\"Warning: malformed dwarf attribute capacity doesn't match length\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i]));\n\t\t\tbuf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf,\n\t\t\t\t\t&da->decls[abbr_code - 1].specs[i],\n\t\t\t\t\t&cu->dies[cu->length].attr_values[i],\n \t\t\t\t\t&cu->hdr, debug_str, debug_str_len);\n \t\t\tif (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) {\n \t\t\t\tconst char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string;\n\t\t\t\tsdb_set (s, \"DW_AT_comp_dir\", name, 0);\n \t\t\t}\n \t\t\tcu->dies[cu->length].length++;\n \t\t}\n\t\tcu->length++;\n\t}\n\treturn buf;\n}\n",
        "target": 1
    },
    {
        "id": 3591,
        "func": "void DateTimeFieldElement::didFocus()\n{\n    if (m_fieldOwner)\n        m_fieldOwner->didFocusOnField();\n}\n",
        "target": 0
    },
    {
        "id": 3592,
        "func": " void TypingCommand::adjustSelectionAfterIncrementalInsertion(\n    LocalFrame* frame,\n    const size_t textLength) {\n  if (!isIncrementalInsertion())\n    return;\n\n  frame->document()->updateStyleAndLayoutIgnorePendingStylesheets();\n\n  Element* element = frame->selection()\n                         .computeVisibleSelectionInDOMTreeDeprecated()\n                         .rootEditableElement();\n  DCHECK(element);\n\n  const size_t end = m_selectionStart + textLength;\n  const size_t start =\n      compositionType() == TextCompositionUpdate ? m_selectionStart : end;\n  const SelectionInDOMTree& selection =\n      createSelection(start, end, endingSelection().isDirectional(), element);\n\n  if (selection ==\n      frame->selection()\n          .computeVisibleSelectionInDOMTreeDeprecated()\n          .asSelection())\n    return;\n\n  setEndingSelection(selection);\n  frame->selection().setSelection(selection);\n}\n",
        "target": 0
    },
    {
        "id": 3593,
        "func": "smp_fetch_http_auth_grp(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                        const struct arg *args, struct sample *smp, const char *kw)\n{\n\n\tif (!args || args->type != ARGT_USR)\n\t\treturn 0;\n\n\tCHECK_HTTP_MESSAGE_FIRST();\n\n\tif (!get_http_auth(l4))\n\t\treturn 0;\n\n\t/* if the user does not belong to the userlist or has a wrong password,\n\t * report that it unconditionally does not match. Otherwise we return\n\t * a string containing the username.\n\t */\n\tif (!check_user(args->data.usr, l4->txn.auth.user, l4->txn.auth.pass))\n\t\treturn 0;\n\n\t/* pat_match_auth() will need the user list */\n\tsmp->ctx.a[0] = args->data.usr;\n\n\tsmp->type = SMP_T_STR;\n\tsmp->flags = SMP_F_CONST;\n\tsmp->data.str.str = l4->txn.auth.user;\n\tsmp->data.str.len = strlen(l4->txn.auth.user);\n\n\treturn 1;\n}\n",
        "target": 0
    },
    {
        "id": 3594,
        "func": "void InterstitialPageImpl::UpdateDeviceScaleFactor(double device_scale_factor) {\n  WebContentsImpl* web_contents_impl =\n      static_cast<WebContentsImpl*>(web_contents_);\n  if (!web_contents_impl)\n    return;\n\n  web_contents_impl->UpdateDeviceScaleFactor(device_scale_factor);\n}\n",
        "target": 0
    },
    {
        "id": 3595,
        "func": "PassRefPtr<HTMLCollection> Document::images()\n{\n    return ensureCachedCollection(DocImages);\n}\n",
        "target": 0
    },
    {
        "id": 3596,
        "func": "pp::Buffer_Dev PDFiumEngine::PrintPagesAsPDF(\n    const PP_PrintPageNumberRange_Dev* page_ranges, uint32_t page_range_count,\n    const PP_PrintSettings_Dev& print_settings) {\n  if (!page_range_count)\n    return pp::Buffer_Dev();\n\n  DCHECK(doc_);\n  FPDF_DOCUMENT output_doc = FPDF_CreateNewDocument();\n  if (!output_doc)\n    return pp::Buffer_Dev();\n\n  SaveSelectedFormForPrint();\n\n  std::string page_number_str;\n  for (uint32_t index = 0; index < page_range_count; ++index) {\n    if (!page_number_str.empty())\n      page_number_str.append(\",\");\n    page_number_str.append(\n        base::UintToString(page_ranges[index].first_page_number + 1));\n    if (page_ranges[index].first_page_number !=\n            page_ranges[index].last_page_number) {\n      page_number_str.append(\"-\");\n      page_number_str.append(\n          base::UintToString(page_ranges[index].last_page_number + 1));\n    }\n  }\n\n  std::vector<uint32_t> page_numbers =\n      GetPageNumbersFromPrintPageNumberRange(page_ranges, page_range_count);\n  for (uint32_t page_number : page_numbers) {\n    pages_[page_number]->GetPage();\n    if (!IsPageVisible(page_number))\n      pages_[page_number]->Unload();\n  }\n\n  FPDF_CopyViewerPreferences(output_doc, doc_);\n  if (!FPDF_ImportPages(output_doc, doc_, page_number_str.c_str(), 0)) {\n    FPDF_CloseDocument(output_doc);\n    return pp::Buffer_Dev();\n  }\n\n  FitContentsToPrintableAreaIfRequired(output_doc, print_settings);\n\n  pp::Buffer_Dev buffer = GetFlattenedPrintData(output_doc);\n  FPDF_CloseDocument(output_doc);\n  return buffer;\n}\n",
        "target": 0
    },
    {
        "id": 3597,
        "func": "   void Add(int original_content_length, int received_content_length) {\n    AddInt64ToListPref(\n        kNumDaysInHistory - 1, original_content_length, original_update_.Get());\n    AddInt64ToListPref(\n        kNumDaysInHistory - 1, received_content_length, received_update_.Get());\n   }\n",
        "target": 1
    },
    {
        "id": 3598,
        "func": "image_transform_png_set_gray_to_rgb_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    /* NOTE: we can actually pend the tRNS processing at this point because we\n     * can correctly recognize the original pixel value even though we have\n    * mapped the one gray channel to the three RGB ones, but in fact libpng\n\n     * doesn't do this, so we don't either.\n     */\n    if ((that->colour_type & PNG_COLOR_MASK_COLOR) == 0 && that->have_tRNS)\n      image_pixel_add_alpha(that, &display->this);\n \n    /* Simply expand the bit depth and alter the colour type as required. */\n    if (that->colour_type == PNG_COLOR_TYPE_GRAY)\n {\n /* RGB images have a bit depth at least equal to '8' */\n if (that->bit_depth < 8)\n         that->sample_depth = that->bit_depth = 8;\n\n /* And just changing the colour type works here because the green and blue\n       * channels are being maintained in lock-step with the red/gray:\n       */\n      that->colour_type = PNG_COLOR_TYPE_RGB;\n }\n\n else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      that->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;\n\n this->next->mod(this->next, that, pp, display);\n}\n",
        "target": 1
    },
    {
        "id": 3599,
        "func": "gs_pattern1_get_pattern(const gs_pattern_instance_t *pinst)\n{\n    return (const gs_pattern_template_t *)\n        &((const gs_pattern1_instance_t *)pinst)->templat;\n}\n",
        "target": 0
    },
    {
        "id": 3600,
        "func": "static inline int rawv6_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tif ((raw6_sk(sk)->checksum || rcu_access_pointer(sk->sk_filter)) &&\n\t    skb_checksum_complete(skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\t/* Charge it to the socket. */\n\tskb_dst_drop(skb);\n\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3601,
        "func": "bool DecodeBQEncoding(const std::string& part,\n                      RFC2047EncodingType enc_type,\n                      const std::string& charset,\n                      std::string* output) {\n  std::string decoded;\n  if (!((enc_type == B_ENCODING) ?\n      base::Base64Decode(part, &decoded) : QPDecode(part, &decoded)))\n    return false;\n\n  if (decoded.empty()) {\n    output->clear();\n    return true;\n  }\n\n  UErrorCode err = U_ZERO_ERROR;\n  UConverter* converter(ucnv_open(charset.c_str(), &err));\n  if (U_FAILURE(err))\n    return false;\n\n  size_t output_length = decoded.length() * 3 + 1;\n  char* buf = WriteInto(output, output_length);\n  output_length = ucnv_toAlgorithmic(UCNV_UTF8, converter, buf, output_length,\n                                     decoded.data(), decoded.length(), &err);\n  ucnv_close(converter);\n  if (U_FAILURE(err))\n    return false;\n  output->resize(output_length);\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 3602,
        "func": "void Part::slotSaveAs()\n{\n    QUrl saveUrl = QFileDialog::getSaveFileUrl(widget(), i18nc(\"@title:window\", \"Save Archive As\"), url());\n\n    if ((saveUrl.isValid()) && (!saveUrl.isEmpty())) {\n        auto statJob = KIO::stat(saveUrl, KIO::StatJob::DestinationSide, 0);\n        KJobWidgets::setWindow(statJob, widget());\n        if (statJob->exec()) {\n            int overwrite = KMessageBox::warningContinueCancel(widget(),\n                                                               xi18nc(\"@info\", \"An archive named <filename>%1</filename> already exists. Are you sure you want to overwrite it?\", saveUrl.fileName()),\n                                                               QString(),\n                                                               KStandardGuiItem::overwrite());\n\n            if (overwrite != KMessageBox::Continue) {\n                return;\n            }\n        }\n\n        QUrl srcUrl = QUrl::fromLocalFile(localFilePath());\n\n        if (!QFile::exists(localFilePath())) {\n            if (url().isLocalFile()) {\n                KMessageBox::error(widget(),\n                                   xi18nc(\"@info\", \"The archive <filename>%1</filename> cannot be copied to the specified location. The archive does not exist anymore.\", localFilePath()));\n\n                return;\n            } else {\n                srcUrl = url();\n            }\n        }\n\n        KIO::Job *copyJob = KIO::file_copy(srcUrl, saveUrl, -1, KIO::Overwrite);\n\n        KJobWidgets::setWindow(copyJob, widget());\n        copyJob->exec();\n        if (copyJob->error()) {\n            KMessageBox::error(widget(),\n                               xi18nc(\"@info\", \"The archive could not be saved as <filename>%1</filename>. Try saving it to another location.\", saveUrl.path()));\n        }\n    }\n}\n",
        "target": 0
    },
    {
        "id": 3603,
        "func": "map_engine_persons(void)\n{\n\tint i;\n\n\tif (s_person_list == NULL)\n\t\ts_person_list = vector_new(sizeof(person_t*));\n\tvector_clear(s_person_list);\n\tfor (i = 0; i < s_num_persons; ++i)\n\t\tvector_push(s_person_list, &s_persons[i]);\n\treturn s_person_list;\n}",
        "target": 0
    },
    {
        "id": 3604,
        "func": "void RenderWidget::ConfigureAsExternalPopupMenu(const WebPopupMenuInfo& info) {\n  popup_params_.reset(new ViewHostMsg_ShowPopup_Params);\n  popup_params_->item_height = info.itemHeight;\n  popup_params_->item_font_size = info.itemFontSize;\n  popup_params_->selected_item = info.selectedIndex;\n  for (size_t i = 0; i < info.items.size(); ++i)\n    popup_params_->popup_items.push_back(WebMenuItem(info.items[i]));\n  popup_params_->right_aligned = info.rightAligned;\n}\n",
        "target": 0
    },
    {
        "id": 3605,
        "func": "static int jas_icctxtdesc_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tint n;\n\tint c;\n\tjas_icctxtdesc_t *txtdesc = &attrval->data.txtdesc;\n\ttxtdesc->ascdata = 0;\n\ttxtdesc->ucdata = 0;\n\tif (jas_iccgetuint32(in, &txtdesc->asclen))\n\t\tgoto error;\n\tif (!(txtdesc->ascdata = jas_malloc(txtdesc->asclen)))\n\t\tgoto error;\n\tif (jas_stream_read(in, txtdesc->ascdata, txtdesc->asclen) !=\n\t  JAS_CAST(int, txtdesc->asclen))\n\t\tgoto error;\n\ttxtdesc->ascdata[txtdesc->asclen - 1] = '\\0';\n\tif (jas_iccgetuint32(in, &txtdesc->uclangcode) ||\n\t  jas_iccgetuint32(in, &txtdesc->uclen))\n\t\tgoto error;\n\tif (!(txtdesc->ucdata = jas_alloc2(txtdesc->uclen, 2)))\n\t\tgoto error;\n\tif (jas_stream_read(in, txtdesc->ucdata, txtdesc->uclen * 2) !=\n\t  JAS_CAST(int, txtdesc->uclen * 2))\n\t\tgoto error;\n\tif (jas_iccgetuint16(in, &txtdesc->sccode))\n\t\tgoto error;\n\tif ((c = jas_stream_getc(in)) == EOF)\n\t\tgoto error;\n\ttxtdesc->maclen = c;\n\tif (jas_stream_read(in, txtdesc->macdata, 67) != 67)\n\t\tgoto error;\n\ttxtdesc->asclen = JAS_CAST(jas_iccuint32_t, strlen(txtdesc->ascdata) + 1);\n#define WORKAROUND_BAD_PROFILES\n#ifdef WORKAROUND_BAD_PROFILES\n\tn = txtdesc->asclen + txtdesc->uclen * 2 + 15 + 67;\n\tif (n > cnt) {\n\t\treturn -1;\n\t}\n\tif (n < cnt) {\n\t\tif (jas_stream_gobble(in, cnt - n) != cnt - n)\n\t\t\tgoto error;\n\t}\n#else\n\tif (txtdesc->asclen + txtdesc->uclen * 2 + 15 + 67 != cnt)\n\t\treturn -1;\n#endif\n\treturn 0;\nerror:\n\tjas_icctxtdesc_destroy(attrval);\n\treturn -1;\n}",
        "target": 0
    },
    {
        "id": 3606,
        "func": "static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n\n    if (get_bits_left(gb) <= 32)\n        return 0;\n\n    s->partitioned_frame = 0;\n    s->decode_mb = mpeg4_decode_studio_mb;\n\n    decode_smpte_tc(ctx, gb);\n\n    skip_bits(gb, 10); /* temporal_reference */\n    skip_bits(gb, 2); /* vop_structure */\n    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; /* vop_coding_type */\n    if (get_bits1(gb)) { /* vop_coded */\n        skip_bits1(gb); /* top_field_first */\n        skip_bits1(gb); /* repeat_first_field */\n        s->progressive_frame = get_bits1(gb) ^ 1; /* progressive_frame */\n    }\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (get_bits1(gb))\n            reset_studio_dc_predictors(s);\n    }\n\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        s->alternate_scan = get_bits1(gb);\n        s->frame_pred_frame_dct = get_bits1(gb);\n        s->dct_precision = get_bits(gb, 2);\n        s->intra_dc_precision = get_bits(gb, 2);\n        s->q_scale_type = get_bits1(gb);\n    }\n\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    }\n\n    mpeg4_load_default_matrices(s);\n\n    next_start_code_studio(gb);\n    extension_and_user_data(s, gb, 4);\n\n    return 0;\n}",
        "target": 1
    },
    {
        "id": 3607,
        "func": "static int check_qos(const struct atm_qos *qos)\n{\n\tint error;\n\n\tif (!qos->txtp.traffic_class && !qos->rxtp.traffic_class)\n\t\treturn -EINVAL;\n\tif (qos->txtp.traffic_class != qos->rxtp.traffic_class &&\n\t    qos->txtp.traffic_class && qos->rxtp.traffic_class &&\n\t    qos->txtp.traffic_class != ATM_ANYCLASS &&\n\t    qos->rxtp.traffic_class != ATM_ANYCLASS)\n\t\treturn -EINVAL;\n\terror = check_tp(&qos->txtp);\n\tif (error)\n\t\treturn error;\n\treturn check_tp(&qos->rxtp);\n}",
        "target": 0
    },
    {
        "id": 3608,
        "func": " int VRDisplay::requestAnimationFrame(FrameRequestCallback* callback) {\n   Document* doc = this->GetDocument();\n   if (!doc)\n     return 0;\n  pending_raf_ = true;\n   if (!vr_v_sync_provider_.is_bound()) {\n     ConnectVSyncProvider();\n   } else if (!display_blurred_ && !pending_vsync_) {\n    pending_vsync_ = true;\n    vr_v_sync_provider_->GetVSync(ConvertToBaseCallback(\n        WTF::Bind(&VRDisplay::OnVSync, WrapWeakPersistent(this))));\n  }\n  callback->use_legacy_time_base_ = false;\n  return EnsureScriptedAnimationController(doc).RegisterCallback(callback);\n }\n",
        "target": 1
    },
    {
        "id": 3609,
        "func": " WebString WebPageSerializer::generateMarkOfTheWebDeclaration(const WebURL& url)\n {\n    return String::format(\"\\n<!-- saved from url=(%04d)%s -->\\n\",\n                          static_cast<int>(url.spec().length()),\n                          url.spec().data());\n }\n",
        "target": 1
    },
    {
        "id": 3610,
        "func": "BOOLEAN bta_hl_co_get_echo_config(UINT8  app_id,\n                                  tBTA_HL_ECHO_CFG *p_echo_cfg)\n{\n    UINT8               app_idx;\n    BOOLEAN             success = FALSE;\n btif_hl_app_cb_t *p_acb;\n    tBTA_HL_SUP_FEATURE *p_sup;\n\n    BTIF_TRACE_DEBUG(\"%s app_id=%d\",__FUNCTION__, app_id );\n\n if (btif_hl_find_app_idx(app_id, &app_idx))\n {\n        p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);\n        p_sup = &p_acb->sup_feature;\n        p_echo_cfg->max_rx_apdu_size = p_sup->echo_cfg.max_rx_apdu_size;\n        p_echo_cfg->max_tx_apdu_size = p_sup->echo_cfg.max_tx_apdu_size;\n        success = TRUE;\n }\n\n    BTIF_TRACE_DEBUG(\"%s success=%d max tx_size=%d rx_size=%d\",\n                      __FUNCTION__, success, p_echo_cfg->max_tx_apdu_size,\n                      p_echo_cfg->max_rx_apdu_size );\n\n return success;\n}\n",
        "target": 0
    },
    {
        "id": 3611,
        "func": "bool ScrollAnchor::RefersTo(const LayoutObject* layout_object) const {\n  return anchor_object_ == layout_object;\n}\n",
        "target": 0
    },
    {
        "id": 3612,
        "func": "isdn_net_reset(struct net_device *dev)\n{\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_device_ops * dops =\n\t\t((isdn_net_local *) netdev_priv(dev))->dops;\n\tstruct concap_proto * cprot =\n\t\t((isdn_net_local *) netdev_priv(dev))->netdev->cprot;\n#endif\n#ifdef CONFIG_ISDN_X25\n\tif( cprot && cprot -> pops && dops )\n\t\tcprot -> pops -> restart ( cprot, dev, dops );\n#endif\n}",
        "target": 0
    },
    {
        "id": 3613,
        "func": "rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n       rar->file_flags & FHD_SPLIT_AFTER)\n     {\n       ret = archive_read_format_rar_read_header(a, a->entry);\n       if (ret == (ARCHIVE_EOF))\n       {\n         rar->has_endarc_header = 1;\n         ret = archive_read_format_rar_read_header(a, a->entry);\n       }\n       if (ret != (ARCHIVE_OK))\n         return NULL;\n       return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}\n",
        "target": 1
    },
    {
        "id": 3614,
        "func": "static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip_far(ctxt, dst, ctxt->mode == X86EMUL_MODE_PROT64);\n}",
        "target": 0
    },
    {
        "id": 3615,
        "func": "void GfxDeviceGrayColorSpace::getGrayLine(Guchar *in, Guchar *out, int length) {\n  memcpy (out, in, length);\n}\n",
        "target": 0
    },
    {
        "id": 3616,
        "func": "base::string16 GetRelyingPartyIdString(\n    AuthenticatorRequestDialogModel* dialog_model) {\n  static constexpr char kRpIdUrlPrefix[] = \"https://\";\n  static constexpr int kDialogWidth = 300;\n   const auto& rp_id = dialog_model->relying_party_id();\n   DCHECK(!rp_id.empty());\n   GURL rp_id_url(kRpIdUrlPrefix + rp_id);\n  auto max_static_string_length = gfx::GetStringWidthF(\n      l10n_util::GetStringUTF16(IDS_WEBAUTHN_GENERIC_TITLE), gfx::FontList(),\n      gfx::Typesetter::DEFAULT);\n  return url_formatter::ElideHost(rp_id_url, gfx::FontList(),\n                                  kDialogWidth - max_static_string_length);\n }\n",
        "target": 1
    },
    {
        "id": 3617,
        "func": "PHP_PHAR_API int phar_resolve_alias(char *alias, int alias_len, char **filename, int *filename_len) /* {{{ */ {\n\tphar_archive_data *fd_ptr;\n\tif (PHAR_G(phar_alias_map.u.flags)\n\t\t\t&& NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), alias, alias_len))) {\n\t\t*filename = fd_ptr->fname;\n\t\t*filename_len = fd_ptr->fname_len;\n\t\treturn SUCCESS;\n\t}\n\treturn FAILURE;\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 3618,
        "func": "bool RenderFrameImpl::RunModalPromptDialog(\n    const blink::WebString& message,\n    const blink::WebString& default_value,\n    blink::WebString* actual_value) {\n  base::string16 result;\n  bool ok = RunJavaScriptDialog(JAVASCRIPT_DIALOG_TYPE_PROMPT, message.Utf16(),\n                                default_value.Utf16(),\n                                frame_->GetDocument().Url(), &result);\n  if (ok)\n    *actual_value = WebString::FromUTF16(result);\n  return ok;\n}\n",
        "target": 0
    },
    {
        "id": 3619,
        "func": "mm_malloc(struct mm_master *mm, size_t size)\n{\n\tstruct mm_share *mms, *tmp;\n\n\tif (size == 0)\n\t\tfatal(\"mm_malloc: try to allocate 0 space\");\n\tif (size > SIZE_MAX - MM_MINSIZE + 1)\n\t\tfatal(\"mm_malloc: size too big\");\n\n\tsize = ((size + (MM_MINSIZE - 1)) / MM_MINSIZE) * MM_MINSIZE;\n\n\tRB_FOREACH(mms, mmtree, &mm->rb_free) {\n\t\tif (mms->size >= size)\n\t\t\tbreak;\n\t}\n\n\tif (mms == NULL)\n\t\treturn (NULL);\n\n\t/* Debug */\n\tmemset(mms->address, 0xd0, size);\n\n\ttmp = mm_make_entry(mm, &mm->rb_allocated, mms->address, size);\n\n\t/* Does not change order in RB tree */\n\tmms->size -= size;\n\tmms->address = (char *)mms->address + size;\n\n\tif (mms->size == 0) {\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t}\n\n\treturn (tmp->address);\n}",
        "target": 1
    },
    {
        "id": 3620,
        "func": "static MagickBooleanType ComparePixels(const ImageLayerMethod method,\n  const MagickPixelPacket *p,const MagickPixelPacket *q)\n{\n  MagickRealType\n    o1,\n    o2;\n\n  /*\n    Any change in pixel values\n  */\n  if (method == CompareAnyLayer)\n    return((MagickBooleanType)(IsMagickColorSimilar(p,q) == MagickFalse));\n\n  o1 = (p->matte != MagickFalse) ? GetPixelOpacity(p) : OpaqueOpacity;\n  o2 = (q->matte != MagickFalse) ? q->opacity : OpaqueOpacity;\n\n  /*\n    Pixel goes from opaque to transprency\n  */\n  if (method == CompareClearLayer)\n    return((MagickBooleanType) ( (o1 <= ((MagickRealType) QuantumRange/2.0)) &&\n      (o2 > ((MagickRealType) QuantumRange/2.0)) ) );\n\n  /*\n    overlay would change first pixel by second\n  */\n  if (method == CompareOverlayLayer)\n    {\n      if (o2 > ((MagickRealType) QuantumRange/2.0))\n        return MagickFalse;\n      return((MagickBooleanType) (IsMagickColorSimilar(p,q) == MagickFalse));\n    }\n  return(MagickFalse);\n}",
        "target": 0
    },
    {
        "id": 3621,
        "func": " const unsigned char* TestBlinkPlatformSupport::getTraceCategoryEnabledFlag(\n    const char* categoryName) {\n  static const unsigned char tracingIsDisabled = 0;\n  return &tracingIsDisabled;\n}\n",
        "target": 0
    },
    {
        "id": 3622,
        "func": "JSRetainPtr<JSStringRef> AccessibilityUIElement::attributesOfChildren()\n{\n    return JSStringCreateWithCharacters(0, 0);\n}\n",
        "target": 0
    },
    {
        "id": 3623,
        "func": "static void __exit floppy_module_exit(void)\n{\n\tint drive;\n\n\tblk_unregister_region(MKDEV(FLOPPY_MAJOR, 0), 256);\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\tplatform_driver_unregister(&floppy_driver);\n\n\tdestroy_workqueue(floppy_wq);\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\n\t\tif (floppy_available(drive)) {\n\t\t\tdel_gendisk(disks[drive]);\n\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t\tblk_cleanup_queue(disks[drive]->queue);\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\n\t\t/*\n\t\t * These disks have not called add_disk().  Don't put down\n\t\t * queue reference in put_disk().\n\t\t */\n\t\tif (!(allowed_drive_mask & (1 << drive)) ||\n\t\t    fdc_state[FDC(drive)].version == FDC_NONE)\n\t\t\tdisks[drive]->queue = NULL;\n\n\t\tput_disk(disks[drive]);\n\t}\n\n\tcancel_delayed_work_sync(&fd_timeout);\n\tcancel_delayed_work_sync(&fd_timer);\n\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\n\n\t/* eject disk, if any */\n\tfd_eject(0);\n}",
        "target": 0
    },
    {
        "id": 3624,
        "func": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount = {};\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}",
        "target": 0
    },
    {
        "id": 3625,
        "func": "static void http_vlog(const char *fmt, va_list vargs)\n{\n    static int print_prefix = 1;\n    char buf[32];\n\n    if (!logfile)\n        return;\n\n    if (print_prefix) {\n        ctime1(buf, sizeof(buf));\n        fprintf(logfile, \"%s \", buf);\n    }\n    print_prefix = strstr(fmt, \"\\n\") != NULL;\n    vfprintf(logfile, fmt, vargs);\n    fflush(logfile);\n}",
        "target": 0
    },
    {
        "id": 3626,
        "func": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->fcc_info = fcc;\ninit_thread:\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}",
        "target": 1
    },
    {
        "id": 3627,
        "func": "static bool __init supported_pmu(void)\n{\n\tif (!strcmp(sparc_pmu_type, \"ultra3\") ||\n\t    !strcmp(sparc_pmu_type, \"ultra3+\") ||\n\t    !strcmp(sparc_pmu_type, \"ultra3i\") ||\n\t    !strcmp(sparc_pmu_type, \"ultra4+\")) {\n\t\tsparc_pmu = &ultra3_pmu;\n\t\treturn true;\n\t}\n\tif (!strcmp(sparc_pmu_type, \"niagara\")) {\n\t\tsparc_pmu = &niagara1_pmu;\n\t\treturn true;\n\t}\n\tif (!strcmp(sparc_pmu_type, \"niagara2\")) {\n\t\tsparc_pmu = &niagara2_pmu;\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "target": 0
    },
    {
        "id": 3628,
        "func": "char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n    int o_name_len = name_len;\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n\tint l;\n\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\t\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\t\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\ndecrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n            memcpy(*where, name, o_name_len);\n            *where += o_name_len;\n            **where = '='; *where +=1;\n\t        memcpy(*where, value, value_len);\n\t        *where += value_len;\n\t\t\treturn *where;\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto decrypt_return_plain;\n\t\t}\n\t}\n\t\n\t\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\t\n\tvalue_len = php_url_decode(buf2, value_len);\n\t\n\td = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);\n    if (d == NULL) {\n        goto skip_cookie;\n    }\n\td_url = php_url_encode(d, l, &l);\n\tefree(d);\n    memcpy(*where, name, o_name_len);\n    *where += o_name_len;\n    **where = '=';*where += 1;\n\tmemcpy(*where, d_url, l);\n\t*where += l;\n\tefree(d_url);\nskip_cookie:\n\tif (buf != buffer) {\n\t\tefree(buf);\n\t}\n\tif (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn *where;\n}",
        "target": 1
    },
    {
        "id": 3629,
        "func": "static qboolean Field_CompletePlayerNameFinal( qboolean whitespace )\n{\n\tint completionOffset;\n\n\tif( matchCount == 0 )\n\t\treturn qtrue;\n\n\tcompletionOffset = strlen( completionField->buffer ) - strlen( completionString );\n\n\tQ_strncpyz( &completionField->buffer[ completionOffset ], shortestMatch,\n\t\tsizeof( completionField->buffer ) - completionOffset );\n\n\tcompletionField->cursor = strlen( completionField->buffer );\n\n\tif( matchCount == 1 && whitespace )\n\t{\n\t\tQ_strcat( completionField->buffer, sizeof( completionField->buffer ), \" \" );\n\t\tcompletionField->cursor++;\n\t\treturn qtrue;\n\t}\n\n\treturn qfalse;\n}\n",
        "target": 0
    },
    {
        "id": 3630,
        "func": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 3631,
        "func": "static size_t ipip6_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t/* IFLA_IPTUN_LINK */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_IPTUN_LOCAL */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_IPTUN_REMOTE */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_IPTUN_TTL */\n\t\tnla_total_size(1) +\n\t\t/* IFLA_IPTUN_TOS */\n\t\tnla_total_size(1) +\n\t\t/* IFLA_IPTUN_PMTUDISC */\n\t\tnla_total_size(1) +\n\t\t/* IFLA_IPTUN_FLAGS */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_IPTUN_PROTO */\n\t\tnla_total_size(1) +\n#ifdef CONFIG_IPV6_SIT_6RD\n\t\t/* IFLA_IPTUN_6RD_PREFIX */\n\t\tnla_total_size(sizeof(struct in6_addr)) +\n\t\t/* IFLA_IPTUN_6RD_RELAY_PREFIX */\n\t\tnla_total_size(4) +\n\t\t/* IFLA_IPTUN_6RD_PREFIXLEN */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_IPTUN_6RD_RELAY_PREFIXLEN */\n\t\tnla_total_size(2) +\n#endif\n\t\t/* IFLA_IPTUN_ENCAP_TYPE */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_IPTUN_ENCAP_FLAGS */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_IPTUN_ENCAP_SPORT */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_IPTUN_ENCAP_DPORT */\n\t\tnla_total_size(2) +\n\t\t/* IFLA_IPTUN_FWMARK */\n\t\tnla_total_size(4) +\n\t\t0;\n}",
        "target": 0
    },
    {
        "id": 3632,
        "func": " PlatformSensorFusion::PlatformSensorFusion(\n    SensorReadingSharedBuffer* reading_buffer,\n     PlatformSensorProvider* provider,\n     std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm,\n     PlatformSensorFusion::SourcesMap sources)\n    : PlatformSensor(fusion_algorithm->fused_type(), reading_buffer, provider),\n       fusion_algorithm_(std::move(fusion_algorithm)),\n       source_sensors_(std::move(sources)),\n       reporting_mode_(mojom::ReportingMode::CONTINUOUS) {\n  for (const auto& pair : source_sensors_)\n    pair.second->AddClient(this);\n\n  fusion_algorithm_->set_fusion_sensor(this);\n\n  if (std::any_of(source_sensors_.begin(), source_sensors_.end(),\n                  [](const SourcesMapEntry& pair) {\n                    return pair.second->GetReportingMode() ==\n                           mojom::ReportingMode::ON_CHANGE;\n                  })) {\n    reporting_mode_ = mojom::ReportingMode::ON_CHANGE;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3633,
        "func": "void disk_part_iter_init(struct disk_part_iter *piter, struct gendisk *disk,\n\t\t\t  unsigned int flags)\n{\n\tstruct disk_part_tbl *ptbl;\n\n\trcu_read_lock();\n\tptbl = rcu_dereference(disk->part_tbl);\n\n\tpiter->disk = disk;\n\tpiter->part = NULL;\n\n\tif (flags & DISK_PITER_REVERSE)\n\t\tpiter->idx = ptbl->len - 1;\n\telse if (flags & (DISK_PITER_INCL_PART0 | DISK_PITER_INCL_EMPTY_PART0))\n\t\tpiter->idx = 0;\n\telse\n\t\tpiter->idx = 1;\n\n\tpiter->flags = flags;\n\n\trcu_read_unlock();\n}",
        "target": 0
    },
    {
        "id": 3634,
        "func": "void WebRuntimeFeatures::EnableRequireCSSExtensionForFile(bool enable) {\n  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);\n}\n",
        "target": 1
    },
    {
        "id": 3635,
        "func": "static int pdf_barcode_39_ch(struct pdf_doc *pdf, struct pdf_object *page, int x, int y, int char_width, int height, uint32_t colour, char ch)\n{\n    int nw = char_width / 12;\n    int ww = char_width / 4;\n    int i;\n    uint32_t code;\n\n    if (nw <= 1 || ww <= 1)\n        return pdf_set_err(pdf, -EINVAL, \"Insufficient width for each character\");\n\n    for (i = 0; i < ARRAY_SIZE(code_39_encoding); i++) {\n        if (code_39_encoding[i].ch == ch) {\n            code = code_39_encoding[i].code;\n            break;\n        }\n    }\n    if (i == ARRAY_SIZE(code_39_encoding))\n        return pdf_set_err(pdf, -EINVAL, \"Invalid Code 39 character %c 0x%x\", ch, ch);\n\n\n    for (i = 5; i >= 0; i--) {\n        int pattern = (code >> i * 4) & 0xf;\n        if (pattern == 0) { // wide\n            if (pdf_add_filled_rectangle(pdf, page, x, y, ww - 1, height, 0, colour) < 0)\n                return pdf->errval;\n            x += ww;\n        }\n        if (pattern == 1) { // narrow\n            if (pdf_add_filled_rectangle(pdf, page, x, y, nw - 1, height, 0, colour) < 0)\n                return pdf->errval;\n            x += nw;\n        }\n        if (pattern == 2) { // space\n            x += nw;\n        }\n    }\n    return x;\n}",
        "target": 0
    },
    {
        "id": 3636,
        "func": "void boa_perror(request * req, const char *message)\n{\n    log_error_doc(req);\n    perror(message);            /* don't need to save errno because log_error_doc does */\n    send_r_error(req);\n}\n",
        "target": 0
    },
    {
        "id": 3637,
        "func": "void WebGL2RenderingContextBase::texSubImage3D(\n    GLenum target,\n    GLint level,\n    GLint xoffset,\n    GLint yoffset,\n    GLint zoffset,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    GLenum format,\n    GLenum type,\n    MaybeShared<DOMArrayBufferView> pixels,\n    GLuint src_offset) {\n  if (isContextLost())\n    return;\n  if (bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texSubImage3D\",\n                       \"a buffer is bound to PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n   TexImageHelperDOMArrayBufferView(\n       kTexSubImage3D, target, level, 0, width, height, depth, 0, format, type,\n       xoffset, yoffset, zoffset, pixels.View(), kNullNotReachable, src_offset);\n}\n",
        "target": 1
    },
    {
        "id": 3638,
        "func": "bool ImageCapture::HasPendingActivity() const {\n  return GetExecutionContext() && HasEventListeners();\n}\n",
        "target": 0
    },
    {
        "id": 3639,
        "func": "void LayerTreeHost::SetElementTransformMutated(\n    ElementId element_id,\n    ElementListType list_type,\n    const gfx::Transform& transform) {\n  Layer* layer = LayerByElementId(element_id);\n  DCHECK(layer);\n  layer->OnTransformAnimated(transform);\n\n  if (property_trees_.IsInIdToIndexMap(PropertyTrees::TreeType::TRANSFORM,\n                                       layer->id())) {\n    DCHECK_EQ(layer->transform_tree_index(),\n              property_trees_.layer_id_to_transform_node_index[layer->id()]);\n    TransformNode* node =\n        property_trees_.transform_tree.Node(layer->transform_tree_index());\n    if (node->local == transform)\n      return;\n\n    node->local = transform;\n    node->needs_local_transform_update = true;\n    node->has_potential_animation = true;\n    property_trees_.transform_tree.set_needs_update(true);\n  }\n\n  SetNeedsUpdateLayers();\n}\n",
        "target": 0
    },
    {
        "id": 3640,
        "func": "int trace_array_vprintk(struct trace_array *tr,\n\t\t\tunsigned long ip, const char *fmt, va_list args)\n{\n\treturn __trace_array_vprintk(tr->trace_buffer.buffer, ip, fmt, args);\n}\n",
        "target": 0
    },
    {
        "id": 3641,
        "func": "static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (clone_flags & CLONE_THREAD)\n\t\treturn 0;\n\n\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tsig->nr_threads = 1;\n\tatomic_set(&sig->live, 1);\n\tatomic_set(&sig->sigcnt, 1);\n\n\t/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */\n\tsig->thread_head = (struct list_head)LIST_HEAD_INIT(tsk->thread_node);\n\ttsk->thread_node = (struct list_head)LIST_HEAD_INIT(sig->thread_head);\n\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tseqlock_init(&sig->stats_lock);\n\tprev_cputime_init(&sig->prev_cputime);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->real_timer.function = it_real_fn;\n#endif\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\ttty_audit_fork(sig);\n\tsched_autogroup_fork(sig);\n\n\tsig->oom_score_adj = current->signal->oom_score_adj;\n\tsig->oom_score_adj_min = current->signal->oom_score_adj_min;\n\n\tmutex_init(&sig->cred_guard_mutex);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3642,
        "func": "void Block::SetKey(bool bKey)\n{\n    if (bKey)\n        m_flags |= static_cast<unsigned char>(1 << 7);\n    else\n        m_flags &= 0x7F;\n }\n",
        "target": 1
    },
    {
        "id": 3643,
        "func": "bool RenderWidgetHostImpl::SynchronizeVisualProperties() {\n  return SynchronizeVisualProperties(false);\n}\n",
        "target": 0
    },
    {
        "id": 3644,
        "func": "static void register_sched_domain_sysctl(void)\n{\n}",
        "target": 0
    },
    {
        "id": 3645,
        "func": "config_tos(\n\tconfig_tree *ptree\n\t)\n{\n\tattr_val *tos;\n\tint item;\n\n\titem = -1;\t/* quiet warning */\n\ttos = HEAD_PFIFO(ptree->orphan_cmds);\n\tfor (; tos != NULL; tos = tos->link) {\n\t\tswitch(tos->attr) {\n\n\t\tdefault:\n\t\t\tNTP_INSIST(0);\n\t\t\tbreak;\n\n\t\tcase T_Ceiling:\n\t\t\titem = PROTO_CEILING;\n\t\t\tbreak;\n\n\t\tcase T_Floor:\n\t\t\titem = PROTO_FLOOR;\n\t\t\tbreak;\n\n\t\tcase T_Cohort:\n\t\t\titem = PROTO_COHORT;\n\t\t\tbreak;\n\n\t\tcase T_Orphan:\n\t\t\titem = PROTO_ORPHAN;\n\t\t\tbreak;\n\n\t\tcase T_Orphanwait:\n\t\t\titem = PROTO_ORPHWAIT;\n\t\t\tbreak;\n\n\t\tcase T_Mindist:\n\t\t\titem = PROTO_MINDISP;\n\t\t\tbreak;\n\n\t\tcase T_Maxdist:\n\t\t\titem = PROTO_MAXDIST;\n\t\t\tbreak;\n\n\t\tcase T_Minclock:\n\t\t\titem = PROTO_MINCLOCK;\n\t\t\tbreak;\n\n\t\tcase T_Maxclock:\n\t\t\titem = PROTO_MAXCLOCK;\n\t\t\tbreak;\n\n\t\tcase T_Minsane:\n\t\t\titem = PROTO_MINSANE;\n\t\t\tbreak;\n\n\t\tcase T_Beacon:\n\t\t\titem = PROTO_BEACON;\n\t\t\tbreak;\n\t\t}\n\t\tproto_config(item, 0, tos->value.d, NULL);\n\t}\n}",
        "target": 0
    },
    {
        "id": 3646,
        "func": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    EHCIqtd qtd;\n    EHCIqh qh;\n    int state;\n\n    /* Verify the qh + qtd, like we do when going through fetchqh & fetchqtd */\n    get_dwords(q->ehci, NLPTR_GET(q->qhaddr),\n               (uint32_t *) &qh, sizeof(EHCIqh) >> 2);\n    get_dwords(q->ehci, NLPTR_GET(q->qtdaddr),\n               (uint32_t *) &qtd, sizeof(EHCIqtd) >> 2);\n    if (!ehci_verify_qh(q, &qh) || !ehci_verify_qtd(p, &qtd)) {\n        p->async = EHCI_ASYNC_INITIALIZED;\n        ehci_free_packet(p);\n        return;\n    }\n\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    }\n    ehci_set_state(q->ehci, q->async, state);\n}\n",
        "target": 0
    },
    {
        "id": 3647,
        "func": "status_t MediaPlayerService::Client::setRetransmitEndpoint(\n const struct sockaddr_in* endpoint) {\n\n if (NULL != endpoint) {\n uint32_t a = ntohl(endpoint->sin_addr.s_addr);\n uint16_t p = ntohs(endpoint->sin_port);\n        ALOGV(\"[%d] setRetransmitEndpoint(%u.%u.%u.%u:%hu)\", mConnId,\n (a >> 24), (a >> 16) & 0xFF, (a >> 8) & 0xFF, (a & 0xFF), p);\n } else {\n        ALOGV(\"[%d] setRetransmitEndpoint = <none>\", mConnId);\n }\n\n    sp<MediaPlayerBase> p = getPlayer();\n\n if (p != 0) return INVALID_OPERATION;\n\n if (NULL != endpoint) {\n        mRetransmitEndpoint = *endpoint;\n        mRetransmitEndpointValid = true;\n } else {\n        mRetransmitEndpointValid = false;\n }\n\n return NO_ERROR;\n}\n",
        "target": 0
    },
    {
        "id": 3648,
        "func": "static void scsi_cancel_io(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    DPRINTF(\"Cancel tag=0x%x\\n\", req->tag);\n    if (r->req.aiocb) {\n        bdrv_aio_cancel(r->req.aiocb);\n    }\n    r->req.aiocb = NULL;\n}",
        "target": 0
    },
    {
        "id": 3649,
        "func": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n\t    EXTRACT_16BITS(ptr))));\n}",
        "target": 1
    },
    {
        "id": 3650,
        "func": "png_read_finish_row(png_structrp png_ptr)\n{\n   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */\n\n   /* Start of interlace block */\n   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n\n   /* Offset to next interlace block */\n   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n\n   /* Start of interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n\n   /* Offset to next interlace block in the y direction */\n   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n\n   png_debug(1, \"in png_read_finish_row\");\n   png_ptr->row_number++;\n   if (png_ptr->row_number < png_ptr->num_rows)\n      return;\n\n   if (png_ptr->interlaced != 0)\n   {\n      png_ptr->row_number = 0;\n\n      /* TO DO: don't do this if prev_row isn't needed (requires\n       * read-ahead of the next row's filter byte.\n       */\n      memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);\n\n      do\n      {\n         png_ptr->pass++;\n\n         if (png_ptr->pass >= 7)\n            break;\n\n         png_ptr->iwidth = (png_ptr->width +\n            png_pass_inc[png_ptr->pass] - 1 -\n            png_pass_start[png_ptr->pass]) /\n            png_pass_inc[png_ptr->pass];\n\n         if ((png_ptr->transformations & PNG_INTERLACE) == 0)\n         {\n            png_ptr->num_rows = (png_ptr->height +\n                png_pass_yinc[png_ptr->pass] - 1 -\n                png_pass_ystart[png_ptr->pass]) /\n                png_pass_yinc[png_ptr->pass];\n         }\n\n         else  /* if (png_ptr->transformations & PNG_INTERLACE) */\n            break; /* libpng deinterlacing sees every row */\n\n      } while (png_ptr->num_rows == 0 || png_ptr->iwidth == 0);\n\n      if (png_ptr->pass < 7)\n         return;\n   }\n\n   /* Here after at the end of the last row of the last pass. */\n   png_read_finish_IDAT(png_ptr);\n}",
        "target": 0
    },
    {
        "id": 3651,
        "func": " SSH_PACKET_CALLBACK(ssh_packet_kexdh_init){\n  int rc = SSH_ERROR;\n   (void)type;\n   (void)user;\n \n  SSH_LOG(SSH_LOG_PACKET,\"Received SSH_MSG_KEXDH_INIT\");\n  if(session->dh_handshake_state != DH_STATE_INIT){\n    SSH_LOG(SSH_LOG_RARE,\"Invalid state for SSH_MSG_KEXDH_INIT\");\n    goto error;\n  }\n  switch(session->next_crypto->kex_type){\n      case SSH_KEX_DH_GROUP1_SHA1:\n      case SSH_KEX_DH_GROUP14_SHA1:\n        rc=ssh_server_kexdh_init(session, packet);\n        break;\n  #ifdef HAVE_ECDH\n      case SSH_KEX_ECDH_SHA2_NISTP256:\n        rc = ssh_server_ecdh_init(session, packet);\n        break;\n  #endif\n  #ifdef HAVE_CURVE25519\n      case SSH_KEX_CURVE25519_SHA256_LIBSSH_ORG:\n    \trc = ssh_server_curve25519_init(session, packet);\n    \tbreak;\n  #endif\n      default:\n         ssh_set_error(session,SSH_FATAL,\"Wrong kex type in ssh_packet_kexdh_init\");\n         rc = SSH_ERROR;\n   }\n\nerror:\n  if (rc == SSH_ERROR) {\n       session->session_state = SSH_SESSION_STATE_ERROR;\n  }\n \n   return SSH_PACKET_USED;\n }\n",
        "target": 0
    },
    {
        "id": 3652,
        "func": "int LayoutTestBrowserMain(\n    const content::MainFunctionParams& parameters,\n    const scoped_ptr<content::BrowserMainRunner>& main_runner) {\n  base::ScopedTempDir browser_context_path_for_layout_tests;\n\n  CHECK(browser_context_path_for_layout_tests.CreateUniqueTempDir());\n  CHECK(!browser_context_path_for_layout_tests.path().MaybeAsASCII().empty());\n  CommandLine::ForCurrentProcess()->AppendSwitchASCII(\n      switches::kContentShellDataPath,\n      browser_context_path_for_layout_tests.path().MaybeAsASCII());\n\n#if defined(OS_ANDROID)\n  content::EnsureInitializeForAndroidLayoutTests();\n#endif\n\n  int exit_code = main_runner->Initialize(parameters);\n  DCHECK_LT(exit_code, 0)\n      << \"BrowserMainRunner::Initialize failed in LayoutTestBrowserMain\";\n\n  if (exit_code >= 0)\n    return exit_code;\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kCheckLayoutTestSysDeps)) {\n    base::MessageLoop::current()->PostTask(FROM_HERE,\n                                           base::MessageLoop::QuitClosure());\n    main_runner->Run();\n    content::Shell::CloseAllWindows();\n    main_runner->Shutdown();\n    return 0;\n  }\n\n  content::WebKitTestController test_controller;\n  {\n    base::ThreadRestrictions::ScopedAllowIO allow_io;\n    base::FilePath temp_path;\n    base::GetTempDir(&temp_path);\n    test_controller.SetTempPath(temp_path);\n  }\n  std::string test_string;\n  CommandLine::StringVector args = CommandLine::ForCurrentProcess()->GetArgs();\n  size_t command_line_position = 0;\n  bool ran_at_least_once = false;\n\n  std::cout << \"#READY\\n\";\n  std::cout.flush();\n\n  while (GetNextTest(args, &command_line_position, &test_string)) {\n    if (!RunOneTest(test_string, &ran_at_least_once, main_runner))\n      break;\n  }\n  if (!ran_at_least_once) {\n    base::MessageLoop::current()->PostTask(FROM_HERE,\n                                           base::MessageLoop::QuitClosure());\n    main_runner->Run();\n  }\n\n#if defined(OS_ANDROID)\n  main_runner->Shutdown();\n#endif\n\n  exit_code = 0;\n\n#if !defined(OS_ANDROID)\n  main_runner->Shutdown();\n#endif\n\n  return exit_code;\n}\n",
        "target": 0
    },
    {
        "id": 3653,
        "func": "unsigned long gfn_to_hva(struct kvm *kvm, gfn_t gfn)\n{\n\treturn gfn_to_hva_many(gfn_to_memslot(kvm, gfn), gfn, NULL);\n}\n",
        "target": 0
    },
    {
        "id": 3654,
        "func": "static inline ut32 r_read_le32(const void *src) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |\n\t\t(((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);\n}",
        "target": 0
    },
    {
        "id": 3655,
        "func": " TestFlashMessageLoop::TestFlashMessageLoop(TestingInstance* instance)\n     : TestCase(instance),\n",
        "target": 0
    },
    {
        "id": 3656,
        "func": "header_put_marker (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n} /* header_put_marker */",
        "target": 0
    },
    {
        "id": 3657,
        "func": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint len = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n}",
        "target": 0
    },
    {
        "id": 3658,
        "func": "int gdImageColorExact (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorExactAlpha (im, r, g, b, gdAlphaOpaque);\n}\n",
        "target": 0
    },
    {
        "id": 3659,
        "func": "void Browser::EnumerateDirectory(WebContents* web_contents,\n                                 int request_id,\n                                 const FilePath& path) {\n  FileSelectHelper::EnumerateDirectory(web_contents, request_id, path);\n}\n",
        "target": 0
    },
    {
        "id": 3660,
        "func": "void LockContentsView::AddRotationAction(const OnRotate& on_rotate) {\n  on_rotate.Run(login_layout_util::ShouldShowLandscape(GetWidget()));\n  rotation_actions_.push_back(on_rotate);\n}\n",
        "target": 0
    },
    {
        "id": 3661,
        "func": "void setJSTestObjAttrWithGetterException(ExecState* exec, JSObject* thisObject, JSValue value)\n{\n    JSTestObj* castedThis = jsCast<JSTestObj*>(thisObject);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    ExceptionCode ec = 0;\n    impl->setAttrWithGetterException(value.toInt32(exec), ec);\n    setDOMException(exec, ec);\n}\n",
        "target": 0
    },
    {
        "id": 3662,
        "func": "NavigationEntryImpl* NavigationControllerImpl::GetEntryAtOffset(\n    int offset) const {\n  return GetEntryAtIndex(GetIndexForOffset(offset));\n}\n",
        "target": 0
    },
    {
        "id": 3663,
        "func": "const char *get_link(struct nameidata *nd)\n{\n\tstruct saved *last = nd->stack + nd->depth - 1;\n\tstruct dentry *dentry = last->link.dentry;\n\tstruct inode *inode = nd->link_inode;\n\tint error;\n\tconst char *res;\n\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\ttouch_atime(&last->link);\n\t\tcond_resched();\n\t} else if (atime_needs_update_rcu(&last->link, inode)) {\n\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\ttouch_atime(&last->link);\n\t}\n\n\terror = security_inode_follow_link(dentry, inode,\n\t\t\t\t\t   nd->flags & LOOKUP_RCU);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\n\tnd->last_type = LAST_BIND;\n\tres = inode->i_link;\n\tif (!res) {\n\t\tconst char * (*get)(struct dentry *, struct inode *,\n\t\t\t\tstruct delayed_call *);\n\t\tget = inode->i_op->get_link;\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tres = get(NULL, inode, &last->done);\n\t\t\tif (res == ERR_PTR(-ECHILD)) {\n\t\t\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\t\t\treturn ERR_PTR(-ECHILD);\n\t\t\t\tres = get(dentry, inode, &last->done);\n\t\t\t}\n\t\t} else {\n\t\t\tres = get(dentry, inode, &last->done);\n\t\t}\n\t\tif (IS_ERR_OR_NULL(res))\n\t\t\treturn res;\n\t}\n\tif (*res == '/') {\n\t\tif (!nd->root.mnt)\n\t\t\tset_root(nd);\n\t\tif (unlikely(nd_jump_root(nd)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\twhile (unlikely(*++res == '/'))\n\t\t\t;\n\t}\n\tif (!*res)\n\t\tres = NULL;\n\treturn res;\n}",
        "target": 0
    },
    {
        "id": 3664,
        "func": "is_uid_in_gid (uid_t uid,\n               gid_t gid)\n{\n  gboolean ret;\n  struct passwd *pw;\n  static gid_t supplementary_groups[128];\n  int num_supplementary_groups = 128;\n  int n;\n\n  /* TODO: use some #define instead of harcoding some random number like 128 */\n\n  ret = FALSE;\n\n  pw = getpwuid (uid);\n  if (pw == NULL)\n    {\n      g_warning (\"Couldn't look up uid %d: %m\", uid);\n      goto out;\n    }\n  if (pw->pw_gid == gid)\n    {\n      ret = TRUE;\n      goto out;\n    }\n\n  if (getgrouplist (pw->pw_name, pw->pw_gid, supplementary_groups, &num_supplementary_groups) < 0)\n    {\n      g_warning (\"Couldn't find supplementary groups for uid %d: %m\", uid);\n      goto out;\n    }\n\n  for (n = 0; n < num_supplementary_groups; n++)\n    {\n      if (supplementary_groups[n] == gid)\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n\n out:\n  return ret;\n}\n",
        "target": 0
    },
    {
        "id": 3665,
        "func": "int SafeSock::put_bytes(const void *data, int sz)\n{\n\tint bytesPut, l_out;\n    unsigned char * dta = 0;\n\n\n    if (get_encryption()) {\n        if (!wrap((unsigned char *)data, sz, dta , l_out)) { \n            dprintf(D_SECURITY, \"Encryption failed\\n\");\n            return -1;  // encryption failed!\n        }\n    }\n    else {\n        dta = (unsigned char *) malloc(sz);\n        memcpy(dta, data, sz);\n    }\n    \n    if (mdChecker_) {\n        mdChecker_->addMD(dta, sz);\n    }\n\n\n    bytesPut = _outMsg.putn((char *)dta, sz);\n    \n    free(dta);\n    \n\treturn bytesPut;\n}\n",
        "target": 0
    },
    {
        "id": 3666,
        "func": "unknowntag_start(struct archive_read *a, struct xar *xar, const char *name)\n{\n\tstruct unknown_tag *tag;\n\n\ttag = malloc(sizeof(*tag));\n\tif (tag == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\ttag->next = xar->unknowntags;\n\tarchive_string_init(&(tag->name));\n\tarchive_strcpy(&(tag->name), name);\n\tif (xar->unknowntags == NULL) {\n#if DEBUG\n\t\tfprintf(stderr, \"UNKNOWNTAG_START:%s\\n\", name);\n#endif\n\t\txar->xmlsts_unknown = xar->xmlsts;\n\t\txar->xmlsts = UNKNOWN;\n\t}\n\txar->unknowntags = tag;\n\treturn (ARCHIVE_OK);\n}",
        "target": 0
    },
    {
        "id": 3667,
        "func": "void GLES2Implementation::OnSwapBufferPresented(\n    uint64_t swap_id,\n    const gfx::PresentationFeedback& feedback) {\n  auto found = pending_presentation_callbacks_.find(swap_id);\n  if (found == pending_presentation_callbacks_.end())\n    return;\n  std::move(found->second).Run(feedback);\n  pending_presentation_callbacks_.erase(found);\n}\n",
        "target": 0
    },
    {
        "id": 3668,
        "func": "u64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn 0;\n\n\ttpr = (u64) kvm_apic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}",
        "target": 0
    },
    {
        "id": 3669,
        "func": "begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_xobject *softmask = gstate->softmask;\n\tfz_rect mask_bbox;\n\tfz_matrix tos_save[2], save_ctm;\n\tfz_matrix mask_matrix;\n\tfz_colorspace *mask_colorspace;\n\n\tsave->softmask = softmask;\n\tif (softmask == NULL)\n\t\treturn gstate;\n\tsave->page_resources = gstate->softmask_resources;\n\tsave->ctm = gstate->softmask_ctm;\n\tsave_ctm = gstate->ctm;\n\n\tpdf_xobject_bbox(ctx, softmask, &mask_bbox);\n\tpdf_xobject_matrix(ctx, softmask, &mask_matrix);\n\n\tpdf_tos_save(ctx, &pr->tos, tos_save);\n\n\tif (gstate->luminosity)\n\t\tmask_bbox = fz_infinite_rect;\n\telse\n\t{\n\t\tfz_transform_rect(&mask_bbox, &mask_matrix);\n\t\tfz_transform_rect(&mask_bbox, &gstate->softmask_ctm);\n\t}\n\tgstate->softmask = NULL;\n\tgstate->softmask_resources = NULL;\n\tgstate->ctm = gstate->softmask_ctm;\n\n        mask_colorspace = pdf_xobject_colorspace(ctx, softmask);\n \n        if (gstate->luminosity && !mask_colorspace)\n               mask_colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx));\n \n        fz_try(ctx)\n        {\n\t\tfz_begin_mask(ctx, pr->dev, &mask_bbox, gstate->luminosity, mask_colorspace, gstate->softmask_bc, &gstate->fill.color_params);\n\t\tpdf_run_xobject(ctx, pr, softmask, save->page_resources, &fz_identity, 1);\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_colorspace(ctx, mask_colorspace);\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t/* FIXME: Ignore error - nasty, but if we throw from\n\t\t * here the clip stack would be messed up. */\n\t\t/* TODO: pass cookie here to increase the cookie error count */\n\t}\n\n\tfz_end_mask(ctx, pr->dev);\n\n\tpdf_tos_restore(ctx, &pr->tos, tos_save);\n\n\tgstate = pr->gstate + pr->gtop;\n\tgstate->ctm = save_ctm;\n\n\treturn gstate;\n}\n",
        "target": 0
    },
    {
        "id": 3670,
        "func": "void PartialMagnificationController::SetScale(float scale) {\n  if (!is_enabled_)\n     return;\n \n  scale_ = scale;\n \n  if (IsPartialMagnified()) {\n    CreateMagnifierWindow();\n  } else {\n     CloseMagnifierWindow();\n   }\n }\n",
        "target": 1
    },
    {
        "id": 3671,
        "func": " void WebContentsImpl::DidCallFocus() {\n  if (IsFullscreenForCurrentTab())\n    ExitFullscreen(true);\n }\n",
        "target": 1
    },
    {
        "id": 3672,
        "func": "atm_if_print(netdissect_options *ndo,\n             const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tuint32_t llchdr;\n\tu_int hdrlen = 0;\n\n\tif (caplen < 1 || length < 1) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n\n        /* Cisco Style NLPID ? */\n        if (*p == LLC_UI) {\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"CNLPID \"));\n            isoclns_print(ndo, p + 1, length - 1, caplen - 1);\n            return hdrlen;\n        }\n\n\t/*\n\t * Must have at least a DSAP, an SSAP, and the first byte of the\n\t * control field.\n\t */\n\tif (caplen < 3 || length < 3) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n\n\t/*\n\t * Extract the presumed LLC header into a variable, for quick\n\t * testing.\n\t * Then check for a header that's neither a header for a SNAP\n\t * packet nor an RFC 2684 routed NLPID-formatted PDU nor\n\t * an 802.2-but-no-SNAP IP packet.\n\t */\n\tllchdr = EXTRACT_24BITS(p);\n\tif (llchdr != LLC_UI_HDR(LLCSAP_SNAP) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_IP)) {\n\t\t/*\n\t\t * XXX - assume 802.6 MAC header from Fore driver.\n\t\t *\n\t\t * Unfortunately, the above list doesn't check for\n\t\t * all known SAPs, doesn't check for headers where\n\t\t * the source and destination SAP aren't the same,\n\t\t * and doesn't check for non-UI frames.  It also\n\t\t * runs the risk of an 802.6 MAC header that happens\n\t\t * to begin with one of those values being\n\t\t * incorrectly treated as an 802.2 header.\n\t\t *\n\t\t * So is that Fore driver still around?  And, if so,\n\t\t * is it still putting 802.6 MAC headers on ATM\n\t\t * packets?  If so, could it be changed to use a\n\t\t * new DLT_IEEE802_6 value if we added it?\n\t\t */\n\t\tif (caplen < 20 || length < 20) {\n\t\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\t\treturn (caplen);\n\t\t}\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%08x%08x %08x%08x \",\n\t\t\t       EXTRACT_32BITS(p),\n\t\t\t       EXTRACT_32BITS(p+4),\n\t\t\t       EXTRACT_32BITS(p+8),\n\t\t\t       EXTRACT_32BITS(p+12)));\n\t\tp += 20;\n\t\tlength -= 20;\n\t\tcaplen -= 20;\n\t\thdrlen += 20;\n\t}\n\thdrlen += atm_llc_print(ndo, p, length, caplen);\n\treturn (hdrlen);\n}",
        "target": 1
    },
    {
        "id": 3673,
        "func": "gpc_gb16(Pixel *out, const Pixel *in, const Background *back)\n{\n if (in->a <= 0)\n      out->r = out->g = out->b = back->ig;\n\n else if (in->a >= 65535)\n      out->r = out->g = out->b = isRGB(in->g);\n\n else\n {\n double a = in->a / 65535.;\n double a1 = 1-a;\n\n      a /= 65535;\n      out->r = out->g = out->b = sRGB(in->g * a + back->dg * a1);\n }\n\n   out->a = 255;\n}\n",
        "target": 0
    },
    {
        "id": 3674,
        "func": "bool acpi_osi_is_win8(void)\n{\n\treturn acpi_gbl_osi_data >= ACPI_OSI_WIN_8;\n}\n",
        "target": 0
    },
    {
        "id": 3675,
        "func": "Response PageHandler::StopScreencast() {\n  screencast_enabled_ = false;\n  return Response::FallThrough();\n}\n",
        "target": 0
    },
    {
        "id": 3676,
        "func": "static void parse_output_words(struct output_struct *words, short *levels,\n\t\t\t       const char *str, uchar priority)\n{\n\tconst char *s;\n\tint j, len, lev;\n\n\tfor ( ; str; str = s) {\n\t\tif ((s = strchr(str, ',')) != NULL)\n\t\t\tlen = s++ - str;\n\t\telse\n\t\t\tlen = strlen(str);\n\t\tif (!len)\n\t\t\tcontinue;\n\t\tif (!isDigit(str)) {\n\t\t\twhile (len && isDigit(str+len-1))\n\t\t\t\tlen--;\n\t\t}\n\t\tlev = isDigit(str+len) ? atoi(str+len) : 1;\n\t\tif (lev > MAX_OUT_LEVEL)\n\t\t\tlev = MAX_OUT_LEVEL;\n\t\tif (len == 4 && strncasecmp(str, \"help\", 4) == 0) {\n\t\t\toutput_item_help(words);\n\t\t\texit_cleanup(0);\n\t\t}\n\t\tif (len == 4 && strncasecmp(str, \"none\", 4) == 0)\n\t\t\tlen = lev = 0;\n\t\telse if (len == 3 && strncasecmp(str, \"all\", 3) == 0)\n\t\t\tlen = 0;\n\t\tfor (j = 0; words[j].name; j++) {\n\t\t\tif (!len\n\t\t\t || (len == words[j].namelen && strncasecmp(str, words[j].name, len) == 0)) {\n\t\t\t\tif (priority >= words[j].priority) {\n\t\t\t\t\twords[j].priority = priority;\n\t\t\t\t\tlevels[j] = lev;\n\t\t\t\t}\n\t\t\t\tif (len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (len && !words[j].name) {\n\t\t\trprintf(FERROR, \"Unknown %s item: \\\"%.*s\\\"\\n\",\n\t\t\t\twords[j].help, len, str);\n\t\t\texit_cleanup(RERR_SYNTAX);\n\t\t}\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 3677,
        "func": " void ImageBitmapFactories::ImageBitmapLoader::RejectPromise(\n    ImageBitmapRejectionReason reason) {\n  switch (reason) {\n    case kUndecodableImageBitmapRejectionReason:\n      resolver_->Reject(\n          DOMException::Create(DOMExceptionCode::kInvalidStateError,\n                               \"The source image could not be decoded.\"));\n      break;\n    case kAllocationFailureImageBitmapRejectionReason:\n      resolver_->Reject(\n          DOMException::Create(DOMExceptionCode::kInvalidStateError,\n                               \"The ImageBitmap could not be allocated.\"));\n      break;\n     default:\n       NOTREACHED();\n   }\n   factory_->DidFinishLoading(this);\n }\n",
        "target": 1
    },
    {
        "id": 3678,
        "func": "void BrowserViewRenderer::ScrollTo(gfx::Vector2d scroll_offset) {\n   gfx::Vector2d max_offset = max_scroll_offset();\n   gfx::Vector2dF scroll_offset_dip;\n  if (max_offset.x()) {\n    scroll_offset_dip.set_x((scroll_offset.x() * max_scroll_offset_dip_.x()) /\n                            max_offset.x());\n  }\n  if (max_offset.y()) {\n    scroll_offset_dip.set_y((scroll_offset.y() * max_scroll_offset_dip_.y()) /\n                            max_offset.y());\n  }\n\n  DCHECK_LE(0.f, scroll_offset_dip.x());\n  DCHECK_LE(0.f, scroll_offset_dip.y());\n  DCHECK(scroll_offset_dip.x() < max_scroll_offset_dip_.x() ||\n         scroll_offset_dip.x() - max_scroll_offset_dip_.x() < kEpsilon)\n      << scroll_offset_dip.x() << \" \" << max_scroll_offset_dip_.x();\n  DCHECK(scroll_offset_dip.y() < max_scroll_offset_dip_.y() ||\n         scroll_offset_dip.y() - max_scroll_offset_dip_.y() < kEpsilon)\n      << scroll_offset_dip.y() << \" \" << max_scroll_offset_dip_.y();\n\n  if (scroll_offset_dip_ == scroll_offset_dip)\n    return;\n\n  scroll_offset_dip_ = scroll_offset_dip;\n\n  TRACE_EVENT_INSTANT2(\"android_webview\",\n               \"BrowserViewRenderer::ScrollTo\",\n               TRACE_EVENT_SCOPE_THREAD,\n               \"x\",\n               scroll_offset_dip.x(),\n               \"y\",\n               scroll_offset_dip.y());\n\n  if (compositor_) {\n    compositor_->DidChangeRootLayerScrollOffset(\n        gfx::ScrollOffset(scroll_offset_dip_));\n  }\n}\n",
        "target": 1
    },
    {
        "id": 3679,
        "func": "static PHP_GSHUTDOWN_FUNCTION(pcre) /* {{{ */\n{\n\tzend_hash_destroy(&pcre_globals->pcre_cache);\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 3680,
        "func": "bool DownloadItemImpl::IsDangerous() const {\n#ifdef OS_WIN\n  return (danger_type_ == content::DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE ||\n          danger_type_ == content::DOWNLOAD_DANGER_TYPE_DANGEROUS_URL ||\n          danger_type_ == content::DOWNLOAD_DANGER_TYPE_DANGEROUS_CONTENT ||\n          danger_type_ == content::DOWNLOAD_DANGER_TYPE_UNCOMMON_CONTENT);\n#else\n  return (danger_type_ == content::DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE ||\n          danger_type_ == content::DOWNLOAD_DANGER_TYPE_DANGEROUS_URL);\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 3681,
        "func": "cmsTagTypeHandler* GetHandler(cmsTagTypeSignature sig, _cmsTagTypeLinkedList* PluginLinkedList, _cmsTagTypeLinkedList* DefaultLinkedList)\n{\n    _cmsTagTypeLinkedList* pt;\n\n    for (pt = PluginLinkedList;\n         pt != NULL;\n         pt = pt ->Next) {\n\n            if (sig == pt -> Handler.Signature) return &pt ->Handler;\n    }\n\n    for (pt = DefaultLinkedList;\n         pt != NULL;\n         pt = pt ->Next) {\n\n            if (sig == pt -> Handler.Signature) return &pt ->Handler;\n    }\n\n    return NULL;\n}",
        "target": 0
    },
    {
        "id": 3682,
        "func": "bool RenderBlockFlow::hitTestFloats(const HitTestRequest& request, HitTestResult& result, const HitTestLocation& locationInContainer, const LayoutPoint& accumulatedOffset)\n{\n    if (!m_floatingObjects)\n        return false;\n\n    LayoutPoint adjustedLocation = accumulatedOffset;\n    if (isRenderView()) {\n        adjustedLocation += toLayoutSize(toRenderView(this)->frameView()->scrollPosition());\n    }\n\n    const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();\n    FloatingObjectSetIterator begin = floatingObjectSet.begin();\n    for (FloatingObjectSetIterator it = floatingObjectSet.end(); it != begin;) {\n        --it;\n        FloatingObject* floatingObject = *it;\n        if (floatingObject->shouldPaint() && !floatingObject->renderer()->hasSelfPaintingLayer()) {\n            LayoutUnit xOffset = xPositionForFloatIncludingMargin(floatingObject) - floatingObject->renderer()->x();\n            LayoutUnit yOffset = yPositionForFloatIncludingMargin(floatingObject) - floatingObject->renderer()->y();\n            LayoutPoint childPoint = flipFloatForWritingModeForChild(floatingObject, adjustedLocation + LayoutSize(xOffset, yOffset));\n            if (floatingObject->renderer()->hitTest(request, result, locationInContainer, childPoint)) {\n                updateHitTestResult(result, locationInContainer.point() - toLayoutSize(childPoint));\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n",
        "target": 0
    },
    {
        "id": 3683,
        "func": "static inline int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\n{\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3684,
        "func": "static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu)\n{\n\treturn;\n}",
        "target": 0
    },
    {
        "id": 3685,
        "func": "static void xilinx_ethlite_reset(DeviceState *dev)\n{\n    struct xlx_ethlite *s = XILINX_ETHLITE(dev);\n\n    s->rxbuf = 0;\n}\n",
        "target": 0
    },
    {
        "id": 3686,
        "func": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tfp->f_cred->user->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}",
        "target": 1
    },
    {
        "id": 3687,
        "func": "int xmlSAXUserParseMemory(xmlSAXHandlerPtr sax, void *user_data,\n\t\t\t  const char *buffer, int size) {\n    int ret = 0;\n    xmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n\n    ctxt = xmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL) return -1;\n    if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)\n        xmlFree(ctxt->sax);\n    ctxt->sax = sax;\n    xmlDetectSAX2(ctxt);\n\n    if (user_data != NULL)\n\tctxt->userData = user_data;\n\n    xmlParseDocument(ctxt);\n    \n    if (ctxt->wellFormed)\n\tret = 0;\n    else {\n        if (ctxt->errNo != 0)\n\t    ret = ctxt->errNo;\n\telse\n\t    ret = -1;\n    }\n    if (sax != NULL)\n        ctxt->sax = NULL;\n    if (ctxt->myDoc != NULL) {\n        xmlFreeDoc(ctxt->myDoc);\n\tctxt->myDoc = NULL;\n    }\n    xmlFreeParserCtxt(ctxt);\n    \n    return ret;\n}\n",
        "target": 0
    },
    {
        "id": 3688,
        "func": " static NPError GetURLNotify(NPP id,\n                             const char* url,\n                             const char* target,\n                            bool notify,\n                            void* notify_data) {\n   if (!url)\n     return NPERR_INVALID_URL;\n \n   scoped_refptr<NPAPI::PluginInstance> plugin = FindInstance(id);\n  if (!plugin.get()) {\n     NOTREACHED();\n     return NPERR_GENERIC_ERROR;\n   }\n\n  plugin->RequestURL(url, \"GET\", target, NULL, 0, notify, notify_data);\n   return NPERR_NO_ERROR;\n }\n",
        "target": 0
    },
    {
        "id": 3689,
        "func": "static apr_status_t php_apache_server_shutdown(void *tmp)\n{\n\tapache2_sapi_module.shutdown(&apache2_sapi_module);\n\tsapi_shutdown();\n#ifdef ZTS\n\ttsrm_shutdown();\n#endif\n\treturn APR_SUCCESS;\n}",
        "target": 0
    },
    {
        "id": 3690,
        "func": "static struct page *get_any_partial(struct kmem_cache *s, gfp_t flags)\n{\n#ifdef CONFIG_NUMA\n\tstruct zonelist *zonelist;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum zone_type high_zoneidx = gfp_zone(flags);\n\tstruct page *page;\n\n\t/*\n\t * The defrag ratio allows a configuration of the tradeoffs between\n\t * inter node defragmentation and node local allocations. A lower\n\t * defrag_ratio increases the tendency to do local allocations\n\t * instead of attempting to obtain partial slabs from other nodes.\n\t *\n\t * If the defrag_ratio is set to 0 then kmalloc() always\n\t * returns node local objects. If the ratio is higher then kmalloc()\n\t * may return off node objects because partial slabs are obtained\n\t * from other nodes and filled up.\n\t *\n\t * If /sys/kernel/slab/xx/defrag_ratio is set to 100 (which makes\n\t * defrag_ratio = 1000) then every (well almost) allocation will\n\t * first attempt to defrag slab caches on other nodes. This means\n\t * scanning over all nodes to look for partial slabs which may be\n\t * expensive if we do it every time we are trying to find a slab\n\t * with available objects.\n\t */\n\tif (!s->remote_node_defrag_ratio ||\n\t\t\tget_cycles() % 1024 > s->remote_node_defrag_ratio)\n\t\treturn NULL;\n\n\tzonelist = node_zonelist(slab_node(current->mempolicy), flags);\n\tfor_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {\n\t\tstruct kmem_cache_node *n;\n\n\t\tn = get_node(s, zone_to_nid(zone));\n\n\t\tif (n && cpuset_zone_allowed_hardwall(zone, flags) &&\n\t\t\t\tn->nr_partial > MIN_PARTIAL) {\n\t\t\tpage = get_partial_node(n);\n\t\t\tif (page)\n\t\t\t\treturn page;\n\t\t}\n\t}\n#endif\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 3691,
        "func": "scoped_refptr<BrowserContext> BrowserContextImpl::GetOffTheRecordContext() {\n   if (!otr_context_) {\n    OTRBrowserContextImpl* context = new OTRBrowserContextImpl(\n        this,\n        static_cast<BrowserContextIODataImpl *>(io_data()));\n    otr_context_ = context->GetWeakPtr();\n   }\n \n  return make_scoped_refptr(otr_context_.get());\n }\n",
        "target": 1
    },
    {
        "id": 3692,
        "func": "struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)\n{\n\tif (atomic_inc_return(&prog->aux->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&prog->aux->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\treturn prog;\n}",
        "target": 0
    },
    {
        "id": 3693,
        "func": "do_init (int event_fd, pid_t initial_pid, struct sock_fprog *seccomp_prog)\n{\n  int initial_exit_status = 1;\n  LockFile *lock;\n\n  for (lock = lock_files; lock != NULL; lock = lock->next)\n    {\n      int fd = open (lock->path, O_RDONLY | O_CLOEXEC);\n      if (fd == -1)\n        die_with_error (\"Unable to open lock file %s\", lock->path);\n\n      struct flock l = {\n        .l_type = F_RDLCK,\n        .l_whence = SEEK_SET,\n        .l_start = 0,\n        .l_len = 0\n      };\n\n      if (fcntl (fd, F_SETLK, &l) < 0)\n        die_with_error (\"Unable to lock file %s\", lock->path);\n\n      /* Keep fd open to hang on to lock */\n      lock->fd = fd;\n    }\n\n  /* Optionally bind our lifecycle to that of the caller */\n  handle_die_with_parent ();\n\n  if (seccomp_prog != NULL &&\n      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, seccomp_prog) != 0)\n    die_with_error (\"prctl(PR_SET_SECCOMP)\");\n\n  while (TRUE)\n    {\n      pid_t child;\n      int status;\n\n      child = wait (&status);\n      if (child == initial_pid && event_fd != -1)\n        {\n          uint64_t val;\n          int res UNUSED;\n\n          initial_exit_status = propagate_exit_status (status);\n\n          val = initial_exit_status + 1;\n          res = write (event_fd, &val, 8);\n          /* Ignore res, if e.g. the parent died and closed event_fd\n             we don't want to error out here */\n        }\n\n      if (child == -1 && errno != EINTR)\n        {\n          if (errno != ECHILD)\n            die_with_error (\"init wait()\");\n          break;\n        }\n    }\n\n  /* Close FDs. */\n  for (lock = lock_files; lock != NULL; lock = lock->next)\n    {\n      if (lock->fd >= 0)\n        {\n          close (lock->fd);\n          lock->fd = -1;\n        }\n    }\n\n  return initial_exit_status;\n}",
        "target": 0
    },
    {
        "id": 3694,
        "func": "void OmniboxViewWin::Update(const WebContents* tab_for_state_restoring) {\n  const bool visibly_changed_permanent_text =\n      model_->UpdatePermanentText(toolbar_model_->GetText());\n\n  const ToolbarModel::SecurityLevel security_level =\n      toolbar_model_->GetSecurityLevel();\n  const bool changed_security_level = (security_level != security_level_);\n\n  if (!changed_security_level && !visibly_changed_permanent_text &&\n      !tab_for_state_restoring)\n    return;\n\n  security_level_ = security_level;\n\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  if (tab_for_state_restoring) {\n    RevertAll();\n\n    const AutocompleteEditState* state = GetStateAccessor()->GetProperty(\n        tab_for_state_restoring->GetPropertyBag());\n    if (state) {\n      model_->RestoreState(state->model_state);\n\n      SetSelectionRange(state->view_state.selection);\n      saved_selection_for_focus_change_ =\n          state->view_state.saved_selection_for_focus_change;\n    }\n  } else if (visibly_changed_permanent_text) {\n\n    CHARRANGE sel;\n    GetSelection(sel);\n    const bool was_reversed = (sel.cpMin > sel.cpMax);\n    const bool was_sel_all = (sel.cpMin != sel.cpMax) &&\n      IsSelectAllForRange(sel);\n\n    RevertAll();\n\n    if (was_sel_all)\n      SelectAll(was_reversed);\n  } else if (changed_security_level) {\n    EmphasizeURLComponents();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3695,
        "func": "GahpClient::gt4_gram_client_job_callback_register(const char * job_contact,\n\tconst char * callback_contact)\n{\n\tstatic const char* command = \"GT4_GRAM_JOB_CALLBACK_REGISTER\";\n\n\tif  (server->m_commands_supported->contains_anycase(command)==FALSE) {\n\t\treturn GAHPCLIENT_COMMAND_NOT_SUPPORTED;\n\t}\n\n\tif (!job_contact) job_contact=NULLSTRING;\n\tif (!callback_contact) callback_contact=NULLSTRING;\n\tstd::string reqline;\n\tchar *esc1 = strdup( escapeGahpString(job_contact) );\n\tchar *esc2 = strdup( escapeGahpString(callback_contact) );\n\tint x = sprintf(reqline,\"%s %s\",esc1,esc2);\n\tfree( esc1 );\n\tfree( esc2 );\n\tASSERT( x > 0 );\n\tconst char *buf = reqline.c_str();\n\n\tif ( !is_pending(command,buf) ) {\n\t\tif ( m_mode == results_only ) {\n\t\t\treturn GAHPCLIENT_COMMAND_NOT_SUBMITTED;\n\t\t}\n\t\tnow_pending(command,buf,normal_proxy);\n\t}\n\n\t\t\n\tGahp_Args* result = get_pending_result(command,buf);\n\tif ( result ) {\n\t\tif (result->argc != 3) {\n\t\t\tEXCEPT(\"Bad %s Result\",command);\n\t\t}\n\t\tint rc = atoi(result->argv[1]);\n\t\tif ( strcasecmp(result->argv[2], NULLSTRING) ) {\n\t\t\terror_string = result->argv[2];\n\t\t} else {\n\t\t\terror_string = \"\";\n\t\t}\n\t\tdelete result;\n\t\treturn rc;\n\t}\n\n\tif ( check_pending_timeout(command,buf) ) {\n\t\tsprintf( error_string, \"%s timed out\", command );\n\t\treturn GAHPCLIENT_COMMAND_TIMED_OUT;\n\t}\n\n\treturn GAHPCLIENT_COMMAND_PENDING;\n}\n",
        "target": 0
    },
    {
        "id": 3696,
        "func": "int UDPSocketWin::GetLocalAddress(IPEndPoint* address) const {\n  DCHECK(CalledOnValidThread());\n  DCHECK(address);\n  if (!is_connected())\n    return ERR_SOCKET_NOT_CONNECTED;\n\n  if (!local_address_.get()) {\n    SockaddrStorage storage;\n    if (getsockname(socket_, storage.addr, &storage.addr_len))\n      return MapSystemError(WSAGetLastError());\n    scoped_ptr<IPEndPoint> address(new IPEndPoint());\n    if (!address->FromSockAddr(storage.addr, storage.addr_len))\n      return ERR_ADDRESS_INVALID;\n    local_address_.reset(address.release());\n    net_log_.AddEvent(NetLog::TYPE_UDP_LOCAL_ADDRESS,\n                      CreateNetLogUDPConnectCallback(local_address_.get()));\n  }\n\n  *address = *local_address_;\n  return OK;\n}\n",
        "target": 0
    },
    {
        "id": 3697,
        "func": "static RtreeDValue cellOverlap(\n  Rtree *pRtree,\n  RtreeCell *p,\n  RtreeCell *aCell,\n  int nCell\n){\n  int ii;\n  RtreeDValue overlap = RTREE_ZERO;\n  for(ii=0; ii<nCell; ii++){\n    int jj;\n    RtreeDValue o = (RtreeDValue)1;\n    for(jj=0; jj<pRtree->nDim2; jj+=2){\n      RtreeDValue x1, x2;\n      x1 = MAX(DCOORD(p->aCoord[jj]), DCOORD(aCell[ii].aCoord[jj]));\n      x2 = MIN(DCOORD(p->aCoord[jj+1]), DCOORD(aCell[ii].aCoord[jj+1]));\n      if( x2<x1 ){\n        o = (RtreeDValue)0;\n        break;\n      }else{\n        o = o * (x2-x1);\n      }\n    }\n    overlap += o;\n  }\n  return overlap;\n}\n",
        "target": 0
    },
    {
        "id": 3698,
        "func": "_SSL_get_cipher_info (SSL * ssl)\n{\n\tconst SSL_CIPHER *c;\n\n\n\tc = SSL_get_current_cipher (ssl);\n\tsafe_strcpy (chiper_info.version, SSL_CIPHER_get_version (c),\n\t\t\t\tsizeof (chiper_info.version));\n\tsafe_strcpy (chiper_info.chiper, SSL_CIPHER_get_name (c),\n\t\t\t\tsizeof (chiper_info.chiper));\n\tSSL_CIPHER_get_bits (c, &chiper_info.chiper_bits);\n\n\treturn (&chiper_info);\n}",
        "target": 0
    },
    {
        "id": 3699,
        "func": "static int ax25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct full_sockaddr_ax25 *addr = (struct full_sockaddr_ax25 *)uaddr;\n\tax25_dev *ax25_dev = NULL;\n\tax25_uid_assoc *user;\n\tax25_address call;\n\tax25_cb *ax25;\n\tint err = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_ax25) &&\n\t    addr_len != sizeof(struct full_sockaddr_ax25))\n\t\t/* support for old structure may go away some time\n\t\t * ax25_bind(): uses old (6 digipeater) socket structure.\n\t\t */\n\t\tif ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||\n\t\t    (addr_len > sizeof(struct full_sockaddr_ax25)))\n\t\t\treturn -EINVAL;\n\n\tif (addr->fsa_ax25.sax25_family != AF_AX25)\n\t\treturn -EINVAL;\n\n\tuser = ax25_findbyuid(current_euid());\n\tif (user) {\n\t\tcall = user->call;\n\t\tax25_uid_put(user);\n\t} else {\n\t\tif (ax25_uid_policy && !capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tcall = addr->fsa_ax25.sax25_call;\n\t}\n\n\tlock_sock(sk);\n\n\tax25 = sk_to_ax25(sk);\n\tif (!sock_flag(sk, SOCK_ZAPPED)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tax25->source_addr = call;\n\n\t/*\n\t * User already set interface with SO_BINDTODEVICE\n\t */\n\tif (ax25->ax25_dev != NULL)\n\t\tgoto done;\n\n\tif (addr_len > sizeof(struct sockaddr_ax25) && addr->fsa_ax25.sax25_ndigis == 1) {\n\t\tif (ax25cmp(&addr->fsa_digipeater[0], &null_ax25_address) != 0 &&\n\t\t    (ax25_dev = ax25_addr_ax25dev(&addr->fsa_digipeater[0])) == NULL) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif ((ax25_dev = ax25_addr_ax25dev(&addr->fsa_ax25.sax25_call)) == NULL) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ax25_dev != NULL)\n\t\tax25_fillin_cb(ax25, ax25_dev);\n\ndone:\n\tax25_cb_add(ax25);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3700,
        "func": "bool StartupBrowserCreator::ActivatedProfile() {\n  return profile_launch_observer.Get().activated_profile();\n}\n",
        "target": 0
    },
    {
        "id": 3701,
        "func": "ModuleExport void UnregisterDDSImage(void)\n{\n  (void) UnregisterMagickInfo(\"DDS\");\n  (void) UnregisterMagickInfo(\"DXT1\");\n  (void) UnregisterMagickInfo(\"DXT5\");\n}\n",
        "target": 0
    },
    {
        "id": 3702,
        "func": "static int adev_set_master_volume(struct audio_hw_device *dev, float volume)\n{\n (void)dev;\n (void)volume;\n\n return -ENOSYS;\n}\n",
        "target": 0
    },
    {
        "id": 3703,
        "func": "ofputil_decode_group_features_reply(const struct ofp_header *oh,\n                                    struct ofputil_group_features *features)\n{\n    const struct ofp12_group_features_stats *ogf = ofpmsg_body(oh);\n    int i;\n\n    features->types = ntohl(ogf->types);\n    features->capabilities = ntohl(ogf->capabilities);\n    for (i = 0; i < OFPGT12_N_TYPES; i++) {\n        features->max_groups[i] = ntohl(ogf->max_groups[i]);\n        features->ofpacts[i] = ofpact_bitmap_from_openflow(\n            ogf->actions[i], oh->version);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 3704,
        "func": "void GLES2DecoderImpl::DoClear(GLbitfield mask) {\n  if (CheckBoundFramebuffersValid(\"glClear\")) {\n    UNSHIPPED_TRACE_EVENT_INSTANT2(\"test_gpu\", \"DoClear\", \"red\", clear_red_,\n                                   \"green\", clear_green_);\n    ApplyDirtyState();\n    glClear(mask);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3705,
        "func": "isoent_cmp_node(const struct archive_rb_node *n1,\n    const struct archive_rb_node *n2)\n{\n\tconst struct isoent *e1 = (const struct isoent *)n1;\n\tconst struct isoent *e2 = (const struct isoent *)n2;\n\n\treturn (strcmp(e1->file->basename.s, e2->file->basename.s));\n}\n",
        "target": 0
    },
    {
        "id": 3706,
        "func": "void WebLocalFrameImpl::SetCaretVisible(bool visible) {\n  GetFrame()->Selection().SetCaretVisible(visible);\n}\n",
        "target": 0
    },
    {
        "id": 3707,
        "func": " void VaapiVideoDecodeAccelerator::VaapiH264Accelerator::FillVAPicture(\n     VAPictureH264* va_pic,\n     scoped_refptr<H264Picture> pic) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n   VASurfaceID va_surface_id = VA_INVALID_SURFACE;\n \n   if (!pic->nonexisting) {\n    scoped_refptr<VaapiDecodeSurface> dec_surface =\n        H264PictureToVaapiDecodeSurface(pic);\n    va_surface_id = dec_surface->va_surface()->id();\n  }\n\n  va_pic->picture_id = va_surface_id;\n  va_pic->frame_idx = pic->frame_num;\n  va_pic->flags = 0;\n\n  switch (pic->field) {\n    case H264Picture::FIELD_NONE:\n      break;\n    case H264Picture::FIELD_TOP:\n      va_pic->flags |= VA_PICTURE_H264_TOP_FIELD;\n      break;\n    case H264Picture::FIELD_BOTTOM:\n      va_pic->flags |= VA_PICTURE_H264_BOTTOM_FIELD;\n      break;\n  }\n\n  if (pic->ref) {\n    va_pic->flags |= pic->long_term ? VA_PICTURE_H264_LONG_TERM_REFERENCE\n                                    : VA_PICTURE_H264_SHORT_TERM_REFERENCE;\n  }\n\n  va_pic->TopFieldOrderCnt = pic->top_field_order_cnt;\n  va_pic->BottomFieldOrderCnt = pic->bottom_field_order_cnt;\n}\n",
        "target": 0
    },
    {
        "id": 3708,
        "func": "MediaStreamImpl::~MediaStreamImpl() {\n  DCHECK(!peer_connection_handler_);\n  if (dependency_factory_.get())\n    dependency_factory_->ReleasePeerConnectionFactory();\n  if (network_manager_) {\n    if (chrome_worker_thread_.IsRunning()) {\n       chrome_worker_thread_.message_loop()->PostTask(FROM_HERE, base::Bind(\n           &MediaStreamImpl::DeleteIpcNetworkManager,\n           base::Unretained(this)));\n      // Stopping the thread will wait until all tasks have been\n      // processed before returning. We wait for the above task to finish before\n      // letting the destructor continue to avoid any potential race issues.\n      chrome_worker_thread_.Stop();\n     } else {\n       NOTREACHED() << \"Worker thread not running.\";\n     }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3709,
        "func": "void BrowserGpuChannelHostFactorySetApplicationVisible(bool is_visible) {\n  DCHECK_EQ(BrowserMainLoop::GetInstance()->gpu_channel_establish_factory(),\n            BrowserGpuChannelHostFactory::instance());\n  BrowserGpuChannelHostFactory::instance()->SetApplicationVisible(is_visible);\n}\n",
        "target": 0
    },
    {
        "id": 3710,
        "func": "static int unlazy_child(struct nameidata *nd, struct dentry *dentry, unsigned seq)\n{\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\tnd->flags &= ~LOOKUP_RCU;\n\tif (unlikely(!legitimize_links(nd)))\n\t\tgoto out2;\n\tif (unlikely(!legitimize_mnt(nd->path.mnt, nd->m_seq)))\n\t\tgoto out2;\n\tif (unlikely(!lockref_get_not_dead(&nd->path.dentry->d_lockref)))\n\t\tgoto out1;\n\n\t/*\n\t * We need to move both the parent and the dentry from the RCU domain\n\t * to be properly refcounted. And the sequence number in the dentry\n\t * validates *both* dentry counters, since we checked the sequence\n\t * number of the parent after we got the child sequence number. So we\n\t * know the parent must still be valid if the child sequence number is\n\t */\n\tif (unlikely(!lockref_get_not_dead(&dentry->d_lockref)))\n\t\tgoto out;\n\tif (unlikely(read_seqcount_retry(&dentry->d_seq, seq))) {\n\t\trcu_read_unlock();\n\t\tdput(dentry);\n\t\tgoto drop_root_mnt;\n\t}\n\t/*\n\t * Sequence counts matched. Now make sure that the root is\n\t * still valid and get it if required.\n\t */\n\tif (nd->root.mnt && !(nd->flags & LOOKUP_ROOT)) {\n\t\tif (unlikely(!legitimize_path(nd, &nd->root, nd->root_seq))) {\n\t\t\trcu_read_unlock();\n\t\t\tdput(dentry);\n\t\t\treturn -ECHILD;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn 0;\n\nout2:\n\tnd->path.mnt = NULL;\nout1:\n\tnd->path.dentry = NULL;\nout:\n\trcu_read_unlock();\ndrop_root_mnt:\n\tif (!(nd->flags & LOOKUP_ROOT))\n\t\tnd->root.mnt = NULL;\n\treturn -ECHILD;\n}",
        "target": 0
    },
    {
        "id": 3711,
        "func": "struct trace_entry *trace_find_next_entry(struct trace_iterator *iter,\n\t\t\t\t\t  int *ent_cpu, u64 *ent_ts)\n{\n\treturn __find_next_entry(iter, ent_cpu, NULL, ent_ts);\n}",
        "target": 0
    },
    {
        "id": 3712,
        "func": "const char* WebPage::interpretKeyEvent(const KeyboardEvent* evt)\n{\n    ASSERT(evt->type() == eventNames().keydownEvent || evt->type() == eventNames().keypressEvent);\n\n    static HashMap<int, const char*>* keyDownCommandsMap = 0;\n    static HashMap<int, const char*>* keyPressCommandsMap = 0;\n\n    if (!keyDownCommandsMap) {\n        keyDownCommandsMap = new HashMap<int, const char*>;\n        keyPressCommandsMap = new HashMap<int, const char*>;\n\n        for (size_t i = 0; i < WTF_ARRAY_LENGTH(keyDownEntries); ++i)\n            keyDownCommandsMap->set(keyDownEntries[i].modifiers << 16 | keyDownEntries[i].virtualKey, keyDownEntries[i].name);\n\n        for (size_t i = 0; i < WTF_ARRAY_LENGTH(keyPressEntries); ++i)\n            keyPressCommandsMap->set(keyPressEntries[i].modifiers << 16 | keyPressEntries[i].charCode, keyPressEntries[i].name);\n    }\n\n    unsigned modifiers = 0;\n    if (evt->shiftKey())\n        modifiers |= ShiftKey;\n    if (evt->altKey())\n        modifiers |= AltKey;\n    if (evt->ctrlKey())\n        modifiers |= CtrlKey;\n\n    if (evt->type() == eventNames().keydownEvent) {\n        int mapKey = modifiers << 16 | evt->keyCode();\n        return mapKey ? keyDownCommandsMap->get(mapKey) : 0;\n    }\n\n    int mapKey = modifiers << 16 | evt->charCode();\n    return mapKey ? keyPressCommandsMap->get(mapKey) : 0;\n}\n",
        "target": 0
    },
    {
        "id": 3713,
        "func": "AP_DECLARE(void) ap_finalize_request_protocol(request_rec *r)\n{\n    int status = ap_discard_request_body(r);\n\n    /* tell the filter chain there is no more content coming */\n    if (status) {\n        error_output_stream(r, status);\n    }\n    if (!r->eos_sent) {\n        end_output_stream(r);\n    }\n}\n",
        "target": 0
    },
    {
        "id": 3714,
        "func": " set_store_for_read(png_store *ps, png_infopp ppi, png_uint_32 id,\n   PNG_CONST char *name)\n {\n    /* Set the name for png_error */\n    safecat(ps->test, sizeof ps->test, 0, name);\n\n if (ps->pread != NULL)\n      png_error(ps->pread, \"read store already in use\");\n\n   store_read_reset(ps);\n\n /* Both the create APIs can return NULL if used in their default mode\n    * (because there is no other way of handling an error because the jmp_buf\n    * by default is stored in png_struct and that has not been allocated!)\n    * However, given that store_error works correctly in these circumstances\n    * we don't ever expect NULL in this program.\n    */\n#  ifdef PNG_USER_MEM_SUPPORTED\n if (!ps->speed)\n         ps->pread = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, ps,\n             store_error, store_warning, &ps->read_memory_pool, store_malloc,\n             store_free);\n\n else\n#  endif\n   ps->pread = png_create_read_struct(PNG_LIBPNG_VER_STRING, ps, store_error,\n      store_warning);\n\n if (ps->pread == NULL)\n {\n struct exception_context *the_exception_context = &ps->exception_context;\n\n      store_log(ps, NULL, \"png_create_read_struct returned NULL (unexpected)\",\n 1 /*error*/);\n\n Throw ps;\n }\n\n#  ifdef PNG_SET_OPTION_SUPPORTED\n {\n int opt;\n for (opt=0; opt<ps->noptions; ++opt)\n if (png_set_option(ps->pread, ps->options[opt].option,\n               ps->options[opt].setting) == PNG_OPTION_INVALID)\n                  png_error(ps->pread, \"png option invalid\");\n }\n#  endif\n\n   store_read_set(ps, id);\n\n if (ppi != NULL)\n *ppi = ps->piread = png_create_info_struct(ps->pread);\n\n return ps->pread;\n}\n",
        "target": 1
    },
    {
        "id": 3715,
        "func": "bool CSPSource::hostMatches(const KURL& url) const\n{\n    const String& host = url.host();\n    Document* document = m_policy->document();\n    bool match;\n\n    bool equalHosts = equalIgnoringCase(host, m_host);\n    if (m_hostWildcard == HasWildcard) {\n        match = host.endsWith(\".\" + m_host, TextCaseInsensitive);\n\n        if (document && equalHosts)\n            UseCounter::count(*document, UseCounter::CSPSourceWildcardWouldMatchExactHost);\n    } else {\n        match = equalHosts;\n    }\n\n    return match;\n}\n",
        "target": 0
    },
    {
        "id": 3716,
        "func": "static void overloadedMethodF1Method(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ExceptionState exceptionState(ExceptionState::ExecutionContext, \"overloadedMethodF\", \"TestObjectPython\", info.Holder(), info.GetIsolate());\n    if (UNLIKELY(info.Length() < 1)) {\n        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, longArg, toInt32(info[0], exceptionState), exceptionState);\n    imp->overloadedMethodF(longArg);\n}\n",
        "target": 0
    },
    {
        "id": 3717,
        "func": "    virtual void SetUp()\n    {\n        m_webViewImpl = toWebViewImpl(WebView::create(0));\n\n        WebSettings* settings = m_webViewImpl->settings();\n        settings->setImagesEnabled(true);\n        settings->setLoadsImagesAutomatically(true);\n        settings->setJavaScriptEnabled(true);\n\n        m_mainFrame = WebFrame::create(&m_webFrameClient);\n        m_webViewImpl->setMainFrame(m_mainFrame);\n    }\n",
        "target": 0
    },
    {
        "id": 3718,
        "func": "keepalived_alloc_dump(void)\n{\n\tkeepalived_alloc_log(false);\n}",
        "target": 0
    },
    {
        "id": 3719,
        "func": "bool ConfirmInfoBarDelegate::Cancel() {\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 3720,
        "func": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n\n\tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n\n\tif (flip) {\n\t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n\t\tminfo6.fport = inc->i_hdr.h_dport;\n\t}\n\n\trds_info_copy(iter, &minfo6, sizeof(minfo6));\n}",
        "target": 1
    },
    {
        "id": 3721,
        "func": "static int qeth_setadpparms_change_macaddr_cb(struct qeth_card *card,\n\t\tstruct qeth_reply *reply, unsigned long data)\n{\n\tstruct qeth_ipa_cmd *cmd;\n\n\tQETH_CARD_TEXT(card, 4, \"chgmaccb\");\n\n\tcmd = (struct qeth_ipa_cmd *) data;\n\tif (!card->options.layer2 ||\n\t    !(card->info.mac_bits & QETH_LAYER2_MAC_READ)) {\n\t\tmemcpy(card->dev->dev_addr,\n\t\t       &cmd->data.setadapterparms.data.change_addr.addr,\n\t\t       OSA_ADDR_LEN);\n\t\tcard->info.mac_bits |= QETH_LAYER2_MAC_READ;\n\t}\n\tqeth_default_setadapterparms_cb(card, reply, (unsigned long) cmd);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3722,
        "func": "handle_queue_stats_dump_cb(uint32_t queue_id,\n                           struct netdev_queue_stats *stats,\n                           void *cbdata_)\n{\n    struct queue_stats_cbdata *cbdata = cbdata_;\n\n    put_queue_stats(cbdata, queue_id, stats);\n}\n",
        "target": 0
    },
    {
        "id": 3723,
        "func": "point_sub(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *p1 = PG_GETARG_POINT_P(0);\n\tPoint\t   *p2 = PG_GETARG_POINT_P(1);\n\tPoint\t   *result;\n\n\tresult = (Point *) palloc(sizeof(Point));\n\n\tresult->x = (p1->x - p2->x);\n\tresult->y = (p1->y - p2->y);\n\n\tPG_RETURN_POINT_P(result);\n}",
        "target": 0
    },
    {
        "id": 3724,
        "func": "raptor_libxml_getParameterEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getParameterEntity(sax2->xc, name);\n}",
        "target": 0
    },
    {
        "id": 3725,
        "func": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "target": 1
    },
    {
        "id": 3726,
        "func": "   void Reset() {\n     error_nframes_ = 0;\n     droppable_nframes_ = 0;\n   }\n",
        "target": 1
    },
    {
        "id": 3727,
        "func": "void WebContentsImpl::LostCapture() {\n  if (delegate_)\n    delegate_->LostCapture();\n}\n",
        "target": 0
    },
    {
        "id": 3728,
        "func": "void RenderViewImpl::DidAutoResize(const blink::WebSize& newSize) {\n  GetWidget()->DidAutoResize(newSize);\n}\n",
        "target": 0
    },
    {
        "id": 3729,
        "func": "static void XMLObjAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_VOID(TestObject*, cppValue, V8TestObject::toNativeWithTypeCheck(info.GetIsolate(), jsValue));\n    imp->setXMLObjAttr(WTF::getPtr(cppValue));\n}\n",
        "target": 0
    },
    {
        "id": 3730,
        "func": "QQmlComponent* OxideQQuickWebView::contextMenu() const {\n  Q_D(const OxideQQuickWebView);\n\n  return d->contents_view_->contextMenu();\n}\n",
        "target": 0
    },
    {
        "id": 3731,
        "func": "void PrintWebViewHelper::OnPrintForPrintPreview(\n    const DictionaryValue& job_settings) {\n  DCHECK(is_preview_);\n  if (print_web_view_)\n    return;\n\n  if (!render_view()->webview())\n    return;\n  WebFrame* main_frame = render_view()->webview()->mainFrame();\n  if (!main_frame)\n    return;\n\n  WebDocument document = main_frame->document();\n  WebElement pdf_element = document.getElementById(\"pdf-viewer\");\n  if (pdf_element.isNull()) {\n    NOTREACHED();\n     return;\n   }\n \n  WebFrame* pdf_frame = pdf_element.document().frame();\n  scoped_ptr<PrepareFrameAndViewForPrint> prepare;\n  if (!InitPrintSettingsAndPrepareFrame(pdf_frame, &pdf_element, &prepare)) {\n    LOG(ERROR) << \"Failed to initialize print page settings\";\n    return;\n  }\n   if (!UpdatePrintSettings(job_settings, false)) {\n     LOG(ERROR) << \"UpdatePrintSettings failed\";\n     DidFinishPrinting(FAIL_PRINT);\n     return;\n   }\n \n   if (!RenderPagesForPrint(pdf_frame, &pdf_element, prepare.get())) {\n     LOG(ERROR) << \"RenderPagesForPrint failed\";\n    DidFinishPrinting(FAIL_PRINT);\n  }\n}\n",
        "target": 1
    },
    {
        "id": 3732,
        "func": "static CURLcode smtp_state_starttls_resp(struct connectdata *conn,\n                                         int smtpcode,\n                                         smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode != 220) {\n    if(data->set.use_ssl != CURLUSESSL_TRY) {\n      failf(data, \"STARTTLS denied, code %d\", smtpcode);\n      result = CURLE_USE_SSL_FAILED;\n    }\n    else\n      result = smtp_perform_authentication(conn);\n  }\n  else\n    result = smtp_perform_upgrade_tls(conn);\n\n  return result;\n}",
        "target": 0
    },
    {
        "id": 3733,
        "func": "void test_file_descriptor()\n{\n  YR_COMPILER* compiler = NULL;\n  YR_RULES* rules = NULL;\n  \n#if defined(_WIN32) || defined(__CYGWIN__)\n  HANDLE fd = CreateFile(\"tests/data/true.yar\", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);\n  if (fd == INVALID_HANDLE_VALUE)\n  {\n    fputs(\"CreateFile failed\", stderr);\n    exit(1);\n  }\n#else\n  int fd = open(\"tests/data/true.yar\", O_RDONLY);\n  if (fd < 0)\n  {\n    perror(\"open\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n  if (yr_compiler_create(&compiler) != ERROR_SUCCESS)\n  {\n    perror(\"yr_compiler_create\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (yr_compiler_add_fd(compiler, fd, NULL, NULL) != 0) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n  \n#if defined(_WIN32) || defined(__CYGWIN__)\n  CloseHandle(fd);\n#else\n  close(fd);\n#endif\n\n  if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS) {\n    perror(\"yr_compiler_add_fd\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (compiler)\n  {\n    yr_compiler_destroy(compiler);\n  }\n  if (rules)\n  {\n    yr_rules_destroy(rules);\n  }\n  \n  return;\n}",
        "target": 0
    },
    {
        "id": 3734,
        "func": "static int midi_setup_instrumentname(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_instrumentname;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n",
        "target": 0
    },
    {
        "id": 3735,
        "func": "void sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this structure just waiting around for us to actually\n\t * get destroyed?\n\t */\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_association_put(asoc);\n}",
        "target": 0
    },
    {
        "id": 3736,
        "func": "void TaskQueue::AsValueInto(base::trace_event::TracedValue* state) const {\n  base::AutoLock lock(lock_);\n  state->BeginDictionary();\n  if (name_)\n    state->SetString(\"name\", name_);\n  state->SetString(\"pump_policy\",\n                   TaskQueueManager::PumpPolicyToString(pump_policy_));\n  state->SetString(\"wakeup_policy\",\n                   TaskQueueManager::WakeupPolicyToString(wakeup_policy_));\n  state->BeginArray(\"incoming_queue\");\n  QueueAsValueInto(incoming_queue_, state);\n  state->EndArray();\n  state->BeginArray(\"work_queue\");\n  QueueAsValueInto(work_queue_, state);\n  state->EndArray();\n  state->BeginArray(\"delayed_task_queue\");\n  QueueAsValueInto(delayed_task_queue_, state);\n  state->EndArray();\n  state->EndDictionary();\n}\n",
        "target": 0
    },
    {
        "id": 3737,
        "func": "static int tls_process_cke_psk_preamble(SSL *s, PACKET *pkt, int *al)\n{\n#ifndef OPENSSL_NO_PSK\n    unsigned char psk[PSK_MAX_PSK_LEN];\n    size_t psklen;\n    PACKET psk_identity;\n\n    if (!PACKET_get_length_prefixed_2(pkt, &psk_identity)) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_LENGTH_MISMATCH);\n        return 0;\n    }\n    if (PACKET_remaining(&psk_identity) > PSK_MAX_IDENTITY_LEN) {\n        *al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_DATA_LENGTH_TOO_LONG);\n        return 0;\n    }\n    if (s->psk_server_callback == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, SSL_R_PSK_NO_SERVER_CB);\n        return 0;\n    }\n\n    if (!PACKET_strndup(&psk_identity, &s->session->psk_identity)) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    psklen = s->psk_server_callback(s, s->session->psk_identity,\n                                    psk, sizeof(psk));\n\n    if (psklen > PSK_MAX_PSK_LEN) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    } else if (psklen == 0) {\n        /*\n         * PSK related to the given identity not found\n         */\n        *al = SSL_AD_UNKNOWN_PSK_IDENTITY;\n        SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE,\n               SSL_R_PSK_IDENTITY_NOT_FOUND);\n        return 0;\n    }\n\n    OPENSSL_free(s->s3->tmp.psk);\n    s->s3->tmp.psk = OPENSSL_memdup(psk, psklen);\n    OPENSSL_cleanse(psk, psklen);\n\n    if (s->s3->tmp.psk == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    s->s3->tmp.psklen = psklen;\n\n    return 1;\n#else\n    /* Should never happen */\n    *al = SSL_AD_INTERNAL_ERROR;\n    SSLerr(SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE, ERR_R_INTERNAL_ERROR);\n    return 0;\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 3738,
        "func": "static void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n        /* hmm. we are done with the inode, and in the process of freeing\n\t * the state_owner. we keep this around to process errors\n\t */\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.open_flags == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN) {\n\t\t\t\trpc_restart_call(task);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n}",
        "target": 1
    },
    {
        "id": 3739,
        "func": " Win32StackFrameUnwinder::Win32StackFrameUnwinder()\n    : Win32StackFrameUnwinder(&win32_unwind_functions_) {\n }\n",
        "target": 1
    },
    {
        "id": 3740,
        "func": "int res_unpack(vorbis_info_residue *info,\n                vorbis_info *vi,oggpack_buffer *opb){\n int j,k;\n  codec_setup_info     *ci=(codec_setup_info *)vi->codec_setup;\n  memset(info,0,sizeof(*info));\n\n  info->type=oggpack_read(opb,16);\n\n   if(info->type>2 || info->type<0)goto errout;\n   info->begin=oggpack_read(opb,24);\n   info->end=oggpack_read(opb,24);\n  info->grouping=oggpack_read(opb,24)+1;              // \"partition size\" in spec\n  info->partitions=(char)(oggpack_read(opb,6)+1);     // \"classification\" in spec\n  info->groupbook=(unsigned char)oggpack_read(opb,8); // \"classbook\" in spec\n   if(info->groupbook>=ci->books)goto errout;\n \n   info->stagemasks=_ogg_malloc(info->partitions*sizeof(*info->stagemasks));\n  info->stagebooks=_ogg_malloc(info->partitions*8*sizeof(*info->stagebooks));\n\n for(j=0;j<info->partitions;j++){\n int cascade=oggpack_read(opb,3);\n if(oggpack_read(opb,1))\n      cascade|=(oggpack_read(opb,5)<<3);\n    info->stagemasks[j]=cascade;\n }\n\n for(j=0;j<info->partitions;j++){\n for(k=0;k<8;k++){\n if((info->stagemasks[j]>>k)&1){\n unsigned char book=(unsigned char)oggpack_read(opb,8);\n if(book>=ci->books)goto errout;\n        info->stagebooks[j*8+k]=book;\n if(k+1>info->stages)info->stages=k+1;\n }else\n        info->stagebooks[j*8+k]=0xff;\n }\n }\n\n \n   if(oggpack_eop(opb))goto errout;\n \n  // According to the Vorbis spec (paragraph 8.6.2 \"packet decode\"), residue\n  // begin and end should be limited to the maximum possible vector size in\n  // case they exceed it. However doing that makes the decoder crash further\n  // down, so we return an error instead.\n  int limit = (info->type == 2 ? vi->channels : 1) * ci->blocksizes[1] / 2;\n  if (info->begin > info->end ||\n          info->end > limit) {\n      goto errout;\n  }\n   return 0;\n  errout:\n   res_clear_info(info);\n return 1;\n}\n",
        "target": 0
    },
    {
        "id": 3741,
        "func": "bool HTMLInputElement::SetupDateTimeChooserParameters(\n    DateTimeChooserParameters& parameters) {\n  if (!GetDocument().View())\n    return false;\n\n  parameters.type = type();\n  parameters.minimum = Minimum();\n  parameters.maximum = Maximum();\n  parameters.required = IsRequired();\n  if (!RuntimeEnabledFeatures::LangAttributeAwareFormControlUIEnabled()) {\n    parameters.locale = DefaultLanguage();\n  } else {\n    AtomicString computed_locale = ComputeInheritedLanguage();\n    parameters.locale =\n        computed_locale.IsEmpty() ? DefaultLanguage() : computed_locale;\n  }\n\n  StepRange step_range = CreateStepRange(kRejectAny);\n  if (step_range.HasStep()) {\n    parameters.step = step_range.Step().ToDouble();\n    parameters.step_base = step_range.StepBase().ToDouble();\n  } else {\n    parameters.step = 1.0;\n    parameters.step_base = 0;\n  }\n\n  parameters.anchor_rect_in_screen =\n      GetDocument().View()->ContentsToScreen(PixelSnappedBoundingBox());\n  parameters.double_value = input_type_->ValueAsDouble();\n  parameters.is_anchor_element_rtl =\n      input_type_view_->ComputedTextDirection() == TextDirection::kRtl;\n  if (HTMLDataListElement* data_list = DataList()) {\n    HTMLDataListOptionsCollection* options = data_list->options();\n    for (unsigned i = 0; HTMLOptionElement* option = options->Item(i); ++i) {\n      if (option->value().IsEmpty() || option->IsDisabledFormControl() ||\n          !IsValidValue(option->value()))\n        continue;\n      DateTimeSuggestion suggestion;\n      suggestion.value =\n          input_type_->ParseToNumber(option->value(), Decimal::Nan())\n              .ToDouble();\n      if (std::isnan(suggestion.value))\n        continue;\n      suggestion.localized_value = LocalizeValue(option->value());\n      suggestion.label =\n          option->value() == option->label() ? String() : option->label();\n      parameters.suggestions.push_back(suggestion);\n    }\n  }\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 3742,
        "func": "static void atrtr_device_down(struct net_device *dev)\n{\n\tstruct atalk_route **r = &atalk_routes;\n\tstruct atalk_route *tmp;\n\n\twrite_lock_bh(&atalk_routes_lock);\n\twhile ((tmp = *r) != NULL) {\n\t\tif (tmp->dev == dev) {\n\t\t\t*r = tmp->next;\n\t\t\tdev_put(dev);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tr = &tmp->next;\n\t}\n\twrite_unlock_bh(&atalk_routes_lock);\n\n\tif (atrtr_default.dev == dev)\n\t\tatrtr_set_default(NULL);\n}",
        "target": 0
    },
    {
        "id": 3743,
        "func": "static void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}\n",
        "target": 0
    },
    {
        "id": 3744,
        "func": "void jsvAddName(JsVar *parent, JsVar *namedChild) {\n  namedChild = jsvRef(namedChild); // ref here VERY important as adding to structure!\n  assert(jsvIsName(namedChild));\n\n  if (jsvIsArray(parent) && jsvIsInt(namedChild)) {\n    JsVarInt index = namedChild->varData.integer;\n    if (index >= jsvGetArrayLength(parent)) {\n      jsvSetArrayLength(parent, index + 1, false);\n    }\n  }\n\n  if (jsvGetLastChild(parent)) { // we have children already\n    JsVar *insertAfter = jsvLock(jsvGetLastChild(parent));\n    if (jsvIsArray(parent)) {\n      while (insertAfter && jsvCompareInteger(namedChild, insertAfter)<0) {\n        JsVarRef prev = jsvGetPrevSibling(insertAfter);\n        jsvUnLock(insertAfter);\n        insertAfter = prev ? jsvLock(prev) : 0;\n      }\n    }\n\n    if (insertAfter) {\n      if (jsvGetNextSibling(insertAfter)) {\n        JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));\n        jsvSetPrevSibling(insertBefore, jsvGetRef(namedChild));\n        jsvSetNextSibling(namedChild, jsvGetRef(insertBefore));\n        jsvUnLock(insertBefore);\n      } else {\n        jsvSetLastChild(parent, jsvGetRef(namedChild));\n      }\n      jsvSetNextSibling(insertAfter, jsvGetRef(namedChild));\n      jsvSetPrevSibling(namedChild, jsvGetRef(insertAfter));\n      jsvUnLock(insertAfter);\n    } else { // Insert right at the beginning of the array\n      JsVar *firstChild = jsvLock(jsvGetFirstChild(parent));\n      jsvSetPrevSibling(firstChild, jsvGetRef(namedChild));\n      jsvUnLock(firstChild);\n\n      jsvSetNextSibling(namedChild, jsvGetFirstChild(parent));\n      jsvSetFirstChild(parent, jsvGetRef(namedChild));\n    }\n  } else { // we have no children - just add it\n    JsVarRef r = jsvGetRef(namedChild);\n    jsvSetFirstChild(parent, r);\n    jsvSetLastChild(parent, r);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3745,
        "func": "    TestHistoryWebFrameClient()\n    {\n        m_replacesCurrentHistoryItem = false;\n        m_frame = 0;\n    }\n",
        "target": 0
    },
    {
        "id": 3746,
        "func": "static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,\n        Packet *p, Flow * const pflow)\n{\n    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);\n    /* cleanup pkt specific part of the patternmatcher */\n    PacketPatternCleanup(det_ctx);\n \n     if (pflow != NULL) {\n         /* update inspected tracker for raw reassembly */\n        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {\n             StreamReassembleRawUpdateProgress(pflow->protoctx, p,\n                     det_ctx->raw_stream_progress);\n \n            DetectEngineCleanHCBDBuffers(det_ctx);\n        }\n    }\n    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);\n    SCReturn;\n}\n",
        "target": 1
    },
    {
        "id": 3747,
        "func": "main(int argc,\n     char **argv)\n{\n   int i, gn;\n   int test = 0;\n   char *action = NULL, *cmd;\n   char *output = NULL;\n#ifdef HAVE_EEZE_MOUNT\n   Eina_Bool mnt = EINA_FALSE;\n   const char *act;\n#endif\n   gid_t gid, gl[65536], egid;\n   int pid = 0;\n\n   for (i = 1; i < argc; i++)\n    const char *act;\n #endif\n    gid_t gid, gl[65536], egid;\n   int pid = 0;\n \n    for (i = 1; i < argc; i++)\n      {\n               \"This is an internal tool for Enlightenment.\\n\"\n               \"do not use it.\\n\"\n               );\n             exit(0);\n          }\n     }\n",
        "target": 1
    },
    {
        "id": 3748,
        "func": "static void commit_list_insert_by_date_cached(struct commit *p, struct commit_list **head,\n\t\t    struct commit_list *cached_base, struct commit_list **cache)\n{\n\tstruct commit_list *new_entry;\n\n\tif (cached_base && p->date < cached_base->item->date)\n\t\tnew_entry = commit_list_insert_by_date(p, &cached_base->next);\n\telse\n\t\tnew_entry = commit_list_insert_by_date(p, head);\n\n\tif (cache && (!*cache || p->date < (*cache)->item->date))\n\t\t*cache = new_entry;\n}",
        "target": 0
    },
    {
        "id": 3749,
        "func": "static int unix_stream_splice_actor(struct sk_buff *skb,\n\t\t\t\t    int skip, int chunk,\n\t\t\t\t    struct unix_stream_read_state *state)\n{\n\treturn skb_splice_bits(skb, state->socket->sk,\n\t\t\t       UNIXCB(skb).consumed + skip,\n\t\t\t       state->pipe, chunk, state->splice_flags,\n\t\t\t       skb_unix_socket_splice);\n}",
        "target": 0
    },
    {
        "id": 3750,
        "func": "bool WebGraphicsContext3DCommandBufferImpl::makeContextCurrent() {\n  if (!MaybeInitializeGL(NULL))\n    return false;\n  gles2::SetGLContext(gl_);\n  if (command_buffer_->GetLastError() != gpu::error::kNoError)\n    return false;\n\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 3751,
        "func": "void PluginServiceImpl::GetAllowedPluginForOpenChannelToPlugin(\n    int render_process_id,\n    int render_view_id,\n    const GURL& url,\n    const GURL& page_url,\n    const std::string& mime_type,\n    PluginProcessHost::Client* client,\n    ResourceContext* resource_context) {\n  webkit::WebPluginInfo info;\n  bool allow_wildcard = true;\n  bool found = GetPluginInfo(\n      render_process_id, render_view_id, resource_context,\n      url, page_url, mime_type, allow_wildcard,\n      NULL, &info, NULL);\n  FilePath plugin_path;\n  if (found)\n    plugin_path = info.path;\n\n  BrowserThread::PostTask(\n      BrowserThread::IO, FROM_HERE,\n      base::Bind(&PluginServiceImpl::FinishOpenChannelToPlugin,\n                 base::Unretained(this),\n                 render_process_id,\n                 plugin_path,\n                 client));\n}\n",
        "target": 0
    },
    {
        "id": 3752,
        "func": "void ossl_statem_set_sctp_read_sock(SSL *s, int read_sock)\n{\n    s->statem.in_sctp_read_sock = read_sock;\n}\n",
        "target": 0
    },
    {
        "id": 3753,
        "func": " bool OSExchangeDataProviderAuraX11::GetURLAndTitle(\n     GURL* url,\n     base::string16* title) const {\n   std::vector< ::Atom> url_atoms = ui::GetURLAtomsFrom(&atom_cache_);\n  std::vector< ::Atom> requested_types;\n  ui::GetAtomIntersection(url_atoms, GetTargets(), &requested_types);\n\n  ui::SelectionData data(format_map_.GetFirstOf(requested_types));\n  if (data.IsValid()) {\n\n    if (data.GetType() == atom_cache_.GetAtom(kMimeTypeMozillaURL)) {\n      base::string16 unparsed;\n      data.AssignTo(&unparsed);\n\n      std::vector<base::string16> tokens;\n      size_t num_tokens = Tokenize(unparsed, base::ASCIIToUTF16(\"\\n\"), &tokens);\n      if (num_tokens > 0) {\n        if (num_tokens > 1)\n          *title = tokens[1];\n        else\n          *title = base::string16();\n\n        *url = GURL(tokens[0]);\n        return true;\n      }\n    } else if (data.GetType() == atom_cache_.GetAtom(\n                   Clipboard::kMimeTypeURIList)) {\n      std::vector<std::string> tokens = ui::ParseURIList(data);\n       for (std::vector<std::string>::const_iterator it = tokens.begin();\n            it != tokens.end(); ++it) {\n         GURL test_url(*it);\n        if (!test_url.SchemeIsFile()) {\n           *url = test_url;\n           *title = base::string16();\n           return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n",
        "target": 1
    },
    {
        "id": 3754,
        "func": "g_utf8_get_char (const gchar * p)\n{\n  int i, mask = 0, len;\n  gunichar result;\n  unsigned char c = (unsigned char) *p;\n\n  UTF8_COMPUTE (c, mask, len);\n  if (len == -1)\n    return (gunichar) - 1;\n  UTF8_GET (result, p, i, mask, len);\n\n  return result;\n}\n",
        "target": 0
    },
    {
        "id": 3755,
        "func": "static int efx_ioctl(struct net_device *net_dev, struct ifreq *ifr, int cmd)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\n\tEFX_ASSERT_RESET_SERIALISED(efx);\n\n\t/* Convert phy_id from older PRTAD/DEVAD format */\n\tif ((cmd == SIOCGMIIREG || cmd == SIOCSMIIREG) &&\n\t    (data->phy_id & 0xfc00) == 0x0400)\n\t\tdata->phy_id ^= MDIO_PHY_ID_C45 | 0x0400;\n\n\treturn mdio_mii_ioctl(&efx->mdio, data, cmd);\n}\n",
        "target": 0
    },
    {
        "id": 3756,
        "func": "time2t(const int hour, const int min, const int sec, const fsec_t fsec)\n{\n\treturn (((((hour * MINS_PER_HOUR) + min) * SECS_PER_MINUTE) + sec) * USECS_PER_SEC) + fsec;\n}\t/* time2t() */",
        "target": 0
    },
    {
        "id": 3757,
        "func": "mm_answer_audit_command(int socket, Buffer *m)\n{\n\tu_int len;\n\tchar *cmd;\n\n\tdebug3(\"%s entering\", __func__);\n\tcmd = buffer_get_string(m, &len);\n\t/* sanity check command, if so how? */\n\taudit_run_command(cmd);\n\tfree(cmd);\n\treturn (0);\n}",
        "target": 0
    },
    {
        "id": 3758,
        "func": "static void genl_unlock_all(void)\n{\n\tgenl_unlock();\n\tup_write(&cb_lock);\n}",
        "target": 0
    },
    {
        "id": 3759,
        "func": "do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n               IOBUF a, size_t *ret_len )\n {\n     int zrc;\n    int rc = 0;\n    int leave = 0;\n     size_t n;\n     int nread, count;\n     int refill = !zs->avail_in;\n    if( DBG_FILTER )\n\tlog_debug(\"begin inflate: avail_in=%u, avail_out=%u, inbuf=%u\\n\",\n\t\t(unsigned)zs->avail_in, (unsigned)zs->avail_out,\n\t\t(unsigned)zfx->inbufsize );\n    do {\n\tif( zs->avail_in < zfx->inbufsize && refill ) {\n\t    n = zs->avail_in;\n\t    if( !n )\n            zs->next_in = BYTEF_CAST (zfx->inbuf);\n\t    count = zfx->inbufsize - n;\n\t    nread = iobuf_read( a, zfx->inbuf + n, count );\n            nread = iobuf_read( a, zfx->inbuf + n, count );\n            if( nread == -1 ) nread = 0;\n            n += nread;\n           /* Algo 1 has no zlib header which requires us to to give\n            * inflate an extra dummy byte to read. To be on the safe\n            * side we allow for up to 4 ff bytes.  */\n           if( nread < count && zfx->algo == 1 && zfx->algo1hack < 4) {\n               *(zfx->inbuf + n) = 0xFF;\n               zfx->algo1hack++;\n                n++;\n                leave = 1;\n            }\n            zs->avail_in = n;\n        }\n\t    log_debug(\"enter inflate: avail_in=%u, avail_out=%u\\n\",\n\t\t    (unsigned)zs->avail_in, (unsigned)zs->avail_out);\n\tzrc = inflate ( zs, Z_SYNC_FLUSH );\n\tif( DBG_FILTER )\n\t    log_debug(\"leave inflate: avail_in=%u, avail_out=%u, zrc=%d\\n\",\n\t\t   (unsigned)zs->avail_in, (unsigned)zs->avail_out, zrc);\n\tif( zrc == Z_STREAM_END )\n\t    rc = -1; /* eof */\n\telse if( zrc != Z_OK && zrc != Z_BUF_ERROR ) {\n\t    if( zs->msg )\n\t\tlog_fatal(\"zlib inflate problem: %s\\n\", zs->msg );\n\t    else\n\t\tlog_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n            else\n                log_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n        }\n    } while (zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR\n             && !leave);\n \n     *ret_len = zfx->outbufsize - zs->avail_out;\n     if( DBG_FILTER )\n}\n",
        "target": 0
    },
    {
        "id": 3760,
        "func": "xmlXPathIsNaN(double val) {\n    return(trio_isnan(val));\n}\n",
        "target": 0
    },
    {
        "id": 3761,
        "func": "bool JSTestMediaQueryListListenerPrototype::getOwnPropertyDescriptor(JSObject* object, ExecState* exec, const Identifier& propertyName, PropertyDescriptor& descriptor)\n{\n    JSTestMediaQueryListListenerPrototype* thisObject = jsCast<JSTestMediaQueryListListenerPrototype*>(object);\n    return getStaticFunctionDescriptor<JSObject>(exec, &JSTestMediaQueryListListenerPrototypeTable, thisObject, propertyName, descriptor);\n}\n",
        "target": 0
    },
    {
        "id": 3762,
        "func": "void RenderFrameHostImpl::OnFrameDidCallFocus() {\n  delegate_->DidCallFocus();\n}\n",
        "target": 0
    },
    {
        "id": 3763,
        "func": "RootInlineBox* LayoutBlockFlow::createRootInlineBox()\n{\n    return new RootInlineBox(*this);\n}\n",
        "target": 0
    },
    {
        "id": 3764,
        "func": "int ping_common_sendmsg(int family, struct msghdr *msg, size_t len,\n\t\t\tvoid *user_icmph, size_t icmph_len) {\n\tu8 type, code;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\t/* Mirror BSD error message compatibility */\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t *\tFetch the ICMP header provided by the userland.\n\t *\tiovec is modified! The ICMP header is consumed.\n\t */\n\tif (memcpy_from_msg(user_icmph, msg, icmph_len))\n\t\treturn -EFAULT;\n\n\tif (family == AF_INET) {\n\t\ttype = ((struct icmphdr *) user_icmph)->type;\n\t\tcode = ((struct icmphdr *) user_icmph)->code;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\ttype = ((struct icmp6hdr *) user_icmph)->icmp6_type;\n\t\tcode = ((struct icmp6hdr *) user_icmph)->icmp6_code;\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (!ping_supported(family, type, code))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3765,
        "func": "bool JSTestInterfaceConstructor::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n{\n    return getStaticPropertySlot<JSTestInterfaceConstructor, JSDOMWrapper>(exec, &JSTestInterfaceConstructorTable, jsCast<JSTestInterfaceConstructor*>(cell), propertyName, slot);\n}\n",
        "target": 0
    },
    {
        "id": 3766,
        "func": "bool OobeUI::IsJSReady(const base::Closure& display_is_ready_callback) {\n  if (!ready_)\n    ready_callbacks_.push_back(display_is_ready_callback);\n  return ready_;\n}\n",
        "target": 0
    },
    {
        "id": 3767,
        "func": "static void _6502_anal_esil_ccall(RAnalOp *op, ut8 data0)\n{\n\tchar *flag;\n\tswitch(data0) {\n\tcase 0x10: // bpl $ffff\n\t\tflag = \"N,!\";\n\t\tbreak;\n\tcase 0x30: // bmi $ffff\n\t\tflag = \"N\";\n\t\tbreak;\n\tcase 0x50: // bvc $ffff\n\t\tflag = \"V,!\";\n\t\tbreak;\n\tcase 0x70: // bvs $ffff\n\t\tflag = \"V\";\n\t\tbreak;\n\tcase 0x90: // bcc $ffff\n\t\tflag = \"C,!\";\n\t\tbreak;\n\tcase 0xb0: // bcs $ffff\n\t\tflag = \"C\";\n\t\tbreak;\n\tcase 0xd0: // bne $ffff\n\t\tflag = \"Z,!\";\n\t\tbreak;\n\tcase 0xf0: // beq $ffff\n\t\tflag = \"Z\";\n\t\tbreak;\n\tdefault:\n\t\t// FIXME: should not happen\n\t\tflag = \"unk\";\n\t\tbreak;\n\t}\n\tr_strbuf_setf (&op->esil, \"%s,?{,0x%04x,pc,=,}\", flag, (op->jump & 0xffff));\n}",
        "target": 0
    },
    {
        "id": 3768,
        "func": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n\n    l_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                               (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            /* We refer to data - 1 since below we incremented it */\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        /* We reserve the initial byte as a fake byte to a non-FF value */\n        /* and increment the data pointer, so that opj_mqc_init_enc() */\n        /* can do bp = data - 1, and opj_mqc_byteout() can safely dereference */\n        /* it. */\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; /*why +1 ?*/\n    }\n    return OPJ_TRUE;\n}",
        "target": 1
    },
    {
        "id": 3769,
        "func": "void VaapiVideoDecodeAccelerator::QueueInputBuffer(\n    const BitstreamBuffer& bitstream_buffer) {\n  VLOGF(4) << \"Queueing new input buffer id: \" << bitstream_buffer.id()\n           << \" size: \" << (int)bitstream_buffer.size();\n  DCHECK(task_runner_->BelongsToCurrentThread());\n  TRACE_EVENT1(\"Video Decoder\", \"QueueInputBuffer\", \"input_id\",\n               bitstream_buffer.id());\n\n  base::AutoLock auto_lock(lock_);\n  if (bitstream_buffer.size() == 0) {\n    DCHECK(!base::SharedMemory::IsHandleValid(bitstream_buffer.handle()));\n    auto flush_buffer = base::MakeUnique<InputBuffer>();\n    DCHECK(flush_buffer->IsFlushRequest());\n    input_buffers_.push(std::move(flush_buffer));\n  } else {\n    std::unique_ptr<SharedMemoryRegion> shm(\n        new SharedMemoryRegion(bitstream_buffer, true));\n    RETURN_AND_NOTIFY_ON_FAILURE(shm->Map(), \"Failed to map input buffer\",\n                                 UNREADABLE_INPUT, );\n\n    auto input_buffer = base::MakeUnique<InputBuffer>(\n        bitstream_buffer.id(), std::move(shm),\n        BindToCurrentLoop(\n            base::Bind(&Client::NotifyEndOfBitstreamBuffer, client_)));\n    input_buffers_.push(std::move(input_buffer));\n\n    TRACE_COUNTER1(\"Video Decoder\", \"Input buffers\", input_buffers_.size());\n  }\n\n  input_ready_.Signal();\n\n  switch (state_) {\n    case kIdle:\n      state_ = kDecoding;\n      decoder_thread_task_runner_->PostTask(\n          FROM_HERE, base::Bind(&VaapiVideoDecodeAccelerator::DecodeTask,\n                                base::Unretained(this)));\n      break;\n\n    case kDecoding:\n      break;\n\n    case kResetting:\n      break;\n\n    default:\n      VLOGF(1) << \"Decode/Flush request from client in invalid state: \"\n               << state_;\n      NotifyError(PLATFORM_FAILURE);\n      break;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3770,
        "func": " void AudioOutputDevice::Stop() {\n   {\n     base::AutoLock auto_lock(audio_thread_lock_);\n    audio_thread_->Stop(MessageLoop::current());\n    audio_thread_.reset();\n   }\n \n   message_loop()->PostTask(FROM_HERE,\n      base::Bind(&AudioOutputDevice::ShutDownOnIOThread, this));\n}\n",
        "target": 1
    },
    {
        "id": 3771,
        "func": "CueTimeline& HTMLMediaElement::cueTimeline() {\n  if (!m_cueTimeline)\n    m_cueTimeline = new CueTimeline(*this);\n  return *m_cueTimeline;\n}\n",
        "target": 0
    },
    {
        "id": 3772,
        "func": "bool ShouldEnableServerPushCancelation(\n    const VariationParameters& quic_trial_params) {\n  return base::LowerCaseEqualsASCII(\n      GetVariationParam(quic_trial_params, \"enable_server_push_cancellation\"),\n      \"true\");\n}\n",
        "target": 0
    },
    {
        "id": 3773,
        "func": "static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\n{\n\tswitch(version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds out;\n\n\t\tmemset(&out, 0, sizeof(out));\n\t\tipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\n\t\tout.shm_segsz\t= in->shm_segsz;\n\t\tout.shm_atime\t= in->shm_atime;\n\t\tout.shm_dtime\t= in->shm_dtime;\n\t\tout.shm_ctime\t= in->shm_ctime;\n\t\tout.shm_cpid\t= in->shm_cpid;\n\t\tout.shm_lpid\t= in->shm_lpid;\n\t\tout.shm_nattch\t= in->shm_nattch;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
        "target": 0
    },
    {
        "id": 3774,
        "func": "void tpm_gen_interrupt(struct tpm_chip *chip)\n{\n\tstruct\ttpm_cmd_t tpm_cmd;\n\tssize_t rc;\n\n\ttpm_cmd.header.in = tpm_getcap_header;\n\ttpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;\n\ttpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);\n\ttpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;\n\n\trc = transmit_cmd(chip, &tpm_cmd, TPM_INTERNAL_RESULT_SIZE,\n\t\t\t\"attempting to determine the timeouts\");\n}",
        "target": 0
    },
    {
        "id": 3775,
        "func": "void DesktopWindowTreeHostX11::SetFullscreen(bool fullscreen) {\n  if (is_fullscreen_ == fullscreen)\n    return;\n  is_fullscreen_ = fullscreen;\n  if (is_fullscreen_)\n    delayed_resize_task_.Cancel();\n\n  bool unmaximize_and_remaximize = !fullscreen && IsMaximized() &&\n                                   ui::GuessWindowManager() == ui::WM_METACITY;\n\n  if (unmaximize_and_remaximize)\n    Restore();\n  SetWMSpecState(fullscreen, gfx::GetAtom(\"_NET_WM_STATE_FULLSCREEN\"),\n                 x11::None);\n  if (unmaximize_and_remaximize)\n    Maximize();\n\n  if (fullscreen) {\n    restored_bounds_in_pixels_ = bounds_in_pixels_;\n    const display::Display display =\n        display::Screen::GetScreen()->GetDisplayNearestWindow(window());\n    bounds_in_pixels_ = ToPixelRect(display.bounds());\n  } else {\n    bounds_in_pixels_ = restored_bounds_in_pixels_;\n  }\n  OnHostMovedInPixels(bounds_in_pixels_.origin());\n  OnHostResizedInPixels(bounds_in_pixels_.size());\n\n  if (ui::HasWMSpecProperty(window_properties_,\n                            gfx::GetAtom(\"_NET_WM_STATE_FULLSCREEN\")) ==\n      fullscreen) {\n    Relayout();\n    ResetWindowRegion();\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3776,
        "func": "IntRect InlineFlowBox::roundedFrameRect() const\n{\n    int snappedX = lroundf(x());\n    int snappedY = lroundf(y());\n    \n    int snappedMaxX = lroundf(x() + width());\n    int snappedMaxY = lroundf(y() + height());\n    \n    return IntRect(snappedX, snappedY, snappedMaxX - snappedX, snappedMaxY - snappedY);\n}\n",
        "target": 0
    },
    {
        "id": 3777,
        "func": "String AXNodeObject::textFromDescendants(AXObjectSet& visited,\n                                         bool recursive) const {\n  if (!canHaveChildren() && recursive)\n    return String();\n\n  StringBuilder accumulatedText;\n  AXObject* previous = nullptr;\n\n  AXObjectVector children;\n\n  HeapVector<Member<AXObject>> ownedChildren;\n  computeAriaOwnsChildren(ownedChildren);\n  for (AXObject* obj = rawFirstChild(); obj; obj = obj->rawNextSibling()) {\n    if (!axObjectCache().isAriaOwned(obj))\n      children.push_back(obj);\n  }\n  for (const auto& ownedChild : ownedChildren)\n    children.push_back(ownedChild);\n\n  for (AXObject* child : children) {\n    if (equalIgnoringCase(child->getAttribute(aria_hiddenAttr), \"true\"))\n       continue;\n \n    if (previous && accumulatedText.length() &&\n        !isHTMLSpace(accumulatedText[accumulatedText.length() - 1])) {\n      if (!isInSameNonInlineBlockFlow(child->getLayoutObject(),\n                                      previous->getLayoutObject()))\n        accumulatedText.append(' ');\n    }\n\n    String result;\n    if (child->isPresentational())\n      result = child->textFromDescendants(visited, true);\n    else\n      result = recursiveTextAlternative(*child, false, visited);\n    accumulatedText.append(result);\n    previous = child;\n  }\n\n  return accumulatedText.toString();\n}\n",
        "target": 1
    },
    {
        "id": 3778,
        "func": "on_tooltip_text_unset(void *user_data, Evas_Object *obj, void *event_info)\n{\n    Browser_Window *window = (Browser_Window *)user_data;\n\n    elm_object_tooltip_unset(window->webview);\n}\n",
        "target": 0
    },
    {
        "id": 3779,
        "func": "Icon* HTMLInputElement::icon() const\n{\n    return m_inputType->icon();\n}\n",
        "target": 0
    },
    {
        "id": 3780,
        "func": "void WebContentsViewAura::ResetOverscrollTransform() {\n  if (!web_contents_->GetRenderWidgetHostView())\n    return;\n  aura::Window* target = GetWindowToAnimateForOverscroll();\n  if (!target)\n    return;\n  {\n    ui::ScopedLayerAnimationSettings settings(target->layer()->GetAnimator());\n    settings.SetPreemptionStrategy(\n        ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);\n    settings.SetTweenType(gfx::Tween::EASE_OUT);\n    settings.AddObserver(this);\n    target->SetTransform(gfx::Transform());\n  }\n  {\n    ui::ScopedLayerAnimationSettings settings(target->layer()->GetAnimator());\n    settings.SetPreemptionStrategy(\n        ui::LayerAnimator::IMMEDIATELY_ANIMATE_TO_NEW_TARGET);\n    settings.SetTweenType(gfx::Tween::EASE_OUT);\n    UpdateOverscrollWindowBrightness(0.f);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3781,
        "func": "static int ovl_create_upper(struct dentry *dentry, struct inode *inode,\n\t\t\t    struct kstat *stat, const char *link,\n\t\t\t    struct dentry *hardlink)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry;\n\tint err;\n\n\tinode_lock_nested(udir, I_MUTEX_PARENT);\n\tnewdentry = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t\t   dentry->d_name.len);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out_unlock;\n\terr = ovl_create_real(udir, newdentry, stat, link, hardlink, false);\n\tif (err)\n\t\tgoto out_dput;\n\n\tovl_dentry_version_inc(dentry->d_parent);\n\tovl_dentry_update(dentry, newdentry);\n\tovl_copyattr(newdentry->d_inode, inode);\n\td_instantiate(dentry, inode);\n\tnewdentry = NULL;\nout_dput:\n\tdput(newdentry);\nout_unlock:\n\tinode_unlock(udir);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3782,
        "func": "void Browser::OpenCurrentURL() {\n  UserMetrics::RecordAction(UserMetricsAction(\"LoadURL\"), profile_);\n  LocationBar* location_bar = window_->GetLocationBar();\n  if (!location_bar)\n    return;\n\n  WindowOpenDisposition open_disposition =\n      location_bar->GetWindowOpenDisposition();\n  if (OpenInstant(open_disposition))\n    return;\n\n  GURL url(WideToUTF8(location_bar->GetInputString()));\n\n  if (open_disposition == CURRENT_TAB && TabFinder::IsEnabled()) {\n    Browser* existing_browser = NULL;\n    TabContents* existing_tab = TabFinder::GetInstance()->FindTab(\n        this, url, &existing_browser);\n    if (existing_tab) {\n      existing_browser->ActivateContents(existing_tab);\n      return;\n    }\n  }\n\n  browser::NavigateParams params(this, url, location_bar->GetPageTransition());\n  params.disposition = open_disposition;\n  params.tabstrip_add_types =\n      TabStripModel::ADD_FORCE_INDEX | TabStripModel::ADD_INHERIT_OPENER;\n  browser::Navigate(&params);\n\n  DCHECK(profile_->GetExtensionService());\n  if (profile_->GetExtensionService()->IsInstalledApp(url)) {\n    UMA_HISTOGRAM_ENUMERATION(extension_misc::kAppLaunchHistogram,\n                              extension_misc::APP_LAUNCH_OMNIBOX_LOCATION,\n                              extension_misc::APP_LAUNCH_BUCKET_BOUNDARY);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3783,
        "func": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  /* 22.2.3 */\n\tvmcs_writel(HOST_CR4, read_cr4());  /* 22.2.3, 22.2.5 */\n\tvmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * __vmx_load_host_state(), in case userspace uses the null selectors\n\t * too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   /* 22.2.4 */\n\tvmx->host_idt_base = dt.address;\n\n\tvmcs_writel(HOST_RIP, vmx_return); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}",
        "target": 1
    },
    {
        "id": 3784,
        "func": "int FLTogrConvertGeometry(OGRGeometryH hGeometry, shapeObj *psShape,\n                          OGRwkbGeometryType nType)\n{\n  return msOGRGeometryToShape(hGeometry, psShape, nType);\n}",
        "target": 0
    },
    {
        "id": 3785,
        "func": "lookup_bytestring(netdissect_options *ndo, register const u_char *bs,\n\t\t  const unsigned int nlen)\n{\n\tstruct enamemem *tp;\n\tregister u_int i, j, k;\n\n\tif (nlen >= 6) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = (bs[4] << 8) | bs[5];\n\t} else if (nlen >= 4) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = 0;\n\t} else\n\t\ti = j = k = 0;\n\n\ttp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k &&\n\t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)\n\t\t\treturn tp;\n\t\telse\n\t\t\ttp = tp->e_nxt;\n\n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n\n\ttp->e_bs = (u_char *) calloc(1, nlen + 1);\n\tif (tp->e_bs == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\n\tmemcpy(tp->e_bs, bs, nlen);\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\n\treturn tp;\n}",
        "target": 1
    },
    {
        "id": 3786,
        "func": "static RtreeDValue cellArea(Rtree *pRtree, RtreeCell *p){\n  RtreeDValue area = (RtreeDValue)1;\n  assert( pRtree->nDim>=1 && pRtree->nDim<=5 );\n#ifndef SQLITE_RTREE_INT_ONLY\n  if( pRtree->eCoordType==RTREE_COORD_REAL32 ){\n    switch( pRtree->nDim ){\n      case 5:  area  = p->aCoord[9].f - p->aCoord[8].f;\n      case 4:  area *= p->aCoord[7].f - p->aCoord[6].f;\n      case 3:  area *= p->aCoord[5].f - p->aCoord[4].f;\n      case 2:  area *= p->aCoord[3].f - p->aCoord[2].f;\n      default: area *= p->aCoord[1].f - p->aCoord[0].f;\n    }\n  }else\n#endif\n  {\n    switch( pRtree->nDim ){\n      case 5:  area  = (i64)p->aCoord[9].i - (i64)p->aCoord[8].i;\n      case 4:  area *= (i64)p->aCoord[7].i - (i64)p->aCoord[6].i;\n      case 3:  area *= (i64)p->aCoord[5].i - (i64)p->aCoord[4].i;\n      case 2:  area *= (i64)p->aCoord[3].i - (i64)p->aCoord[2].i;\n      default: area *= (i64)p->aCoord[1].i - (i64)p->aCoord[0].i;\n    }\n  }\n  return area;\n}\n",
        "target": 0
    },
    {
        "id": 3787,
        "func": "int Track::Info::CopyStr(char* Info::*str, Info& dst_) const\n{\n    if (str == static_cast<char* Info::*>(NULL))\n        return -1;\n    char*& dst = dst_.*str;\n    if (dst)  //should be NULL already\n        return -1;\n    const char* const src = this->*str;\n    if (src == NULL)\n        return 0;\n    const size_t len = strlen(src);\n    dst = new (std::nothrow) char[len+1];\n    if (dst == NULL)\n        return -1;\n    strcpy(dst, src);\n     return 0;\n }\n",
        "target": 1
    },
    {
        "id": 3788,
        "func": "static inline void next_request(blk_status_t err)\n{\n\tunsigned long saved_flags;\n\n\tspin_lock_irqsave(&pf_spin_lock, saved_flags);\n\tpf_end_request(err);\n\tpf_busy = 0;\n\tpf_request();\n\tspin_unlock_irqrestore(&pf_spin_lock, saved_flags);\n}",
        "target": 0
    },
    {
        "id": 3789,
        "func": "my_object_async_throw_error (MyObject *obj, DBusGMethodInvocation *context)\n{\n  IncrementData *data = g_new0(IncrementData, 1);\n  data->context = context;\n  g_idle_add ((GSourceFunc)do_async_error,  data);\n}\n",
        "target": 1
    },
    {
        "id": 3790,
        "func": "bool SyncerProtoUtil::PostAndProcessHeaders(ServerConnectionManager* scm,\n                                            sessions::SyncSession* session,\n                                            const ClientToServerMessage& msg,\n                                            ClientToServerResponse* response) {\n\n  ServerConnectionManager::PostBufferParams params;\n  msg.SerializeToString(&params.buffer_in);\n\n  ScopedServerStatusWatcher server_status_watcher(scm, &params.response);\n  if (!scm->PostBufferWithCachedAuth(&params, &server_status_watcher)) {\n    LOG(WARNING) << \"Error posting from syncer:\" << params.response;\n    return false;\n  }\n\n  std::string new_token = params.response.update_client_auth_header;\n  if (!new_token.empty()) {\n    SyncEngineEvent event(SyncEngineEvent::UPDATED_TOKEN);\n    event.updated_token = new_token;\n    session->context()->NotifyListeners(event);\n  }\n\n  if (response->ParseFromString(params.buffer_out)) {\n    switch (response->error_code()) {\n      case ClientToServerResponse::ACCESS_DENIED:\n      case ClientToServerResponse::AUTH_INVALID:\n      case ClientToServerResponse::USER_NOT_ACTIVATED:\n        params.response.server_status = HttpResponse::SYNC_AUTH_ERROR;\n        return false;\n      default:\n        return true;\n    }\n  }\n\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 3791,
        "func": "SPL_METHOD(RecursiveDirectoryIterator, getChildren)\n{\n\tzval *zpath, *zflags;\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tspl_filesystem_object *subdir;\n \tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n \tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n \n \tMAKE_STD_ZVAL(zflags);\n\tMAKE_STD_ZVAL(zpath);\n\tZVAL_LONG(zflags, intern->flags);\n\tZVAL_STRINGL(zpath, intern->file_name, intern->file_name_len, 1);\n\tspl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, zpath, zflags TSRMLS_CC);\n\tzval_ptr_dtor(&zpath);\n\tzval_ptr_dtor(&zflags);\n\n\tsubdir = (spl_filesystem_object*)zend_object_store_get_object(return_value TSRMLS_CC);\n\tif (subdir) {\n\t\tif (intern->u.dir.sub_path && intern->u.dir.sub_path[0]) {\n\t\t\tsubdir->u.dir.sub_path_len = spprintf(&subdir->u.dir.sub_path, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\t} else {\n\t\t\tsubdir->u.dir.sub_path_len = strlen(intern->u.dir.entry.d_name);\n\t\t\tsubdir->u.dir.sub_path = estrndup(intern->u.dir.entry.d_name, subdir->u.dir.sub_path_len);\n\t\t}\n\t\tsubdir->info_class = intern->info_class;\n\t\tsubdir->file_class = intern->file_class;\n\t\tsubdir->oth = intern->oth;\n\t}\n}\n",
        "target": 1
    },
    {
        "id": 3792,
        "func": "static int hci_uart_flush(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu  = hci_get_drvdata(hdev);\n\tstruct tty_struct *tty = hu->tty;\n\n\tBT_DBG(\"hdev %p tty %p\", hdev, tty);\n\n\tif (hu->tx_skb) {\n\t\tkfree_skb(hu->tx_skb); hu->tx_skb = NULL;\n\t}\n\n\t/* Flush any pending characters in the driver and discipline. */\n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\thu->proto->flush(hu);\n\n\tpercpu_up_read(&hu->proto_lock);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3793,
        "func": "rpl_dio_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dio *dio = (const struct nd_rpl_dio *)bp;\n        const char *dagid_str;\n\n        ND_TCHECK(*dio);\n        dagid_str = ip6addr_string (ndo, dio->rpl_dagid);\n\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]\",\n                  dagid_str,\n                  dio->rpl_dtsn,\n                  dio->rpl_instanceid,\n                  EXTRACT_16BITS(&dio->rpl_dagrank),\n                  RPL_DIO_GROUNDED(dio->rpl_mopprf) ? \"grounded,\":\"\",\n                  tok2str(rpl_mop_values, \"mop%u\", RPL_DIO_MOP(dio->rpl_mopprf)),\n                  RPL_DIO_PRF(dio->rpl_mopprf)));\n\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)&dio[1];\n                rpl_dio_printopt(ndo, opt, length);\n         }\n \treturn;\n trunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n \treturn;\n }\n",
        "target": 1
    },
    {
        "id": 3794,
        "func": "void server_connect_ref(SERVER_CONNECT_REC *conn)\n{\n        conn->refcount++;\n}",
        "target": 0
    },
    {
        "id": 3795,
        "func": "LayoutUnit RenderBox::computeContentAndScrollbarLogicalHeightUsing(const Length& height, LayoutUnit intrinsicContentHeight) const\n{\n    if (height.isIntrinsic()) {\n        if (intrinsicContentHeight == -1)\n            return -1; // Intrinsic height isn't available.\n        return computeIntrinsicLogicalContentHeightUsing(height, intrinsicContentHeight, borderAndPaddingLogicalHeight());\n    }\n    if (height.isFixed())\n        return height.value();\n    if (height.isPercent())\n        return computePercentageLogicalHeight(height);\n    return -1;\n}\n",
        "target": 0
    },
    {
        "id": 3796,
        "func": "static int sctp_wait_for_accept(struct sock *sk, long timeo)\n{\n\tstruct sctp_endpoint *ep;\n\tint err = 0;\n\tDEFINE_WAIT(wait);\n\n\tep = sctp_sk(sk)->ep;\n\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(sk->sk_sleep, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\n\t\tif (list_empty(&ep->asocs)) {\n\t\t\tsctp_release_sock(sk);\n\t\t\ttimeo = schedule_timeout(timeo);\n\t\t\tsctp_lock_sock(sk);\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (!sctp_sstate(sk, LISTENING))\n\t\t\tbreak;\n\n\t\terr = 0;\n\t\tif (!list_empty(&ep->asocs))\n\t\t\tbreak;\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t}\n\n\tfinish_wait(sk->sk_sleep, &wait);\n\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3797,
        "func": "static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,\n\t\t\t\t\t  u32 *mask)\n{\n\tstruct crypto_attr_type *algt;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn;\n\tif ((algt->type & CRYPTO_ALG_INTERNAL))\n\t\t*type |= CRYPTO_ALG_INTERNAL;\n\tif ((algt->mask & CRYPTO_ALG_INTERNAL))\n\t\t*mask |= CRYPTO_ALG_INTERNAL;\n}",
        "target": 1
    },
    {
        "id": 3798,
        "func": "void LocalFrameClientImpl::DidContainInsecureFormAction() {\n  if (web_frame_->Client())\n    web_frame_->Client()->DidContainInsecureFormAction();\n}\n",
        "target": 0
    },
    {
        "id": 3799,
        "func": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n     if (!err) {\n         err = offset;\n     }\n    put_fid(pdu, oldfidp);\n out:\n     put_fid(pdu, dfidp);\n out_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "target": 0
    },
    {
        "id": 3800,
        "func": "buf_remove_from_front(buf_t *buf, size_t n)\n{\n  tor_assert(buf->datalen >= n);\n  while (n) {\n    tor_assert(buf->head);\n    if (buf->head->datalen > n) {\n      buf->head->datalen -= n;\n      buf->head->data += n;\n      buf->datalen -= n;\n      return;\n    } else {\n      chunk_t *victim = buf->head;\n      n -= victim->datalen;\n      buf->datalen -= victim->datalen;\n      buf->head = victim->next;\n      if (buf->tail == victim)\n        buf->tail = NULL;\n      chunk_free_unchecked(victim);\n    }\n  }\n  check();\n}",
        "target": 0
    },
    {
        "id": 3801,
        "func": "gpu::CommandBuffer::State CommandBufferProxyImpl::WaitForTokenInRange(\n    int32_t start,\n    int32_t end) {\n  CheckLock();\n  base::AutoLock lock(last_state_lock_);\n  TRACE_EVENT2(\"gpu\", \"CommandBufferProxyImpl::WaitForToken\", \"start\", start,\n               \"end\", end);\n  if (last_state_.error != gpu::error::kNoError) {\n    if (gpu_control_client_)\n      gpu_control_client_->OnGpuControlLostContextMaybeReentrant();\n    return last_state_;\n  }\n  TryUpdateState();\n  if (!InRange(start, end, last_state_.token) &&\n      last_state_.error == gpu::error::kNoError) {\n    gpu::CommandBuffer::State state;\n    if (Send(new GpuCommandBufferMsg_WaitForTokenInRange(route_id_, start, end,\n                                                         &state))) {\n      SetStateFromMessageReply(state);\n    }\n  }\n  if (!InRange(start, end, last_state_.token) &&\n      last_state_.error == gpu::error::kNoError) {\n    LOG(ERROR) << \"GPU state invalid after WaitForTokenInRange.\";\n    OnGpuSyncReplyError();\n  }\n  return last_state_;\n}\n",
        "target": 0
    },
    {
        "id": 3802,
        "func": " swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \tuint32* wp = (uint32*) cp0;\n \ttmsize_t wc = cc / 4;\n \n         TIFFSwabArrayOfLong(wp, wc);\n\thorAcc32(tif, cp0, cc);\n }\n",
        "target": 1
    },
    {
        "id": 3803,
        "func": "remove_all_entry_guards(void)\n{\n  remove_all_entry_guards_for_guard_selection(get_guard_selection_info());\n}",
        "target": 0
    },
    {
        "id": 3804,
        "func": "static unsigned int ib_ucm_poll(struct file *filp,\n\t\t\t\tstruct poll_table_struct *wait)\n{\n\tstruct ib_ucm_file *file = filp->private_data;\n\tunsigned int mask = 0;\n\n\tpoll_wait(filp, &file->poll_wait, wait);\n\n\tif (!list_empty(&file->events))\n\t\tmask = POLLIN | POLLRDNORM;\n\n\treturn mask;\n}",
        "target": 0
    },
    {
        "id": 3805,
        "func": "pushTable(struct table *tbl, struct table *tbl1)\n{\n    int col;\n    int row;\n\n    col = tbl->col;\n    row = tbl->row;\n\n    if (tbl->ntable >= tbl->tables_size) {\n\tstruct table_in *tmp;\n\ttbl->tables_size += MAX_TABLE_N;\n\ttmp = New_N(struct table_in, tbl->tables_size);\n\tif (tbl->tables)\n\t    bcopy(tbl->tables, tmp, tbl->ntable * sizeof(struct table_in));\n\ttbl->tables = tmp;\n    }\n\n    tbl->tables[tbl->ntable].ptr = tbl1;\n    tbl->tables[tbl->ntable].col = col;\n    tbl->tables[tbl->ntable].row = row;\n    tbl->tables[tbl->ntable].indent = tbl->indent;\n    tbl->tables[tbl->ntable].buf = newTextLineList();\n    check_row(tbl, row);\n    if (col + 1 <= tbl->maxcol && tbl->tabattr[row][col + 1] & HTT_X)\n\ttbl->tables[tbl->ntable].cell = tbl->cell.icell;\n    else\n\ttbl->tables[tbl->ntable].cell = -1;\n    tbl->ntable++;\n}",
        "target": 0
    },
    {
        "id": 3806,
        "func": "static int smaps_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t   struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tsmaps_pmd_entry(pmd, addr, walk);\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\t/*\n\t * The mmap_sem held all the way back in m_start() is what\n\t * keeps khugepaged out of here and from collapsing things\n\t * in here.\n\t */\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tsmaps_pte_entry(pte, addr, walk);\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3807,
        "func": "\nstatic bool nl80211_valid_cipher_suite(u32 cipher)\n{\n\treturn cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\tcipher == WLAN_CIPHER_SUITE_WEP104 ||\n\t\tcipher == WLAN_CIPHER_SUITE_TKIP ||\n\t\tcipher == WLAN_CIPHER_SUITE_CCMP ||\n\t\tcipher == WLAN_CIPHER_SUITE_AES_CMAC;",
        "target": 0
    },
    {
        "id": 3808,
        "func": "static int f_midi_do_transmit(struct f_midi *midi, struct usb_ep *ep)\n{\n\tstruct usb_request *req = NULL;\n\tunsigned int len, i;\n\tbool active = false;\n\tint err;\n\n\t/*\n\t * We peek the request in order to reuse it if it fails to enqueue on\n\t * its endpoint\n\t */\n\tlen = kfifo_peek(&midi->in_req_fifo, &req);\n\tif (len != 1) {\n\t\tERROR(midi, \"%s: Couldn't get usb request\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If buffer overrun, then we ignore this transmission.\n\t * IMPORTANT: This will cause the user-space rawmidi device to block\n\t * until a) usb requests have been completed or b) snd_rawmidi_write()\n\t * times out.\n\t */\n\tif (req->length > 0)\n\t\treturn 0;\n\n\tfor (i = midi->in_last_port; i < midi->in_ports; ++i) {\n\t\tstruct gmidi_in_port *port = midi->in_ports_array + i;\n\t\tstruct snd_rawmidi_substream *substream = port->substream;\n\n\t\tif (!port->active || !substream)\n\t\t\tcontinue;\n\n\t\twhile (req->length + 3 < midi->buflen) {\n\t\t\tuint8_t b;\n\n\t\t\tif (snd_rawmidi_transmit(substream, &b, 1) != 1) {\n\t\t\t\tport->active = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf_midi_transmit_byte(req, port, b);\n\t\t}\n\n\t\tactive = !!port->active;\n\t\tif (active)\n\t\t\tbreak;\n\t}\n\tmidi->in_last_port = active ? i : 0;\n\n\tif (req->length <= 0)\n\t\tgoto done;\n\n\terr = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tERROR(midi, \"%s failed to queue req: %d\\n\",\n\t\t      midi->in_ep->name, err);\n\t\treq->length = 0; /* Re-use request next time. */\n\t} else {\n\t\t/* Upon success, put request at the back of the queue. */\n\t\tkfifo_skip(&midi->in_req_fifo);\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\ndone:\n\treturn active;\n}",
        "target": 0
    },
    {
        "id": 3809,
        "func": "static void update_event_times(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tu64 run_end;\n\n\tif (event->state < PERF_EVENT_STATE_INACTIVE ||\n\t    event->group_leader->state < PERF_EVENT_STATE_INACTIVE)\n\t\treturn;\n\t/*\n\t * in cgroup mode, time_enabled represents\n\t * the time the event was enabled AND active\n\t * tasks were in the monitored cgroup. This is\n\t * independent of the activity of the context as\n\t * there may be a mix of cgroup and non-cgroup events.\n\t *\n\t * That is why we treat cgroup events differently\n\t * here.\n\t */\n\tif (is_cgroup_event(event))\n\t\trun_end = perf_cgroup_event_time(event);\n\telse if (ctx->is_active)\n\t\trun_end = ctx->time;\n\telse\n\t\trun_end = event->tstamp_stopped;\n\n\tevent->total_time_enabled = run_end - event->tstamp_enabled;\n\n\tif (event->state == PERF_EVENT_STATE_INACTIVE)\n\t\trun_end = event->tstamp_stopped;\n\telse\n\t\trun_end = perf_event_time(event);\n\n\tevent->total_time_running = run_end - event->tstamp_running;\n\n}",
        "target": 0
    },
    {
        "id": 3810,
        "func": "void InputMethodIBus::OnInputLocaleChanged() {\n}\n",
        "target": 1
    },
    {
        "id": 3811,
        "func": "DictionaryValue* CreateCookieStoreValue(Profile* profile,\n                                        ListValue* tab_ids) {\n  DCHECK(profile);\n  DCHECK(tab_ids);\n  DictionaryValue* result = new DictionaryValue();\n  result->SetString(keys::kIdKey, GetStoreIdFromProfile(profile));\n  result->Set(keys::kTabIdsKey, tab_ids);\n  return result;\n}\n",
        "target": 0
    },
    {
        "id": 3812,
        "func": "static void spl_ptr_llist_copy(spl_ptr_llist *from, spl_ptr_llist *to) /* {{{ */\n{\n\tspl_ptr_llist_element *current = from->head, *next;\n\n\twhile (current) {\n\t\tnext = current->next;\n\n\t\t/*??? FIXME\n\t\tif (ctor) {\n\t\t\tctor(current);\n\t\t}\n\t\t*/\n\n\t\tspl_ptr_llist_push(to, &current->data);\n\t\tcurrent = next;\n\t}\n\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 3813,
        "func": "GF_Err stsh_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_StshEntry *ent;\n\tGF_ShadowSyncBox *ptr = (GF_ShadowSyncBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, gf_list_count(ptr->entries));\n\ti=0;\n\twhile ((ent = (GF_StshEntry *)gf_list_enum(ptr->entries, &i))) {\n\t\tgf_bs_write_u32(bs, ent->shadowedSampleNumber);\n\t\tgf_bs_write_u32(bs, ent->syncSampleNumber);\n\t}\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 3814,
        "func": "static inline int l2cap_check_security(struct sock *sk)\n{\n\tstruct l2cap_conn *conn = l2cap_pi(sk)->conn;\n\t__u8 auth_type;\n\n\tif (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)\n\t\t\tauth_type = HCI_AT_NO_BONDING_MITM;\n\t\telse\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\n\t\tif (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)\n\t\t\tl2cap_pi(sk)->sec_level = BT_SECURITY_SDP;\n\t} else {\n\t\tswitch (l2cap_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\t\tauth_type = HCI_AT_GENERAL_BONDING_MITM;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\tauth_type = HCI_AT_GENERAL_BONDING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tauth_type = HCI_AT_NO_BONDING;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn hci_conn_security(conn->hcon, l2cap_pi(sk)->sec_level,\n\t\t\t\t\t\t\t\tauth_type);\n}",
        "target": 0
    },
    {
        "id": 3815,
        "func": "BOOLEAN AnalyzeIP6DestinationExtension(\n    PVOID destHdr,\n    ULONG dataLength,\n    IPV6_ADDRESS **homeAddr)\n{\n    while(dataLength != 0)\n    {\n        PIP6_EXT_HDR_OPTION optHdr = (PIP6_EXT_HDR_OPTION) destHdr;\n        ULONG optionLen;\n\n        switch(optHdr->Type)\n        {\n        case IP6_EXT_HDR_OPTION_HOME_ADDR:\n            if(dataLength < sizeof(IP6_EXT_HDR_OPTION))\n                return FALSE;\n\n            optionLen = optHdr->Length + sizeof(IP6_EXT_HDR_OPTION);\n            if(optHdr->Length != sizeof(IPV6_ADDRESS))\n                return FALSE;\n\n            *homeAddr = (IPV6_ADDRESS*) RtlOffsetToPointer(optHdr, sizeof(IP6_EXT_HDR_OPTION));\n            break;\n\n        case IP6_EXT_HDR_OPTION_PAD1:\n            optionLen = RTL_SIZEOF_THROUGH_FIELD(IP6_EXT_HDR_OPTION, Type);\n            break;\n\n        default:\n            if(dataLength < sizeof(IP6_EXT_HDR_OPTION))\n                return FALSE;\n\n            optionLen = optHdr->Length + sizeof(IP6_EXT_HDR_OPTION);\n            break;\n        }\n\n        destHdr = RtlOffsetToPointer(destHdr, optionLen);\n        if(dataLength < optionLen)\n            return FALSE;\n\n        dataLength -= optionLen;\n    }\n\n    return TRUE;\n}",
        "target": 0
    },
    {
        "id": 3816,
        "func": "ofproto_class_register(const struct ofproto_class *new_class)\n{\n    size_t i;\n\n    for (i = 0; i < n_ofproto_classes; i++) {\n        if (ofproto_classes[i] == new_class) {\n            return EEXIST;\n        }\n    }\n\n    if (n_ofproto_classes >= allocated_ofproto_classes) {\n        ofproto_classes = x2nrealloc(ofproto_classes,\n                                     &allocated_ofproto_classes,\n                                     sizeof *ofproto_classes);\n    }\n    ofproto_classes[n_ofproto_classes++] = new_class;\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 3817,
        "func": "void RenderProcessHostImpl::CreateSharedRendererHistogramAllocator() {\n  if (!base::GlobalHistogramAllocator::Get()) {\n    if (is_initialized_) {\n      HistogramController::GetInstance()->SetHistogramMemory<RenderProcessHost>(\n          this, mojo::ScopedSharedBufferHandle());\n    }\n    return;\n  }\n\n  base::ProcessHandle destination = GetHandle();\n  if (destination == base::kNullProcessHandle)\n    return;\n\n  if (!metrics_allocator_) {\n    std::unique_ptr<base::SharedMemory> shm(new base::SharedMemory());\n    if (!shm->CreateAndMapAnonymous(2 << 20))  // 2 MiB\n      return;\n    metrics_allocator_.reset(new base::SharedPersistentMemoryAllocator(\n        std::move(shm), GetID(), \"RendererMetrics\", /*readonly=*/false));\n  }\n\n   HistogramController::GetInstance()->SetHistogramMemory<RenderProcessHost>(\n       this, mojo::WrapSharedMemoryHandle(\n                 metrics_allocator_->shared_memory()->handle().Duplicate(),\n                metrics_allocator_->shared_memory()->mapped_size(), false));\n }\n",
        "target": 1
    },
    {
        "id": 3818,
        "func": "static int aesni_cbc_hmac_sha256_init_key(EVP_CIPHER_CTX *ctx,\n                                          const unsigned char *inkey,\n                                          const unsigned char *iv, int enc)\n{\n    EVP_AES_HMAC_SHA256 *key = data(ctx);\n    int ret;\n\n    if (enc)\n        memset(&key->ks, 0, sizeof(key->ks.rd_key)),\n            ret = aesni_set_encrypt_key(inkey, ctx->key_len * 8, &key->ks);\n    else\n        ret = aesni_set_decrypt_key(inkey, ctx->key_len * 8, &key->ks);\n\n    SHA256_Init(&key->head);    /* handy when benchmarking */\n    key->tail = key->head;\n    key->md = key->head;\n\n    key->payload_length = NO_PAYLOAD_LENGTH;\n\n    return ret < 0 ? 0 : 1;\n}\n",
        "target": 0
    },
    {
        "id": 3819,
        "func": "void update_free(rdpUpdate* update)\n{\n\tif (update != NULL)\n\t{\n\t\tOFFSCREEN_DELETE_LIST* deleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\n\t\tif (deleteList)\n\t\t\tfree(deleteList->indices);\n\n\t\tfree(update->pointer);\n\n\t\tif (update->primary)\n\t\t{\n\t\t\tfree(update->primary->polyline.points);\n\t\t\tfree(update->primary->polygon_sc.points);\n\t\t\tfree(update->primary->fast_glyph.glyphData.aj);\n\t\t\tfree(update->primary);\n\t\t}\n\n\t\tfree(update->secondary);\n\t\tfree(update->altsec);\n\n\t\tif (update->window)\n\t\t{\n\t\t\tfree(update->window->monitored_desktop.windowIds);\n\t\t\tupdate_free_window_state(&update->window->window_state);\n\t\t\tupdate_free_window_icon_info(update->window->window_icon.iconInfo);\n\t\t\tfree(update->window);\n\t\t}\n\n\t\tMessageQueue_Free(update->queue);\n\t\tfree(update);\n\t}\n}",
        "target": 0
    },
    {
        "id": 3820,
        "func": "void Com_InitZoneMemory( void ) {\n\tcvar_t\t*cv;\n\n\n\tcv = Cvar_Get( \"com_zoneMegs\", DEF_COMZONEMEGS_S, CVAR_LATCH | CVAR_ARCHIVE );\n\n\tif ( cv->integer < DEF_COMZONEMEGS ) {\n\t\ts_zoneTotal = 1024 * 1024 * DEF_COMZONEMEGS;\n\t} else {\n\t\ts_zoneTotal = cv->integer * 1024 * 1024;\n\t}\n\n\tmainzone = calloc( s_zoneTotal, 1 );\n\tif ( !mainzone ) {\n\t\tCom_Error( ERR_FATAL, \"Zone data failed to allocate %i megs\", s_zoneTotal / (1024*1024) );\n\t}\n\tZ_ClearZone( mainzone, s_zoneTotal );\n\n}\n",
        "target": 0
    },
    {
        "id": 3821,
        "func": "SYSCALL_DEFINE4(msgsnd, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz,\n\t\tint, msgflg)\n{\n\tlong mtype;\n\n\tif (get_user(mtype, &msgp->mtype))\n\t\treturn -EFAULT;\n\treturn do_msgsnd(msqid, mtype, msgp->mtext, msgsz, msgflg);\n}",
        "target": 0
    },
    {
        "id": 3822,
        "func": "static int mem_cgroup_oom_unlock(struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *iter;\n\n\tfor_each_mem_cgroup_tree(iter, memcg)\n\t\titer->oom_lock = false;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3823,
        "func": "upnp_event_process_notify(struct upnp_event_notify * obj)\n{\n\tint err;\n\tsocklen_t len;\n\tswitch(obj->state) {\n\tcase EConnecting:\n\t\t/* now connected or failed to connect */\n\t\tlen = sizeof(err);\n\t\tif(getsockopt(obj->s, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: getsockopt: %m\", \"upnp_event_process_notify\");\n\t\t\tobj->state = EError;\n\t\t\tbreak;\n\t\t}\n\t\tif(err != 0) {\n\t\t\terrno = err;\n\t\t\tsyslog(LOG_WARNING, \"%s: connect(%s%s): %m\",\n\t\t\t       \"upnp_event_process_notify\",\n\t\t\t       obj->addrstr, obj->portstr);\n\t\t\tobj->state = EError;\n\t\t\tbreak;\n\t\t}\n\t\tupnp_event_prepare(obj);\n\t\tif(obj->state == ESending)\n\t\t\tupnp_event_send(obj);\n\t\tbreak;\n\tcase ESending:\n\t\tupnp_event_send(obj);\n\t\tbreak;\n\tcase EWaitingForResponse:\n\t\tupnp_event_recv(obj);\n\t\tbreak;\n\tcase EFinished:\n\t\tclose(obj->s);\n\t\tobj->s = -1;\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_ERR, \"%s: unknown state\", \"upnp_event_process_notify\");\n\t}\n}",
        "target": 0
    },
    {
        "id": 3824,
        "func": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\n\tval = 0;\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif (val > SG_MAX_QUEUE)\n\t\t\tbreak;\n\t\trinfo[val].req_state = srp->done + 1;\n\t\trinfo[val].problem =\n\t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}",
        "target": 0
    },
    {
        "id": 3825,
        "func": "kdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code)\n        return code;\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}",
        "target": 1
    },
    {
        "id": 3826,
        "func": "static int ecc_check_pubkey_order(ecc_key* key, ecc_point* pubkey, mp_int* a,\n        mp_int* prime, mp_int* order)\n{\n    ecc_point* inf = NULL;\n    int        err;\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    inf = wc_ecc_new_point_h(key->heap);\n    if (inf == NULL)\n        err = MEMORY_E;\n    else {\n#ifdef WOLFSSL_HAVE_SP_ECC\n#ifndef WOLFSSL_SP_NO_256\n        if (key->idx != ECC_CUSTOM_IDX &&\n                                       ecc_sets[key->idx].id == ECC_SECP256R1) {\n            err = sp_ecc_mulmod_256(order, pubkey, inf, 1, key->heap);\n        }\n        else\n#endif\n#endif\n#ifndef WOLFSSL_SP_MATH\n            err = wc_ecc_mulmod_ex(order, pubkey, inf, a, prime, 1, key->heap);\n        if (err == MP_OKAY && !wc_ecc_point_is_at_infinity(inf))\n            err = ECC_INF_E;\n#else\n            (void)a;\n            (void)prime;\n\n            err = WC_KEY_SIZE_E;\n#endif\n    }\n\n    wc_ecc_del_point_h(inf, key->heap);\n\n    return err;\n}",
        "target": 0
    },
    {
        "id": 3827,
        "func": "static int tcp_try_undo_loss(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_may_undo(tp)) {\n\t\tstruct sk_buff *skb;\n\t\ttcp_for_write_queue(skb, sk) {\n\t\t\tif (skb == tcp_send_head(sk))\n\t\t\t\tbreak;\n\t\t\tTCP_SKB_CB(skb)->sacked &= ~TCPCB_LOST;\n\t\t}\n\n\t\ttcp_clear_all_retrans_hints(tp);\n\n\t\tDBGUNDO(sk, \"partial loss\");\n\t\ttp->lost_out = 0;\n\t\ttcp_undo_cwr(sk, true);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPLOSSUNDO);\n\t\tinet_csk(sk)->icsk_retransmits = 0;\n\t\ttp->undo_marker = 0;\n\t\tif (tcp_is_sack(tp))\n\t\t\ttcp_set_ca_state(sk, TCP_CA_Open);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3828,
        "func": "int sm_looptest_path_length(p_fm_config_conx_hdlt hdl, fm_mgr_type_t mgr, int argc, char *argv[]) {\n\tfm_mgr_config_errno_t\tres;\n\tfm_msg_ret_code_t\t\tret_code;\n\tint\t\t\t\t\t\tplen=3;\n\tuint8_t                 data[BUF_SZ];\n\n\tif (argc > 1) {\n\t\tprintf(\"Error: only 1 argument expected\\n\");\n\t\treturn 0;\n\t}\n\n\tif (argc == 1) {\n\t\tplen = atol(argv[0]);\n\t\tif (plen < 2 || plen > 4) {\n\t\t\tprintf(\"Error: length must be 2-4\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*(int*)data = plen;\n\tif((res = fm_mgr_simple_query(hdl, FM_ACT_GET, FM_DT_SM_LOOP_TEST_PATH_LEN, mgr, \n\t\t\t\t\t\t\t\t  BUF_SZ, data, &ret_code)) != FM_CONF_OK)\n\t{\n\t\tfprintf(stderr, \"sm_looptest_path_length: Failed to retrieve data: \\n\"\n\t\t\t   \"\\tError:(%d) %s \\n\\tRet code:(%d) %s\\n\",\n\t\t\t   res, fm_mgr_get_error_str(res),ret_code,\n\t\t\t   fm_mgr_get_resp_error_str(ret_code));\n\t} else {\n\t\tprintf(\"Successfully sent Loop Test Path Length set to %d control to local SM instance\\n\", plen);\n\t\tdata[BUF_SZ-1]=0;\n\t\tprintf(\"%s\", (char*) data);\n\t}\n\treturn 0;\n}\n",
        "target": 0
    },
    {
        "id": 3829,
        "func": "static inline int notify_page_fault(struct pt_regs *regs)\n{\n\tint ret = 0;\n\n\t/* kprobe_running() needs smp_processor_id() */\n\tif (kprobes_built_in() && !user_mode(regs)) {\n\t\tpreempt_disable();\n\t\tif (kprobe_running() && kprobe_fault_handler(regs, 14))\n\t\t\tret = 1;\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 3830,
        "func": "msPostGISLayerInfo *msPostGISCreateLayerInfo(void)\n{\n  msPostGISLayerInfo *layerinfo = msSmallMalloc(sizeof(msPostGISLayerInfo));\n  layerinfo->sql = NULL;\n  layerinfo->srid = NULL;\n  layerinfo->uid = NULL;\n  layerinfo->pgconn = NULL;\n  layerinfo->pgresult = NULL;\n  layerinfo->geomcolumn = NULL;\n  layerinfo->fromsource = NULL;\n  layerinfo->endian = 0;\n  layerinfo->rownum = 0;\n  layerinfo->version = 0;\n  layerinfo->paging = MS_TRUE;\n  return layerinfo;\n}",
        "target": 0
    },
    {
        "id": 3831,
        "func": "static int gluster_cache_add(gluster_server *dst, glfs_t *fs, char* cfgstring)\n{\n\tstruct gluster_cacheconn *entry;\n\tchar* cfg_copy = NULL;\n\n\tentry = calloc(1, sizeof(gluster_cacheconn));\n\tif (!entry)\n\t\tgoto error;\n\n\tentry->volname = strdup(dst->volname);\n\n\tentry->server = calloc(1, sizeof(gluster_hostdef));\n\tif (!entry->server)\n\t\tgoto error;\n\n\tentry->server->type = dst->server->type;\n\n\tif (entry->server->type == GLUSTER_TRANSPORT_UNIX) {\n\t\tentry->server->u.uds.socket = strdup(dst->server->u.uds.socket);\n\t} else {\n\t\tentry->server->u.inet.addr = strdup(dst->server->u.inet.addr);\n\t\tentry->server->u.inet.port = strdup(dst->server->u.inet.port);\n\t}\n\n\tentry->fs = fs;\n\n\tcfg_copy = strdup(cfgstring);\n\tdarray_init(entry->cfgstring);\n\tdarray_append(entry->cfgstring, cfg_copy);\n\n\tdarray_append(cache, entry);\n\n\treturn 0;\n\n error:\n\treturn -1;\n}",
        "target": 0
    },
    {
        "id": 3832,
        "func": "timespec_to_jiffies(const struct timespec *value)\n{\n\tunsigned long sec = value->tv_sec;\n\tlong nsec = value->tv_nsec + TICK_NSEC - 1;\n\n\tif (sec >= MAX_SEC_IN_JIFFIES){\n\t\tsec = MAX_SEC_IN_JIFFIES;\n\t\tnsec = 0;\n\t}\n\treturn (((u64)sec * SEC_CONVERSION) +\n\t\t(((u64)nsec * NSEC_CONVERSION) >>\n\t\t (NSEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;\n\n}",
        "target": 0
    },
    {
        "id": 3833,
        "func": "gst_asf_demux_activate_mode (GstPad * sinkpad, GstObject * parent,\n    GstPadMode mode, gboolean active)\n{\n  gboolean res;\n  GstASFDemux *demux;\n\n  demux = GST_ASF_DEMUX (parent);\n\n  switch (mode) {\n    case GST_PAD_MODE_PUSH:\n      demux->state = GST_ASF_DEMUX_STATE_HEADER;\n      demux->streaming = TRUE;\n      res = TRUE;\n      break;\n    case GST_PAD_MODE_PULL:\n      if (active) {\n        demux->state = GST_ASF_DEMUX_STATE_HEADER;\n        demux->streaming = FALSE;\n\n        res = gst_pad_start_task (sinkpad, (GstTaskFunction) gst_asf_demux_loop,\n            demux, NULL);\n      } else {\n        res = gst_pad_stop_task (sinkpad);\n      }\n      break;\n    default:\n      res = FALSE;\n      break;\n  }\n  return res;\n}",
        "target": 0
    },
    {
        "id": 3834,
        "func": "static int tcp_try_undo_partial(struct sock *sk, int acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t/* Partial ACK arrived. Force Hoe's retransmit. */\n\tint failed = tcp_is_reno(tp) || (tcp_fackets_out(tp) > tp->reordering);\n\n\tif (tcp_may_undo(tp)) {\n\t\t/* Plain luck! Hole if filled with delayed\n\t\t * packet, rather than with a retransmit.\n\t\t */\n\t\tif (!tcp_any_retrans_done(sk))\n\t\t\ttp->retrans_stamp = 0;\n\n\t\ttcp_update_reordering(sk, tcp_fackets_out(tp) + acked, 1);\n\n\t\tDBGUNDO(sk, \"Hoe\");\n\t\ttcp_undo_cwr(sk, false);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPPARTIALUNDO);\n\n\t\t/* So... Do not make Hoe's retransmit yet.\n\t\t * If the first packet was delayed, the rest\n\t\t * ones are most probably delayed as well.\n\t\t */\n\t\tfailed = 0;\n\t}\n\treturn failed;\n}",
        "target": 0
    },
    {
        "id": 3835,
        "func": "void BrowserPluginGuest::SendMessageToEmbedder(IPC::Message* msg) {\n  embedder_web_contents_->Send(msg);\n}\n",
        "target": 0
    },
    {
        "id": 3836,
        "func": "PixarLogFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn (1);\n}\n",
        "target": 0
    },
    {
        "id": 3837,
        "func": "DefragVlanQinQTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *r = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n\n    /* With no VLAN IDs set, packets should re-assemble. */\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)\n        goto end;\n    SCFree(r);\n\n    /* With mismatched VLANs, packets should not re-assemble. */\n    p1->vlan_id[0] = 1;\n    p2->vlan_id[0] = 1;\n    p1->vlan_id[1] = 1;\n    p2->vlan_id[1] = 2;\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)\n        goto end;\n\n    /* Pass. */\n    ret = 1;\n\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    DefragDestroy();\n\n    return ret;\n}",
        "target": 1
    },
    {
        "id": 3838,
        "func": "InspectorResourceAgent::InspectorResourceAgent(InspectorPageAgent* pageAgent, InspectorClient* client)\n     : InspectorBaseAgent<InspectorResourceAgent>(\"Network\")\n     , m_pageAgent(pageAgent)\n    , m_client(client)\n     , m_frontend(0)\n     , m_resourcesData(adoptPtr(new NetworkResourcesData()))\n     , m_isRecalculatingStyle(false)\n{\n}\n",
        "target": 1
    },
    {
        "id": 3839,
        "func": "void GLES2DecoderImpl::DoVertexAttrib4fv(GLuint index, const GLfloat* v) {\n  VertexAttribManager::VertexAttribInfo* info =\n      vertex_attrib_manager_.GetVertexAttribInfo(index);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glVertexAttrib4fv: index out of range\");\n    return;\n  }\n  VertexAttribManager::VertexAttribInfo::Vec4 value;\n  value.v[0] = v[0];\n  value.v[1] = v[1];\n  value.v[2] = v[2];\n  value.v[3] = v[3];\n  info->set_value(value);\n  glVertexAttrib4fv(index, v);\n}\n",
        "target": 0
    },
    {
        "id": 3840,
        "func": "WebRunnerContentBrowserClient::WebRunnerContentBrowserClient(\n    zx::channel context_channel)\n    : context_channel_(std::move(context_channel)) {}\n",
        "target": 0
    },
    {
        "id": 3841,
        "func": "static void qeth_free_qdio_buffers(struct qeth_card *card)\n{\n\tint i, j;\n\n\tif (atomic_xchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED) ==\n\t\tQETH_QDIO_UNINITIALIZED)\n\t\treturn;\n\n\tqeth_free_cq(card);\n\tcancel_delayed_work_sync(&card->buffer_reclaim_work);\n\tfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\n\t\tif (card->qdio.in_q->bufs[j].rx_skb)\n\t\t\tdev_kfree_skb_any(card->qdio.in_q->bufs[j].rx_skb);\n\t}\n\tkfree(card->qdio.in_q);\n\tcard->qdio.in_q = NULL;\n\t/* inbound buffer pool */\n\tqeth_free_buffer_pool(card);\n\t/* free outbound qdio_qs */\n\tif (card->qdio.out_qs) {\n\t\tfor (i = 0; i < card->qdio.no_out_queues; ++i) {\n\t\t\tqeth_clear_outq_buffers(card->qdio.out_qs[i], 1);\n\t\t\tkfree(card->qdio.out_qs[i]);\n\t\t}\n\t\tkfree(card->qdio.out_qs);\n\t\tcard->qdio.out_qs = NULL;\n\t}\n}",
        "target": 0
    },
    {
        "id": 3842,
        "func": "static av_always_inline void last_reset(int *recode, int *last) {\n    recode[last[0]] = recode[last[1]] = recode[last[2]] = 0;\n}",
        "target": 0
    },
    {
        "id": 3843,
        "func": "std::string APIPermission::ToString() const {\n  return name();\n}\n",
        "target": 0
    },
    {
        "id": 3844,
        "func": "static bool reserve_pmc_hardware(void) { return true; }",
        "target": 0
    },
    {
        "id": 3845,
        "func": "static int digest_encode(const char *src, int len, char *dst)\n{\n\tint i = 0, bits = 0, ac = 0;\n\tchar *cp = dst;\n\n\twhile (i < len) {\n\t\tac += (((unsigned char) src[i]) << bits);\n\t\tbits += 8;\n\t\tdo {\n\t\t\t*cp++ = lookup_table[ac & 0x3f];\n\t\t\tac >>= 6;\n\t\t\tbits -= 6;\n\t\t} while (bits >= 6);\n\t\ti++;\n\t}\n\tif (bits)\n\t\t*cp++ = lookup_table[ac & 0x3f];\n\treturn cp - dst;\n}",
        "target": 0
    },
    {
        "id": 3846,
        "func": "PHP_METHOD(Phar, loadPhar)\n{\n        char *fname, *alias = NULL, *error;\n        size_t fname_len, alias_len = 0;\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|s!\", &fname, &fname_len, &alias, &alias_len) == FAILURE) {\n                return;\n        }\n \n\tphar_request_initialize();\n\n\tRETVAL_BOOL(phar_open_from_filename(fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, &error) == SUCCESS);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"%s\", error);\n\t\tefree(error);\n\t}\n} /* }}} */\n\n/* {{{ proto string Phar::apiVersion()\n",
        "target": 1
    },
    {
        "id": 3847,
        "func": "void WebGL2RenderingContextBase::texSubImage2D(\n    ExecutionContext* execution_context,\n    GLenum target,\n    GLint level,\n    GLint xoffset,\n    GLint yoffset,\n    GLenum format,\n    GLenum type,\n    HTMLVideoElement* video,\n    ExceptionState& exception_state) {\n  WebGLRenderingContextBase::texSubImage2D(execution_context, target, level,\n                                           xoffset, yoffset, format, type,\n                                           video, exception_state);\n}\n",
        "target": 0
    },
    {
        "id": 3848,
        "func": "static int decode_lt_rps(HEVCContext *s, LongTermRPS *rps, GetBitContext *gb)\n{\n    const HEVCSPS *sps = s->ps.sps;\n    int max_poc_lsb    = 1 << sps->log2_max_poc_lsb;\n    int prev_delta_msb = 0;\n    unsigned int nb_sps = 0, nb_sh;\n    int i;\n\n    rps->nb_refs = 0;\n    if (!sps->long_term_ref_pics_present_flag)\n        return 0;\n\n    if (sps->num_long_term_ref_pics_sps > 0)\n        nb_sps = get_ue_golomb_long(gb);\n    nb_sh = get_ue_golomb_long(gb);\n\n    if (nb_sps > sps->num_long_term_ref_pics_sps)\n        return AVERROR_INVALIDDATA;\n    if (nb_sh + (uint64_t)nb_sps > FF_ARRAY_ELEMS(rps->poc))\n        return AVERROR_INVALIDDATA;\n\n    rps->nb_refs = nb_sh + nb_sps;\n\n    for (i = 0; i < rps->nb_refs; i++) {\n        uint8_t delta_poc_msb_present;\n\n        if (i < nb_sps) {\n            uint8_t lt_idx_sps = 0;\n\n            if (sps->num_long_term_ref_pics_sps > 1)\n                lt_idx_sps = get_bits(gb, av_ceil_log2(sps->num_long_term_ref_pics_sps));\n\n            rps->poc[i]  = sps->lt_ref_pic_poc_lsb_sps[lt_idx_sps];\n            rps->used[i] = sps->used_by_curr_pic_lt_sps_flag[lt_idx_sps];\n        } else {\n            rps->poc[i]  = get_bits(gb, sps->log2_max_poc_lsb);\n            rps->used[i] = get_bits1(gb);\n        }\n\n        delta_poc_msb_present = get_bits1(gb);\n        if (delta_poc_msb_present) {\n            int64_t delta = get_ue_golomb_long(gb);\n            int64_t poc;\n\n            if (i && i != nb_sps)\n                delta += prev_delta_msb;\n\n            poc = rps->poc[i] + s->poc - delta * max_poc_lsb - s->sh.pic_order_cnt_lsb;\n            if (poc != (int32_t)poc)\n                return AVERROR_INVALIDDATA;\n            rps->poc[i] = poc;\n            prev_delta_msb = delta;\n        }\n    }\n\n    return 0;\n}",
        "target": 0
    },
    {
        "id": 3849,
        "func": "void AutoFillManager::FillFormField(const AutoFillProfile* profile,\n                                    AutoFillType type,\n                                    webkit_glue::FormField* field) {\n  DCHECK(profile);\n  DCHECK(field);\n\n  if (type.subgroup() == AutoFillType::PHONE_NUMBER) {\n    FillPhoneNumberField(profile, field);\n  } else {\n    if (field->form_control_type() == ASCIIToUTF16(\"select-one\"))\n      autofill::FillSelectControl(profile, type, field);\n    else\n      field->set_value(profile->GetFieldText(type));\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3850,
        "func": "void crypto_unregister_skciphers(struct skcipher_alg *algs, int count)\n{\n\tint i;\n\n\tfor (i = count - 1; i >= 0; --i)\n\t\tcrypto_unregister_skcipher(&algs[i]);\n}",
        "target": 0
    },
    {
        "id": 3851,
        "func": "bool HTMLFormElement::checkValidityWithoutDispatchingEvents()\n{\n    return !checkInvalidControlsAndCollectUnhandled(0, HTMLFormControlElement::CheckValidityDispatchEventsNone);\n}\n",
        "target": 0
    },
    {
        "id": 3852,
        "func": " void NotifyCacheOnIO(\n     scoped_refptr<net::URLRequestContextGetter> request_context,\n     const GURL& url,\n    const std::string& http_method) {\n  net::HttpCache* cache = request_context->GetURLRequestContext()->\n      http_transaction_factory()->GetCache();\n  if (cache)\n    cache->OnExternalCacheHit(url, http_method);\n}\n",
        "target": 0
    },
    {
        "id": 3853,
        "func": "void FrameView::paintOverhangAreas(GraphicsContext* context, const IntRect& horizontalOverhangArea, const IntRect& verticalOverhangArea, const IntRect& dirtyRect)\n{\n    if (m_frame->document()->printing())\n        return;\n\n    if (m_frame->isMainFrame()) {\n        if (m_frame->page()->chrome().client().paintCustomOverhangArea(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect))\n            return;\n    }\n\n     ScrollView::paintOverhangAreas(context, horizontalOverhangArea, verticalOverhangArea, dirtyRect);\n }\n",
        "target": 0
    },
    {
        "id": 3854,
        "func": "void jswrap_graphics_setPixel(JsVar *parent, int x, int y, JsVar *color) {\n  JsGraphics gfx; if (!graphicsGetFromVar(&gfx, parent)) return;\n  unsigned int col = gfx.data.fgColor;\n  if (!jsvIsUndefined(color))\n    col = (unsigned int)jsvGetInteger(color);\n  graphicsSetPixel(&gfx, (short)x, (short)y, col);\n  gfx.data.cursorX = (short)x;\n  gfx.data.cursorY = (short)y;\n  graphicsSetVar(&gfx); // gfx data changed because modified area\n}",
        "target": 0
    },
    {
        "id": 3855,
        "func": " DownloadRequestLimiter::DownloadRequestLimiter() : factory_(this) {}\n",
        "target": 0
    },
    {
        "id": 3856,
        "func": "void WebGL2RenderingContextBase::uniform4fv(\n    const WebGLUniformLocation* location,\n    Vector<GLfloat>& v) {\n  WebGLRenderingContextBase::uniform4fv(location, v);\n}\n",
        "target": 0
    },
    {
        "id": 3857,
        "func": "PHP_FUNCTION(snmp_set_valueretrieval)\n{\n\tlong method;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &method) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (method >= 0 && method <= (SNMP_VALUE_LIBRARY|SNMP_VALUE_PLAIN|SNMP_VALUE_OBJECT)) {\n\t\t\tSNMP_G(valueretrieval) = method;\n\t\t\tRETURN_TRUE;\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown SNMP value retrieval method '%ld'\", method);\n\t\tRETURN_FALSE;\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 3858,
        "func": "void Instance::DocumentSizeUpdated(const pp::Size& size) {\n  document_size_ = size;\n\n  OnGeometryChanged(zoom_, device_scale_);\n}\n",
        "target": 0
    },
    {
        "id": 3859,
        "func": "static int read_node_page(struct page *page, int op_flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\tstruct node_info ni;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.type = NODE,\n\t\t.op = REQ_OP_READ,\n\t\t.op_flags = op_flags,\n\t\t.page = page,\n\t\t.encrypted_page = NULL,\n\t};\n\n\tif (PageUptodate(page))\n\t\treturn LOCKED_PAGE;\n\n\tget_node_info(sbi, page->index, &ni);\n\n\tif (unlikely(ni.blk_addr == NULL_ADDR)) {\n\t\tClearPageUptodate(page);\n\t\treturn -ENOENT;\n\t}\n\n\tfio.new_blkaddr = fio.old_blkaddr = ni.blk_addr;\n\treturn f2fs_submit_page_bio(&fio);\n}",
        "target": 0
    },
    {
        "id": 3860,
        "func": "void V8TestObject::ShadowRootAttributeAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_shadowRootAttribute_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  test_object_v8_internal::ShadowRootAttributeAttributeSetter(v8_value, info);\n}\n",
        "target": 0
    },
    {
        "id": 3861,
        "func": "gfx::Point TreeView::GetKeyboardContextMenuLocation() {\n  int y = height() / 2;\n  if (GetSelectedNode()) {\n    RECT bounds;\n    RECT client_rect;\n    if (TreeView_GetItemRect(tree_view_,\n                             GetNodeDetails(GetSelectedNode())->tree_item,\n                             &bounds, TRUE) &&\n        GetClientRect(tree_view_, &client_rect) &&\n        bounds.bottom >= 0 && bounds.bottom < client_rect.bottom) {\n      y = bounds.bottom;\n    }\n  }\n  gfx::Point screen_loc(0, y);\n  if (base::i18n::IsRTL())\n    screen_loc.set_x(width());\n  ConvertPointToScreen(this, &screen_loc);\n  return screen_loc;\n}\n",
        "target": 0
    },
    {
        "id": 3862,
        "func": "void ServiceManagerConnection::SetForProcess(\n    std::unique_ptr<ServiceManagerConnection> connection) {\n  DCHECK(!g_connection_for_process.Get());\n  g_connection_for_process.Get() = std::move(connection);\n}\n",
        "target": 0
    },
    {
        "id": 3863,
        "func": "int json_array_set_new(json_t *json, size_t index, json_t *value)\n{\n    json_array_t *array;\n\n    if(!value)\n        return -1;\n\n    if(!json_is_array(json) || json == value)\n    {\n        json_decref(value);\n        return -1;\n    }\n    array = json_to_array(json);\n\n    if(index >= array->entries)\n    {\n        json_decref(value);\n        return -1;\n    }\n\n    json_decref(array->table[index]);\n    array->table[index] = value;\n\n    return 0;\n}",
        "target": 0
    },
    {
        "id": 3864,
        "func": " static inline void schedule_debug(struct task_struct *prev)\n {\n #ifdef CONFIG_SCHED_STACK_END_CHECK\n\tBUG_ON(task_stack_end_corrupted(prev));\n #endif\n \n \tif (unlikely(in_atomic_preempt_off())) {\n\t\t__schedule_bug(prev);\n\t\tpreempt_count_set(PREEMPT_DISABLED);\n\t}\n\trcu_sleep_check();\n\n\tprofile_hit(SCHED_PROFILING, __builtin_return_address(0));\n\n\tschedstat_inc(this_rq(), sched_count);\n}\n",
        "target": 1
    },
    {
        "id": 3865,
        "func": "MagickExport MagickBooleanType IsTaintImage(const Image *image)\n{\n  char\n    magick[MaxTextExtent],\n    filename[MaxTextExtent];\n\n  register const Image\n    *p;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  (void) CopyMagickString(magick,image->magick,MaxTextExtent);\n  (void) CopyMagickString(filename,image->filename,MaxTextExtent);\n  for (p=image; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    if (p->taint != MagickFalse)\n      return(MagickTrue);\n    if (LocaleCompare(p->magick,magick) != 0)\n      return(MagickTrue);\n    if (LocaleCompare(p->filename,filename) != 0)\n      return(MagickTrue);\n  }\n  return(MagickFalse);\n}\n",
        "target": 0
    },
    {
        "id": 3866,
        "func": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(dir, name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
        "target": 0
    },
    {
        "id": 3867,
        "func": "get_handle(struct sshbuf *queue, int *hp)\n{\n\tu_char *handle;\n\tint r;\n\tsize_t hlen;\n\n\t*hp = -1;\n\tif ((r = sshbuf_get_string(queue, &handle, &hlen)) != 0)\n\t\treturn r;\n\tif (hlen < 256)\n\t\t*hp = handle_from_string(handle, hlen);\n\tfree(handle);\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3868,
        "func": "rdp_out_ts_input_capabilityset(STREAM s)\n{\n\tuint16 inputflags = 0;\n\tinputflags |= INPUT_FLAG_SCANCODES;\n\n\tout_uint16_le(s, RDP_CAPSET_INPUT);\n\tout_uint16_le(s, RDP_CAPLEN_INPUT);\n\n\tout_uint16_le(s, inputflags);\t/* inputFlags */\n\tout_uint16_le(s, 0);\t/* pad2OctetsA */\n\tout_uint32_le(s, 0x409);\t/* keyboardLayout */\n\tout_uint32_le(s, 0x4);\t/* keyboardType */\n\tout_uint32_le(s, 0);\t/* keyboardSubtype */\n\tout_uint32_le(s, 0xC);\t/* keyboardFunctionKey */\n\tout_utf16s_padded(s, \"\", 64, 0);\t/* imeFileName */\n}",
        "target": 0
    },
    {
        "id": 3869,
        "func": "void InspectorOverlay::onTimer(Timer<InspectorOverlay>*)\n{\n    m_drawViewSize = false;\n    update();\n}\n",
        "target": 0
    },
    {
        "id": 3870,
        "func": "static USBDevice *ehci_find_device(EHCIState *ehci, uint8_t addr)\n{\n    USBDevice *dev;\n    USBPort *port;\n    int i;\n\n    for (i = 0; i < NB_PORTS; i++) {\n        port = &ehci->ports[i];\n        if (!(ehci->portsc[i] & PORTSC_PED)) {\n            DPRINTF(\"Port %d not enabled\\n\", i);\n            continue;\n        }\n        dev = usb_find_device(port, addr);\n        if (dev != NULL) {\n            return dev;\n        }\n    }\n    return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 3871,
        "func": "status_t MPEG4Extractor::parseAC3SampleEntry(off64_t offset) {\n    offset += 16;\n uint16_t channelCount;\n if (!mDataSource->getUInt16(offset, &channelCount)) {\n return ERROR_MALFORMED;\n }\n    offset += 8;\n uint16_t sampleRate;\n if (!mDataSource->getUInt16(offset, &sampleRate)) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 block: cannot read sample rate\");\n return ERROR_MALFORMED;\n }\n\n    offset += 4;\n return parseAC3SpecificBox(offset, sampleRate);\n}\n",
        "target": 0
    },
    {
        "id": 3872,
        "func": "start_xmit (struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct netdev_desc *txdesc;\n\tunsigned entry;\n\tu32 ioaddr;\n\tu64 tfc_vlan_tag = 0;\n\n\tif (np->link_status == 0) {\t/* Link Down */\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tioaddr = dev->base_addr;\n\tentry = np->cur_tx % TX_RING_SIZE;\n\tnp->tx_skbuff[entry] = skb;\n\ttxdesc = &np->tx_ring[entry];\n\n#if 0\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\ttxdesc->status |=\n\t\t    cpu_to_le64 (TCPChecksumEnable | UDPChecksumEnable |\n\t\t\t\t IPChecksumEnable);\n\t}\n#endif\n\tif (np->vlan) {\n\t\ttfc_vlan_tag = VLANTagInsert |\n\t\t    ((u64)np->vlan << 32) |\n\t\t    ((u64)skb->priority << 45);\n\t}\n\ttxdesc->fraginfo = cpu_to_le64 (pci_map_single (np->pdev, skb->data,\n\t\t\t\t\t\t\tskb->len,\n\t\t\t\t\t\t\tPCI_DMA_TODEVICE));\n\ttxdesc->fraginfo |= cpu_to_le64((u64)skb->len << 48);\n\n\t/* DL2K bug: DMA fails to get next descriptor ptr in 10Mbps mode\n\t * Work around: Always use 1 descriptor in 10Mbps mode */\n\tif (entry % np->tx_coalesce == 0 || np->speed == 10)\n\t\ttxdesc->status = cpu_to_le64 (entry | tfc_vlan_tag |\n\t\t\t\t\t      WordAlignDisable |\n\t\t\t\t\t      TxDMAIndicate |\n\t\t\t\t\t      (1 << FragCountShift));\n\telse\n\t\ttxdesc->status = cpu_to_le64 (entry | tfc_vlan_tag |\n\t\t\t\t\t      WordAlignDisable |\n\t\t\t\t\t      (1 << FragCountShift));\n\n\t/* TxDMAPollNow */\n\twritel (readl (ioaddr + DMACtrl) | 0x00001000, ioaddr + DMACtrl);\n\t/* Schedule ISR */\n\twritel(10000, ioaddr + CountDown);\n\tnp->cur_tx = (np->cur_tx + 1) % TX_RING_SIZE;\n\tif ((np->cur_tx - np->old_tx + TX_RING_SIZE) % TX_RING_SIZE\n\t\t\t< TX_QUEUE_LEN - 1 && np->speed != 10) {\n\t\t/* do nothing */\n\t} else if (!netif_queue_stopped(dev)) {\n\t\tnetif_stop_queue (dev);\n\t}\n\n\t/* The first TFDListPtr */\n\tif (readl (dev->base_addr + TFDListPtr0) == 0) {\n\t\twritel (np->tx_ring_dma + entry * sizeof (struct netdev_desc),\n\t\t\tdev->base_addr + TFDListPtr0);\n\t\twritel (0, dev->base_addr + TFDListPtr1);\n\t}\n\n\treturn NETDEV_TX_OK;\n}",
        "target": 0
    },
    {
        "id": 3873,
        "func": "connection_ap_get_original_destination(entry_connection_t *conn,\n                                       socks_request_t *req)\n{\n#ifdef TRANS_NETFILTER\n  return destination_from_socket(conn, req);\n#elif defined(TRANS_PF)\n  const or_options_t *options = get_options();\n\n  if (options->TransProxyType_parsed == TPT_PF_DIVERT)\n    return destination_from_socket(conn, req);\n\n  if (options->TransProxyType_parsed == TPT_DEFAULT ||\n      options->TransProxyType_parsed == TPT_IPFW)\n    return destination_from_pf(conn, req);\n\n  (void)conn;\n  (void)req;\n  log_warn(LD_BUG, \"Proxy destination determination mechanism %s unknown.\",\n           options->TransProxyType);\n  return -1;\n#else\n  (void)conn;\n  (void)req;\n  log_warn(LD_BUG, \"Called connection_ap_get_original_destination, but no \"\n           \"transparent proxy method was configured.\");\n  return -1;\n#endif\n}",
        "target": 0
    },
    {
        "id": 3874,
        "func": "static void cfunbody(JF, js_Ast *name, js_Ast *params, js_Ast *body)\n{\n\tF->lightweight = 1;\n\tF->arguments = 0;\n\n\tif (F->script)\n\t\tF->lightweight = 0;\n\n\tif (body)\n\t\tanalyze(J, F, body);\n\n\tcparams(J, F, params);\n\n\tif (name) {\n\t\temit(J, F, OP_CURRENT);\n\t\tif (F->lightweight) {\n\t\t\taddlocal(J, F, name, 0);\n\t\t\temit(J, F, OP_INITLOCAL);\n\t\t\temitraw(J, F, findlocal(J, F, name->string));\n\t\t} else {\n\t\t\temitstring(J, F, OP_INITVAR, name->string);\n\t\t}\n\t}\n\n\tif (body) {\n\t\tcvardecs(J, F, body);\n\t\tcfundecs(J, F, body);\n\t}\n\n\tif (F->script) {\n\t\temit(J, F, OP_UNDEF);\n\t\tcstmlist(J, F, body);\n\t\temit(J, F, OP_RETURN);\n\t} else {\n\t\tcstmlist(J, F, body);\n\t\temit(J, F, OP_UNDEF);\n\t\temit(J, F, OP_RETURN);\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 3875,
        "func": "static bool IsJavaScriptUrl(const std::string& url) {\n  return StartsWithASCII(url, \"javascript:\", false);\n}\n",
        "target": 1
    },
    {
        "id": 3876,
        "func": "static void nfc_llcp_recv_agf(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 ptype;\n\tu16 pdu_len;\n\tstruct sk_buff *new_skb;\n\n\tif (skb->len <= LLCP_HEADER_SIZE) {\n\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\treturn;\n\t}\n\n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\n\twhile (skb->len > LLCP_AGF_PDU_HEADER_SIZE) {\n\t\tpdu_len = skb->data[0] << 8 | skb->data[1];\n\n\t\tskb_pull(skb, LLCP_AGF_PDU_HEADER_SIZE);\n\n\t\tif (pdu_len < LLCP_HEADER_SIZE || pdu_len > skb->len) {\n\t\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tptype = nfc_llcp_ptype(skb);\n\n\t\tif (ptype == LLCP_PDU_SYMM || ptype == LLCP_PDU_AGF)\n\t\t\tgoto next;\n\n\t\tnew_skb = nfc_alloc_recv_skb(pdu_len, GFP_KERNEL);\n\t\tif (new_skb == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tskb_put_data(new_skb, skb->data, pdu_len);\n\n\t\tnfc_llcp_rx_skb(local, new_skb);\n\n\t\tkfree_skb(new_skb);\nnext:\n\t\tskb_pull(skb, pdu_len);\n\t}\n}",
        "target": 0
    },
    {
        "id": 3877,
        "func": "void CharacterIterator::advance(int count)\n{\n    if (count <= 0) {\n        ASSERT(count == 0);\n        return;\n    }\n    \n    m_atBreak = false;\n\n    int remaining = m_textIterator.length() - m_runOffset;\n    if (count < remaining) {\n        m_runOffset += count;\n        m_offset += count;\n        return;\n    }\n\n    count -= remaining;\n    m_offset += remaining;\n    \n    for (m_textIterator.advance(); !atEnd(); m_textIterator.advance()) {\n        int runLength = m_textIterator.length();\n        if (runLength == 0)\n            m_atBreak = true;\n        else {\n            if (count < runLength) {\n                m_runOffset = count;\n                m_offset += count;\n                return;\n            }\n            \n            count -= runLength;\n            m_offset += runLength;\n        }\n    }\n\n    m_atBreak = true;\n    m_runOffset = 0;\n}\n",
        "target": 0
    },
    {
        "id": 3878,
        "func": "void __init __weak arch_task_cache_init(void) { }",
        "target": 0
    },
    {
        "id": 3879,
        "func": "static void dispatchChildInsertionEvents(Node* child)\n{\n    if (child->isInShadowTree())\n        return;\n\n    ASSERT(!NoEventDispatchAssertion::isEventDispatchForbidden());\n\n    RefPtr<Node> c = child;\n    RefPtr<Document> document = &child->document();\n\n    if (c->parentNode() && document->hasListenerType(Document::DOMNODEINSERTED_LISTENER))\n        c->dispatchScopedEvent(MutationEvent::create(eventNames().DOMNodeInsertedEvent, true, c->parentNode()));\n\n    if (c->inDocument() && document->hasListenerType(Document::DOMNODEINSERTEDINTODOCUMENT_LISTENER)) {\n        for (; c; c = NodeTraversal::next(c.get(), child))\n            c->dispatchScopedEvent(MutationEvent::create(eventNames().DOMNodeInsertedIntoDocumentEvent, false));\n    }\n}\n",
        "target": 0
    },
    {
        "id": 3880,
        "func": "xmlXPathEvaluatePredicateResult(xmlXPathParserContextPtr ctxt,\n                                xmlXPathObjectPtr res) {\n    if ((ctxt == NULL) || (res == NULL)) return(0);\n    switch (res->type) {\n        case XPATH_BOOLEAN:\n\t    return(res->boolval);\n        case XPATH_NUMBER:\n#if defined(__BORLANDC__) || (defined(_MSC_VER) && (_MSC_VER == 1200))\n\t    return((res->floatval == ctxt->context->proximityPosition) &&\n\t           (!xmlXPathIsNaN(res->floatval))); /* MSC pbm Mark Vakoc !*/\n#else\n\t    return(res->floatval == ctxt->context->proximityPosition);\n#endif\n        case XPATH_NODESET:\n        case XPATH_XSLT_TREE:\n\t    if (res->nodesetval == NULL)\n\t\treturn(0);\n\t    return(res->nodesetval->nodeNr != 0);\n        case XPATH_STRING:\n\t    return((res->stringval != NULL) && (res->stringval[0] != 0));\n#ifdef LIBXML_XPTR_ENABLED\n\tcase XPATH_LOCATIONSET:{\n\t    xmlLocationSetPtr ptr = res->user;\n\t    if (ptr == NULL)\n\t        return(0);\n\t    return (ptr->locNr != 0);\n\t    }\n#endif\n        default:\n\t    STRANGE\n    }\n    return(0);\n}\n",
        "target": 0
    },
    {
        "id": 3881,
        "func": " bool ResourceFetcher::IsPreloadedForTest(const KURL& url) const {\n  DCHECK(preloaded_ur_ls_for_test_);\n  return preloaded_ur_ls_for_test_->Contains(url.GetString());\n }\n",
        "target": 1
    },
    {
        "id": 3882,
        "func": "EncodedJSValue JSC_HOST_CALL jsTestActiveDOMObjectPrototypeFunctionExcitingFunction(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestActiveDOMObject::s_info))\n        return throwVMTypeError(exec);\n    JSTestActiveDOMObject* castedThis = jsCast<JSTestActiveDOMObject*>(asObject(thisValue));\n    ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestActiveDOMObject::s_info);\n    if (!castedThis->allowsAccessFrom(exec))\n         return JSValue::encode(jsUndefined());\n     TestActiveDOMObject* impl = static_cast<TestActiveDOMObject*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     Node* nextChild(toNode(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->excitingFunction(nextChild);\n    return JSValue::encode(jsUndefined());\n}\n",
        "target": 1
    },
    {
        "id": 3883,
        "func": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_finish_cmd(cmd);\n\t}\n}",
        "target": 0
    },
    {
        "id": 3884,
        "func": "static void ipip6_tunnel_unlink(struct sit_net *sitn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel __rcu **tp;\n\tstruct ip_tunnel *iter;\n\n\tfor (tp = ipip6_bucket(sitn, t);\n\t     (iter = rtnl_dereference(*tp)) != NULL;\n\t     tp = &iter->next) {\n\t\tif (t == iter) {\n\t\t\trcu_assign_pointer(*tp, t->next);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 3885,
        "func": "   Closes the cursor, leaving the statement ready for re-execution. */\nstatic PHP_METHOD(PDOStatement, closeCursor)\n{\n\tPHP_STMT_GET_OBJ;\n\n\tif (!stmt->methods->cursor_closer) {\n\t\t/* emulate it by fetching and discarding rows */\n\t\tdo {\n\t\t\twhile (stmt->methods->fetcher(stmt, PDO_FETCH_ORI_NEXT, 0 TSRMLS_CC))\n\t\t\t\t;\n\t\t\tif (!stmt->methods->next_rowset) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!pdo_stmt_do_next_rowset(stmt TSRMLS_CC)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} while (1);\n\t\tstmt->executed = 0;\n\t\tRETURN_TRUE;\n\t}\n\n\tPDO_STMT_CLEAR_ERR();\n\n\tif (!stmt->methods->cursor_closer(stmt TSRMLS_CC)) {\n\t\tPDO_HANDLE_STMT_ERR();\n\t\tRETURN_FALSE;\n\t}\n\tstmt->executed = 0;\n\tRETURN_TRUE;",
        "target": 0
    },
    {
        "id": 3886,
        "func": "exsltDateDurationFunction (xmlXPathParserContextPtr ctxt, int nargs)\n{\n    xmlChar *ret;\n    xmlChar *number = NULL;\n\n    if ((nargs < 0) || (nargs > 1)) {\n\txmlXPathSetArityError(ctxt);\n\treturn;\n    }\n\n    if (nargs == 1) {\n\tnumber = xmlXPathPopString(ctxt);\n\tif (xmlXPathCheckError(ctxt)) {\n\t    xmlXPathSetTypeError(ctxt);\n\t    return;\n\t}\n    }\n\n    ret = exsltDateDuration(number);\n\n    if (number != NULL)\n\txmlFree(number);\n\n    if (ret == NULL)\n\txmlXPathReturnEmptyString(ctxt);\n    else\n\txmlXPathReturnString(ctxt, ret);\n}\n",
        "target": 0
    },
    {
        "id": 3887,
        "func": "void ModuleSystem::SetLazyField(v8::Local<v8::Object> object,\n                                const std::string& field,\n                                const std::string& module_name,\n                                const std::string& module_field) {\n  SetLazyField(\n      object, field, module_name, module_field, &ModuleSystem::LazyFieldGetter);\n}\n",
        "target": 0
    },
    {
        "id": 3888,
        "func": "gdImagePtr gdImageCreateFromWBMPPtr (int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);\n\tim = gdImageCreateFromWBMPCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}",
        "target": 0
    },
    {
        "id": 3889,
        "func": "static char *alloc_one_pg_vec_page(unsigned long order)\n{\n\tchar *buffer = NULL;\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_COMP |\n\t\t\t  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;\n\n\tbuffer = (char *) __get_free_pages(gfp_flags, order);\n\n\tif (buffer)\n\t\treturn buffer;\n\n\t/*\n\t * __get_free_pages failed, fall back to vmalloc\n\t */\n\tbuffer = vzalloc((1 << order) * PAGE_SIZE);\n\n\tif (buffer)\n\t\treturn buffer;\n\n\t/*\n\t * vmalloc failed, lets dig into swap here\n\t */\n\tgfp_flags &= ~__GFP_NORETRY;\n\tbuffer = (char *)__get_free_pages(gfp_flags, order);\n\tif (buffer)\n\t\treturn buffer;\n\n\t/*\n\t * complete and utter failure\n\t */\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 3890,
        "func": "static void yv12_extend_frame_top_c(YV12_BUFFER_CONFIG *ybf)\n{\n int i;\n unsigned char *src_ptr1;\n unsigned char *dest_ptr1;\n\n unsigned int Border;\n int plane_stride;\n\n /***********/\n /* Y Plane */\n /***********/\n Border = ybf->border;\n    plane_stride = ybf->y_stride;\n    src_ptr1 = ybf->y_buffer - Border;\n    dest_ptr1 = src_ptr1 - (Border * plane_stride);\n\n for (i = 0; i < (int)Border; i++)\n {\n        memcpy(dest_ptr1, src_ptr1, plane_stride);\n        dest_ptr1 += plane_stride;\n }\n\n\n /***********/\n /* U Plane */\n /***********/\n    plane_stride = ybf->uv_stride;\n Border /= 2;\n    src_ptr1 = ybf->u_buffer - Border;\n    dest_ptr1 = src_ptr1 - (Border * plane_stride);\n\n for (i = 0; i < (int)(Border); i++)\n {\n        memcpy(dest_ptr1, src_ptr1, plane_stride);\n        dest_ptr1 += plane_stride;\n }\n\n /***********/\n /* V Plane */\n /***********/\n\n    src_ptr1 = ybf->v_buffer - Border;\n    dest_ptr1 = src_ptr1 - (Border * plane_stride);\n\n for (i = 0; i < (int)(Border); i++)\n {\n        memcpy(dest_ptr1, src_ptr1, plane_stride);\n        dest_ptr1 += plane_stride;\n }\n}\n",
        "target": 0
    },
    {
        "id": 3891,
        "func": "bool Editor::deleteWithDirection(DeleteDirection direction,\n                                 TextGranularity granularity,\n                                 bool killRing,\n                                 bool isTypingAction) {\n  if (!canEdit())\n    return false;\n\n  EditingState editingState;\n  if (frame()\n          .selection()\n          .computeVisibleSelectionInDOMTreeDeprecated()\n          .isRange()) {\n    if (isTypingAction) {\n      DCHECK(frame().document());\n      TypingCommand::deleteKeyPressed(\n          *frame().document(),\n          canSmartCopyOrDelete() ? TypingCommand::SmartDelete : 0, granularity);\n      revealSelectionAfterEditingOperation();\n    } else {\n      if (killRing)\n        addToKillRing(selectedRange());\n      deleteSelectionWithSmartDelete(\n          canSmartCopyOrDelete() ? DeleteMode::Smart : DeleteMode::Simple,\n          deletionInputTypeFromTextGranularity(direction, granularity));\n    }\n  } else {\n    TypingCommand::Options options = 0;\n    if (canSmartCopyOrDelete())\n      options |= TypingCommand::SmartDelete;\n    if (killRing)\n      options |= TypingCommand::KillRing;\n    switch (direction) {\n      case DeleteDirection::Forward:\n        DCHECK(frame().document());\n        TypingCommand::forwardDeleteKeyPressed(\n            *frame().document(), &editingState, options, granularity);\n        if (editingState.isAborted())\n          return false;\n        break;\n      case DeleteDirection::Backward:\n        DCHECK(frame().document());\n        TypingCommand::deleteKeyPressed(*frame().document(), options,\n                                        granularity);\n        break;\n    }\n    revealSelectionAfterEditingOperation();\n  }\n\n  if (killRing)\n    setStartNewKillRingSequence(false);\n\n  return true;\n}\n",
        "target": 0
    },
    {
        "id": 3892,
        "func": "void GLES2DecoderImpl::DoVertexAttrib4f(\n    GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {\n  GLfloat v[4] = { v0, v1, v2, v3, };\n  if (SetVertexAttribValue(\"glVertexAttrib4f\", index, v)) {\n    glVertexAttrib4f(index, v0, v1, v2, v3);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3893,
        "func": "int ssl3_send_alert(SSL *s, int level, int desc)\n{\n    /* Map tls/ssl alert value to correct one */\n    desc = s->method->ssl3_enc->alert_value(desc);\n    if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)\n        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have\n                                          * protocol_version alerts */\n                                           * protocol_version alerts */\n     if (desc < 0)\n         return -1;\n    /* If a fatal one, remove from cache */\n    if ((level == 2) && (s->session != NULL))\n        SSL_CTX_remove_session(s->session_ctx, s->session);\n \n     s->s3->alert_dispatch = 1;\n     s->s3->send_alert[0] = level;\n     * else data is still being written out, we will get written some time in\n     * the future\n     */\n    return -1;\n}\n",
        "target": 1
    },
    {
        "id": 3894,
        "func": "int f2fs_get_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tstruct extent_info ei;\n\tstruct inode *inode = dn->inode;\n\n\tif (f2fs_lookup_extent_cache(inode, index, &ei)) {\n\t\tdn->data_blkaddr = ei.blk + index - ei.fofs;\n\t\treturn 0;\n\t}\n\n\treturn f2fs_reserve_block(dn, index);\n}",
        "target": 0
    },
    {
        "id": 3895,
        "func": "static irqreturn_t vfio_intx_handler(int irq, void *dev_id)\n{\n\tstruct vfio_pci_device *vdev = dev_id;\n\tunsigned long flags;\n\tint ret = IRQ_NONE;\n\n\tspin_lock_irqsave(&vdev->irqlock, flags);\n\n\tif (!vdev->pci_2_3) {\n\t\tdisable_irq_nosync(vdev->pdev->irq);\n\t\tvdev->ctx[0].masked = true;\n\t\tret = IRQ_HANDLED;\n\t} else if (!vdev->ctx[0].masked &&  /* may be shared */\n\t\t   pci_check_and_mask_intx(vdev->pdev)) {\n\t\tvdev->ctx[0].masked = true;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tspin_unlock_irqrestore(&vdev->irqlock, flags);\n\n\tif (ret == IRQ_HANDLED)\n\t\tvfio_send_intx_eventfd(vdev, NULL);\n\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 3896,
        "func": "GfxTilingPattern::~GfxTilingPattern() {\n  resDict.free();\n  contentStream.free();\n}\n",
        "target": 0
    },
    {
        "id": 3897,
        "func": "void DisplayItemList::invalidatePaintOffset(const DisplayItemClientWrapper& client)\n{\n    ASSERT(RuntimeEnabledFeatures::slimmingPaintOffsetCachingEnabled());\n\n    updateValidlyCachedClientsIfNeeded();\n    m_validlyCachedClients.remove(client.displayItemClient());\n\n    if (RuntimeEnabledFeatures::slimmingPaintV2Enabled() && m_trackedPaintInvalidationObjects)\n        m_trackedPaintInvalidationObjects->append(client.debugName());\n\n#if ENABLE(ASSERT)\n    m_clientsWithPaintOffsetInvalidations.add(client.displayItemClient());\n\n    for (const auto& item : m_newDisplayItems)\n        ASSERT(!item.isCached() || item.client() != client.displayItemClient());\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 3898,
        "func": "perf_sw_event(u32 event_id, u64 nr, int nmi,\n\t\t     struct pt_regs *regs, u64 addr)\t\t\t{ }",
        "target": 1
    },
    {
        "id": 3899,
        "func": "static inline bool is_breakpoint(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, BP_VECTOR);\n}",
        "target": 0
    },
    {
        "id": 3900,
        "func": "int regulator_bulk_force_disable(int num_consumers,\n\t\t\t   struct regulator_bulk_data *consumers)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_consumers; i++)\n\t\tconsumers[i].ret =\n\t\t\t    regulator_force_disable(consumers[i].consumer);\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].ret != 0) {\n\t\t\tret = consumers[i].ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn 0;\nout:\n\treturn ret;\n}",
        "target": 0
    },
    {
        "id": 3901,
        "func": "nlmsvc_grant_blocked(struct nlm_block *block)\n{\n\tstruct nlm_file\t\t*file = block->b_file;\n\tstruct nlm_lock\t\t*lock = &block->b_call->a_args.lock;\n\tint\t\t\terror;\n\tloff_t\t\t\tfl_start, fl_end;\n\n\tdprintk(\"lockd: grant blocked lock %p\\n\", block);\n\n\tkref_get(&block->b_count);\n\n\t/* Unlink block request from list */\n\tnlmsvc_unlink_block(block);\n\n\t/* If b_granted is true this means we've been here before.\n\t * Just retry the grant callback, possibly refreshing the RPC\n\t * binding */\n\tif (block->b_granted) {\n\t\tnlm_rebind_host(block->b_host);\n\t\tgoto callback;\n\t}\n\n\t/* Try the lock operation again */\n\t/* vfs_lock_file() can mangle fl_start and fl_end, but we need\n\t * them unchanged for the GRANT_MSG\n\t */\n\tlock->fl.fl_flags |= FL_SLEEP;\n\tfl_start = lock->fl.fl_start;\n\tfl_end = lock->fl.fl_end;\n\terror = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);\n\tlock->fl.fl_flags &= ~FL_SLEEP;\n\tlock->fl.fl_start = fl_start;\n\tlock->fl.fl_end = fl_end;\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase FILE_LOCK_DEFERRED:\n\t\tdprintk(\"lockd: lock still blocked error %d\\n\", error);\n\t\tnlmsvc_insert_block(block, NLM_NEVER);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\tdefault:\n\t\tprintk(KERN_WARNING \"lockd: unexpected error %d in %s!\\n\",\n\t\t\t\t-error, __func__);\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n\t\tnlmsvc_release_block(block);\n\t\treturn;\n\t}\n\ncallback:\n\t/* Lock was granted by VFS. */\n\tdprintk(\"lockd: GRANTing blocked lock.\\n\");\n\tblock->b_granted = 1;\n\n\t/* keep block on the list, but don't reattempt until the RPC\n\t * completes or the submission fails\n\t */\n\tnlmsvc_insert_block(block, NLM_NEVER);\n\n\t/* Call the client -- use a soft RPC task since nlmsvc_retry_blocked\n\t * will queue up a new one if this one times out\n\t */\n\terror = nlm_async_call(block->b_call, NLMPROC_GRANTED_MSG,\n\t\t\t\t&nlmsvc_grant_ops);\n\n\t/* RPC submission failed, wait a bit and retry */\n\tif (error < 0)\n\t\tnlmsvc_insert_block(block, 10 * HZ);\n}\n",
        "target": 0
    },
    {
        "id": 3902,
        "func": "PermissionsData::~PermissionsData() {\n}\n",
        "target": 0
    },
    {
        "id": 3903,
        "func": "bool Document::AllowedToUseDynamicMarkUpInsertion(\n    const char* api_name,\n    ExceptionState& exception_state) {\n  if (!RuntimeEnabledFeatures::ExperimentalProductivityFeaturesEnabled()) {\n    return true;\n  }\n  if (!frame_ ||\n      frame_->IsFeatureEnabled(mojom::FeaturePolicyFeature::kDocumentWrite)) {\n    return true;\n  }\n\n  exception_state.ThrowDOMException(\n      DOMExceptionCode::kNotAllowedError,\n      String::Format(\n          \"The use of method '%s' has been blocked by feature policy. The \"\n          \"feature \"\n          \"'document-write' is disabled in this document.\",\n          api_name));\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 3904,
        "func": "void BrowserTabStripController::TabChangedAt(TabContents* contents,\n                                             int model_index,\n                                             TabChangeType change_type) {\n  if (change_type == TITLE_NOT_LOADING) {\n    tabstrip_->TabTitleChangedNotLoading(model_index);\n    return;\n  }\n\n  SetTabDataAt(contents->web_contents(), model_index);\n}\n",
        "target": 0
    },
    {
        "id": 3905,
        "func": "void OmniboxViewWin::OpenMatch(const AutocompleteMatch& match,\n                               WindowOpenDisposition disposition,\n                               const GURL& alternate_nav_url,\n                               size_t selected_line,\n                               const string16& keyword) {\n  if (!match.destination_url.is_valid())\n    return;\n\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  model_->OpenMatch(match, disposition, alternate_nav_url,\n                    selected_line, keyword);\n}\n",
        "target": 0
    },
    {
        "id": 3906,
        "func": " SPL_METHOD(SplFileObject, key)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n/*\tDo not read the next line to support correct counting with fgetc()\n\tif (!intern->current_line) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t} */\n\tRETURN_LONG(intern->u.file.current_line_num);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::next()\n",
        "target": 1
    },
    {
        "id": 3907,
        "func": "static void kvm_exit_debug(void)\n{\n\tstruct kvm_stats_debugfs_item *p;\n\n\tfor (p = debugfs_entries; p->name; ++p)\n\t\tdebugfs_remove(p->dentry);\n\tdebugfs_remove(kvm_debugfs_dir);\n}\n",
        "target": 0
    },
    {
        "id": 3908,
        "func": "static void byteAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::byteAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "target": 0
    },
    {
        "id": 3909,
        "func": "unsigned long nsecs_to_usecs(unsigned long nsecs)\n{\n\treturn nsecs / 1000;\n}",
        "target": 0
    },
    {
        "id": 3910,
        "func": "nfssvc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readdirres *resp)\n{\n\txdr_ressize_check(rqstp, p);\n\tp = resp->buffer;\n\t*p++ = 0;\t\t\t/* no more entries */\n\t*p++ = htonl((resp->common.err == nfserr_eof));\n\trqstp->rq_res.page_len = (((unsigned long)p-1) & ~PAGE_MASK)+1;\n\n\treturn 1;\n}\n",
        "target": 0
    },
    {
        "id": 3911,
        "func": "static int ciedefgrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)\n{\n    int code;\n    ref CIEdict, *tempref;\n\n    code = array_get(imemory, space, 1, &CIEdict);\n    if (code < 0)\n        return code;\n\n    /* If we have a RangeDEFG, get the values from that */\n    code = dict_find_string(&CIEdict, \"RangeDEFG\", &tempref);\n    if (code > 0 && !r_has_type(tempref, t_null)) {\n        code = get_cie_param_array(imemory, tempref, 8, ptr);\n        if (code < 0)\n            return code;\n    } else {\n        /* Default values for a CIEBasedDEFG */\n    \tmemcpy(ptr, default_0_1, 8*sizeof(float));\n    }\n    return 0;\n}\n",
        "target": 0
    },
    {
        "id": 3912,
        "func": "void mem_cgroup_reset_owner(struct page *newpage)\n{\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tpc = lookup_page_cgroup(newpage);\n\tVM_BUG_ON(PageCgroupUsed(pc));\n\tpc->mem_cgroup = root_mem_cgroup;\n}",
        "target": 0
    },
    {
        "id": 3913,
        "func": "int btsock_thread_add_fd(int h, int fd, int type, int flags, uint32_t user_id)\n{\n if(h < 0 || h >= MAX_THREAD)\n {\n        APPL_TRACE_ERROR(\"invalid bt thread handle:%d\", h);\n return FALSE;\n }\n if(ts[h].cmd_fdw == -1)\n {\n        APPL_TRACE_ERROR(\"cmd socket is not created. socket thread may not initialized\");\n return FALSE;\n }\n if(flags & SOCK_THREAD_ADD_FD_SYNC)\n {\n if(ts[h].thread_id == pthread_self())\n {\n            flags &= ~SOCK_THREAD_ADD_FD_SYNC;\n            add_poll(h, fd, type, flags, user_id);\n return TRUE;\n }\n        APPL_TRACE_DEBUG(\"THREAD_ADD_FD_SYNC is not called in poll thread, fallback to async\");\n\n     }\n     sock_cmd_t cmd = {CMD_ADD_FD, fd, type, flags, user_id};\n     APPL_TRACE_DEBUG(\"adding fd:%d, flags:0x%x\", fd, flags);\n    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n }\n",
        "target": 1
    },
    {
        "id": 3914,
        "func": "bool TabSpecificContentSettings::IsContentBlocked(\n    ContentSettingsType content_type) const {\n  DCHECK(content_type != CONTENT_SETTINGS_TYPE_GEOLOCATION)\n      << \"Geolocation settings handled by ContentSettingGeolocationImageModel\";\n  DCHECK(content_type != CONTENT_SETTINGS_TYPE_NOTIFICATIONS)\n      << \"Notifications settings handled by \"\n      << \"ContentSettingsNotificationsImageModel\";\n\n  if (content_type == CONTENT_SETTINGS_TYPE_IMAGES ||\n      content_type == CONTENT_SETTINGS_TYPE_JAVASCRIPT ||\n      content_type == CONTENT_SETTINGS_TYPE_PLUGINS ||\n      content_type == CONTENT_SETTINGS_TYPE_COOKIES ||\n      content_type == CONTENT_SETTINGS_TYPE_POPUPS ||\n      content_type == CONTENT_SETTINGS_TYPE_MIXEDSCRIPT)\n    return content_blocked_[content_type];\n\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 3915,
        "func": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSshort(int16 value)\n{\n\tif (value<0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}\n",
        "target": 0
    },
    {
        "id": 3916,
        "func": "void luaD_growstack (lua_State *L, int n) {\n  if (n <= L->stacksize)  /* double size is enough? */\n    luaD_reallocstack(L, 2*L->stacksize);\n  else\n    luaD_reallocstack(L, L->stacksize + n);\n}",
        "target": 0
    },
    {
        "id": 3917,
        "func": "static int handle_vmcall(struct kvm_vcpu *vcpu)\n{\n\tskip_emulated_instruction(vcpu);\n\tkvm_emulate_hypercall(vcpu);\n\treturn 1;\n}",
        "target": 0
    },
    {
        "id": 3918,
        "func": "jpc_pchg_t *jpc_pchg_copy(jpc_pchg_t *pchg)\n{\n\tjpc_pchg_t *newpchg;\n\tif (!(newpchg = jas_malloc(sizeof(jpc_pchg_t)))) {\n\t\treturn 0;\n\t}\n\t*newpchg = *pchg;\n\treturn newpchg;\n}",
        "target": 0
    },
    {
        "id": 3919,
        "func": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}",
        "target": 1
    },
    {
        "id": 3920,
        "func": "void AwContents::DocumentHasImages(JNIEnv* env, jobject obj, jobject message) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  ScopedJavaGlobalRef<jobject> j_message;\n  j_message.Reset(env, message);\n  render_view_host_ext_->DocumentHasImages(\n      base::Bind(&DocumentHasImagesCallback, j_message));\n}\n",
        "target": 0
    },
    {
        "id": 3921,
        "func": "Document* BaseAudioContext::GetDocument() const {\n  return ToDocument(GetExecutionContext());\n}\n",
        "target": 0
    },
    {
        "id": 3922,
        "func": " virtual status_t configureVideoTunnelMode(\n            node_id node, OMX_U32 portIndex, OMX_BOOL tunneled,\n            OMX_U32 audioHwSync, native_handle_t **sidebandHandle ) {\n Parcel data, reply;\n        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());\n        data.writeInt32((int32_t)node);\n        data.writeInt32(portIndex);\n        data.writeInt32((int32_t)tunneled);\n        data.writeInt32(audioHwSync);\n\n         remote()->transact(CONFIGURE_VIDEO_TUNNEL_MODE, data, &reply);\n \n         status_t err = reply.readInt32();\n        if (sidebandHandle) {\n             *sidebandHandle = (native_handle_t *)reply.readNativeHandle();\n         }\n         return err;\n }\n",
        "target": 1
    },
    {
        "id": 3923,
        "func": "static noinline void do_low_address(struct pt_regs *regs, long int_code,\n\t\t\t\t    unsigned long trans_exc_code)\n{\n\t/* Low-address protection hit in kernel mode means\n\t   NULL pointer write access in kernel mode.  */\n\tif (regs->psw.mask & PSW_MASK_PSTATE) {\n\t\t/* Low-address protection hit in user mode 'cannot happen'. */\n\t\tdie (\"Low-address protection\", regs, int_code);\n\t\tdo_exit(SIGKILL);\n\t}\n\n\tdo_no_context(regs, int_code, trans_exc_code);\n}",
        "target": 0
    },
    {
        "id": 3924,
        "func": "TestPaintArtifact& TestPaintArtifact::KnownToBeOpaque() {\n  paint_chunks_data_.chunks.back().known_to_be_opaque = true;\n  return *this;\n}\n",
        "target": 0
    },
    {
        "id": 3925,
        "func": "get_text_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval and\n   converting to extended RGB */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),\n                         ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),)\n  } else {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],\n                         ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],)\n  }\n  return 1;\n}",
        "target": 0
    },
    {
        "id": 3926,
        "func": "void UrlFetcher::Core::Start(const UrlFetcher::DoneCallback& done_callback) {\n  done_callback_ = done_callback;\n  network_task_runner_ = request_context_getter_->GetNetworkTaskRunner();\n  DCHECK(network_task_runner_);\n  network_task_runner_->PostTask(FROM_HERE, base::Bind(\n      &UrlFetcher::Core::DoStart, this));\n}\n",
        "target": 0
    },
    {
        "id": 3927,
        "func": "ShellContentUtilityClient::ShellContentUtilityClient() {\n  if (base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(\n          switches::kProcessType) == switches::kUtilityProcess)\n     network_service_test_helper_ = std::make_unique<NetworkServiceTestHelper>();\n }\n",
        "target": 1
    },
    {
        "id": 3928,
        "func": "String Element::title() const\n{\n    return String();\n}\n",
        "target": 0
    },
    {
        "id": 3929,
        "func": "void MojoVideoEncodeAcceleratorService::UseOutputBitstreamBuffer(\n    int32_t bitstream_buffer_id,\n    mojo::ScopedSharedBufferHandle buffer) {\n  DVLOG(2) << __func__ << \" bitstream_buffer_id=\" << bitstream_buffer_id;\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n\n  if (!encoder_)\n    return;\n  if (!buffer.is_valid()) {\n    DLOG(ERROR) << __func__ << \" invalid |buffer|.\";\n    NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);\n    return;\n  }\n  if (bitstream_buffer_id < 0) {\n    DLOG(ERROR) << __func__ << \" bitstream_buffer_id=\" << bitstream_buffer_id\n                << \" must be >= 0\";\n    NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);\n    return;\n  }\n \n   base::SharedMemoryHandle handle;\n   size_t memory_size = 0;\n   auto result = mojo::UnwrapSharedMemoryHandle(std::move(buffer), &handle,\n                                               &memory_size, nullptr);\n   if (result != MOJO_RESULT_OK || memory_size == 0u) {\n     DLOG(ERROR) << __func__ << \" mojo::UnwrapSharedMemoryHandle() failed\";\n     NotifyError(::media::VideoEncodeAccelerator::kPlatformFailureError);\n    return;\n  }\n\n  if (memory_size < output_buffer_size_) {\n    DLOG(ERROR) << __func__ << \" bitstream_buffer_id=\" << bitstream_buffer_id\n                << \" has a size of \" << memory_size\n                << \"B, different from expected \" << output_buffer_size_ << \"B\";\n    NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);\n    return;\n  }\n\n  encoder_->UseOutputBitstreamBuffer(\n      BitstreamBuffer(bitstream_buffer_id, handle, memory_size));\n}\n",
        "target": 0
    },
    {
        "id": 3930,
        "func": "CStarter::updateX509Proxy( int cmd, Stream* s )\n{\n\tASSERT(s);\n\tReliSock* rsock = (ReliSock*)s;\n\tASSERT(jic);\n\treturn jic->updateX509Proxy(cmd,rsock) ? TRUE : FALSE;\n}\n",
        "target": 0
    },
    {
        "id": 3931,
        "func": "void BackTexture::Copy() {\n  DCHECK_NE(id(), 0u);\n  ScopedGLErrorSuppressor suppressor(\"BackTexture::Copy\",\n                                     decoder_->state_.GetErrorState());\n  ScopedTextureBinder binder(&decoder_->state_, id(), Target());\n  api()->glCopyTexSubImage2DFn(Target(),\n                               0,  // level\n                               0, 0, 0, 0, size_.width(), size_.height());\n}\n",
        "target": 0
    },
    {
        "id": 3932,
        "func": "    StateBase* writeFile(v8::Handle<v8::Value> value, StateBase* next)\n    {\n        File* file = V8File::toNative(value.As<v8::Object>());\n        if (!file)\n            return 0;\n         if (file->hasBeenClosed())\n             return handleError(DataCloneError, \"A File object has been closed, and could therefore not be cloned.\", next);\n         int blobIndex = -1;\n        m_blobDataHandles.set(file->uuid(), file->blobDataHandle());\n         if (appendFileInfo(file, &blobIndex)) {\n             ASSERT(blobIndex >= 0);\n             m_writer.writeFileIndex(blobIndex);\n        } else {\n            m_writer.writeFile(*file);\n        }\n        return 0;\n    }\n",
        "target": 0
    },
    {
        "id": 3933,
        "func": "struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n\t\tstruct user_namespace *user_ns, struct fs_struct *new_fs)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct vfsmount *rootmnt = NULL, *pwdmnt = NULL;\n\tstruct mount *p, *q;\n\tstruct mount *old;\n\tstruct mount *new;\n\tint copy_flags;\n\n\tBUG_ON(!ns);\n\n\tif (likely(!(flags & CLONE_NEWNS))) {\n\t\tget_mnt_ns(ns);\n\t\treturn ns;\n\t}\n\n\told = ns->root;\n\n\tnew_ns = alloc_mnt_ns(user_ns);\n\tif (IS_ERR(new_ns))\n\t\treturn new_ns;\n\n\tnamespace_lock();\n\t/* First pass: copy the tree topology */\n\tcopy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;\n\tif (user_ns != ns->user_ns)\n\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n\tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n\tif (IS_ERR(new)) {\n\t\tnamespace_unlock();\n\t\tfree_mnt_ns(new_ns);\n\t\treturn ERR_CAST(new);\n\t}\n\tnew_ns->root = new;\n\tlist_add_tail(&new_ns->list, &new->mnt_list);\n\n\t/*\n\t * Second pass: switch the tsk->fs->* elements and mark new vfsmounts\n\t * as belonging to new namespace.  We have already acquired a private\n\t * fs_struct, so tsk->fs->lock is not needed.\n\t */\n\tp = old;\n\tq = new;\n\twhile (p) {\n\t\tq->mnt_ns = new_ns;\n\t\tif (new_fs) {\n\t\t\tif (&p->mnt == new_fs->root.mnt) {\n\t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n\t\t\t\trootmnt = &p->mnt;\n\t\t\t}\n\t\t\tif (&p->mnt == new_fs->pwd.mnt) {\n\t\t\t\tnew_fs->pwd.mnt = mntget(&q->mnt);\n\t\t\t\tpwdmnt = &p->mnt;\n\t\t\t}\n\t\t}\n\t\tp = next_mnt(p, old);\n\t\tq = next_mnt(q, new);\n\t\tif (!q)\n\t\t\tbreak;\n\t\twhile (p->mnt.mnt_root != q->mnt.mnt_root)\n\t\t\tp = next_mnt(p, old);\n\t}\n\tnamespace_unlock();\n\n\tif (rootmnt)\n\t\tmntput(rootmnt);\n\tif (pwdmnt)\n\t\tmntput(pwdmnt);\n\n\treturn new_ns;\n}",
        "target": 1
    },
    {
        "id": 3934,
        "func": "bool PermissionsData::CanRunContentScriptOnPage(const GURL& document_url,\n                                                int tab_id,\n                                                std::string* error) const {\n  PageAccess result = GetContentScriptAccess(document_url, tab_id, error);\n\n  return result == PageAccess::kAllowed || result == PageAccess::kWithheld;\n}\n",
        "target": 0
    },
    {
        "id": 3935,
        "func": "void InterstitialPageImpl::CreateNewFullscreenWidget(int32_t render_process_id,\n                                                     int32_t route_id) {\n  NOTREACHED()\n      << \"InterstitialPage does not support showing full screen popups.\";\n}\n",
        "target": 0
    },
    {
        "id": 3936,
        "func": "void PrintWebViewHelper::OnPrintForPrintPreview(\n    const DictionaryValue& job_settings) {\n  DCHECK(is_preview_);\n  if (print_web_view_)\n    return;\n\n  if (!render_view()->webview())\n    return;\n  WebFrame* main_frame = render_view()->webview()->mainFrame();\n  if (!main_frame)\n    return;\n\n  WebDocument document = main_frame->document();\n  WebElement pdf_element = document.getElementById(\"pdf-viewer\");\n  if (pdf_element.isNull()) {\n    NOTREACHED();\n     return;\n   }\n \n   if (!UpdatePrintSettings(job_settings, false)) {\n     LOG(ERROR) << \"UpdatePrintSettings failed\";\n     DidFinishPrinting(FAIL_PRINT);\n     return;\n   }\n \n  WebFrame* pdf_frame = pdf_element.document().frame();\n  scoped_ptr<PrepareFrameAndViewForPrint> prepare;\n  prepare.reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,\n                                                pdf_frame, &pdf_element));\n  UpdatePrintableSizeInPrintParameters(pdf_frame, &pdf_element, prepare.get(),\n                                       &print_pages_params_->params);\n\n   if (!RenderPagesForPrint(pdf_frame, &pdf_element, prepare.get())) {\n     LOG(ERROR) << \"RenderPagesForPrint failed\";\n    DidFinishPrinting(FAIL_PRINT);\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3937,
        "func": "  virtual void RunWork() {\n    set_error_code(PerformCommonCheckAndPreparationForMoveAndCopy(\n        src_file_path_, dest_file_path_));\n    if (error_code() != base::PLATFORM_FILE_OK)\n      return;\n    if (!file_util::Move(src_file_path_, dest_file_path_))\n      set_error_code(base::PLATFORM_FILE_ERROR_FAILED);\n  }\n",
        "target": 0
    },
    {
        "id": 3938,
        "func": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\n\t/* Create a CMA ID and try to bind it. This catches both\n\t * IB and iWARP capable NICs.\n\t */\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\n\t/* rdma_bind_addr will only succeed for IB & iWARP devices */\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\t/* due to this, we will claim to support iWARP devices unless we\n\t   check node_type. */\n\tif (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)\n\t\tret = -EADDRNOTAVAIL;\n\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\n\trdma_destroy_id(cm_id);\n\n\treturn ret;\n}",
        "target": 1
    },
    {
        "id": 3939,
        "func": "ofproto_type_run(const char *datapath_type)\n{\n    const struct ofproto_class *class;\n    int error;\n\n    datapath_type = ofproto_normalize_type(datapath_type);\n    class = ofproto_class_find__(datapath_type);\n\n    error = class->type_run ? class->type_run(datapath_type) : 0;\n    if (error && error != EAGAIN) {\n        VLOG_ERR_RL(&rl, \"%s: type_run failed (%s)\",\n                    datapath_type, ovs_strerror(error));\n    }\n    return error;\n}\n",
        "target": 0
    },
    {
        "id": 3940,
        "func": "static void megasas_unmap_sgl(MegasasCmd *cmd)\n{\n    qemu_sglist_destroy(&cmd->qsg);\n    cmd->iov_offset = 0;\n}\n",
        "target": 0
    },
    {
        "id": 3941,
        "func": "static inline u32 max_delay(const struct illinois *ca)\n{\n\treturn ca->max_rtt - ca->base_rtt;\n}",
        "target": 0
    },
    {
        "id": 3942,
        "func": " void SynchronousCompositorImpl::BeginFrame(const cc::BeginFrameArgs& args) {\n   if (begin_frame_source_)\n     begin_frame_source_->BeginFrame(args);\n }\n",
        "target": 1
    },
    {
        "id": 3943,
        "func": "void TabStripGtk::DidProcessEvent(GdkEvent* event) {\n  switch (event->type) {\n    case GDK_MOTION_NOTIFY:\n    case GDK_LEAVE_NOTIFY:\n      HandleGlobalMouseMoveEvent();\n      break;\n    default:\n      break;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3944,
        "func": "void unkn_del(GF_Box *s)\n{\n\tGF_UnknownBox *ptr = (GF_UnknownBox *) s;\n\tif (!s) return;\n\tif (ptr->data) gf_free(ptr->data);\n\tgf_free(ptr);\n}",
        "target": 0
    },
    {
        "id": 3945,
        "func": "\nGF_Box *bloc_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_BaseLocationBox, GF_ISOM_BOX_TYPE_TRIK);\n\treturn (GF_Box *)tmp;",
        "target": 0
    },
    {
        "id": 3946,
        "func": "linux_lvm2_lv_start_completed_cb (DBusGMethodInvocation *context,\n                                  Device *device,\n                                  gboolean job_was_cancelled,\n                                  int status,\n                                  const char *stderr,\n                                  const char *stdout,\n                                  gpointer user_data)\n{\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      dbus_g_method_return (context);\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error starting LVM2 Logical Volume: lvchange exited with exit code %d: %s\",\n                       WEXITSTATUS (status),\n                       stderr);\n        }\n    }\n}\n",
        "target": 0
    },
    {
        "id": 3947,
        "func": "static __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}\n",
        "target": 0
    },
    {
        "id": 3948,
        "func": "   virtual ~CpuSpeedTest() {}\n",
        "target": 0
    },
    {
        "id": 3949,
        "func": "xsltCheckParentElement(xsltStylesheetPtr style, xmlNodePtr inst,\n                       const xmlChar *allow1, const xmlChar *allow2) {\n    xmlNodePtr parent;\n\n    if ((style == NULL) || (inst == NULL) || (inst->ns == NULL) ||\n        (style->literal_result))\n        return;\n\n    parent = inst->parent;\n    if (parent == NULL) {\n\txsltTransformError(NULL, style, inst,\n\t\t\"internal problem: element has no parent\\n\");\n\tstyle->errors++;\n\treturn;\n    }\n    if (((parent->ns == inst->ns) ||\n\t ((parent->ns != NULL) &&\n\t  (xmlStrEqual(parent->ns->href, inst->ns->href)))) &&\n\t((xmlStrEqual(parent->name, allow1)) ||\n\t (xmlStrEqual(parent->name, allow2)))) {\n\treturn;\n    }\n\n    if (style->extInfos != NULL) {\n\twhile ((parent != NULL) && (parent->type != XML_DOCUMENT_NODE)) {\n\t    /*\n\t     * if we are within an extension element all bets are off\n\t     * about the semantic there e.g. xsl:param within func:function\n\t     */\n\t    if ((parent->ns != NULL) &&\n\t\t(xmlHashLookup(style->extInfos, parent->ns->href) != NULL))\n\t\treturn;\n\n\t    parent = parent->parent;\n\t}\n    }\n    xsltTransformError(NULL, style, inst,\n\t\t       \"element %s is not allowed within that context\\n\",\n\t\t       inst->name);\n    style->errors++;\n}\n",
        "target": 0
    },
    {
        "id": 3950,
        "func": "\nGF_Err ssix_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i,j;\n\tGF_SubsegmentIndexBox *ptr = (GF_SubsegmentIndexBox*)s;\n\n\tif (ptr->size < 4) return GF_BAD_PARAM;\n\tptr->subsegment_count = gf_bs_read_u32(bs);\n\tptr->size -= 4;\n\tptr->subsegments = gf_malloc(ptr->subsegment_count*sizeof(GF_SubsegmentInfo));\n\tfor (i = 0; i < ptr->subsegment_count; i++) {\n\t\tGF_SubsegmentInfo *subseg = &ptr->subsegments[i];\n\t\tif (ptr->size < 4) return GF_BAD_PARAM;\n\t\tsubseg->range_count = gf_bs_read_u32(bs);\n\t\tptr->size -= 4;\n\t\tif (ptr->size < subseg->range_count*4) return GF_BAD_PARAM;\n\t\tsubseg->ranges = (GF_SubsegmentRangeInfo*) gf_malloc(sizeof(GF_SubsegmentRangeInfo) * subseg->range_count);\n\t\tfor (j = 0; j < subseg->range_count; j++) {\n\t\t\tsubseg->ranges[j].level = gf_bs_read_u8(bs);\n\t\t\tsubseg->ranges[j].range_size = gf_bs_read_u24(bs);\n\t\t\tptr->size -= 4;\n\t\t}\n\t}\n\treturn GF_OK;",
        "target": 0
    },
    {
        "id": 3951,
        "func": "SPICE_GNUC_VISIBLE int spice_server_set_sasl(SpiceServer *s, int enabled)\n{\n    spice_assert(reds == s);\n#if HAVE_SASL\n    sasl_enabled = enabled;\n    return 0;\n#else\n    return -1;\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 3952,
        "func": "void WT_InterpolateMono (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n const EAS_I8 *pLoopEnd;\n const EAS_I8 *pCurrentPhaseInt;\n    EAS_I32 numSamples;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 currentPhaseFrac;\n    EAS_I32 phaseInc;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n    EAS_I8 *pLoopStart;\n\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n         return;\n     }\n     pMixBuffer = pWTIntFrame->pMixBuffer;\n\n /* calculate gain increment */\n    gainIncrement = (pWTIntFrame->gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n if (gainIncrement < 0)\n        gainIncrement++;\n    gain = pWTIntFrame->prevGain << 16;\n\n    pCurrentPhaseInt = pWTVoice->pPhaseAccum;\n    currentPhaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->phaseIncrement;\n\n    pLoopStart = pWTVoice->pLoopStart;\n    pLoopEnd = pWTVoice->pLoopEnd + 1;\n\nInterpolationLoop:\n    tmp0 = (EAS_I32)(pCurrentPhaseInt - pLoopEnd);\n if (tmp0 >= 0)\n        pCurrentPhaseInt = pLoopStart + tmp0;\n\n    tmp0 = *pCurrentPhaseInt;\n    tmp1 = *(pCurrentPhaseInt + 1);\n\n    tmp2 = phaseInc + currentPhaseFrac;\n\n    tmp1 = tmp1 - tmp0;\n    tmp1 = tmp1 * currentPhaseFrac;\n\n    tmp1 = tmp0 + (tmp1 >> NUM_EG1_FRAC_BITS);\n\n    pCurrentPhaseInt += (tmp2 >> NUM_PHASE_FRAC_BITS);\n    currentPhaseFrac = tmp2 & PHASE_FRAC_MASK;\n\n    gain += gainIncrement;\n    tmp2 = (gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n\n    tmp0 = *pMixBuffer;\n    tmp2 = tmp1 * tmp2;\n    tmp2 = (tmp2 >> 9);\n    tmp0 = tmp2 + tmp0;\n *pMixBuffer++ = tmp0;\n\n    numSamples--;\n if (numSamples > 0)\n goto InterpolationLoop;\n\n    pWTVoice->pPhaseAccum = pCurrentPhaseInt;\n    pWTVoice->phaseFrac = currentPhaseFrac;\n /*lint -e{702} <avoid divide>*/\n    pWTVoice->gain = (EAS_I16)(gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n}\n",
        "target": 1
    },
    {
        "id": 3953,
        "func": "static void record_and_restart(struct perf_event *event, unsigned long val,\n\t\t\t       struct pt_regs *regs, int nmi)\n{\n\tu64 period = event->hw.sample_period;\n\ts64 prev, delta, left;\n\tint record = 0;\n\n\tif (event->hw.state & PERF_HES_STOPPED) {\n\t\twrite_pmc(event->hw.idx, 0);\n\t\treturn;\n\t}\n\n\t/* we don't have to worry about interrupts here */\n\tprev = local64_read(&event->hw.prev_count);\n\tdelta = (val - prev) & 0xfffffffful;\n\tlocal64_add(delta, &event->count);\n\n\t/*\n\t * See if the total period for this event has expired,\n\t * and update for the next period.\n\t */\n\tval = 0;\n\tleft = local64_read(&event->hw.period_left) - delta;\n\tif (period) {\n\t\tif (left <= 0) {\n\t\t\tleft += period;\n\t\t\tif (left <= 0)\n\t\t\t\tleft = period;\n\t\t\trecord = 1;\n\t\t\tevent->hw.last_period = event->hw.sample_period;\n\t\t}\n\t\tif (left < 0x80000000LL)\n\t\t\tval = 0x80000000LL - left;\n\t}\n\n\twrite_pmc(event->hw.idx, val);\n\tlocal64_set(&event->hw.prev_count, val);\n\tlocal64_set(&event->hw.period_left, left);\n\tperf_event_update_userpage(event);\n\n\t/*\n\t * Finally record data if requested.\n\t */\n\tif (record) {\n\t\tstruct perf_sample_data data;\n\n\t\tperf_sample_data_init(&data, 0);\n\t\tdata.period = event->hw.last_period;\n\n\t\tif (perf_event_overflow(event, nmi, &data, regs))\n\t\t\tfsl_emb_pmu_stop(event, 0);\n\t}\n}",
        "target": 1
    },
    {
        "id": 3954,
        "func": "void RenderThreadImpl::OnAssociatedInterfaceRequest(\n    const std::string& name,\n    mojo::ScopedInterfaceEndpointHandle handle) {\n  if (associated_interfaces_.CanBindRequest(name))\n    associated_interfaces_.BindRequest(name, std::move(handle));\n  else\n    ChildThreadImpl::OnAssociatedInterfaceRequest(name, std::move(handle));\n}\n",
        "target": 0
    },
    {
        "id": 3955,
        "func": "void InspectorResourceAgent::restore()\n{\n    if (m_state->getBoolean(ResourceAgentState::resourceAgentEnabled))\n        enable();\n}\n",
        "target": 0
    },
    {
        "id": 3956,
        "func": "static void tcp_cong_control(struct sock *sk, u32 ack, u32 acked_sacked,\n\t\t\t     int flag)\n{\n\tif (tcp_in_cwnd_reduction(sk)) {\n\t\t/* Reduce cwnd if state mandates */\n\t\ttcp_cwnd_reduction(sk, acked_sacked, flag);\n\t} else if (tcp_may_raise_cwnd(sk, flag)) {\n\t\t/* Advance cwnd if state allows */\n\t\ttcp_cong_avoid(sk, ack, acked_sacked);\n\t}\n\ttcp_update_pacing_rate(sk);\n}",
        "target": 0
    },
    {
        "id": 3957,
        "func": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
        "target": 0
    },
    {
        "id": 3958,
        "func": "dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n\t\t\t  proto_tree *tree, guint8 *drep _U_, char **data,\n\t\t\t  int hf_name)\n{\n\tgint len, remaining;\n\tchar *text;\n\n\tif (offset % 2)\n\t\toffset += 2 - (offset % 2);\n\n\t/* Get remaining data in buffer as a string */\n\n\tremaining = tvb_captured_length_remaining(tvb, offset);\n\tif (remaining <= 0) {\n\t\tif (data)\n\t\t\t*data = g_strdup(\"\");\n\t\treturn offset;\n\t}\n\n\ttext = tvb_get_string_enc(NULL, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\tlen = (int)strlen(text);\n\n\tproto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);\n\n\tif (data)\n\t\t*data = text;\n\telse\n\t\tg_free(text);\n\n\treturn offset + (len + 1) * 2;\n}",
        "target": 1
    },
    {
        "id": 3959,
        "func": "ffs_setup_state_clear_cancelled(struct ffs_data *ffs)\n{\n\treturn (enum ffs_setup_state)\n\t\tcmpxchg(&ffs->setup_state, FFS_SETUP_CANCELLED, FFS_NO_SETUP);\n}",
        "target": 0
    },
    {
        "id": 3960,
        "func": "void GLES2DecoderImpl::RestoreStateForTextures() {\n  DCHECK(state_.current_program.get());\n  const Program::SamplerIndices& sampler_indices =\n      state_.current_program->sampler_indices();\n  for (size_t ii = 0; ii < sampler_indices.size(); ++ii) {\n    const Program::UniformInfo* uniform_info =\n        state_.current_program->GetUniformInfo(sampler_indices[ii]);\n    DCHECK(uniform_info);\n    for (size_t jj = 0; jj < uniform_info->texture_units.size(); ++jj) {\n      GLuint texture_unit_index = uniform_info->texture_units[jj];\n      if (texture_unit_index < state_.texture_units.size()) {\n        TextureUnit& texture_unit = state_.texture_units[texture_unit_index];\n        TextureRef* texture_ref =\n            texture_unit.GetInfoForSamplerType(uniform_info->type).get();\n        if (!texture_ref || !texture_manager()->CanRender(texture_ref)) {\n          glActiveTexture(GL_TEXTURE0 + texture_unit_index);\n          texture_ref = texture_unit.bind_target == GL_TEXTURE_2D\n                            ? texture_unit.bound_texture_2d.get()\n                            : texture_unit.bound_texture_cube_map.get();\n          glBindTexture(texture_unit.bind_target,\n                        texture_ref ? texture_ref->service_id() : 0);\n          continue;\n        }\n\n        if (texture_unit.bind_target != GL_TEXTURE_CUBE_MAP) {\n          Texture* texture = texture_ref->texture();\n          gfx::GLImage* image =\n              texture->GetLevelImage(texture_unit.bind_target, 0);\n          if (image && !texture->IsAttachedToFramebuffer()) {\n            ScopedGLErrorSuppressor suppressor(\n                \"GLES2DecoderImpl::RestoreStateForTextures\", GetErrorState());\n            glActiveTexture(GL_TEXTURE0 + texture_unit_index);\n            image->DidUseTexImage();\n            continue;\n          }\n        }\n      }\n    }\n  }\n  glActiveTexture(GL_TEXTURE0 + state_.active_texture_unit);\n}\n",
        "target": 0
    },
    {
        "id": 3961,
        "func": "size_t CompositedLayerRasterInvalidator::MatchNewChunkToOldChunk(\n    const PaintChunk& new_chunk,\n    size_t old_index) {\n  for (size_t i = old_index; i < paint_chunks_info_.size(); i++) {\n    if (paint_chunks_info_[i].Matches(new_chunk))\n      return i;\n  }\n  for (size_t i = 0; i < old_index; i++) {\n    if (paint_chunks_info_[i].Matches(new_chunk))\n      return i;\n  }\n  return kNotFound;\n}\n",
        "target": 0
    },
    {
        "id": 3962,
        "func": "static void VoidMethodFlexibleArrayBufferViewTypedArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"voidMethodFlexibleArrayBufferViewTypedArg\");\n\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n    return;\n  }\n\n  FlexibleFloat32ArrayView typed_array_buffer_view_arg;\n  ToFlexibleArrayBufferView(info.GetIsolate(), info[0], typed_array_buffer_view_arg, allocateFlexibleArrayBufferViewStorage(info[0]));\n  if (!typed_array_buffer_view_arg) {\n    exception_state.ThrowTypeError(ExceptionMessages::ArgumentNotOfType(0, \"Float32Array\"));\n    return;\n  }\n\n  impl->voidMethodFlexibleArrayBufferViewTypedArg(typed_array_buffer_view_arg);\n}\n",
        "target": 0
    },
    {
        "id": 3963,
        "func": "static int netbk_check_gop(struct xenvif *vif, int nr_meta_slots,\n\t\t\t   struct netrx_pending_operations *npo)\n{\n\tstruct gnttab_copy     *copy_op;\n\tint status = XEN_NETIF_RSP_OKAY;\n\tint i;\n\n\tfor (i = 0; i < nr_meta_slots; i++) {\n\t\tcopy_op = npo->copy + npo->copy_cons++;\n\t\tif (copy_op->status != GNTST_okay) {\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Bad status %d from copy to DOM%d.\\n\",\n\t\t\t\t   copy_op->status, vif->domid);\n\t\t\tstatus = XEN_NETIF_RSP_ERROR;\n\t\t}\n\t}\n\n\treturn status;\n}",
        "target": 0
    },
    {
        "id": 3964,
        "func": "static PassOwnPtr<WebWheelEvent> coalesceWheelEvents(WebWheelEvent* oldNextWheelEvent, const WebWheelEvent& newWheelEvent)\n{\n#if MERGE_WHEEL_EVENTS\n    if (!oldNextWheelEvent)\n        return adoptPtr(new WebWheelEvent(newWheelEvent));\n\n    if (oldNextWheelEvent->position() != newWheelEvent.position() || oldNextWheelEvent->modifiers() != newWheelEvent.modifiers() || oldNextWheelEvent->granularity() != newWheelEvent.granularity())\n        return adoptPtr(new WebWheelEvent(newWheelEvent));\n\n    FloatSize mergedDelta = oldNextWheelEvent->delta() + newWheelEvent.delta();\n    FloatSize mergedWheelTicks = oldNextWheelEvent->wheelTicks() + newWheelEvent.wheelTicks();\n\n    return adoptPtr(new WebWheelEvent(WebEvent::Wheel, newWheelEvent.position(), newWheelEvent.globalPosition(), mergedDelta, mergedWheelTicks, newWheelEvent.granularity(), newWheelEvent.modifiers(), newWheelEvent.timestamp()));\n#else\n    return adoptPtr(new WebWheelEvent(newWheelEvent));\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 3965,
        "func": "static void gs_destroy_candev(struct gs_can *dev)\n{\n\tunregister_candev(dev->netdev);\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tfree_candev(dev->netdev);\n}",
        "target": 0
    },
    {
        "id": 3966,
        "func": "g_NPN_MemFree(void *ptr)\n{\n  D(bugiI(\"NPN_MemFree ptr=%p\\n\", ptr));\n  NPW_MemFree(ptr);\n  D(bugiD(\"NPN_MemFree done\\n\"));\n}",
        "target": 0
    },
    {
        "id": 3967,
        "func": "static void hugetlb_unregister_node(struct node *node)\n{\n\tstruct hstate *h;\n\tstruct node_hstate *nhs = &node_hstates[node->dev.id];\n\n\tif (!nhs->hugepages_kobj)\n\t\treturn;\t\t/* no hstate attributes */\n\n\tfor_each_hstate(h) {\n\t\tint idx = hstate_index(h);\n\t\tif (nhs->hstate_kobjs[idx]) {\n\t\t\tkobject_put(nhs->hstate_kobjs[idx]);\n\t\t\tnhs->hstate_kobjs[idx] = NULL;\n\t\t}\n\t}\n\n\tkobject_put(nhs->hugepages_kobj);\n\tnhs->hugepages_kobj = NULL;\n}",
        "target": 0
    },
    {
        "id": 3968,
        "func": "cleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/') {\n\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t                  \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tseparator = *src++;\n\t}\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}",
        "target": 1
    },
    {
        "id": 3969,
        "func": "void PluginInstance::RemoveStream(PluginStream* stream) {\n  if (in_close_streams_)\n    return;\n\n  std::vector<scoped_refptr<PluginStream> >::iterator stream_index;\n  for (stream_index = open_streams_.begin();\n       stream_index != open_streams_.end(); ++stream_index) {\n    if (*stream_index == stream) {\n      open_streams_.erase(stream_index);\n      break;\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3970,
        "func": "int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,\n\t\t\t\t     sctp_scope_t scope, gfp_t gfp)\n{\n\tint flags;\n\n\t/* Use scoping rules to determine the subset of addresses from\n\t * the endpoint.\n\t */\n\tflags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;\n\tif (asoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (asoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\n\treturn sctp_bind_addr_copy(sock_net(asoc->base.sk),\n\t\t\t\t   &asoc->base.bind_addr,\n\t\t\t\t   &asoc->ep->base.bind_addr,\n\t\t\t\t   scope, gfp, flags);\n}",
        "target": 0
    },
    {
        "id": 3971,
        "func": "static void release_one_tty(struct work_struct *work)\n{\n\tstruct tty_struct *tty =\n\t\tcontainer_of(work, struct tty_struct, hangup_work);\n\tstruct tty_driver *driver = tty->driver;\n\tstruct module *owner = driver->owner;\n\n\tif (tty->ops->cleanup)\n\t\ttty->ops->cleanup(tty);\n\n\ttty->magic = 0;\n\ttty_driver_kref_put(driver);\n\tmodule_put(owner);\n\n\tspin_lock(&tty_files_lock);\n\tlist_del_init(&tty->tty_files);\n\tspin_unlock(&tty_files_lock);\n\n\tput_pid(tty->pgrp);\n\tput_pid(tty->session);\n\tfree_tty_struct(tty);\n}",
        "target": 0
    },
    {
        "id": 3972,
        "func": "e1000e_set_imc(E1000ECore *core, int index, uint32_t val)\n{\n    trace_e1000e_irq_ims_clear_set_imc(val);\n    e1000e_clear_ims_bits(core, val);\n    e1000e_update_interrupt_state(core);\n}\n",
        "target": 0
    },
    {
        "id": 3973,
        "func": "void PaintController::SetTracksRasterInvalidations(bool value) {\n  if (value) {\n    raster_invalidation_tracking_info_ =\n        std::make_unique<RasterInvalidationTrackingInfo>();\n\n    DCHECK(new_display_item_list_.IsEmpty());\n    for (const auto& item : current_paint_artifact_.GetDisplayItemList()) {\n      raster_invalidation_tracking_info_->old_client_debug_names.Set(\n          &item.Client(), item.Client().DebugName());\n    }\n  } else if (!RasterInvalidationTracking::ShouldAlwaysTrack()) {\n    raster_invalidation_tracking_info_ = nullptr;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 3974,
        "func": "static int ___sys_recvmsg(struct socket *sock, struct user_msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned int flags, int nosec)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tunsigned long cmsg_ptr;\n\tint total_len, len;\n\tssize_t err;\n\n\t/* kernel mode address */\n\tstruct sockaddr_storage addr;\n\n\t/* user mode address pointers */\n\tstruct sockaddr __user *uaddr;\n\tint __user *uaddr_len = COMPAT_NAMELEN(msg);\n\n\tmsg_sys->msg_name = &addr;\n\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = get_compat_msghdr(msg_sys, msg_compat, &uaddr, &iov);\n\telse\n\t\terr = copy_msghdr_from_user(msg_sys, msg, &uaddr, &iov);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n\tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\n\t/* We assume all kernel code knows the size of sockaddr_storage */\n\tmsg_sys->msg_namelen = 0;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\n\t\t\t\t\t\t\t  total_len, flags);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\tlen = err;\n\n\tif (uaddr != NULL) {\n\t\terr = move_addr_to_user(&addr,\n\t\t\t\t\tmsg_sys->msg_namelen, uaddr,\n\t\t\t\t\tuaddr_len);\n\t\tif (err < 0)\n\t\t\tgoto out_freeiov;\n\t}\n\terr = __put_user((msg_sys->msg_flags & ~MSG_CMSG_COMPAT),\n\t\t\t COMPAT_FLAGS(msg));\n\tif (err)\n\t\tgoto out_freeiov;\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg_compat->msg_controllen);\n\telse\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg->msg_controllen);\n\tif (err)\n\t\tgoto out_freeiov;\n\terr = len;\n\nout_freeiov:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\treturn err;\n}",
        "target": 0
    },
    {
        "id": 3975,
        "func": "static ScopedJavaLocalRef<jstring> GetDownloadWarningText(\n    JNIEnv* env,\n    const JavaParamRef<jclass>& clazz,\n    const JavaParamRef<jstring>& filename) {\n  return base::android::ConvertUTF8ToJavaString(\n      env, l10n_util::GetStringFUTF8(\n               IDS_PROMPT_DANGEROUS_DOWNLOAD,\n               base::android::ConvertJavaStringToUTF16(env, filename)));\n}\n",
        "target": 0
    },
    {
        "id": 3976,
        "func": "const std::vector<std::string> CSPHandler::Keys() const {\n  const std::string& key = is_platform_app_ ?\n      keys::kPlatformAppContentSecurityPolicy : keys::kContentSecurityPolicy;\n  return SingleKey(key);\n}\n",
        "target": 0
    },
    {
        "id": 3977,
        "func": "AP_DECLARE(const char *) ap_context_document_root(request_rec *r)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (conf->context_document_root)\n        return conf->context_document_root;\n    else\n        return ap_document_root(r);\n}\n",
        "target": 0
    },
    {
        "id": 3978,
        "func": "ppp_unregister_channel(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct ppp_net *pn;\n\n\tif (!pch)\n\t\treturn;\t\t/* should never happen */\n\n\tchan->ppp = NULL;\n\n\t/*\n\t * This ensures that we have returned from any calls into the\n\t * the channel's start_xmit or ioctl routine before we proceed.\n\t */\n\tdown_write(&pch->chan_sem);\n\tspin_lock_bh(&pch->downl);\n\tpch->chan = NULL;\n\tspin_unlock_bh(&pch->downl);\n\tup_write(&pch->chan_sem);\n\tppp_disconnect_channel(pch);\n\n\tpn = ppp_pernet(pch->chan_net);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tlist_del(&pch->list);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\tput_net(pch->chan_net);\n\tpch->chan_net = NULL;\n\n\tpch->file.dead = 1;\n\twake_up_interruptible(&pch->file.rwait);\n\tif (atomic_dec_and_test(&pch->file.refcnt))\n\t\tppp_destroy_channel(pch);\n}",
        "target": 0
    },
    {
        "id": 3979,
        "func": "const GURL& TopSitesCache::GetURLFromIterator(\n    CanonicalURLs::const_iterator it) const {\n  DCHECK(it != canonical_urls_.end());\n  return it->first.first->redirects[it->first.second];\n}\n",
        "target": 0
    },
    {
        "id": 3980,
        "func": "void VideoCaptureManager::OnScreenLocked() {\n#if !defined(OS_ANDROID)\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  EmitLogMessage(\"VideoCaptureManager::OnScreenLocked\", 1);\n\n  std::vector<media::VideoCaptureSessionId> desktopcapture_session_ids;\n  for (auto it : sessions_) {\n    if (IsDesktopCaptureMediaType(it.second.type))\n      desktopcapture_session_ids.push_back(it.first);\n  }\n\n  for (auto session_id : desktopcapture_session_ids) {\n    Close(session_id);\n  }\n#endif  // OS_ANDROID\n}\n",
        "target": 0
    },
    {
        "id": 3981,
        "func": "gsf_infile_tar_dispose (GObject *obj)\n{\n\tGsfInfileTar *tar = GSF_INFILE_TAR (obj);\n\tunsigned ui;\n\n\tgsf_infile_tar_set_source (tar, NULL);\n\tg_clear_error (&tar->err);\n\n\tfor (ui = 0; ui < tar->children->len; ui++) {\n\t\tTarChild *c = &g_array_index (tar->children, TarChild, ui);\n\t\tg_free (c->name);\n\t\tif (c->modtime)\n\t\t\tg_date_time_unref (c->modtime);\n\t\tif (c->dir)\n\t\t\tg_object_unref (c->dir);\n\t}\n\tg_array_set_size (tar->children, 0);\n\n\tparent_class->dispose (obj);\n}",
        "target": 0
    },
    {
        "id": 3982,
        "func": "  UpdateTemporaryGlobalQuotaTask(\n      QuotaManager* manager,\n      int64 new_quota,\n      QuotaCallback* callback)\n      : DatabaseTaskBase(manager),\n        new_quota_(new_quota),\n        callback_(callback) {\n    DCHECK_GE(new_quota, 0);\n  }\n",
        "target": 0
    },
    {
        "id": 3983,
        "func": "void NetworkScreen::OnHelpLinkActivated() {\n  ClearErrors();\n  if (!help_app_.get())\n    help_app_.reset(new HelpAppLauncher(view()->GetNativeWindow()));\n  help_app_->ShowHelpTopic(HelpAppLauncher::HELP_CONNECTIVITY);\n}\n",
        "target": 0
    },
    {
        "id": 3984,
        "func": "void PasswordAccessoryControllerTest::InitializeGeneration(\n    const base::string16& password) {\n  ON_CALL(*(mock_password_manager_driver_.get()),\n          GetPasswordGenerationManager())\n      .WillByDefault(Return(mock_generation_manager_.get()));\n  EXPECT_CALL(mock_manual_filling_controller_,\n              OnAutomaticGenerationStatusChanged(true));\n  controller()->OnAutomaticGenerationStatusChanged(\n      true, GetTestGenerationUIData1(),\n      mock_password_manager_driver_->AsWeakPtr());\n  ON_CALL(*(mock_generation_manager_.get()), GeneratePassword(_, _, _, _, _))\n      .WillByDefault(Return(password));\n  ON_CALL(mock_dialog_factory(), Run)\n      .WillByDefault(Return(ByMove(std::move(mock_dialog_))));\n}\n",
        "target": 1
    },
    {
        "id": 3985,
        "func": "void ContentSecurityPolicy::ReportMixedContent(\n    const KURL& mixed_url,\n    RedirectStatus redirect_status) const {\n  for (const auto& policy : policies_)\n    policy->ReportMixedContent(mixed_url, redirect_status);\n}\n",
        "target": 0
    },
    {
        "id": 3986,
        "func": "SparseHistogram::~SparseHistogram() {}\n",
        "target": 0
    },
    {
        "id": 3987,
        "func": "int dmarc_init()\n{\n  int *netmask   = NULL;   /* Ignored */\n  int is_ipv6    = 0;\n  char *tld_file = (dmarc_tld_file == NULL) ?\n                   \"/etc/exim/opendmarc.tlds\" :\n                   (char *)dmarc_tld_file;\n\n  /* Set some sane defaults.  Also clears previous results when\n   * multiple messages in one connection. */\n  dmarc_pctx         = NULL;\n  dmarc_status       = US\"none\";\n  dmarc_abort        = FALSE;\n  dmarc_pass_fail    = US\"skipped\";\n  dmarc_used_domain  = US\"\";\n  dmarc_ar_header    = NULL;\n  dmarc_has_been_checked = FALSE;\n  header_from_sender = NULL;\n  spf_sender_domain  = NULL;\n  spf_human_readable = NULL;\n\n  /* ACLs have \"control=dmarc_disable_verify\" */\n  if (dmarc_disable_verify == TRUE)\n    return OK;\n\n  (void) memset(&dmarc_ctx, '\\0', sizeof dmarc_ctx);\n  dmarc_ctx.nscount = 0;\n  libdm_status = opendmarc_policy_library_init(&dmarc_ctx);\n  if (libdm_status != DMARC_PARSE_OKAY)\n  {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"DMARC failure to init library: %s\",\n                         opendmarc_policy_status_to_str(libdm_status));\n    dmarc_abort = TRUE;\n  }\n  if (dmarc_tld_file == NULL)\n    dmarc_abort = TRUE;\n  else if (opendmarc_tld_read_file(tld_file, NULL, NULL, NULL))\n  {\n    log_write(0, LOG_MAIN|LOG_PANIC, \"DMARC failure to load tld list %s: %d\",\n                         tld_file, errno);\n    dmarc_abort = TRUE;\n  }\n  if (sender_host_address == NULL)\n    dmarc_abort = TRUE;\n  /* This catches locally originated email and startup errors above. */\n  if ( dmarc_abort == FALSE )\n  {\n    is_ipv6 = string_is_ip_address(sender_host_address, netmask);\n    is_ipv6 = (is_ipv6 == 6) ? TRUE :\n              (is_ipv6 == 4) ? FALSE : FALSE;\n    dmarc_pctx = opendmarc_policy_connect_init(sender_host_address, is_ipv6);\n    if (dmarc_pctx == NULL )\n    {\n      log_write(0, LOG_MAIN|LOG_PANIC, \"DMARC failure creating policy context: ip=%s\",\n                                       sender_host_address);\n      dmarc_abort = TRUE;\n    }\n  }\n\n  return OK;\n}\n",
        "target": 0
    },
    {
        "id": 3988,
        "func": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tBUG_ON(client != handle->client);\n\n\tmutex_lock(&client->lock);\n\tion_free_nolock(client, handle);\n\tmutex_unlock(&client->lock);\n}",
        "target": 0
    },
    {
        "id": 3989,
        "func": "void Textfield::MoveCaretTo(const gfx::Point& point) {\n  SelectRect(point, point);\n}\n",
        "target": 0
    },
    {
        "id": 3990,
        "func": "static int decode_link(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\tint status;\n\t\n\tstatus = decode_op_hdr(xdr, OP_LINK);\n\tif (status)\n\t\treturn status;\n\treturn decode_change_info(xdr, cinfo);\n}",
        "target": 0
    },
    {
        "id": 3991,
        "func": "  tt_cmap10_validate( FT_Byte*      table,\n                      FT_Validator  valid )\n  {\n    FT_Byte*  p = table + 4;\n    FT_ULong  length, count;\n\n\n    if ( table + 20 > valid->limit )\n      FT_INVALID_TOO_SHORT;\n\n    length = TT_NEXT_ULONG( p );\n     p      = table + 16;\n     count  = TT_NEXT_ULONG( p );\n \n    if ( table + length > valid->limit || length < 20 + count * 2 )\n       FT_INVALID_TOO_SHORT;\n \n     /* check glyph indices */\n    {\n      FT_UInt  gindex;\n\n\n      for ( ; count > 0; count-- )\n      {\n        gindex = TT_NEXT_USHORT( p );\n        if ( gindex >= TT_VALID_GLYPH_COUNT( valid ) )\n          FT_INVALID_GLYPH_ID;\n      }\n    }\n\n    return SFNT_Err_Ok;\n  }\n",
        "target": 1
    },
    {
        "id": 3992,
        "func": "INST_HANDLER (cpse) {\t// CPSE Rd, Rr\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to true, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t// Rr == Rd\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}",
        "target": 0
    },
    {
        "id": 3993,
        "func": "xsltResolveSASCallback(xsltAttrElemPtr values, xsltStylesheetPtr style,\n \t               const xmlChar *name, const xmlChar *ns,\n\t\t       ATTRIBUTE_UNUSED const xmlChar *ignored) {\n     xsltAttrElemPtr tmp;\n     xsltAttrElemPtr refs;\n \n     tmp = values;\n     while (tmp != NULL) {\n \tif (tmp->set != NULL) {\n \t    /*\n\t     * Check against cycles !\n\t     */\n\t    if ((xmlStrEqual(name, tmp->set)) && (xmlStrEqual(ns, tmp->ns))) {\n\t\txsltGenericError(xsltGenericErrorContext,\n     \"xsl:attribute-set : use-attribute-sets recursion detected on %s\\n\",\n                                 name);\n\t    } else {\n#ifdef WITH_XSLT_DEBUG_ATTRIBUTES\n\t\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t\"Importing attribute list %s\\n\", tmp->set);\n#endif\n\n\t\trefs = xsltGetSAS(style, tmp->set, tmp->ns);\n\t\tif (refs == NULL) {\n\t\t    xsltGenericError(xsltGenericErrorContext,\n     \"xsl:attribute-set : use-attribute-sets %s reference missing %s\\n\",\n\t\t\t\t     name, tmp->set);\n\t\t} else {\n \t\t    /*\n \t\t     * recurse first for cleanup\n \t\t     */\n\t\t    xsltResolveSASCallback(refs, style, name, ns, NULL);\n \t\t    /*\n \t\t     * Then merge\n \t\t     */\n\t\t    xsltMergeAttrElemList(style, values, refs);\n\t\t    /*\n\t\t     * Then suppress the reference\n\t\t     */\n\t\t    tmp->set = NULL;\n\t\t    tmp->ns = NULL;\n\t\t}\n\t    }\n\t}\n\ttmp = tmp->next;\n     }\n }\n",
        "target": 1
    },
    {
        "id": 3994,
        "func": "void GLES2DecoderImpl::DoGetSynciv(GLuint sync_id,\n                                   GLenum pname,\n                                   GLsizei num_values,\n                                   GLsizei* length,\n                                   GLint* values) {\n  GLsync service_sync = 0;\n  if (!group_->GetSyncServiceId(sync_id, &service_sync)) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, \"glGetSynciv\", \"invalid sync id\");\n    return;\n  }\n  api()->glGetSyncivFn(service_sync, pname, num_values, nullptr, values);\n}\n",
        "target": 0
    },
    {
        "id": 3995,
        "func": "   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n     if (video->frame() == 1) {\n       encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);\n      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);\n      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);\n      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);\n      encoder->Control(VP8E_SET_ARNR_TYPE, 3);\n     }\n   }\n",
        "target": 1
    },
    {
        "id": 3996,
        "func": "static int phar_call_openssl_signverify(int is_sign, php_stream *fp, zend_off_t end, char *key, int key_len, char **signature, int *signature_len) /* {{{ */\n{\n\tzend_fcall_info fci;\n\tzend_fcall_info_cache fcc;\n\tzval retval, zp[3], openssl;\n\tzend_string *str;\n\n\tZVAL_STRINGL(&openssl, is_sign ? \"openssl_sign\" : \"openssl_verify\", is_sign ? sizeof(\"openssl_sign\")-1 : sizeof(\"openssl_verify\")-1);\n\tZVAL_STRINGL(&zp[1], *signature, *signature_len);\n\tZVAL_STRINGL(&zp[2], key, key_len);\n\tphp_stream_rewind(fp);\n\tstr = php_stream_copy_to_mem(fp, (size_t) end, 0);\n\tif (str) {\n\t\tZVAL_STR(&zp[0], str);\n\t} else {\n\t\tZVAL_EMPTY_STRING(&zp[0]);\n\t}\n\n\tif (end != Z_STRLEN(zp[0])) {\n\t\tzval_dtor(&zp[0]);\n\t\tzval_dtor(&zp[1]);\n\t\tzval_dtor(&zp[2]);\n\t\tzval_dtor(&openssl);\n\t\treturn FAILURE;\n\t}\n\n\tif (FAILURE == zend_fcall_info_init(&openssl, 0, &fci, &fcc, NULL, NULL)) {\n\t\tzval_dtor(&zp[0]);\n\t\tzval_dtor(&zp[1]);\n\t\tzval_dtor(&zp[2]);\n\t\tzval_dtor(&openssl);\n\t\treturn FAILURE;\n\t}\n\n\tfci.param_count = 3;\n\tfci.params = zp;\n\tZ_ADDREF(zp[0]);\n\tif (is_sign) {\n\t\tZVAL_NEW_REF(&zp[1], &zp[1]);\n\t} else {\n\t\tZ_ADDREF(zp[1]);\n\t}\n\tZ_ADDREF(zp[2]);\n\n\tfci.retval = &retval;\n\n\tif (FAILURE == zend_call_function(&fci, &fcc)) {\n\t\tzval_dtor(&zp[0]);\n\t\tzval_dtor(&zp[1]);\n\t\tzval_dtor(&zp[2]);\n\t\tzval_dtor(&openssl);\n\t\treturn FAILURE;\n\t}\n\n\tzval_dtor(&openssl);\n\tZ_DELREF(zp[0]);\n\n\tif (is_sign) {\n\t\tZVAL_UNREF(&zp[1]);\n\t} else {\n\t\tZ_DELREF(zp[1]);\n\t}\n\tZ_DELREF(zp[2]);\n\n\tzval_dtor(&zp[0]);\n\tzval_dtor(&zp[2]);\n\n\tswitch (Z_TYPE(retval)) {\n\t\tdefault:\n\t\tcase IS_LONG:\n\t\t\tzval_dtor(&zp[1]);\n\t\t\tif (1 == Z_LVAL(retval)) {\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\tcase IS_TRUE:\n\t\t\t*signature = estrndup(Z_STRVAL(zp[1]), Z_STRLEN(zp[1]));\n\t\t\t*signature_len = Z_STRLEN(zp[1]);\n\t\t\tzval_dtor(&zp[1]);\n\t\t\treturn SUCCESS;\n\t\tcase IS_FALSE:\n\t\t\tzval_dtor(&zp[1]);\n\t\t\treturn FAILURE;\n\t}\n}\n/* }}} */\n",
        "target": 0
    },
    {
        "id": 3997,
        "func": "static unsigned int udp4_portaddr_hash(struct net *net, __be32 saddr,\n\t\t\t\t       unsigned int port)\n{\n\treturn jhash_1word((__force u32)saddr, net_hash_mix(net)) ^ port;\n}",
        "target": 0
    },
    {
        "id": 3998,
        "func": "static int jas_iccgetuint8(jas_stream_t *in, jas_iccuint8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF)\n\t\treturn -1;\n\t*val = c;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 3999,
        "func": "SubresourceFilter* WorkerFetchContext::GetSubresourceFilter() const {\n  return subresource_filter_.Get();\n}\n",
        "target": 0
    },
    {
        "id": 4000,
        "func": "struct kvm_memory_slot *gfn_to_memslot(struct kvm *kvm, gfn_t gfn)\n{\n\treturn __gfn_to_memslot(kvm_memslots(kvm), gfn);\n}\n",
        "target": 0
    },
    {
        "id": 4001,
        "func": "void LayerWebKitThread::commitOnWebKitThread(double scale)\n{\n    updateTextureContents(scale);\n}\n",
        "target": 0
    },
    {
        "id": 4002,
        "func": "void WebContext::setDoNotTrack(bool dnt) {\n  if (IsInitialized()) {\n    context_->SetDoNotTrack(dnt);\n  } else {\n    construct_props_->do_not_track = dnt;\n  }\n}\n",
        "target": 0
    },
    {
        "id": 4003,
        "func": "void MockRenderThread::EnsureWebKitInitialized() {\n}\n",
        "target": 0
    },
    {
        "id": 4004,
        "func": "static inline u64 calc_delta_fair(u64 delta, struct sched_entity *se)\n{\n\tif (unlikely(se->load.weight != NICE_0_LOAD))\n\t\tdelta = __calc_delta(delta, NICE_0_LOAD, &se->load);\n\n\treturn delta;\n}",
        "target": 0
    },
    {
        "id": 4005,
        "func": "static int process_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\t struct timespec64 *tp)\n{\n\treturn posix_cpu_clock_get(PROCESS_CLOCK, tp);\n}",
        "target": 0
    },
    {
        "id": 4006,
        "func": "void Browser::RendererUnresponsive(\n    WebContents* source,\n    content::RenderWidgetHost* render_widget_host,\n    base::RepeatingClosure hang_monitor_restarter) {\n  int index = tab_strip_model_->GetIndexOfWebContents(source);\n  DCHECK_NE(TabStripModel::kNoTab, index);\n  if (tab_strip_model_->IsTabBlocked(index))\n    return;\n\n  TabDialogs::FromWebContents(source)->ShowHungRendererDialog(\n      render_widget_host, std::move(hang_monitor_restarter));\n}\n",
        "target": 0
    },
    {
        "id": 4007,
        "func": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint r = 0;\n\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn r;\n}\n",
        "target": 0
    },
    {
        "id": 4008,
        "func": "static void dwc3_gadget_disable_irq(struct dwc3 *dwc)\n{\n\t/* mask all interrupts */\n\tdwc3_writel(dwc->regs, DWC3_DEVTEN, 0x00);\n}",
        "target": 0
    },
    {
        "id": 4009,
        "func": "xsltCountKeys(xsltTransformContextPtr ctxt)\n{\n    xsltStylesheetPtr style;\n    xsltKeyDefPtr keyd;\n\n    if (ctxt == NULL)\n\treturn(-1);\n\n    /*\n    * Do we have those nastly templates with a key() in the match pattern?\n    */\n    ctxt->hasTemplKeyPatterns = 0;\n    style = ctxt->style;\n    while (style != NULL) {\n\tif (style->keyMatch != NULL) {\n\t    ctxt->hasTemplKeyPatterns = 1;\n\t    break;\n\t}\n\tstyle = xsltNextImport(style);\n    }\n    /*\n    * Count number of key declarations.\n    */\n    ctxt->nbKeys = 0;\n    style = ctxt->style;\n    while (style != NULL) {\n\tkeyd = style->keys;\n\twhile (keyd) {\n\t    ctxt->nbKeys++;\n\t    keyd = keyd->next;\n\t}\n\tstyle = xsltNextImport(style);\n    }\n    return(ctxt->nbKeys);\n}\n",
        "target": 0
    },
    {
        "id": 4010,
        "func": "static void print_enc_string(FILE* fp, OnigEncoding enc,\n                             const UChar *s, const UChar *end)\n{\n  fprintf(fp, \"\\nPATTERN: /\");\n\n  if (ONIGENC_MBC_MINLEN(enc) > 1) {\n    const UChar *p;\n    OnigCodePoint code;\n\n    p = s;\n    while (p < end) {\n      code = ONIGENC_MBC_TO_CODE(enc, p, end);\n      if (code >= 0x80) {\n        fprintf(fp, \" 0x%04x \", (int )code);\n      }\n      else {\n        fputc((int )code, fp);\n      }\n\n      p += enclen(enc, p);\n    }\n  }\n  else {\n    while (s < end) {\n      fputc((int )*s, fp);\n      s++;\n    }\n  }\n\n  fprintf(fp, \"/\\n\");\n}",
        "target": 0
    },
    {
        "id": 4011,
        "func": "void LocalFrameClientImpl::Detached(FrameDetachType type) {\n  WebLocalFrameClient* client = web_frame_->Client();\n  if (!client)\n    return;\n\n  web_frame_->WillDetachParent();\n\n  web_frame_->SetClient(nullptr);\n\n  client->FrameDetached(static_cast<WebLocalFrameClient::DetachType>(type));\n\n  if (type == FrameDetachType::kRemove)\n    web_frame_->DetachFromParent();\n\n  web_frame_->SetCoreFrame(nullptr);\n}\n",
        "target": 0
    },
    {
        "id": 4012,
        "func": "free_external_lucid_ctx_v1(\n    gss_krb5_lucid_context_v1_t *ctx)\n{\n    if (ctx) {\n        if (ctx->protocol == 0) {\n            free_lucid_key_data(&ctx->rfc1964_kd.ctx_key);\n        }\n        if (ctx->protocol == 1) {\n            free_lucid_key_data(&ctx->cfx_kd.ctx_key);\n            if (ctx->cfx_kd.have_acceptor_subkey)\n                free_lucid_key_data(&ctx->cfx_kd.acceptor_subkey);\n        }\n        xfree(ctx);\n        ctx = NULL;\n    }\n}",
        "target": 0
    },
    {
        "id": 4013,
        "func": "void RenderFrameHostImpl::OnSwapOutACK() {\n  if (frame_tree_node_->render_manager()->is_attaching_inner_delegate()) {\n    SetRenderFrameCreated(false);\n    return;\n  }\n\n  if (!is_waiting_for_swapout_ack_)\n    return;\n\n  DCHECK_EQ(UnloadState::InProgress, unload_state_);\n  unload_state_ = UnloadState::Completed;\n  PendingDeletionCheckCompleted();  // Can delete |this|.\n}\n",
        "target": 0
    },
    {
        "id": 4014,
        "func": "iasecc_decipher(struct sc_card *card,\n\t\tconst unsigned char *in, size_t in_len,\n\t\tunsigned char *out, size_t out_len)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char sbuf[0x200];\n\tunsigned char resp[SC_MAX_APDU_BUFFER_SIZE];\n\tsize_t offs;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(card->ctx,\n\t       \"crgram_len %\"SC_FORMAT_LEN_SIZE_T\"u;  outlen %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       in_len, out_len);\n\tif (!out || !out_len || in_len > SC_MAX_APDU_BUFFER_SIZE)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\toffs = 0;\n\tsbuf[offs++] = 0x81;\n\tmemcpy(sbuf + offs, in, in_len);\n\toffs += in_len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\tapdu.data = sbuf;\n\tapdu.datalen = offs;\n\tapdu.lc = offs;\n\tapdu.resp = resp;\n\tapdu.resplen = sizeof(resp);\n\tapdu.le = 256;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"Card returned error\");\n\n\tif (out_len > apdu.resplen)\n\t\tout_len = apdu.resplen;\n\n\tmemcpy(out, apdu.resp, out_len);\n\trv = out_len;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n",
        "target": 0
    },
    {
        "id": 4015,
        "func": "void init_idle(struct task_struct *idle, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\n\t__sched_fork(0, idle);\n\tidle->state = TASK_RUNNING;\n\tidle->se.exec_start = sched_clock();\n\n\tdo_set_cpus_allowed(idle, cpumask_of(cpu));\n\t/*\n\t * We're having a chicken and egg problem, even though we are\n\t * holding rq->lock, the cpu isn't yet set to this cpu so the\n\t * lockdep check in task_group() will fail.\n\t *\n\t * Similar case to sched_fork(). / Alternatively we could\n\t * use task_rq_lock() here and obtain the other rq->lock.\n\t *\n\t * Silence PROVE_RCU\n\t */\n\trcu_read_lock();\n\t__set_task_cpu(idle, cpu);\n\trcu_read_unlock();\n\n\trq->curr = rq->idle = idle;\n#if defined(CONFIG_SMP)\n\tidle->on_cpu = 1;\n#endif\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\n\t/* Set the preempt count _outside_ the spinlocks! */\n\tinit_idle_preempt_count(idle, cpu);\n\n\t/*\n\t * The idle tasks have their own, simple scheduling class:\n\t */\n\tidle->sched_class = &idle_sched_class;\n\tftrace_graph_init_idle_task(idle, cpu);\n\tvtime_init_idle(idle, cpu);\n#if defined(CONFIG_SMP)\n\tsprintf(idle->comm, \"%s/%d\", INIT_TASK_COMM, cpu);\n#endif\n}",
        "target": 0
    },
    {
        "id": 4016,
        "func": "bool ContainerNode::insertBefore(PassRefPtr<Node> newChild, Node* refChild, ExceptionCode& ec, bool shouldLazyAttach)\n{\n    ASSERT(refCount() || parentOrHostNode());\n\n    RefPtr<Node> protect(this);\n\n    ec = 0;\n\n    if (!refChild)\n        return appendChild(newChild, ec, shouldLazyAttach);\n\n    checkAddChild(newChild.get(), ec);\n    if (ec)\n        return false;\n\n    if (refChild->parentNode() != this) {\n        ec = NOT_FOUND_ERR;\n        return false;\n    }\n\n    if (refChild->previousSibling() == newChild || refChild == newChild) // nothing to do\n        return true;\n\n    RefPtr<Node> next = refChild;\n\n    NodeVector targets;\n    collectChildrenAndRemoveFromOldParent(newChild.get(), targets, ec);\n    if (ec)\n        return false;\n    if (targets.isEmpty())\n        return true;\n\n    InspectorInstrumentation::willInsertDOMNode(document(), this);\n\n#if ENABLE(MUTATION_OBSERVERS)\n    ChildListMutationScope mutation(this);\n#endif\n\n    for (NodeVector::const_iterator it = targets.begin(); it != targets.end(); ++it) {\n        Node* child = it->get();\n\n        if (next->parentNode() != this)\n            break;\n        if (child->parentNode())\n            break;\n\n        treeScope()->adoptIfNeeded(child);\n\n        insertBeforeCommon(next.get(), child);\n\n        updateTreeAfterInsertion(this, child, shouldLazyAttach);\n    }\n\n    dispatchSubtreeModifiedEvent();\n    return true;\n}\n",
        "target": 0
    },
    {
        "id": 4017,
        "func": "XdmcpGenerateKey (XdmAuthKeyPtr key)\n{\n #ifndef HAVE_ARC4RANDOM_BUF\n     long    lowbits, highbits;\n \n     srandom ((int)getpid() ^ time((Time_t *)0));\n    highbits = random ();\n     highbits = random ();\n     getbits (lowbits, key->data);\n     getbits (highbits, key->data + 4);\n#else\n     arc4random_buf(key->data, 8);\n#endif\n }\n",
        "target": 1
    },
    {
        "id": 4018,
        "func": "   TabContentsTest()\n       : ui_thread_(BrowserThread::UI, &message_loop_),\n         old_browser_client_(NULL) {\n   }\n",
        "target": 1
    },
    {
        "id": 4019,
        "func": "PassRefPtr<Scrollbar> RenderLayerScrollableArea::createScrollbar(ScrollbarOrientation orientation)\n{\n    RefPtr<Scrollbar> widget;\n    RenderObject* actualRenderer = rendererForScrollbar(box());\n    bool hasCustomScrollbarStyle = actualRenderer->isBox() && actualRenderer->style()->hasPseudoStyle(SCROLLBAR);\n    if (hasCustomScrollbarStyle) {\n        widget = RenderScrollbar::createCustomScrollbar(this, orientation, actualRenderer->node());\n    } else {\n        ScrollbarControlSize scrollbarSize = RegularScrollbar;\n        if (actualRenderer->style()->hasAppearance())\n            scrollbarSize = RenderTheme::theme().scrollbarControlSizeForPart(actualRenderer->style()->appearance());\n        widget = Scrollbar::create(this, orientation, scrollbarSize);\n        if (orientation == HorizontalScrollbar)\n            didAddScrollbar(widget.get(), HorizontalScrollbar);\n        else\n            didAddScrollbar(widget.get(), VerticalScrollbar);\n    }\n    box().document().view()->addChild(widget.get());\n    return widget.release();\n}\n",
        "target": 0
    },
    {
        "id": 4020,
        "func": "static int __net_init ip6mr_rules_init(struct net *net)\n{\n\tnet->ipv6.mrt6 = ip6mr_new_table(net, RT6_TABLE_DFLT);\n\treturn net->ipv6.mrt6 ? 0 : -ENOMEM;\n}",
        "target": 0
    },
    {
        "id": 4021,
        "func": "static void freeze_limited_counters(struct cpu_hw_events *cpuhw,\n\t\t\t\t    unsigned long pmc5, unsigned long pmc6)\n{\n\tstruct perf_event *event;\n\tu64 val, prev, delta;\n\tint i;\n\n\tfor (i = 0; i < cpuhw->n_limited; ++i) {\n\t\tevent = cpuhw->limited_counter[i];\n\t\tif (!event->hw.idx)\n\t\t\tcontinue;\n\t\tval = (event->hw.idx == 5) ? pmc5 : pmc6;\n\t\tprev = local64_read(&event->hw.prev_count);\n\t\tevent->hw.idx = 0;\n\t\tdelta = check_and_compute_delta(prev, val);\n\t\tif (delta)\n\t\t\tlocal64_add(delta, &event->count);\n\t}\n}",
        "target": 0
    },
    {
        "id": 4022,
        "func": "OMX_ERRORTYPE  omx_video::empty_this_buffer(OMX_IN OMX_HANDLETYPE         hComp,\n        OMX_IN OMX_BUFFERHEADERTYPE* buffer)\n{\n    OMX_ERRORTYPE ret1 = OMX_ErrorNone;\n unsigned int nBufferIndex ;\n\n    DEBUG_PRINT_LOW(\"ETB: buffer = %p, buffer->pBuffer[%p]\", buffer, buffer->pBuffer);\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"ERROR: Empty this buffer in Invalid State\");\n return OMX_ErrorInvalidState;\n }\n\n if (buffer == NULL || (buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {\n        DEBUG_PRINT_ERROR(\"ERROR: omx_video::etb--> buffer is null or buffer size is invalid\");\n return OMX_ErrorBadParameter;\n }\n\n if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {\n        DEBUG_PRINT_ERROR(\"ERROR: omx_video::etb--> OMX Version Invalid\");\n return OMX_ErrorVersionMismatch;\n }\n\n if (buffer->nInputPortIndex != (OMX_U32)PORT_INDEX_IN) {\n        DEBUG_PRINT_ERROR(\"ERROR: Bad port index to call empty_this_buffer\");\n return OMX_ErrorBadPortIndex;\n }\n if (!m_sInPortDef.bEnabled) {\n        DEBUG_PRINT_ERROR(\"ERROR: Cannot call empty_this_buffer while I/P port is disabled\");\n return OMX_ErrorIncorrectStateOperation;\n }\n\n    nBufferIndex = buffer - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);\n\n if (nBufferIndex > m_sInPortDef.nBufferCountActual ) {\n        DEBUG_PRINT_ERROR(\"ERROR: ETB: Invalid buffer index[%d]\", nBufferIndex);\n return OMX_ErrorBadParameter;\n }\n\n    m_etb_count++;\n    DEBUG_PRINT_LOW(\"DBG: i/p nTimestamp = %u\", (unsigned)buffer->nTimeStamp);\n    post_event ((unsigned long)hComp,(unsigned long)buffer,m_input_msg_id);\n return OMX_ErrorNone;\n}\n",
        "target": 0
    },
    {
        "id": 4023,
        "func": "void InvalidationNotifier::UpdateCredentials(\n     const std::string& email, const std::string& token) {\n   if (state_ == STOPPED) {\n     invalidation_client_.Start(\n         invalidation_client_id_, client_info_, invalidation_state_,\n         initial_max_invalidation_versions_,\n         invalidation_state_tracker_,\n        this);\n    invalidation_state_.clear();\n    state_ = STARTED;\n  }\n  invalidation_client_.UpdateCredentials(email, token);\n}\n",
        "target": 1
    },
    {
        "id": 4024,
        "func": "SpeechRecognitionManagerImpl* SpeechRecognitionManagerImpl::GetInstance() {\n  return g_speech_recognition_manager_impl;\n}\n",
        "target": 0
    },
    {
        "id": 4025,
        "func": "static int r_bin_dwarf_expand_cu(RBinDwarfCompUnit *cu) {\n\tRBinDwarfDIE *tmp;\n\n\tif (!cu || cu->capacity == 0 || cu->capacity != cu->length) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfDIE*)realloc(cu->dies,\n\t\t\tcu->capacity * 2 * sizeof(RBinDwarfDIE));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset ((ut8*)tmp + cu->capacity, 0, cu->capacity);\n\tcu->dies = tmp;\n\tcu->capacity *= 2;\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 4026,
        "func": "void kvm_vcpu_block(struct kvm_vcpu *vcpu)\n{\n\tktime_t start, cur;\n\tDECLARE_SWAITQUEUE(wait);\n\tbool waited = false;\n\tu64 block_ns;\n\n\tstart = cur = ktime_get();\n\tif (vcpu->halt_poll_ns) {\n\t\tktime_t stop = ktime_add_ns(ktime_get(), vcpu->halt_poll_ns);\n\n\t\t++vcpu->stat.halt_attempted_poll;\n\t\tdo {\n\t\t\t/*\n\t\t\t * This sets KVM_REQ_UNHALT if an interrupt\n\t\t\t * arrives.\n\t\t\t */\n\t\t\tif (kvm_vcpu_check_block(vcpu) < 0) {\n\t\t\t\t++vcpu->stat.halt_successful_poll;\n\t\t\t\tif (!vcpu_valid_wakeup(vcpu))\n\t\t\t\t\t++vcpu->stat.halt_poll_invalid;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcur = ktime_get();\n\t\t} while (single_task_running() && ktime_before(cur, stop));\n\t}\n\n\tkvm_arch_vcpu_blocking(vcpu);\n\n\tfor (;;) {\n\t\tprepare_to_swait_exclusive(&vcpu->wq, &wait, TASK_INTERRUPTIBLE);\n\n\t\tif (kvm_vcpu_check_block(vcpu) < 0)\n\t\t\tbreak;\n\n\t\twaited = true;\n\t\tschedule();\n\t}\n\n\tfinish_swait(&vcpu->wq, &wait);\n\tcur = ktime_get();\n\n\tkvm_arch_vcpu_unblocking(vcpu);\nout:\n\tblock_ns = ktime_to_ns(cur) - ktime_to_ns(start);\n\n\tif (!vcpu_valid_wakeup(vcpu))\n\t\tshrink_halt_poll_ns(vcpu);\n\telse if (halt_poll_ns) {\n\t\tif (block_ns <= vcpu->halt_poll_ns)\n\t\t\t;\n\t\t/* we had a long block, shrink polling */\n\t\telse if (vcpu->halt_poll_ns && block_ns > halt_poll_ns)\n\t\t\tshrink_halt_poll_ns(vcpu);\n\t\t/* we had a short halt and our poll time is too small */\n\t\telse if (vcpu->halt_poll_ns < halt_poll_ns &&\n\t\t\tblock_ns < halt_poll_ns)\n\t\t\tgrow_halt_poll_ns(vcpu);\n\t} else\n\t\tvcpu->halt_poll_ns = 0;\n\n\ttrace_kvm_vcpu_wakeup(block_ns, waited, vcpu_valid_wakeup(vcpu));\n\tkvm_arch_vcpu_block_finish(vcpu);\n}",
        "target": 0
    },
    {
        "id": 4027,
        "func": " void PlatformSensor::UpdateSharedBuffer(const SensorReading& reading) {\n  ReadingBuffer* buffer =\n      static_cast<ReadingBuffer*>(shared_buffer_mapping_.get());\n   auto& seqlock = buffer->seqlock.value();\n   seqlock.WriteBegin();\n   buffer->reading = reading;\n  seqlock.WriteEnd();\n}\n",
        "target": 1
    },
    {
        "id": 4028,
        "func": "void btm_create_conn_cancel_complete (UINT8 *p)\n{\n    UINT8       status;\n\n    STREAM_TO_UINT8 (status, p);\n    BTM_TRACE_EVENT (\"btm_create_conn_cancel_complete(): in State: %s  status:%d\",\n                      btm_pair_state_descr(btm_cb.pairing_state), status);\n\n /* if the create conn cancel cmd was issued by the bond cancel,\n    ** the application needs to be notified that bond cancel succeeded\n    */\n switch (status)\n {\n case HCI_SUCCESS:\n            btm_sec_bond_cancel_complete();\n break;\n case HCI_ERR_CONNECTION_EXISTS:\n case HCI_ERR_NO_CONNECTION:\n default:\n /* Notify application of the error */\n if (btm_cb.api.p_bond_cancel_cmpl_callback)\n                btm_cb.api.p_bond_cancel_cmpl_callback(BTM_ERR_PROCESSING);\n break;\n }\n}\n",
        "target": 0
    },
    {
        "id": 4029,
        "func": "static void TraceSquareLinecap(PrimitiveInfo *primitive_info,\n  const size_t number_vertices,const double offset)\n{\n  double\n    distance;\n\n  register double\n    dx,\n    dy;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j;\n\n  dx=0.0;\n  dy=0.0;\n  for (i=1; i < (ssize_t) number_vertices; i++)\n  {\n    dx=primitive_info[0].point.x-primitive_info[i].point.x;\n    dy=primitive_info[0].point.y-primitive_info[i].point.y;\n    if ((fabs((double) dx) >= MagickEpsilon) ||\n        (fabs((double) dy) >= MagickEpsilon))\n      break;\n  }\n  if (i == (ssize_t) number_vertices)\n    i=(ssize_t) number_vertices-1L;\n  distance=hypot((double) dx,(double) dy);\n  primitive_info[0].point.x=(double) (primitive_info[i].point.x+\n    dx*(distance+offset)/distance);\n  primitive_info[0].point.y=(double) (primitive_info[i].point.y+\n    dy*(distance+offset)/distance);\n  for (j=(ssize_t) number_vertices-2; j >= 0;  j--)\n  {\n    dx=primitive_info[number_vertices-1].point.x-primitive_info[j].point.x;\n    dy=primitive_info[number_vertices-1].point.y-primitive_info[j].point.y;\n    if ((fabs((double) dx) >= MagickEpsilon) ||\n        (fabs((double) dy) >= MagickEpsilon))\n      break;\n  }\n  distance=hypot((double) dx,(double) dy);\n  primitive_info[number_vertices-1].point.x=(double) (primitive_info[j].point.x+\n    dx*(distance+offset)/distance);\n  primitive_info[number_vertices-1].point.y=(double) (primitive_info[j].point.y+\n    dy*(distance+offset)/distance);\n}",
        "target": 0
    },
    {
        "id": 4030,
        "func": "static inline bool __force_buffered_io(struct inode *inode, int rw)\n{\n\treturn ((f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode)) ||\n\t\t\t(rw == WRITE && test_opt(F2FS_I_SB(inode), LFS)) ||\n\t\t\tF2FS_I_SB(inode)->s_ndevs);\n}",
        "target": 0
    },
    {
        "id": 4031,
        "func": "static void OverloadedMethodBMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  scheduler::CooperativeSchedulingManager::Instance()->Safepoint();\n\n  bool is_arity_error = false;\n\n  switch (std::min(2, info.Length())) {\n    case 1:\n      if (info[0]->IsNumber()) {\n        OverloadedMethodB1Method(info);\n        return;\n      }\n      if (true) {\n        OverloadedMethodB2Method(info);\n        return;\n      }\n      if (true) {\n        OverloadedMethodB1Method(info);\n        return;\n      }\n      break;\n    case 2:\n      if (true) {\n        OverloadedMethodB2Method(info);\n        return;\n      }\n      break;\n    default:\n      is_arity_error = true;\n  }\n\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"overloadedMethodB\");\n  if (is_arity_error) {\n    if (info.Length() < 1) {\n      exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n      return;\n    }\n  }\n  exception_state.ThrowTypeError(\"No function was found that matched the signature provided.\");\n}\n",
        "target": 0
    },
    {
        "id": 4032,
        "func": " nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)\n {\n \tNMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);\n\tguint32 mtu = nm_ip4_config_get_mtu (config);\n \tint i;\n \n \tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (config != NULL, FALSE);\n\n\t/* Addresses */\n\tnm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);\n\n\t/* Routes */\n\t{\n\t\tint count = nm_ip4_config_get_num_routes (config);\n\t\tGArray *routes = g_array_sized_new (FALSE, FALSE, sizeof (NMPlatformIP4Route), count);\n\t\tconst NMPlatformIP4Route *route;\n\t\tgboolean success;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\troute = nm_ip4_config_get_route (config, i);\n\n\t\t\t/* Don't add the route if it's more specific than one of the subnets\n\t\t\t * the device already has an IP address on.\n\t\t\t */\n\t\t\tif (   route->gateway == 0\n\t\t\t    && nm_ip4_config_destination_is_direct (config, route->network, route->plen))\n\t\t\t\tcontinue;\n\n\t\t\tg_array_append_vals (routes, route, 1);\n\t\t}\n\n\t\tsuccess = nm_route_manager_ip4_route_sync (nm_route_manager_get (), ifindex, routes);\n\t\tg_array_unref (routes);\n \t\t\treturn FALSE;\n \t}\n \n\t/* MTU */\n\tif (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n\t\tnm_platform_link_set_mtu (ifindex, mtu);\n \treturn TRUE;\n }\n",
        "target": 1
    },
    {
        "id": 4033,
        "func": "hfs_attr_walk_lzvn_rsrc(const TSK_FS_ATTR * fs_attr,\n    int flags, TSK_FS_FILE_WALK_CB a_action, void *ptr)\n{\n    return hfs_attr_walk_compressed_rsrc(\n      fs_attr, flags, a_action, ptr,\n      hfs_read_lzvn_block_table,\n      hfs_decompress_lzvn_block\n    );\n}",
        "target": 0
    },
    {
        "id": 4034,
        "func": " void WorkerProcessLauncherTest::KillProcess(DWORD exit_code) {\n  exit_code_ = exit_code;\n   BOOL result = SetEvent(process_exit_event_);\n   EXPECT_TRUE(result);\n }\n",
        "target": 1
    },
    {
        "id": 4035,
        "func": "struct posix_acl *get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *acl;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tacl = rcu_dereference(*p);\n\t\tif (!acl || is_uncached_acl(acl) ||\n\t\t    atomic_inc_not_zero(&acl->a_refcount))\n\t\t\tbreak;\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t}\n\trcu_read_unlock();\n\treturn acl;\n}",
        "target": 0
    },
    {
        "id": 4036,
        "func": "static void ebt_standard_compat_from_user(void *dst, const void *src)\n{\n\tint v = *(compat_int_t *)src;\n\n\tif (v >= 0)\n\t\tv += xt_compat_calc_jump(NFPROTO_BRIDGE, v);\n\tmemcpy(dst, &v, sizeof(v));\n}",
        "target": 0
    },
    {
        "id": 4037,
        "func": "void SetupPluginInterfaces() {\n}\n",
        "target": 0
    },
    {
        "id": 4038,
        "func": "vmnc_fill_buffer (GstVMncDec * dec, GstVideoCodecFrame * frame)\n{\n  GstFlowReturn ret;\n  GstMapInfo map;\n\n  ret =\n      gst_video_decoder_allocate_output_frame (GST_VIDEO_DECODER (dec), frame);\n  if (ret != GST_FLOW_OK)\n    return ret;\n\n  gst_buffer_map (frame->output_buffer, &map, GST_MAP_READWRITE);\n\n  memcpy (map.data, dec->imagedata, map.size);\n\n  if (dec->cursor.visible)\n    render_cursor (dec, map.data);\n\n  gst_buffer_unmap (frame->output_buffer, &map);\n\n  return GST_FLOW_OK;\n}\n",
        "target": 0
    },
    {
        "id": 4039,
        "func": "void RenderWidgetHostImpl::SetImportance(ChildProcessImportance importance) {\n  if (importance_ == importance)\n    return;\n  ChildProcessImportance old = importance_;\n  importance_ = importance;\n  process_->UpdateWidgetImportance(old, importance_);\n}\n",
        "target": 0
    },
    {
        "id": 4040,
        "func": "static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)\n{\n\tif (!is_guest_mode(vcpu)) {\n\t\tvmcs_write64(APIC_ACCESS_ADDR, hpa);\n\t\tvmx_flush_tlb(vcpu, true);\n\t}\n}",
        "target": 0
    },
    {
        "id": 4041,
        "func": "PrintWebViewHelper::PrintWebViewHelper(content::RenderView* render_view)\n    : content::RenderViewObserver(render_view),\n      content::RenderViewObserverTracker<PrintWebViewHelper>(render_view),\n      print_web_view_(NULL),\n      is_preview_enabled_(IsPrintPreviewEnabled()),\n      is_scripted_print_throttling_disabled_(IsPrintThrottlingDisabled()),\n      is_print_ready_metafile_sent_(false),\n      ignore_css_margins_(false),\n       user_cancelled_scripted_print_count_(0),\n       is_scripted_printing_blocked_(false),\n       notify_browser_of_print_failure_(true),\n      print_for_preview_(false) {\n }\n",
        "target": 1
    },
    {
        "id": 4042,
        "func": "int fibw_count(void) {\n\tint rv = 0;\n\tIFBW *ptr = ifbw;\n\n\twhile (ptr) {\n\t\trv++;\n\t\tptr = ptr->next;\n\t}\n\t\n\treturn rv;\n}",
        "target": 0
    },
    {
        "id": 4043,
        "func": " exsltStrPaddingFunction (xmlXPathParserContextPtr ctxt, int nargs) {\n    int number, str_len = 0;\n    xmlChar *str = NULL, *ret = NULL, *tmp;\n \n     if ((nargs < 1) || (nargs > 2)) {\n \txmlXPathSetArityError(ctxt);\n\treturn;\n    }\n\n     if (nargs == 2) {\n \tstr = xmlXPathPopString(ctxt);\n \tstr_len = xmlUTF8Strlen(str);\n     }\n     if (str_len == 0) {\n \tif (str != NULL) xmlFree(str);\n \tstr = xmlStrdup((const xmlChar *) \" \");\n \tstr_len = 1;\n     }\n \n     number = (int) xmlXPathPopNumber(ctxt);\n\n    if (number <= 0) {\n\txmlXPathReturnEmptyString(ctxt);\n\txmlFree(str);\n\treturn;\n     }\n \n     while (number >= str_len) {\n\tret = xmlStrncat(ret, str, str_len);\n \tnumber -= str_len;\n     }\n    tmp = xmlUTF8Strndup (str, number);\n    ret = xmlStrcat(ret, tmp);\n    if (tmp != NULL)\n\txmlFree (tmp);\n \n     xmlXPathReturnString(ctxt, ret);\n \n    if (str != NULL)\n\txmlFree(str);\n}\n",
        "target": 1
    },
    {
        "id": 4044,
        "func": "static void pid_to_ns_wrapper(int sock, pid_t tpid)\n{\n\tint newnsfd = -1, ret, cpipe[2];\n\tchar fnam[100];\n\tpid_t cpid;\n\tstruct timeval tv;\n\tfd_set s;\n\tchar v;\n\n\tret = snprintf(fnam, sizeof(fnam), \"/proc/%d/ns/pid\", tpid);\n\tif (ret < 0 || ret >= sizeof(fnam))\n\t\t_exit(1);\n\tnewnsfd = open(fnam, O_RDONLY);\n\tif (newnsfd < 0)\n\t\t_exit(1);\n\tif (setns(newnsfd, 0) < 0)\n\t\t_exit(1);\n\tclose(newnsfd);\n\n\tif (pipe(cpipe) < 0)\n\t\t_exit(1);\n\nloop:\n\tcpid = fork();\n\tif (cpid < 0)\n\t\t_exit(1);\n\n\tif (!cpid) {\n\t\tchar b = '1';\n\t\tclose(cpipe[0]);\n\t\tif (write(cpipe[1], &b, sizeof(char)) < 0) {\n\t\t\tfprintf(stderr, \"%s (child): erorr on write: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t}\n\t\tclose(cpipe[1]);\n\t\tpid_to_ns(sock, tpid);\n\t}\n\t// give the child 1 second to be done forking and\n\t// write it's ack\n\tFD_ZERO(&s);\n\tFD_SET(cpipe[0], &s);\n\ttv.tv_sec = 1;\n\ttv.tv_usec = 0;\n\tret = select(cpipe[0]+1, &s, NULL, NULL, &tv);\n\tif (ret <= 0)\n\t\tgoto again;\n\tret = read(cpipe[0], &v, 1);\n\tif (ret != sizeof(char) || v != '1') {\n\t\tgoto again;\n\t}\n\n\tif (!wait_for_pid(cpid))\n\t\t_exit(1);\n\t_exit(0);\n\nagain:\n\tkill(cpid, SIGKILL);\n\twait_for_pid(cpid);\n\tgoto loop;\n}",
        "target": 0
    },
    {
        "id": 4045,
        "func": "bool set_pool(PgSocket *client, const char *dbname, const char *username)\n{\n\tPgDatabase *db;\n\tPgUser *user;\n\n\t/* find database */\n\tdb = find_database(dbname);\n\tif (!db) {\n\t\tdb = register_auto_database(dbname);\n\t\tif (!db) {\n\t\t\tdisconnect_client(client, true, \"No such database: %s\", dbname);\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tslog_info(client, \"registered new auto-database: db = %s\", dbname );\n\t\t}\n\t}\n\n\t/* find user */\n\tif (cf_auth_type == AUTH_ANY) {\n\t\t/* ignore requested user */\n\t\tuser = NULL;\n\n\t\tif (db->forced_user == NULL) {\n\t\t\tslog_error(client, \"auth_type=any requires forced user\");\n\t\t\tdisconnect_client(client, true, \"bouncer config error\");\n\t\t\treturn false;\n\t\t}\n\t\tclient->auth_user = db->forced_user;\n\t} else {\n\t\t/* the user clients wants to log in as */\n\t\tuser = find_user(username);\n\t\tif (!user) {\n\t\t\tdisconnect_client(client, true, \"No such user: %s\", username);\n\t\t\treturn false;\n\t\t}\n\t\tclient->auth_user = user;\n\t}\n\n\t/* pool user may be forced */\n\tif (db->forced_user)\n\t\tuser = db->forced_user;\n\tclient->pool = get_pool(db, user);\n\tif (!client->pool) {\n\t\tdisconnect_client(client, true, \"no memory for pool\");\n\t\treturn false;\n\t}\n\n\treturn check_fast_fail(client);\n}\n",
        "target": 0
    },
    {
        "id": 4046,
        "func": "void WebRuntimeFeatures::EnableAllowActivationDelegationAttr(bool enable) {\n  RuntimeEnabledFeatures::SetAllowActivationDelegationAttrEnabled(enable);\n}\n",
        "target": 0
    },
    {
        "id": 4047,
        "func": "int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t    struct kvm_io_device *dev)\n{\n\tstruct kvm_io_bus *new_bus, *bus;\n\n\tbus = kvm->buses[bus_idx];\n\tif (bus->dev_count > NR_IOBUS_DEVS-1)\n\t\treturn -ENOSPC;\n\n\tnew_bus = kzalloc(sizeof(struct kvm_io_bus), GFP_KERNEL);\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\tmemcpy(new_bus, bus, sizeof(struct kvm_io_bus));\n\tnew_bus->devs[new_bus->dev_count++] = dev;\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 4048,
        "func": "static void webkitWebViewBaseSizeAllocate(GtkWidget* widget, GtkAllocation* allocation)\n{\n    GTK_WIDGET_CLASS(webkit_web_view_base_parent_class)->size_allocate(widget, allocation);\n\n    WebKitWebViewBase* webViewBase = WEBKIT_WEB_VIEW_BASE(widget);\n    if (!gtk_widget_get_mapped(GTK_WIDGET(webViewBase)) && !webViewBase->priv->pageProxy->drawingArea()->size().isEmpty()) {\n        webViewBase->priv->needsResizeOnMap = true;\n        return;\n    }\n    resizeWebKitWebViewBaseFromAllocation(webViewBase, allocation);\n}\n",
        "target": 0
    },
    {
        "id": 4049,
        "func": "XineramaXvShmPutImage(ClientPtr client)\n {\n     REQUEST(xvShmPutImageReq);\n     PanoramiXRes *draw, *gc, *port;\n    Bool send_event = stuff->send_event;\n     Bool isRoot;\n     int result, i, x, y;\n \n     REQUEST_SIZE_MATCH(xvShmPutImageReq);\n \n     result = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n     if (result != Success)\n    result = dixLookupResourceByType((void **) &gc, stuff->gc,\n                                     XRT_GC, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    result = dixLookupResourceByType((void **) &port, stuff->port,\n                                     XvXRTPort, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;\n\n    x = stuff->drw_x;\n    y = stuff->drw_y;\n\n    FOR_NSCREENS_BACKWARD(i) {\n        if (port->info[i].id) {\n            stuff->drawable = draw->info[i].id;\n            stuff->port = port->info[i].id;\n            stuff->gc = gc->info[i].id;\n            stuff->drw_x = x;\n            stuff->drw_y = y;\n            if (isRoot) {\n                stuff->drw_x -= screenInfo.screens[i]->x;\n                stuff->drw_y -= screenInfo.screens[i]->y;\n            }\n            stuff->send_event = (send_event && !i) ? 1 : 0;\n\n            result = ProcXvShmPutImage(client);\n        }\n    }\n    return result;\n}\n",
        "target": 1
    },
    {
        "id": 4050,
        "func": "  ParseQualifiedNameResult() {}\n",
        "target": 0
    },
    {
        "id": 4051,
        "func": "void AXLayoutObject::offsetBoundingBoxForRemoteSVGElement(\n    LayoutRect& rect) const {\n  for (AXObject* parent = parentObject(); parent;\n       parent = parent->parentObject()) {\n    if (parent->isAXSVGRoot()) {\n      rect.moveBy(\n          parent->parentObject()->getBoundsInFrameCoordinates().location());\n      break;\n    }\n  }\n}\n",
        "target": 0
    },
    {
        "id": 4052,
        "func": "vips_gifload( const char *filename, VipsImage **out, ... )\n{\n\tva_list ap;\n\tint result;\n\n\tva_start( ap, out );\n\tresult = vips_call_split( \"gifload\", ap, filename, out );\n\tva_end( ap );\n\n\treturn( result );\n}",
        "target": 0
    },
    {
        "id": 4053,
        "func": "PanoramiXRenderAddTraps(ClientPtr client)\n{\n    PanoramiXRes *picture;\n    int result = Success, j;\n\n    REQUEST(xRenderAddTrapsReq);\n    char *extra;\n    int extra_len;\n    INT16 x_off, y_off;\n\n    REQUEST_AT_LEAST_SIZE(xRenderAddTrapsReq);\n    VERIFY_XIN_PICTURE(picture, stuff->picture, client, DixWriteAccess);\n    extra_len = (client->req_len << 2) - sizeof(xRenderAddTrapsReq);\n    if (extra_len && (extra = (char *) malloc(extra_len))) {\n        memcpy(extra, stuff + 1, extra_len);\n        x_off = stuff->xOff;\n        y_off = stuff->yOff;\n        FOR_NSCREENS_FORWARD(j) {\n            if (j)\n                memcpy(stuff + 1, extra, extra_len);\n            stuff->picture = picture->info[j].id;\n\n            if (picture->u.pict.root) {\n                stuff->xOff = x_off + screenInfo.screens[j]->x;\n                stuff->yOff = y_off + screenInfo.screens[j]->y;\n            }\n            result = (*PanoramiXSaveRenderVector[X_RenderAddTraps]) (client);\n            if (result != Success)\n                break;\n        }\n        free(extra);\n    }\n\n    return result;\n}\n",
        "target": 0
    },
    {
        "id": 4054,
        "func": "alloc_and_copy_ftrace_hash(int size_bits, struct ftrace_hash *hash)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_hash *new_hash;\n\tint size;\n\tint ret;\n\tint i;\n\n\tnew_hash = alloc_ftrace_hash(size_bits);\n\tif (!new_hash)\n\t\treturn NULL;\n\n\t/* Empty hash? */\n\tif (ftrace_hash_empty(hash))\n\t\treturn new_hash;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tret = add_hash_entry(new_hash, entry->ip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tFTRACE_WARN_ON(new_hash->count != hash->count);\n\n\treturn new_hash;\n\n free_hash:\n\tfree_ftrace_hash(new_hash);\n\treturn NULL;\n}",
        "target": 0
    },
    {
        "id": 4055,
        "func": "static v8::Handle<v8::Value> methodWithNonCallbackArgAndCallbackArgCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodWithNonCallbackArgAndCallbackArg\");\n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, nonCallback, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     if (args.Length() <= 1 || !args[1]->IsFunction())\n        return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n    RefPtr<TestCallback> callback = V8TestCallback::create(args[1], getScriptExecutionContext());\n    imp->methodWithNonCallbackArgAndCallbackArg(nonCallback, callback);\n    return v8::Handle<v8::Value>();\n}\n",
        "target": 1
    },
    {
        "id": 4056,
        "func": "void ResourceFetcher::didChangeLoadingPriority(const Resource* resource, ResourceLoadPriority loadPriority, int intraPriorityValue)\n{\n    TRACE_EVENT_ASYNC_STEP_INTO1(\"net\", \"Resource\", resource, \"ChangePriority\", \"priority\", loadPriority);\n    context().dispatchDidChangeResourcePriority(resource->identifier(), loadPriority, intraPriorityValue);\n}\n",
        "target": 0
    },
    {
        "id": 4057,
        "func": "static void hns_gmac_set_mac_addr(void *mac_drv, char *mac_addr)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tu32 high_val = mac_addr[1] | (mac_addr[0] << 8);\n\n\tu32 low_val = mac_addr[5] | (mac_addr[4] << 8)\n\t\t| (mac_addr[3] << 16) | (mac_addr[2] << 24);\n\n\tu32 val = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG);\n\tu32 sta_addr_en = dsaf_get_bit(val, GMAC_ADDR_EN_B);\n\n\tdsaf_write_dev(drv, GMAC_STATION_ADDR_LOW_2_REG, low_val);\n\tdsaf_write_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG,\n\t\t       high_val | (sta_addr_en << GMAC_ADDR_EN_B));\n}",
        "target": 0
    },
    {
        "id": 4058,
        "func": "GF_Err trgt_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tptr->track_group_id = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\treturn GF_OK;\n}",
        "target": 0
    },
    {
        "id": 4059,
        "func": " void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n         bool success, uint64_t dump_guid,\n         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };\n\n  QueuedRequest::Args args(dump_type, level_of_detail, {},\n                           true /* add_to_trace */, base::kNullProcessId);\n  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n}\n",
        "target": 1
    },
    {
        "id": 4060,
        "func": "static void report_duplication(const char *full_path) {\n\tchar *fname = strrchr(full_path, '/');\n\tif (fname && *(++fname) != '\\0') {\n\t\t// report the file on all bin paths\n\t\tint i = 0;\n\t\twhile (default_lib_paths[i]) {\n\t\t\tchar *p;\n\t\t\tif (asprintf(&p, \"%s/%s\", default_lib_paths[i], fname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tfs_logger2(\"clone\", p);\n\t\t\tfree(p);\n\t\t\ti++;\n\t\t}\n\t}\n}",
        "target": 0
    },
    {
        "id": 4061,
        "func": "void RenderProcessHostImpl::RegisterHost(int host_id, RenderProcessHost* host) {\n  g_all_hosts.Get().AddWithID(host, host_id);\n}\n",
        "target": 0
    },
    {
        "id": 4062,
        "func": "convert_initialized_extent(handle_t *handle, struct inode *inode,\n\t\t\t   struct ext4_map_blocks *map,\n\t\t\t   struct ext4_ext_path **ppath,\n\t\t\t   unsigned int allocated)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\tstruct ext4_extent *ex;\n\text4_lblk_t ee_block;\n\tunsigned int ee_len;\n\tint depth;\n\tint err = 0;\n\n\t/*\n\t * Make sure that the extent is no bigger than we support with\n\t * unwritten extent\n\t */\n\tif (map->m_len > EXT_UNWRITTEN_MAX_LEN)\n\t\tmap->m_len = EXT_UNWRITTEN_MAX_LEN / 2;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\n\text_debug(\"%s: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", __func__, inode->i_ino,\n\t\t  (unsigned long long)ee_block, ee_len);\n\n\tif (ee_block != map->m_lblk || ee_len > map->m_len) {\n\t\terr = ext4_split_convert_extents(handle, inode, map, ppath,\n\t\t\t\tEXT4_GET_BLOCKS_CONVERT_UNWRITTEN);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tpath = ext4_find_extent(inode, map->m_lblk, ppath, 0);\n\t\tif (IS_ERR(path))\n\t\t\treturn PTR_ERR(path);\n\t\tdepth = ext_depth(inode);\n\t\tex = path[depth].p_ext;\n\t\tif (!ex) {\n\t\t\tEXT4_ERROR_INODE(inode, \"unexpected hole at %lu\",\n\t\t\t\t\t (unsigned long) map->m_lblk);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\treturn err;\n\t/* first mark the extent as unwritten */\n\text4_ext_mark_unwritten(ex);\n\n\t/* note: ext4_ext_correct_indexes() isn't needed here because\n\t * borders are not changed\n\t */\n\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t/* Mark modified extent as dirty */\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\tif (err)\n\t\treturn err;\n\text4_ext_show_leaf(inode, path);\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\terr = check_eofblocks_fl(handle, inode, map->m_lblk, path, map->m_len);\n\tif (err)\n\t\treturn err;\n\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\tmap->m_len = allocated;\n\treturn allocated;\n}",
        "target": 0
    },
    {
        "id": 4063,
        "func": "static int l2cap_parse_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *req = pi->conf_req;\n\tint len = pi->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tpi->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen == sizeof(rfc))\n\t\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (rfc.mode == L2CAP_MODE_BASIC) {\n\t\t\tif (mtu < pi->omtu)\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\t\telse {\n\t\t\t\tpi->omtu = mtu;\n\t\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n\t\t\t}\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\t\t} else {\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = L2CAP_MODE_BASIC;\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\t}\n\t}\n\n\trsp->scid   = cpu_to_le16(pi->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;\n}",
        "target": 1
    },
    {
        "id": 4064,
        "func": "void V8TestObject::VoidMethodTestCallbackInterfaceOrNullArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_voidMethodTestCallbackInterfaceOrNullArg\");\n\n  test_object_v8_internal::VoidMethodTestCallbackInterfaceOrNullArgMethod(info);\n}\n",
        "target": 0
    },
    {
        "id": 4065,
        "func": "static void *DestroyProfile(void *profile)\n{\n  return((void *) DestroyStringInfo((StringInfo *) profile));\n}\n",
        "target": 0
    },
    {
        "id": 4066,
        "func": "void NuPlayer::GenericSource::notifyPreparedAndCleanup(status_t err) {\n if (err != OK) {\n        mMetaDataSize = -1ll;\n        mContentType = \"\";\n        mSniffedMIME = \"\";\n {\n            sp<DataSource> dataSource = mDataSource;\n            sp<NuCachedSource2> cachedSource = mCachedSource;\n            sp<DataSource> httpSource = mHttpSource;\n\n             {\n                 Mutex::Autolock _l(mDisconnectLock);\n                 mDataSource.clear();\n                mDrmManagerClient = NULL;\n                 mCachedSource.clear();\n                 mHttpSource.clear();\n             }\n }\n\n        cancelPollBuffering();\n }\n    notifyPrepared(err);\n}\n",
        "target": 0
    },
    {
        "id": 4067,
        "func": "void HTMLFormControlElement::updateAncestorDisabledState() const\n{\n    HTMLFieldSetElement* fieldSetAncestor = 0;\n    ContainerNode* legendAncestor = 0;\n    for (HTMLElement* ancestor = Traversal<HTMLElement>::firstAncestor(*this); ancestor; ancestor = Traversal<HTMLElement>::firstAncestor(*ancestor)) {\n        if (!legendAncestor && isHTMLLegendElement(*ancestor))\n            legendAncestor = ancestor;\n        if (isHTMLFieldSetElement(*ancestor)) {\n            fieldSetAncestor = toHTMLFieldSetElement(ancestor);\n            break;\n        }\n    }\n    m_ancestorDisabledState = (fieldSetAncestor && fieldSetAncestor->isDisabledFormControl() && !(legendAncestor && legendAncestor == fieldSetAncestor->legend())) ? AncestorDisabledStateDisabled : AncestorDisabledStateEnabled;\n}\n",
        "target": 0
    },
    {
        "id": 4068,
        "func": "bool WallpaperManagerBase::GetPathFromCache(const AccountId& account_id,\n                                            base::FilePath* path) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  CustomWallpaperMap::const_iterator it = wallpaper_cache_.find(account_id);\n  if (it != wallpaper_cache_.end()) {\n    *path = (*it).second.first;\n    return true;\n  }\n  return false;\n}\n",
        "target": 0
    },
    {
        "id": 4069,
        "func": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\n\tif (test)\n\t\treturn 0;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\n\tif (ops->init)\n\t\tops->init(dev);\n\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}",
        "target": 1
    },
    {
        "id": 4070,
        "func": "_dbus_get_real_time (long *tv_sec,\n                     long *tv_usec)\n{\n  FILETIME ft;\n  dbus_uint64_t time64;\n\n  GetSystemTimeAsFileTime (&ft);\n\n  memcpy (&time64, &ft, sizeof (time64));\n\n  /* Convert from 100s of nanoseconds since 1601-01-01\n  * to Unix epoch. Yes, this is Y2038 unsafe.\n  */\n  time64 -= DBUS_INT64_CONSTANT (116444736000000000);\n  time64 /= 10;\n\n  if (tv_sec)\n    *tv_sec = time64 / 1000000;\n\n  if (tv_usec)\n    *tv_usec = time64 % 1000000;\n}\n",
        "target": 0
    },
    {
        "id": 4071,
        "func": "static int cm_apr_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_apr_msg *apr_msg;\n\tint ret;\n\n\tapr_msg = (struct cm_apr_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(apr_msg->remote_comm_id,\n\t\t\t\t   apr_msg->local_comm_id);\n\tif (!cm_id_priv)\n\t\treturn -EINVAL; /* Unmatched reply. */\n\n\twork->cm_event.param.apr_rcvd.ap_status = apr_msg->ap_status;\n\twork->cm_event.param.apr_rcvd.apr_info = &apr_msg->info;\n\twork->cm_event.param.apr_rcvd.info_len = apr_msg->info_length;\n\twork->cm_event.private_data = &apr_msg->private_data;\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state != IB_CM_ESTABLISHED ||\n\t    (cm_id_priv->id.lap_state != IB_CM_LAP_SENT &&\n\t     cm_id_priv->id.lap_state != IB_CM_MRA_LAP_RCVD)) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tgoto out;\n\t}\n\tcm_id_priv->id.lap_state = IB_CM_LAP_IDLE;\n\tib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\n\tcm_id_priv->msg = NULL;\n\n\tret = atomic_inc_and_test(&cm_id_priv->work_count);\n\tif (!ret)\n\t\tlist_add_tail(&work->list, &cm_id_priv->work_list);\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\tif (ret)\n\t\tcm_process_work(cm_id_priv, work);\n\telse\n\t\tcm_deref_id(cm_id_priv);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}",
        "target": 0
    },
    {
        "id": 4072,
        "func": "void usb_disable_device(struct usb_device *dev, int skip_ep0)\n{\n\tint i;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\n\t/* getting rid of interfaces will disconnect\n\t * any drivers bound to them (a key side effect)\n\t */\n\tif (dev->actconfig) {\n\t\t/*\n\t\t * FIXME: In order to avoid self-deadlock involving the\n\t\t * bandwidth_mutex, we have to mark all the interfaces\n\t\t * before unregistering any of them.\n\t\t */\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++)\n\t\t\tdev->actconfig->interface[i]->unregistering = 1;\n\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tstruct usb_interface\t*interface;\n\n\t\t\t/* remove this interface if it has been registered */\n\t\t\tinterface = dev->actconfig->interface[i];\n\t\t\tif (!device_is_registered(&interface->dev))\n\t\t\t\tcontinue;\n\t\t\tdev_dbg(&dev->dev, \"unregistering interface %s\\n\",\n\t\t\t\tdev_name(&interface->dev));\n\t\t\tremove_intf_ep_devs(interface);\n\t\t\tdevice_del(&interface->dev);\n\t\t}\n\n\t\t/* Now that the interfaces are unbound, nobody should\n\t\t * try to access them.\n\t\t */\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tput_device(&dev->actconfig->interface[i]->dev);\n\t\t\tdev->actconfig->interface[i] = NULL;\n\t\t}\n\n\t\tif (dev->usb2_hw_lpm_enabled == 1)\n\t\t\tusb_set_usb2_hardware_lpm(dev, 0);\n\t\tusb_unlocked_disable_lpm(dev);\n\t\tusb_disable_ltm(dev);\n\n\t\tdev->actconfig = NULL;\n\t\tif (dev->state == USB_STATE_CONFIGURED)\n\t\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);\n\t}\n\n\tdev_dbg(&dev->dev, \"%s nuking %s URBs\\n\", __func__,\n\t\tskip_ep0 ? \"non-ep0\" : \"all\");\n\tif (hcd->driver->check_bandwidth) {\n\t\t/* First pass: Cancel URBs, leave endpoint pointers intact. */\n\t\tfor (i = skip_ep0; i < 16; ++i) {\n\t\t\tusb_disable_endpoint(dev, i, false);\n\t\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, false);\n\t\t}\n\t\t/* Remove endpoints from the host controller internal state */\n\t\tmutex_lock(hcd->bandwidth_mutex);\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\t/* Second pass: remove endpoint pointers */\n\t}\n\tfor (i = skip_ep0; i < 16; ++i) {\n\t\tusb_disable_endpoint(dev, i, true);\n\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, true);\n\t}\n}",
        "target": 0
    },
    {
        "id": 4073,
        "func": "static void btif_hl_proc_cch_open_ind(tBTA_HL *p_data)\n\n{\n btif_hl_mcl_cb_t *p_mcb;\n    UINT8                   mcl_idx;\n int                     i;\n\n    BTIF_TRACE_DEBUG(\"%s\", __FUNCTION__);\n for(i=0; i<BTA_HL_NUM_APPS; i++)\n {\n if (btif_hl_cb.acb[i].in_use)\n {\n if (!btif_hl_find_mcl_idx(i, p_data->cch_open_ind.bd_addr, &mcl_idx))\n {\n if (btif_hl_find_avail_mcl_idx(i, &mcl_idx))\n {\n                    p_mcb = BTIF_HL_GET_MCL_CB_PTR(i, mcl_idx);\n                    memset(p_mcb, 0, sizeof(btif_hl_mcl_cb_t));\n                    p_mcb->in_use = TRUE;\n                    p_mcb->is_connected = TRUE;\n                    p_mcb->mcl_handle = p_data->cch_open_ind.mcl_handle;\n                    bdcpy(p_mcb->bd_addr, p_data->cch_open_ind.bd_addr);\n                    btif_hl_start_cch_timer(i, mcl_idx);\n }\n }\n else\n {\n                BTIF_TRACE_ERROR(\"The MCL already exist for cch_open_ind\");\n }\n }\n }\n}\n",
        "target": 0
    },
    {
        "id": 4074,
        "func": "Page* ChromeClientImpl::CreateWindow(LocalFrame* frame,\n                                     const FrameLoadRequest& r,\n                                     const WebWindowFeatures& features,\n                                     NavigationPolicy navigation_policy,\n                                     SandboxFlags sandbox_flags) {\n  if (!web_view_->Client())\n    return nullptr;\n \n   if (!frame->GetPage() || frame->GetPage()->Paused())\n     return nullptr;\n  DCHECK(frame->GetDocument());\n  Fullscreen::FullyExitFullscreen(*frame->GetDocument());\n \n   const AtomicString& frame_name =\n       !EqualIgnoringASCIICase(r.FrameName(), \"_blank\") ? r.FrameName()\n                                                       : g_empty_atom;\n  WebViewImpl* new_view =\n      static_cast<WebViewImpl*>(web_view_->Client()->CreateView(\n          WebLocalFrameImpl::FromFrame(frame),\n          WrappedResourceRequest(r.GetResourceRequest()), features, frame_name,\n          static_cast<WebNavigationPolicy>(navigation_policy),\n          r.GetShouldSetOpener() == kNeverSetOpener,\n          static_cast<WebSandboxFlags>(sandbox_flags)));\n  if (!new_view)\n    return nullptr;\n  return new_view->GetPage();\n}\n",
        "target": 1
    },
    {
        "id": 4075,
        "func": "static vpx_image_t *decoder_get_frame(vpx_codec_alg_priv_t *ctx,\n vpx_codec_iter_t *iter) {\n vpx_image_t *img = NULL;\n\n if (ctx->frame_parallel_decode && ctx->available_threads > 0 &&\n !ctx->flushed) {\n return NULL;\n }\n\n if (ctx->num_cache_frames > 0) {\n    release_last_output_frame(ctx);\n    ctx->last_show_frame  = ctx->frame_cache[ctx->frame_cache_read].fb_idx;\n if (ctx->need_resync)\n return NULL;\n    img = &ctx->frame_cache[ctx->frame_cache_read].img;\n    ctx->frame_cache_read = (ctx->frame_cache_read + 1) % FRAME_CACHE_SIZE;\n --ctx->num_cache_frames;\n return img;\n }\n\n if (*iter == NULL && ctx->frame_workers != NULL) {\n do {\n      YV12_BUFFER_CONFIG sd;\n vp9_ppflags_t flags = {0, 0, 0};\n const VPxWorkerInterface *const winterface = vpx_get_worker_interface();\n VPxWorker *const worker =\n &ctx->frame_workers[ctx->next_output_worker_id];\n FrameWorkerData *const frame_worker_data =\n (FrameWorkerData *)worker->data1;\n      ctx->next_output_worker_id =\n (ctx->next_output_worker_id + 1) % ctx->num_frame_workers;\n if (ctx->base.init_flags & VPX_CODEC_USE_POSTPROC)\n        set_ppflags(ctx, &flags);\n if (winterface->sync(worker)) {\n if (frame_worker_data->received_frame == 1) {\n ++ctx->available_threads;\n          frame_worker_data->received_frame = 0;\n          check_resync(ctx, frame_worker_data->pbi);\n }\n if (vp9_get_raw_frame(frame_worker_data->pbi, &sd, &flags) == 0) {\n          VP9_COMMON *const cm = &frame_worker_data->pbi->common;\n RefCntBuffer *const frame_bufs = cm->buffer_pool->frame_bufs;\n          release_last_output_frame(ctx);\n          ctx->last_show_frame = frame_worker_data->pbi->common.new_fb_idx;\n if (ctx->need_resync)\n return NULL;\n          yuvconfig2image(&ctx->img, &sd, frame_worker_data->user_priv);\n          ctx->img.fb_priv = frame_bufs[cm->new_fb_idx].raw_frame_buffer.priv;\n          img = &ctx->img;\n return img;\n }\n } else {\n        frame_worker_data->received_frame = 0;\n ++ctx->available_threads;\n        ctx->need_resync = 1;\n if (ctx->flushed != 1)\n return NULL;\n }\n } while (ctx->next_output_worker_id != ctx->next_submit_worker_id);\n }\n return NULL;\n}\n",
        "target": 0
    },
    {
        "id": 4076,
        "func": "void AudioContext::markAudioNodeOutputDirty(AudioNodeOutput* output)\n{\n    ASSERT(isGraphOwner());\n    ASSERT(isMainThread());\n    m_dirtyAudioNodeOutputs.add(output);\n}\n",
        "target": 0
    },
    {
        "id": 4077,
        "func": "fm_mgr_config_init\n(\n\t\t\t\t\tOUT\tp_fm_config_conx_hdlt\t\t*p_hdl,\n\t\t\t\tIN\t\tint\t\t\t\t\t\t\tinstance,\n\tOPTIONAL\tIN\t\tchar\t\t\t\t\t\t*rem_address,\n\tOPTIONAL\tIN\t\tchar\t\t\t\t\t\t*community\n)\n{\n\tfm_config_conx_hdl      *hdl;\n\tfm_mgr_config_errno_t   res = FM_CONF_OK;\n\n\n\tif ( (hdl = calloc(1,sizeof(fm_config_conx_hdl))) == NULL )\n\t{\n\t\tres = FM_CONF_NO_MEM;\n\t\tgoto cleanup;\n\t}\n\n\thdl->instance = instance;\n\n\t*p_hdl = hdl;\n\n\tif(!rem_address || (strcmp(rem_address,\"localhost\") == 0))\n\t{\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_SM) == FM_CONF_INIT_ERR )\n\t\t{\n\t\t\tres = FM_CONF_INIT_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_PM) == FM_CONF_INIT_ERR )\n\t\t{\n\t\t\tres = FM_CONF_INIT_ERR;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif ( fm_mgr_config_mgr_connect(hdl, FM_MGR_FE) == FM_CONF_INIT_ERR )\n\t\t{\n\t\t\tres = FM_CONF_INIT_ERR;\n\t\t\tgoto cleanup;\n \t\t}\n \t}\n \n\treturn res;\n\tcleanup:\n\tif ( hdl ) {\n\t\tfree(hdl);\n\t\thdl = NULL;\n\t}\n \treturn res;\n }\n",
        "target": 1
    },
    {
        "id": 4078,
        "func": "void DOMPatchSupport::markNodeAsUsed(Digest* digest)\n{\n    Deque<Digest*> queue;\n    queue.append(digest);\n    while (!queue.isEmpty()) {\n        Digest* first = queue.takeFirst();\n        m_unusedNodesMap.remove(first->m_sha1);\n        for (size_t i = 0; i < first->m_children.size(); ++i)\n            queue.append(first->m_children[i].get());\n    }\n}\n",
        "target": 0
    },
    {
        "id": 4079,
        "func": "static bool cmd_queue_full(struct ImapData *idata)\n{\n  if ((idata->nextcmd + 1) % idata->cmdslots == idata->lastcmd)\n    return true;\n\n  return false;\n}",
        "target": 0
    },
    {
        "id": 4080,
        "func": "void Vp9Parser::SetStream(const uint8_t* stream, off_t stream_size) {\n  DCHECK(stream);\n  stream_ = stream;\n  bytes_left_ = stream_size;\n  frames_.clear();\n}\n",
        "target": 1
    },
    {
        "id": 4081,
        "func": "static void virgl_resource_attach_backing(VirtIOGPU *g,\n                                          struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_attach_backing att_rb;\n    struct iovec *res_iovs;\n    int ret;\n\n    VIRTIO_GPU_FILL_CMD(att_rb);\n    trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id);\n\n    ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, NULL, &res_iovs);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n         return;\n     }\n \n    virgl_renderer_resource_attach_iov(att_rb.resource_id,\n                                       res_iovs, att_rb.nr_entries);\n }\n",
        "target": 1
    },
    {
        "id": 4082,
        "func": "DEFINE_TRACE(RuleFeatureSet)\n{\n#if ENABLE(OILPAN)\n    visitor->trace(siblingRules);\n    visitor->trace(uncommonAttributeRules);\n#endif\n}\n",
        "target": 0
    },
    {
        "id": 4083,
        "func": "static void intel_pmu_pebs_enable(struct perf_event *event)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thwc->config &= ~ARCH_PERFMON_EVENTSEL_INT;\n\n\tcpuc->pebs_enabled |= 1ULL << hwc->idx;\n\tWARN_ON_ONCE(cpuc->enabled);\n\n\tif (x86_pmu.intel_cap.pebs_trap && event->attr.precise_ip > 1)\n\t\tintel_pmu_lbr_enable(event);\n}",
        "target": 0
    },
    {
        "id": 4084,
        "func": " QString IRCView::openTags(TextHtmlData* data, int from)\n {\n     QString ret, tag;\n    int i = from;\n     for ( ;  i < data->openHtmlTags.count(); ++i)\n     {\n         tag = data->openHtmlTags.at(i);\n            if (data->reverse)\n            {\n                ret += fontColorOpenTag(Preferences::self()->color(Preferences::TextViewBackground).name());\n            }\n            else\n            {\n                ret += fontColorOpenTag(data->lastFgColor);\n            }\n        }\n        else if (tag == QLatin1String(\"span\"))\n        {\n            if (data->reverse)\n            {\n                ret += spanColorOpenTag(data->defaultColor);\n            }\n            else\n            {\n                ret += spanColorOpenTag(data->lastBgColor);\n            }\n        }\n        else\n        {\n            ret += QLatin1Char('<') + tag + QLatin1Char('>');\n        }\n    }\n",
        "target": 1
    },
    {
        "id": 4085,
        "func": "void btif_dm_execute_service_request(UINT16 event, char *p_param)\n{\n    BOOLEAN b_enable = FALSE;\n bt_status_t status;\n if (event == BTIF_DM_ENABLE_SERVICE)\n {\n        b_enable = TRUE;\n }\n    status = btif_in_execute_service_request(*((tBTA_SERVICE_ID*)p_param), b_enable);\n if (status == BT_STATUS_SUCCESS)\n {\n bt_property_t property;\n bt_uuid_t local_uuids[BT_MAX_NUM_UUIDS];\n\n /* Now send the UUID_PROPERTY_CHANGED event to the upper layer */\n        BTIF_STORAGE_FILL_PROPERTY(&property, BT_PROPERTY_UUIDS,\n sizeof(local_uuids), local_uuids);\n        btif_storage_get_adapter_property(&property);\n        HAL_CBACK(bt_hal_cbacks, adapter_properties_cb,\n                          BT_STATUS_SUCCESS, 1, &property);\n }\n return;\n}\n",
        "target": 0
    },
    {
        "id": 4086,
        "func": "void hrtick_start(struct rq *rq, u64 delay)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\tktime_t time;\n\ts64 delta;\n\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense and can cause timer DoS.\n\t */\n\tdelta = max_t(s64, delay, 10000LL);\n\ttime = ktime_add_ns(timer->base->get_time(), delta);\n\n\thrtimer_set_expires(timer, time);\n\n\tif (rq == this_rq()) {\n\t\t__hrtick_restart(rq);\n\t} else if (!rq->hrtick_csd_pending) {\n\t\tsmp_call_function_single_async(cpu_of(rq), &rq->hrtick_csd);\n\t\trq->hrtick_csd_pending = 1;\n\t}\n}\n",
        "target": 0
    },
    {
        "id": 4087,
        "func": "static int __net_init raw6_init_net(struct net *net)\n{\n\tif (!proc_create(\"raw6\", S_IRUGO, net->proc_net, &raw6_seq_fops))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 4088,
        "func": "xmlBufMemoryError(xmlBufPtr buf, const char *extra)\n{\n    __xmlSimpleError(XML_FROM_BUFFER, XML_ERR_NO_MEMORY, NULL, NULL, extra);\n    if ((buf) && (buf->error == 0))\n        buf->error = XML_ERR_NO_MEMORY;\n}\n",
        "target": 0
    },
    {
        "id": 4089,
        "func": "static int em_clflush(struct x86_emulate_ctxt *ctxt)\n{\n\t/* emulating clflush regardless of cpuid */\n\treturn X86EMUL_CONTINUE;\n}",
        "target": 0
    },
    {
        "id": 4090,
        "func": "static int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}",
        "target": 0
    },
    {
        "id": 4091,
        "func": "void ResourceFetcher::PreloadStarted(Resource* resource) {\n  if (preloads_ && preloads_->Contains(resource))\n    return;\n  resource->IncreasePreloadCount();\n\n  if (!preloads_)\n     preloads_ = new HeapListHashSet<Member<Resource>>;\n   preloads_->insert(resource);\n \n  if (preloaded_ur_ls_for_test_)\n    preloaded_ur_ls_for_test_->insert(resource->Url().GetString());\n }\n",
        "target": 1
    }
]